/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/anymatch/index.js":
/*!****************************************!*\
  !*** ./node_modules/anymatch/index.js ***!
  \****************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, module, __webpack_require__ */
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nconst picomatch = __webpack_require__(/*! picomatch */ \"./node_modules/picomatch/index.js\");\nconst normalizePath = __webpack_require__(/*! normalize-path */ \"./node_modules/normalize-path/index.js\");\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG = '!';\nconst DEFAULT_OPTIONS = {returnIndex: false};\nconst arrify = (item) => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return (string) => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return (string) => matcher.test(string);\n  }\n  return (string) => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' +\n      Object.prototype.toString.call(_path))\n  }\n  const path = normalizePath(_path);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify(matchers);\n  const negatedGlobs = mtchers\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)\n    .map(item => item.slice(1))\n    .map(item => picomatch(item, opts));\n  const patterns = mtchers.map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    }\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch.default = anymatch;\nmodule.exports = anymatch;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/anymatch/index.js?");

/***/ }),

/***/ "./node_modules/binary-extensions/binary-extensions.json":
/*!***************************************************************!*\
  !*** ./node_modules/binary-extensions/binary-extensions.json ***!
  \***************************************************************/
/*! default exports */
/*! export 0 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 1 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 10 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 100 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 101 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 102 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 103 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 104 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 105 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 106 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 107 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 108 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 109 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 11 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 110 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 111 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 112 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 113 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 114 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 115 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 116 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 117 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 118 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 119 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 12 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 120 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 121 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 122 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 123 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 124 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 125 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 126 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 127 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 128 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 129 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 13 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 130 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 131 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 132 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 133 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 134 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 135 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 136 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 137 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 138 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 139 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 14 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 140 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 141 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 142 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 143 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 144 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 145 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 146 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 147 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 148 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 149 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 15 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 150 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 151 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 152 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 153 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 154 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 155 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 156 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 157 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 158 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 159 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 16 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 160 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 161 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 162 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 163 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 164 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 165 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 166 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 167 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 168 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 169 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 17 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 170 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 171 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 172 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 173 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 174 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 175 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 176 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 177 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 178 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 179 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 18 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 180 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 181 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 182 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 183 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 184 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 185 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 186 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 187 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 188 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 189 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 19 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 190 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 191 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 192 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 193 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 194 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 195 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 196 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 197 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 198 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 199 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 2 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 20 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 200 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 201 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 202 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 203 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 204 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 205 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 206 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 207 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 208 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 209 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 21 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 210 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 211 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 212 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 213 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 214 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 215 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 216 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 217 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 218 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 219 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 22 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 220 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 221 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 222 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 223 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 224 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 225 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 226 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 227 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 228 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 229 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 23 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 230 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 231 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 232 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 233 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 234 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 235 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 236 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 237 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 238 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 239 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 24 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 240 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 241 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 242 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 243 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 244 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 245 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 246 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 247 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 248 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 249 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 25 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 26 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 27 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 28 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 29 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 3 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 30 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 31 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 32 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 33 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 34 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 35 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 36 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 37 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 38 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 39 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 4 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 40 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 41 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 42 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 43 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 44 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 45 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 46 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 47 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 48 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 49 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 5 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 50 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 51 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 52 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 53 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 54 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 55 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 56 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 57 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 58 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 59 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 6 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 60 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 61 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 62 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 63 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 64 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 65 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 66 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 67 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 68 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 69 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 7 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 70 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 71 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 72 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 73 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 74 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 75 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 76 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 77 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 78 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 79 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 8 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 80 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 81 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 82 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 83 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 84 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 85 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 86 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 87 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 88 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 89 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 9 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 90 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 91 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 92 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 93 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 94 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 95 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 96 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 97 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 98 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export 99 [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse(\"[\\\"3dm\\\",\\\"3ds\\\",\\\"3g2\\\",\\\"3gp\\\",\\\"7z\\\",\\\"a\\\",\\\"aac\\\",\\\"adp\\\",\\\"ai\\\",\\\"aif\\\",\\\"aiff\\\",\\\"alz\\\",\\\"ape\\\",\\\"apk\\\",\\\"ar\\\",\\\"arj\\\",\\\"asf\\\",\\\"au\\\",\\\"avi\\\",\\\"bak\\\",\\\"baml\\\",\\\"bh\\\",\\\"bin\\\",\\\"bk\\\",\\\"bmp\\\",\\\"btif\\\",\\\"bz2\\\",\\\"bzip2\\\",\\\"cab\\\",\\\"caf\\\",\\\"cgm\\\",\\\"class\\\",\\\"cmx\\\",\\\"cpio\\\",\\\"cr2\\\",\\\"cur\\\",\\\"dat\\\",\\\"dcm\\\",\\\"deb\\\",\\\"dex\\\",\\\"djvu\\\",\\\"dll\\\",\\\"dmg\\\",\\\"dng\\\",\\\"doc\\\",\\\"docm\\\",\\\"docx\\\",\\\"dot\\\",\\\"dotm\\\",\\\"dra\\\",\\\"DS_Store\\\",\\\"dsk\\\",\\\"dts\\\",\\\"dtshd\\\",\\\"dvb\\\",\\\"dwg\\\",\\\"dxf\\\",\\\"ecelp4800\\\",\\\"ecelp7470\\\",\\\"ecelp9600\\\",\\\"egg\\\",\\\"eol\\\",\\\"eot\\\",\\\"epub\\\",\\\"exe\\\",\\\"f4v\\\",\\\"fbs\\\",\\\"fh\\\",\\\"fla\\\",\\\"flac\\\",\\\"fli\\\",\\\"flv\\\",\\\"fpx\\\",\\\"fst\\\",\\\"fvt\\\",\\\"g3\\\",\\\"gh\\\",\\\"gif\\\",\\\"graffle\\\",\\\"gz\\\",\\\"gzip\\\",\\\"h261\\\",\\\"h263\\\",\\\"h264\\\",\\\"icns\\\",\\\"ico\\\",\\\"ief\\\",\\\"img\\\",\\\"ipa\\\",\\\"iso\\\",\\\"jar\\\",\\\"jpeg\\\",\\\"jpg\\\",\\\"jpgv\\\",\\\"jpm\\\",\\\"jxr\\\",\\\"key\\\",\\\"ktx\\\",\\\"lha\\\",\\\"lib\\\",\\\"lvp\\\",\\\"lz\\\",\\\"lzh\\\",\\\"lzma\\\",\\\"lzo\\\",\\\"m3u\\\",\\\"m4a\\\",\\\"m4v\\\",\\\"mar\\\",\\\"mdi\\\",\\\"mht\\\",\\\"mid\\\",\\\"midi\\\",\\\"mj2\\\",\\\"mka\\\",\\\"mkv\\\",\\\"mmr\\\",\\\"mng\\\",\\\"mobi\\\",\\\"mov\\\",\\\"movie\\\",\\\"mp3\\\",\\\"mp4\\\",\\\"mp4a\\\",\\\"mpeg\\\",\\\"mpg\\\",\\\"mpga\\\",\\\"mxu\\\",\\\"nef\\\",\\\"npx\\\",\\\"numbers\\\",\\\"nupkg\\\",\\\"o\\\",\\\"oga\\\",\\\"ogg\\\",\\\"ogv\\\",\\\"otf\\\",\\\"pages\\\",\\\"pbm\\\",\\\"pcx\\\",\\\"pdb\\\",\\\"pdf\\\",\\\"pea\\\",\\\"pgm\\\",\\\"pic\\\",\\\"png\\\",\\\"pnm\\\",\\\"pot\\\",\\\"potm\\\",\\\"potx\\\",\\\"ppa\\\",\\\"ppam\\\",\\\"ppm\\\",\\\"pps\\\",\\\"ppsm\\\",\\\"ppsx\\\",\\\"ppt\\\",\\\"pptm\\\",\\\"pptx\\\",\\\"psd\\\",\\\"pya\\\",\\\"pyc\\\",\\\"pyo\\\",\\\"pyv\\\",\\\"qt\\\",\\\"rar\\\",\\\"ras\\\",\\\"raw\\\",\\\"resources\\\",\\\"rgb\\\",\\\"rip\\\",\\\"rlc\\\",\\\"rmf\\\",\\\"rmvb\\\",\\\"rtf\\\",\\\"rz\\\",\\\"s3m\\\",\\\"s7z\\\",\\\"scpt\\\",\\\"sgi\\\",\\\"shar\\\",\\\"sil\\\",\\\"sketch\\\",\\\"slk\\\",\\\"smv\\\",\\\"snk\\\",\\\"so\\\",\\\"stl\\\",\\\"suo\\\",\\\"sub\\\",\\\"swf\\\",\\\"tar\\\",\\\"tbz\\\",\\\"tbz2\\\",\\\"tga\\\",\\\"tgz\\\",\\\"thmx\\\",\\\"tif\\\",\\\"tiff\\\",\\\"tlz\\\",\\\"ttc\\\",\\\"ttf\\\",\\\"txz\\\",\\\"udf\\\",\\\"uvh\\\",\\\"uvi\\\",\\\"uvm\\\",\\\"uvp\\\",\\\"uvs\\\",\\\"uvu\\\",\\\"viv\\\",\\\"vob\\\",\\\"war\\\",\\\"wav\\\",\\\"wax\\\",\\\"wbmp\\\",\\\"wdp\\\",\\\"weba\\\",\\\"webm\\\",\\\"webp\\\",\\\"whl\\\",\\\"wim\\\",\\\"wm\\\",\\\"wma\\\",\\\"wmv\\\",\\\"wmx\\\",\\\"woff\\\",\\\"woff2\\\",\\\"wrm\\\",\\\"wvx\\\",\\\"xbm\\\",\\\"xif\\\",\\\"xla\\\",\\\"xlam\\\",\\\"xls\\\",\\\"xlsb\\\",\\\"xlsm\\\",\\\"xlsx\\\",\\\"xlt\\\",\\\"xltm\\\",\\\"xltx\\\",\\\"xm\\\",\\\"xmind\\\",\\\"xpi\\\",\\\"xpm\\\",\\\"xwd\\\",\\\"xz\\\",\\\"z\\\",\\\"zip\\\",\\\"zipx\\\"]\");\n\n//# sourceURL=webpack://pyright-server/./node_modules/binary-extensions/binary-extensions.json?");

/***/ }),

/***/ "./node_modules/binary-extensions/index.js":
/*!*************************************************!*\
  !*** ./node_modules/binary-extensions/index.js ***!
  \*************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./binary-extensions.json */ \"./node_modules/binary-extensions/binary-extensions.json\");\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/binary-extensions/index.js?");

/***/ }),

/***/ "./node_modules/chokidar/index.js":
/*!****************************************!*\
  !*** ./node_modules/chokidar/index.js ***!
  \****************************************/
/*! default exports */
/*! export FSWatcher [provided] [no usage info] [missing usage info prevents renaming] */
/*! export watch [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_exports__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { EventEmitter } = __webpack_require__(/*! events */ \"events\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst sysPath = __webpack_require__(/*! path */ \"path\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst readdirp = __webpack_require__(/*! readdirp */ \"./node_modules/readdirp/index.js\");\nconst anymatch = __webpack_require__(/*! anymatch */ \"./node_modules/anymatch/index.js\").default;\nconst globParent = __webpack_require__(/*! glob-parent */ \"./node_modules/glob-parent/index.js\");\nconst isGlob = __webpack_require__(/*! is-glob */ \"./node_modules/is-glob/index.js\");\nconst braces = __webpack_require__(/*! braces */ \"./node_modules/chokidar/node_modules/braces/index.js\");\nconst normalizePath = __webpack_require__(/*! normalize-path */ \"./node_modules/normalize-path/index.js\");\n\nconst NodeFsHandler = __webpack_require__(/*! ./lib/nodefs-handler */ \"./node_modules/chokidar/lib/nodefs-handler.js\");\nconst FsEventsHandler = __webpack_require__(/*! ./lib/fsevents-handler */ \"./node_modules/chokidar/lib/fsevents-handler.js\");\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n\n  STR_CLOSE,\n  STR_END,\n\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n\n  SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n\n  isWindows,\n  isMacos\n} = __webpack_require__(/*! ./lib/constants */ \"./node_modules/chokidar/lib/constants.js\");\n\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = (paths_) => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\nconst toUnix = (string) => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {items} = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {items} = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {items} = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {items} = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach((parts) => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath,\n      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\n    );\n  }\n\n  filterPath(entry) {\n    const {stats} = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\n      this.globFilter(resolvedPath) : true;\n    return matchesGlob &&\n      this.fsw._isntIgnored(resolvedPath, stats) &&\n      this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach((path) => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some((parts) => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n// Not indenting methods for history sake; for now.\nconstructor(_opts) {\n  super();\n\n  const opts = {};\n  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n  /** @type {Map<String, DirEntry>} */\n  this._watched = new Map();\n  /** @type {Map<String, Array>} */\n  this._closers = new Map();\n  /** @type {Set<String>} */\n  this._ignoredPaths = new Set();\n\n  /** @type {Map<ThrottleType, Map>} */\n  this._throttled = new Map();\n\n  /** @type {Map<Path, String|Boolean>} */\n  this._symlinkPaths = new Map();\n\n  this._streams = new Set();\n  this.closed = false;\n\n  // Set up default options.\n  if (undef(opts, 'persistent')) opts.persistent = true;\n  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef(opts, 'interval')) opts.interval = 100;\n  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\n  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n  // If we can't use fsevents, ensure the options reflect it's disabled.\n  const canUseFsEvents = FsEventsHandler.canUse();\n  if (!canUseFsEvents) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs_watch.\n  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n    opts.usePolling = isMacos;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    const envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n  const envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = Number.parseInt(envInterval, 10);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = new Map();\n\n  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  const awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = new Map();\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  let readyCalls = 0;\n  this._emitReady = () => {\n    readyCalls++;\n    if (readyCalls >= this._readyCount) {\n      this._emitReady = EMPTY_FN;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(() => this.emit(EV_READY));\n    }\n  };\n  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n  this._readyEmitted = false;\n  this.options = opts;\n\n  // Initialize with proper watcher.\n  if (opts.useFsEvents) {\n    this._fsEventsHandler = new FsEventsHandler(this);\n  } else {\n    this._nodeFsHandler = new NodeFsHandler(this);\n  }\n\n  // You’re frozen when your heart’s not open.\n  Object.freeze(opts);\n}\n\n// Public methods\n\n/**\n * Adds paths to be watched on an existing FSWatcher instance\n * @param {Path|Array<Path>} paths_\n * @param {String=} _origAdd private; for handling non-existent paths to be watched\n * @param {Boolean=} _internal private; indicates a non-user add\n * @returns {FSWatcher} for chaining\n */\nadd(paths_, _origAdd, _internal) {\n  const {cwd, disableGlobbing} = this.options;\n  this.closed = false;\n  let paths = unifyPaths(paths_);\n  if (cwd) {\n    paths = paths.map((path) => {\n      const absPath = getAbsolutePath(path, cwd);\n\n      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n      if (disableGlobbing || !isGlob(path)) {\n        return absPath;\n      }\n      return normalizePath(absPath);\n    });\n  }\n\n  // set aside negated glob strings\n  paths = paths.filter((path) => {\n    if (path.startsWith(BANG)) {\n      this._ignoredPaths.add(path.slice(1));\n      return false;\n    }\n\n    // if a path is being added that was previously ignored, stop ignoring it\n    this._ignoredPaths.delete(path);\n    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n\n    return true;\n  });\n\n  if (this.options.useFsEvents && this._fsEventsHandler) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    Promise.all(\n      paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })\n    ).then(results => {\n      if (this.closed) return;\n      results.filter(item => item).forEach(item => {\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      });\n    });\n  }\n\n  return this;\n}\n\n/**\n * Close watchers or start ignoring events from specified paths.\n * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n * @returns {FSWatcher} for chaining\n*/\nunwatch(paths_) {\n  if (this.closed) return this;\n  const paths = unifyPaths(paths_);\n  const {cwd} = this.options;\n\n  paths.forEach((path) => {\n    // convert to absolute path unless relative path already matches\n    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n      if (cwd) path = sysPath.join(cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths.add(path);\n    if (this._watched.has(path)) {\n      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n  });\n\n  return this;\n}\n\n/**\n * Close watchers and remove all listeners from watched paths.\n * @returns {Promise<void>}.\n*/\nclose() {\n  if (this.closed) return this._closePromise;\n  this.closed = true;\n\n  // Memory management.\n  this.removeAllListeners();\n  const closers = [];\n  this._closers.forEach(closerList => closerList.forEach(closer => {\n    const promise = closer();\n    if (promise instanceof Promise) closers.push(promise);\n  }));\n  this._streams.forEach(stream => stream.destroy());\n  this._userIgnored = undefined;\n  this._readyCount = 0;\n  this._readyEmitted = false;\n  this._watched.forEach(dirent => dirent.dispose());\n  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n    this[`_${key}`].clear();\n  });\n\n  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n  return this._closePromise;\n}\n\n/**\n * Expose list of watched paths\n * @returns {Object} for chaining\n*/\ngetWatched() {\n  const watchList = {};\n  this._watched.forEach((entry, dir) => {\n    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || ONE_DOT] = entry.getChildren().sort();\n  });\n  return watchList;\n}\n\nemitWithAll(event, args) {\n  this.emit(...args);\n  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n}\n\n// Common helpers\n// --------------\n\n/**\n * Normalize and emit events.\n * Calling _emit DOES NOT MEAN emit() would be called!\n * @param {EventName} event Type of event\n * @param {Path} path File or directory path\n * @param {*=} val1 arguments to be passed with event\n * @param {*=} val2\n * @param {*=} val3\n * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\nasync _emit(event, path, val1, val2, val3) {\n  if (this.closed) return;\n\n  const opts = this.options;\n  if (isWindows) path = sysPath.normalize(path);\n  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n  /** @type Array<any> */\n  const args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  const awf = opts.awaitWriteFinish;\n  let pw;\n  if (awf && (pw = this._pendingWrites.get(path))) {\n    pw.lastChange = new Date();\n    return this;\n  }\n\n  if (opts.atomic) {\n    if (event === EV_UNLINK) {\n      this._pendingUnlinks.set(path, args);\n      setTimeout(() => {\n        this._pendingUnlinks.forEach((entry, path) => {\n          this.emit(...entry);\n          this.emit(EV_ALL, ...entry);\n          this._pendingUnlinks.delete(path);\n        });\n      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n      return this;\n    }\n    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n      event = args[0] = EV_CHANGE;\n      this._pendingUnlinks.delete(path);\n    }\n  }\n\n  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n    const awfEmit = (err, stats) => {\n      if (err) {\n        event = args[0] = EV_ERROR;\n        args[1] = err;\n        this.emitWithAll(event, args);\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        this.emitWithAll(event, args);\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === EV_CHANGE) {\n    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n    if (isThrottled) return this;\n  }\n\n  if (opts.alwaysStat && val1 === undefined &&\n    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\n  ) {\n    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n    let stats;\n    try {\n      stats = await stat(fullPath);\n    } catch (err) {}\n    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n    if (!stats || this.closed) return;\n    args.push(stats);\n  }\n  this.emitWithAll(event, args);\n\n  return this;\n}\n\n/**\n * Common handler for errors\n * @param {Error} error\n * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\n_handleError(error) {\n  const code = error && error.code;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n  ) {\n    this.emit(EV_ERROR, error);\n  }\n  return error || this.closed;\n}\n\n/**\n * Helper utility for throttling\n * @param {ThrottleType} actionType type being throttled\n * @param {Path} path being acted upon\n * @param {Number} timeout duration of time to suppress duplicate actions\n * @returns {Object|false} tracking object or false if action should be suppressed\n */\n_throttle(actionType, path, timeout) {\n  if (!this._throttled.has(actionType)) {\n    this._throttled.set(actionType, new Map());\n  }\n\n  /** @type {Map<Path, Object>} */\n  const action = this._throttled.get(actionType);\n  /** @type {Object} */\n  const actionPath = action.get(path);\n\n  if (actionPath) {\n    actionPath.count++;\n    return false;\n  }\n\n  let timeoutObject;\n  const clear = () => {\n    const item = action.get(path);\n    const count = item ? item.count : 0;\n    action.delete(path);\n    clearTimeout(timeoutObject);\n    if (item) clearTimeout(item.timeoutObject);\n    return count;\n  };\n  timeoutObject = setTimeout(clear, timeout);\n  const thr = {timeoutObject, clear, count: 0};\n  action.set(path, thr);\n  return thr;\n}\n\n_incrReadyCount() {\n  return this._readyCount++;\n}\n\n/**\n * Awaits write operation to finish.\n * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n * @param {Path} path being acted upon\n * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n * @param {EventName} event\n * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n */\n_awaitWriteFinish(path, threshold, event, awfEmit) {\n  let timeoutHandler;\n\n  let fullPath = path;\n  if (this.options.cwd && !sysPath.isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  const now = new Date();\n\n  const awaitWriteFinish = (prevStat) => {\n    fs.stat(fullPath, (err, curStat) => {\n      if (err || !this._pendingWrites.has(path)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      const now = Number(new Date());\n\n      if (prevStat && curStat.size !== prevStat.size) {\n        this._pendingWrites.get(path).lastChange = now;\n      }\n      const pw = this._pendingWrites.get(path);\n      const df = now - pw.lastChange;\n\n      if (df >= threshold) {\n        this._pendingWrites.delete(path);\n        awfEmit(undefined, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish,\n          this.options.awaitWriteFinish.pollInterval,\n          curStat\n        );\n      }\n    });\n  };\n\n  if (!this._pendingWrites.has(path)) {\n    this._pendingWrites.set(path, {\n      lastChange: now,\n      cancelWait: () => {\n        this._pendingWrites.delete(path);\n        clearTimeout(timeoutHandler);\n        return event;\n      }\n    });\n    timeoutHandler = setTimeout(\n      awaitWriteFinish,\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n}\n\n_getGlobIgnored() {\n  return [...this._ignoredPaths.values()];\n}\n\n/**\n * Determines whether user has asked to ignore this path.\n * @param {Path} path filepath or dir\n * @param {fs.Stats=} stats result of fs.stat\n * @returns {Boolean}\n */\n_isIgnored(path, stats) {\n  if (this.options.atomic && DOT_RE.test(path)) return true;\n  if (!this._userIgnored) {\n    const {cwd} = this.options;\n    const ign = this.options.ignored;\n\n    const ignored = ign && ign.map(normalizeIgnored(cwd));\n    const paths = arrify(ignored)\n      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n      .map((path) => path + SLASH_GLOBSTAR);\n    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n  }\n\n  return this._userIgnored([path, stats]);\n}\n\n_isntIgnored(path, stat) {\n  return !this._isIgnored(path, stat);\n}\n\n/**\n * Provides a set of common helpers and properties relating to symlink and glob handling.\n * @param {Path} path file, directory, or glob pattern being watched\n * @param {Number=} depth at any depth > 0, this isn't a glob\n * @returns {WatchHelper} object containing helpers for this path\n */\n_getWatchHelpers(path, depth) {\n  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  const follow = this.options.followSymlinks;\n\n  return new WatchHelper(path, watchPath, follow, this);\n}\n\n// Directory helpers\n// -----------------\n\n/**\n * Provides directory tracking objects\n * @param {String} directory path of the directory\n * @returns {DirEntry} the directory's tracking object\n */\n_getWatchedDir(directory) {\n  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n  const dir = sysPath.resolve(directory);\n  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n  return this._watched.get(dir);\n}\n\n// File helpers\n// ------------\n\n/**\n * Check for read permissions.\n * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n * @param {fs.Stats} stats - object, result of fs_stat\n * @returns {Boolean} indicates whether the file can be read\n*/\n_hasReadPermissions(stats) {\n  if (this.options.ignorePermissionErrors) return true;\n\n  // stats.mode may be bigint\n  const md = stats && Number.parseInt(stats.mode, 10);\n  const st = md & 0o777;\n  const it = Number.parseInt(st.toString(8)[0], 10);\n  return Boolean(4 & it);\n}\n\n/**\n * Handles emitting unlink events for\n * files and directories, and via recursion, for\n * files and directories within directories that are unlinked\n * @param {String} directory within which the following item is located\n * @param {String} item      base path of item/directory\n * @returns {void}\n*/\n_remove(directory, item, isDirectory) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  const path = sysPath.join(directory, item);\n  const fullPath = sysPath.resolve(path);\n  isDirectory = isDirectory != null\n    ? isDirectory\n    : this._watched.has(path) || this._watched.has(fullPath);\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle('remove', path, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  const wp = this._getWatchedDir(path);\n  const nestedDirectoryChildren = wp.getChildren();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n  // Check if item was on the watched list and remove it\n  const parent = this._getWatchedDir(directory);\n  const wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // If we wait for this file to be fully written, cancel the wait.\n  let relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n    const event = this._pendingWrites.get(relPath).cancelWait();\n    if (event === EV_ADD) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  this._watched.delete(path);\n  this._watched.delete(fullPath);\n  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n}\n\n/**\n *\n * @param {Path} path\n */\n_closePath(path) {\n  const closers = this._closers.get(path);\n  if (!closers) return;\n  closers.forEach(closer => closer());\n  this._closers.delete(path);\n  const dir = sysPath.dirname(path);\n  this._getWatchedDir(dir).remove(sysPath.basename(path));\n}\n\n/**\n *\n * @param {Path} path\n * @param {Function} closer\n */\n_addPathCloser(path, closer) {\n  if (!closer) return;\n  let list = this._closers.get(path);\n  if (!list) {\n    list = [];\n    this._closers.set(path, list);\n  }\n  list.push(closer);\n}\n\n_readdirp(root, opts) {\n  if (this.closed) return;\n  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n  let stream = readdirp(root, options);\n  this._streams.add(stream);\n  stream.once(STR_CLOSE, () => {\n    stream = undefined;\n  });\n  stream.once(STR_END, () => {\n    if (stream) {\n      this._streams.delete(stream);\n      stream = undefined;\n    }\n  });\n  return stream;\n}\n\n}\n\n// Export FSWatcher class\nexports.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nexports.watch = watch;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/chokidar/index.js?");

/***/ }),

/***/ "./node_modules/chokidar/lib/constants.js":
/*!************************************************!*\
  !*** ./node_modules/chokidar/lib/constants.js ***!
  \************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {sep} = __webpack_require__(/*! path */ \"path\");\nconst {platform} = process;\n\nexports.EV_ALL = 'all';\nexports.EV_READY = 'ready';\nexports.EV_ADD = 'add';\nexports.EV_CHANGE = 'change';\nexports.EV_ADD_DIR = 'addDir';\nexports.EV_UNLINK = 'unlink';\nexports.EV_UNLINK_DIR = 'unlinkDir';\nexports.EV_RAW = 'raw';\nexports.EV_ERROR = 'error';\n\nexports.STR_DATA = 'data';\nexports.STR_END = 'end';\nexports.STR_CLOSE = 'close';\n\nexports.FSEVENT_CREATED = 'created';\nexports.FSEVENT_MODIFIED = 'modified';\nexports.FSEVENT_DELETED = 'deleted';\nexports.FSEVENT_MOVED = 'moved';\nexports.FSEVENT_CLONED = 'cloned';\nexports.FSEVENT_UNKNOWN = 'unknown';\nexports.FSEVENT_TYPE_FILE = 'file';\nexports.FSEVENT_TYPE_DIRECTORY = 'directory';\nexports.FSEVENT_TYPE_SYMLINK = 'symlink';\n\nexports.KEY_LISTENERS = 'listeners';\nexports.KEY_ERR = 'errHandlers';\nexports.KEY_RAW = 'rawEmitters';\nexports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n\nexports.DOT_SLASH = `.${sep}`;\n\nexports.BACK_SLASH_RE = /\\\\/g;\nexports.DOUBLE_SLASH_RE = /\\/\\//;\nexports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\nexports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\nexports.REPLACER_RE = /^\\.[/\\\\]/;\n\nexports.SLASH = '/';\nexports.BRACE_START = '{';\nexports.BANG = '!';\nexports.ONE_DOT = '.';\nexports.TWO_DOTS = '..';\nexports.STAR = '*';\nexports.GLOBSTAR = '**';\nexports.ROOT_GLOBSTAR = '/**/*';\nexports.SLASH_GLOBSTAR = '/**';\nexports.DIR_SUFFIX = 'Dir';\nexports.ANYMATCH_OPTS = {dot: true};\nexports.STRING_TYPE = 'string';\nexports.FUNCTION_TYPE = 'function';\nexports.EMPTY_STR = '';\nexports.EMPTY_FN = () => {};\nexports.IDENTITY_FN = val => val;\n\nexports.isWindows = platform === 'win32';\nexports.isMacos = platform === 'darwin';\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/chokidar/lib/constants.js?");

/***/ }),

/***/ "./node_modules/chokidar/lib/fsevents-handler.js":
/*!*******************************************************!*\
  !*** ./node_modules/chokidar/lib/fsevents-handler.js ***!
  \*******************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst sysPath = __webpack_require__(/*! path */ \"path\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\n\nlet fsevents;\ntry {\n  fsevents = __webpack_require__(/*! fsevents */ \"./node_modules/fsevents/fsevents.js\");\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD,\n  EV_CHANGE,\n  EV_ADD_DIR,\n  EV_UNLINK,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE,\n  EMPTY_FN,\n  IDENTITY_FN\n} = __webpack_require__(/*! ./constants */ \"./node_modules/chokidar/lib/constants.js\");\n\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\n\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\nconst statMethods = { stat, lstat };\n\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n\n// fsevents instance helper functions\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\n\nconst wrongEventFlags = new Set([\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n]);\n\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {stop};\n};\n\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\nfunction setFSEventsListener(path, realPath, listener, rawEmitter, fsw) {\n  let watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;\n  const parentPath = sysPath.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath.sep)\n    ) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (fsw.closed) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = (path) => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path, root) => {\n  let i = 0;\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => (\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\n)\n\n/**\n * @mixin\n */\nclass FsEventsHandler {\n\n/**\n * @param {import('../index').FSWatcher} fsw\n */\nconstructor(fsw) {\n  this.fsw = fsw;\n}\ncheckIgnored(path, stats) {\n  const ipaths = this.fsw._ignoredPaths;\n  if (this.fsw._isIgnored(path, stats)) {\n    ipaths.add(path);\n    if (stats && stats.isDirectory()) {\n      ipaths.add(path + ROOT_GLOBSTAR);\n    }\n    return true;\n  }\n\n  ipaths.delete(path);\n  ipaths.delete(path + ROOT_GLOBSTAR);\n}\n\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n}\n\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  try {\n    const stats = await stat(path)\n    if (this.fsw.closed) return;\n    if (this.fsw.closed) return;\n    if (sameTypes(info, stats)) {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  } catch (error) {\n    if (error.code === 'EACCES') {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  }\n}\n\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  if (this.fsw.closed || this.checkIgnored(path)) return;\n\n  if (event === EV_UNLINK) {\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY\n    // suppress unlink events on never before seen files\n    if (isDirectory || watchedDir.has(item)) {\n      this.fsw._remove(parent, item, isDirectory);\n    }\n  } else {\n    if (event === EV_ADD) {\n      // track new directories\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n        // push symlinks back to the top of the stack to get handled\n        const curDepth = opts.depth === undefined ?\n          undefined : calcDepth(fullPath, realPath) + 1;\n        return this._addToFsEvents(path, false, true, curDepth);\n      }\n\n      // track new paths\n      // (other than symlinks being followed, which will be tracked soon)\n      this.fsw._getWatchedDir(parent).add(item);\n    }\n    /**\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n     */\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n    this.fsw._emit(eventName, path);\n    if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\n  }\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} watchPath  - file/dir path to be watched with fsevents\n * @param {String} realPath   - real path (in case of symlinks)\n * @param {Function} transform  - path transformer\n * @param {Function} globFilter - path filter in case a glob pattern was provided\n * @returns {Function} closer for the watcher instance\n*/\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n  if (this.fsw.closed) return;\n  if (this.fsw._isIgnored(watchPath)) return;\n  const opts = this.fsw.options;\n  const watchCallback = async (fullPath, flags, info) => {\n    if (this.fsw.closed) return;\n    if (\n      opts.depth !== undefined &&\n      calcDepth(fullPath, realPath) > opts.depth\n    ) return;\n    const path = transform(sysPath.join(\n      watchPath, sysPath.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    const parent = sysPath.dirname(path);\n    const item = sysPath.basename(path);\n    const watchedDir = this.fsw._getWatchedDir(\n      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\n    );\n\n    // correct for wrong events emitted\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n      if (typeof opts.ignored === FUNCTION_TYPE) {\n        let stats;\n        try {\n          stats = await stat(path);\n        } catch (error) {}\n        if (this.fsw.closed) return;\n        if (this.checkIgnored(path, stats)) return;\n        if (sameTypes(info, stats)) {\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } else {\n      switch (info.event) {\n      case FSEVENT_CREATED:\n      case FSEVENT_MODIFIED:\n        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      case FSEVENT_DELETED:\n      case FSEVENT_MOVED:\n        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  };\n\n  const closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.fsw._emitRaw,\n    this.fsw\n  );\n\n  this.fsw._emitReady();\n  return closer;\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} linkPath path to symlink\n * @param {String} fullPath absolute path to the symlink\n * @param {Function} transform pre-existing path transformer\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\n * @returns {Promise<void>}\n */\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n  this.fsw._symlinkPaths.set(fullPath, true);\n  this.fsw._incrReadyCount();\n\n  try {\n    const linkTarget = await realpath(linkPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(linkTarget)) {\n      return this.fsw._emitReady();\n    }\n\n    this.fsw._incrReadyCount();\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, (path) => {\n      let aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== DOT_SLASH) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== DOT_SLASH) {\n        aliasedPath = sysPath.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  } catch(error) {\n    if (this.fsw._handleError(error)) {\n      return this.fsw._emitReady();\n    }\n  }\n}\n\n/**\n *\n * @param {Path} newPath\n * @param {fs.Stats} stats\n */\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\n  const pp = processPath(newPath);\n  const isDir = stats.isDirectory();\n  const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\n  const base = sysPath.basename(pp);\n\n  // ensure empty dirs get tracked\n  if (isDir) this.fsw._getWatchedDir(pp);\n  if (dirObj.has(base)) return;\n  dirObj.add(base);\n\n  if (!opts.ignoreInitial || forceAdd === true) {\n    this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\n  }\n}\n\ninitWatch(realPath, path, wh, processPath) {\n  if (this.fsw.closed) return;\n  const closer = this._watchWithFsEvents(\n    wh.watchPath,\n    sysPath.resolve(realPath || wh.watchPath),\n    processPath,\n    wh.globFilter\n  );\n  this.fsw._addPathCloser(path, closer);\n}\n\n/**\n * Handle added path with fsevents\n * @param {String} path file/dir path or glob pattern\n * @param {Function|Boolean=} transform converts working path to what the user expects\n * @param {Boolean=} forceAdd ensure add is emitted\n * @param {Number=} priorDepth Level of subdirectories already traversed.\n * @returns {Promise<void>}\n */\nasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const opts = this.fsw.options;\n  const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n\n  const wh = this.fsw._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      throw null;\n    }\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > opts.depth) return;\n\n      // scan the contents of the dir\n      this.fsw._readdirp(wh.watchPath, {\n        fileFilter: entry => wh.filterPath(entry),\n        directoryFilter: entry => wh.filterDir(entry),\n        ...Depth(opts.depth - (priorDepth || 0))\n      }).on(STR_DATA, (entry) => {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (this.fsw.closed) {\n          return;\n        }\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n\n        const joinedPath = sysPath.join(wh.watchPath, entry.path);\n        const {fullPath} = entry;\n\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          const curDepth = opts.depth === undefined ?\n            undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n        }\n      }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\n        this.fsw._emitReady();\n      });\n    } else {\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n      this.fsw._emitReady();\n    }\n  } catch (error) {\n    if (!error || this.fsw._handleError(error)) {\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n      this.fsw._emitReady();\n      this.fsw._emitReady();\n    }\n  }\n\n  if (opts.persistent && forceAdd !== true) {\n    if (typeof transform === FUNCTION_TYPE) {\n      // realpath has already been resolved\n      this.initWatch(undefined, path, wh, processPath);\n    } else {\n      let realPath;\n      try {\n        realPath = await realpath(wh.watchPath);\n      } catch (e) {}\n      this.initWatch(realPath, path, wh, processPath);\n    }\n  }\n}\n\n}\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/chokidar/lib/fsevents-handler.js?");

/***/ }),

/***/ "./node_modules/chokidar/lib/nodefs-handler.js":
/*!*****************************************************!*\
  !*** ./node_modules/chokidar/lib/nodefs-handler.js ***!
  \*****************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst sysPath = __webpack_require__(/*! path */ \"path\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst isBinaryPath = __webpack_require__(/*! is-binary-path */ \"./node_modules/is-binary-path/index.js\");\nconst {\n  isWindows,\n  EMPTY_FN,\n  EMPTY_STR,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE,\n  EV_ADD,\n  EV_ADD_DIR,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  BRACE_START,\n  STAR\n} = __webpack_require__(/*! ./constants */ \"./node_modules/chokidar/lib/constants.js\");\n\nconst THROTTLE_MODE_WATCH = 'watch';\n\nconst open = promisify(fs.open);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst close = promisify(fs.close);\nconst fsrealpath = promisify(fs.realpath);\n\nconst statMethods = { lstat, stat };\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(\n        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], (listener) => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {listener, errHandler, rawEmitter} = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\n    );\n    if (!watcher) return;\n    watcher.on(EV_ERROR, async (error) => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (isWindows && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {listener, rawEmitter} = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n\n  /* eslint-disable no-unused-vars, prefer-destructuring */\n  let listeners = new Set();\n  let rawEmitters = new Set();\n\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = cont.listeners;\n    rawEmitters = cont.rawEmitters;\n    fs.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, (rawEmitter) => {\n          rawEmitter(EV_CHANGE, fullPath, {curr, prev});\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, (listener) => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nclass NodeFsHandler {\n\n/**\n * @param {import(\"../index\").FSWatcher} fsW\n */\nconstructor(fsW) {\n  this.fsw = fsW;\n  this._boundHandleError = (error) => fsW._handleError(error);\n}\n\n/**\n * Watch file for changes with fs_watchFile or fs_watch.\n * @param {String} path to file or dir\n * @param {Function} listener on fs change\n * @returns {Function} closer for the watcher instance\n */\n_watchWithNodeFs(path, listener) {\n  const opts = this.fsw.options;\n  const directory = sysPath.dirname(path);\n  const basename = sysPath.basename(path);\n  const parent = this.fsw._getWatchedDir(directory);\n  parent.add(basename);\n  const absolutePath = sysPath.resolve(path);\n  const options = {persistent: opts.persistent};\n  if (!listener) listener = EMPTY_FN;\n\n  let closer;\n  if (opts.usePolling) {\n    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\n      opts.binaryInterval : opts.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener,\n      rawEmitter: this.fsw._emitRaw\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener,\n      errHandler: this._boundHandleError,\n      rawEmitter: this.fsw._emitRaw\n    });\n  }\n  return closer;\n}\n\n/**\n * Watch a file and emit add event if warranted.\n * @param {Path} file Path\n * @param {fs.Stats} stats result of fs_stat\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @returns {Function} closer for the watcher instance\n */\n_handleFile(file, stats, initialAdd) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const dirname = sysPath.dirname(file);\n  const basename = sysPath.basename(file);\n  const parent = this.fsw._getWatchedDir(dirname);\n  // stats is always present\n  let prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return;\n\n  // kick off the watcher\n  const closer = this._watchWithNodeFs(file, async (path, newStats) => {\n    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n    if (!newStats || newStats.mtimeMs === 0) {\n      try {\n        const newStats = await stat(file);\n        if (this.fsw.closed) return;\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE, file, newStats);\n        }\n        prevStats = newStats;\n      } catch (error) {\n        // Fix issues where mtime is null but file is still present\n        this.fsw._remove(dirname, basename);\n      }\n    // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      const at = newStats.atimeMs;\n      const mt = newStats.mtimeMs;\n      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n        this.fsw._emit(EV_CHANGE, file, newStats);\n      }\n      prevStats = newStats;\n    }\n  });\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n    if (!this.fsw._throttle(EV_ADD, file, 0)) return;\n    this.fsw._emit(EV_ADD, file, stats);\n  }\n\n  return closer;\n}\n\n/**\n * Handle symlinks encountered while reading a dir.\n * @param {Object} entry returned by readdirp\n * @param {String} directory path of dir being read\n * @param {String} path of this item\n * @param {String} item basename of this item\n * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n */\nasync _handleSymlink(entry, directory, path, item) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const full = entry.fullPath;\n  const dir = this.fsw._getWatchedDir(directory);\n\n  if (!this.fsw.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this.fsw._incrReadyCount();\n    const linkPath = await fsrealpath(path);\n    if (this.fsw.closed) return;\n    if (dir.has(item)) {\n      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n        this.fsw._symlinkPaths.set(full, linkPath);\n        this.fsw._emit(EV_CHANGE, path, entry.stats);\n      }\n    } else {\n      dir.add(item);\n      this.fsw._symlinkPaths.set(full, linkPath);\n      this.fsw._emit(EV_ADD, path, entry.stats);\n    }\n    this.fsw._emitReady();\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this.fsw._symlinkPaths.has(full)) {\n    return true;\n  }\n\n  this.fsw._symlinkPaths.set(full, true);\n}\n\n_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n  // Normalize the directory name on Windows\n  directory = sysPath.join(directory, EMPTY_STR);\n\n  if (!wh.hasGlob) {\n    throttler = this.fsw._throttle('readdir', directory, 1000);\n    if (!throttler) return;\n  }\n\n  const previous = this.fsw._getWatchedDir(wh.path);\n  const current = new Set();\n\n  let stream = this.fsw._readdirp(directory, {\n    fileFilter: entry => wh.filterPath(entry),\n    directoryFilter: entry => wh.filterDir(entry),\n    depth: 0\n  }).on(STR_DATA, async (entry) => {\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    const item = entry.path;\n    let path = sysPath.join(directory, item);\n    current.add(item);\n\n    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\n      return;\n    }\n\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    // Files that present in current directory snapshot\n    // but absent in previous are added to watch list and\n    // emit `add` event.\n    if (item === target || !target && !previous.has(item)) {\n      this.fsw._incrReadyCount();\n\n      // ensure relativeness of path is preserved in case of watcher reuse\n      path = sysPath.join(dir, sysPath.relative(dir, path));\n\n      this._addToNodeFs(path, initialAdd, wh, depth + 1);\n    }\n  }).on(EV_ERROR, this._boundHandleError);\n\n  return new Promise(resolve =>\n    stream.once(STR_END, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter((item) => {\n        return item !== directory &&\n          !current.has(item) &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath.resolve(directory, item)\n          }));\n      }).forEach((item) => {\n        this.fsw._remove(directory, item);\n      });\n\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    })\n  );\n}\n\n/**\n * Read directory to add / remove files from `@watched` list and re-read it on change.\n * @param {String} dir fs path\n * @param {fs.Stats} stats\n * @param {Boolean} initialAdd\n * @param {Number} depth relative to user-supplied path\n * @param {String} target child path targeted for watch\n * @param {Object} wh Common watch helpers for this path\n * @param {String} realpath\n * @returns {Promise<Function>} closer for the watcher instance.\n */\nasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n  const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\n  const tracked = parentDir.has(sysPath.basename(dir));\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath.basename(dir));\n  this.fsw._getWatchedDir(dir);\n  let throttler;\n  let closer;\n\n  const oDepth = this.fsw.options.depth;\n  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n    if (!target) {\n      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n      if (this.fsw.closed) return;\n    }\n\n    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtimeMs === 0) return;\n\n      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n    });\n  }\n  return closer;\n}\n\n/**\n * Handle added file, directory, or glob pattern.\n * Delegates call to _handleFile / _handleDir after checks.\n * @param {String} path to file or ir\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @param {Object} priorWh depth relative to user-supplied path\n * @param {Number} depth Child path actually targeted for watch\n * @param {String=} target Child path actually targeted for watch\n * @returns {Promise}\n */\nasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n  const ready = this.fsw._emitReady;\n  if (this.fsw._isIgnored(path) || this.fsw.closed) {\n    ready();\n    return false;\n  }\n\n  const wh = this.fsw._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = entry => priorWh.filterPath(entry);\n    wh.filterDir = entry => priorWh.filterDir(entry);\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return false;\n    }\n\n    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);\n    let closer;\n    if (stats.isDirectory()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n      if (this.fsw.closed) return;\n      // preserve this symlink's target path\n      if (path !== targetPath && targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(targetPath, true);\n      }\n    } else if (stats.isSymbolicLink()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      const parent = sysPath.dirname(wh.watchPath);\n      this.fsw._getWatchedDir(parent).add(wh.watchPath);\n      this.fsw._emit(EV_ADD, wh.watchPath, stats);\n      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n      if (this.fsw.closed) return;\n\n      // preserve this symlink's target path\n      if (targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\n      }\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd);\n    }\n    ready();\n\n    this.fsw._addPathCloser(path, closer);\n    return false;\n\n  } catch (error) {\n    if (this.fsw._handleError(error)) {\n      ready();\n      return path;\n    }\n  }\n}\n\n}\n\nmodule.exports = NodeFsHandler;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/chokidar/lib/nodefs-handler.js?");

/***/ }),

/***/ "./node_modules/chokidar/node_modules/braces/index.js":
/*!************************************************************!*\
  !*** ./node_modules/chokidar/node_modules/braces/index.js ***!
  \************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst stringify = __webpack_require__(/*! ./lib/stringify */ \"./node_modules/chokidar/node_modules/braces/lib/stringify.js\");\nconst compile = __webpack_require__(/*! ./lib/compile */ \"./node_modules/chokidar/node_modules/braces/lib/compile.js\");\nconst expand = __webpack_require__(/*! ./lib/expand */ \"./node_modules/chokidar/node_modules/braces/lib/expand.js\");\nconst parse = __webpack_require__(/*! ./lib/parse */ \"./node_modules/chokidar/node_modules/braces/lib/parse.js\");\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n return options.expand !== true\n    ? braces.compile(input, options)\n    : braces.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nmodule.exports = braces;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/chokidar/node_modules/braces/index.js?");

/***/ }),

/***/ "./node_modules/chokidar/node_modules/braces/lib/compile.js":
/*!******************************************************************!*\
  !*** ./node_modules/chokidar/node_modules/braces/lib/compile.js ***!
  \******************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fill = __webpack_require__(/*! fill-range */ \"./node_modules/chokidar/node_modules/fill-range/index.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/chokidar/node_modules/braces/lib/utils.js\");\n\nconst compile = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? (prefix + node.value) : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? (prefix + node.value) : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n      let range = fill(...args, { ...options, wrap: false, toRegex: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n    return output;\n  };\n\n  return walk(ast);\n};\n\nmodule.exports = compile;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/chokidar/node_modules/braces/lib/compile.js?");

/***/ }),

/***/ "./node_modules/chokidar/node_modules/braces/lib/constants.js":
/*!********************************************************************!*\
  !*** ./node_modules/chokidar/node_modules/braces/lib/constants.js ***!
  \********************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/chokidar/node_modules/braces/lib/constants.js?");

/***/ }),

/***/ "./node_modules/chokidar/node_modules/braces/lib/expand.js":
/*!*****************************************************************!*\
  !*** ./node_modules/chokidar/node_modules/braces/lib/expand.js ***!
  \*****************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fill = __webpack_require__(/*! fill-range */ \"./node_modules/chokidar/node_modules/fill-range/index.js\");\nconst stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/chokidar/node_modules/braces/lib/stringify.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/chokidar/node_modules/braces/lib/utils.js\");\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nmodule.exports = expand;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/chokidar/node_modules/braces/lib/expand.js?");

/***/ }),

/***/ "./node_modules/chokidar/node_modules/braces/lib/parse.js":
/*!****************************************************************!*\
  !*** ./node_modules/chokidar/node_modules/braces/lib/parse.js ***!
  \****************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/chokidar/node_modules/braces/lib/stringify.js\");\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = __webpack_require__(/*! ./constants */ \"./node_modules/chokidar/node_modules/braces/lib/constants.js\");\n\n/**\n * parse\n */\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = { type: 'root', input, nodes: [] };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n  let memo = {};\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n\n      let closed = true;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nmodule.exports = parse;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/chokidar/node_modules/braces/lib/parse.js?");

/***/ }),

/***/ "./node_modules/chokidar/node_modules/braces/lib/stringify.js":
/*!********************************************************************!*\
  !*** ./node_modules/chokidar/node_modules/braces/lib/stringify.js ***!
  \********************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/chokidar/node_modules/braces/lib/utils.js\");\n\nmodule.exports = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/chokidar/node_modules/braces/lib/stringify.js?");

/***/ }),

/***/ "./node_modules/chokidar/node_modules/braces/lib/utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/chokidar/node_modules/braces/lib/utils.js ***!
  \****************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\n * Find a node of the given type\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\n * Find a node of the given type\n */\n\nexports.exceedsLimit = (min, max, step = 1, limit) => {\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n};\n\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\nexports.escapeNode = (block, n = 0, type) => {\n  let node = block.nodes[n];\n  if (!node) return;\n\n  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a brace node is invalid.\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a node is an open or close node\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\n * Reduce an array of text nodes.\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\n * Flatten an array\n */\n\nexports.flatten = (...args) => {\n  const result = [];\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      let ele = arr[i];\n      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n    }\n    return result;\n  };\n  flat(args);\n  return result;\n};\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/chokidar/node_modules/braces/lib/utils.js?");

/***/ }),

/***/ "./node_modules/chokidar/node_modules/fill-range/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/chokidar/node_modules/fill-range/index.js ***!
  \****************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\nconst util = __webpack_require__(/*! util */ \"util\");\nconst toRegexRange = __webpack_require__(/*! to-regex-range */ \"./node_modules/chokidar/node_modules/to-regex-range/index.js\");\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nmodule.exports = fill;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/chokidar/node_modules/fill-range/index.js?");

/***/ }),

/***/ "./node_modules/chokidar/node_modules/is-number/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/chokidar/node_modules/is-number/index.js ***!
  \***************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nmodule.exports = function(num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/chokidar/node_modules/is-number/index.js?");

/***/ }),

/***/ "./node_modules/chokidar/node_modules/to-regex-range/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/chokidar/node_modules/to-regex-range/index.js ***!
  \********************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nconst isNumber = __webpack_require__(/*! is-number */ \"./node_modules/chokidar/node_modules/is-number/index.js\");\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/chokidar/node_modules/to-regex-range/index.js?");

/***/ }),

/***/ "./node_modules/fsevents/fsevents.js":
/*!*******************************************!*\
  !*** ./node_modules/fsevents/fsevents.js ***!
  \*******************************************/
/*! default exports */
/*! export constants [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getInfo [provided] [no usage info] [missing usage info prevents renaming] */
/*! export watch [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*\n ** © 2020 by Philipp Dunkel, Ben Noordhuis, Elan Shankar, Paul Miller\n ** Licensed under MIT License.\n */\n\n/* jshint node:true */\n\n\nif (process.platform !== 'darwin') {\n  throw new Error(`Module 'fsevents' is not compatible with platform '${process.platform}'`);\n}\n\nconst Native = __webpack_require__(/*! ./fsevents.node */ \"./node_modules/fsevents/fsevents.node\");\nconst events = Native.constants;\n\nfunction watch(path, handler) {\n  if (typeof path !== 'string') {\n    throw new TypeError(`fsevents argument 1 must be a string and not a ${typeof path}`);\n  }\n  if (typeof handler !== 'function') {\n    throw new TypeError(`fsevents argument 2 must be a function and not a ${typeof handler}`);\n  }\n\n  let instance = Native.start(path, handler);\n  if (!instance) throw new Error(`could not watch: ${path}`);\n  return () => {\n    const result = instance\n      ? Promise.resolve(instance).then(Native.stop)\n      : Promise.resolve(undefined);\n    instance = undefined;\n    return result;\n  };\n}\n\nfunction getInfo(path, flags) {\n  return {\n    path,\n    flags,\n    event: getEventType(flags),\n    type: getFileType(flags),\n    changes: getFileChanges(flags)\n  };\n}\n\nfunction getFileType(flags) {\n  if (events.ItemIsFile & flags) return 'file';\n  if (events.ItemIsDir & flags) return 'directory';\n  if (events.ItemIsSymlink & flags) return 'symlink';\n}\nfunction anyIsTrue(obj) {\n  for (let key in obj) {\n    if (obj[key]) return true;\n  }\n  return false;\n}\nfunction getEventType(flags) {\n  if (events.ItemRemoved & flags) return 'deleted';\n  if (events.ItemRenamed & flags) return 'moved';\n  if (events.ItemCreated & flags) return 'created';\n  if (events.ItemModified & flags) return 'modified';\n  if (events.RootChanged & flags) return 'root-changed';\n  if (events.ItemCloned & flags) return 'cloned';\n  if (anyIsTrue(flags)) return 'modified';\n  return 'unknown';\n}\nfunction getFileChanges(flags) {\n  return {\n    inode: !!(events.ItemInodeMetaMod & flags),\n    finder: !!(events.ItemFinderInfoMod & flags),\n    access: !!(events.ItemChangeOwner & flags),\n    xattrs: !!(events.ItemXattrMod & flags)\n  };\n}\n\nexports.watch = watch;\nexports.getInfo = getInfo;\nexports.constants = events;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/fsevents/fsevents.js?");

/***/ }),

/***/ "./node_modules/glob-parent/index.js":
/*!*******************************************!*\
  !*** ./node_modules/glob-parent/index.js ***!
  \*******************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_require__, module */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isGlob = __webpack_require__(/*! is-glob */ \"./node_modules/is-glob/index.js\");\nvar pathPosixDirname = __webpack_require__(/*! path */ \"path\").posix.dirname;\nvar isWin32 = __webpack_require__(/*! os */ \"os\").platform() === 'win32';\n\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\/]*.*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n */\nmodule.exports = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/glob-parent/index.js?");

/***/ }),

/***/ "./node_modules/is-binary-path/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-binary-path/index.js ***!
  \**********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst binaryExtensions = __webpack_require__(/*! binary-extensions */ \"./node_modules/binary-extensions/index.js\");\n\nconst extensions = new Set(binaryExtensions);\n\nmodule.exports = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/is-binary-path/index.js?");

/***/ }),

/***/ "./node_modules/is-extglob/index.js":
/*!******************************************!*\
  !*** ./node_modules/is-extglob/index.js ***!
  \******************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

eval("/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nmodule.exports = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/is-extglob/index.js?");

/***/ }),

/***/ "./node_modules/is-glob/index.js":
/*!***************************************!*\
  !*** ./node_modules/is-glob/index.js ***!
  \***************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = __webpack_require__(/*! is-extglob */ \"./node_modules/is-extglob/index.js\");\nvar chars = { '{': '}', '(': ')', '[': ']'};\nvar strictRegex = /\\\\(.)|(^!|\\*|[\\].+)]\\?|\\[[^\\\\\\]]+\\]|\\{[^\\\\}]+\\}|\\(\\?[:!=][^\\\\)]+\\)|\\([^|]+\\|[^\\\\)]+\\))/;\nvar relaxedRegex = /\\\\(.)|(^!|[*?{}()[\\]]|\\(\\?)/;\n\nmodule.exports = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var regex = strictRegex;\n  var match;\n\n  // optionally relax regex\n  if (options && options.strict === false) {\n    regex = relaxedRegex;\n  }\n\n  while ((match = regex.exec(str))) {\n    if (match[2]) return true;\n    var idx = match.index + match[0].length;\n\n    // if an open bracket/brace/paren is escaped,\n    // set the index to the next closing character\n    var open = match[1];\n    var close = open ? chars[open] : null;\n    if (open && close) {\n      var n = str.indexOf(close, idx);\n      if (n !== -1) {\n        idx = n + 1;\n      }\n    }\n\n    str = str.slice(idx);\n  }\n  return false;\n};\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/is-glob/index.js?");

/***/ }),

/***/ "./node_modules/leven/index.js":
/*!*************************************!*\
  !*** ./node_modules/leven/index.js ***!
  \*************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("\nconst array = [];\nconst charCodeCache = [];\n\nconst leven = (left, right) => {\n\tif (left === right) {\n\t\treturn 0;\n\t}\n\n\tconst swap = left;\n\n\t// Swapping the strings if `a` is longer than `b` so we know which one is the\n\t// shortest & which one is the longest\n\tif (left.length > right.length) {\n\t\tleft = right;\n\t\tright = swap;\n\t}\n\n\tlet leftLength = left.length;\n\tlet rightLength = right.length;\n\n\t// Performing suffix trimming:\n\t// We can linearly drop suffix common to both strings since they\n\t// don't increase distance at all\n\t// Note: `~-` is the bitwise way to perform a `- 1` operation\n\twhile (leftLength > 0 && (left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength))) {\n\t\tleftLength--;\n\t\trightLength--;\n\t}\n\n\t// Performing prefix trimming\n\t// We can linearly drop prefix common to both strings since they\n\t// don't increase distance at all\n\tlet start = 0;\n\n\twhile (start < leftLength && (left.charCodeAt(start) === right.charCodeAt(start))) {\n\t\tstart++;\n\t}\n\n\tleftLength -= start;\n\trightLength -= start;\n\n\tif (leftLength === 0) {\n\t\treturn rightLength;\n\t}\n\n\tlet bCharCode;\n\tlet result;\n\tlet temp;\n\tlet temp2;\n\tlet i = 0;\n\tlet j = 0;\n\n\twhile (i < leftLength) {\n\t\tcharCodeCache[i] = left.charCodeAt(start + i);\n\t\tarray[i] = ++i;\n\t}\n\n\twhile (j < rightLength) {\n\t\tbCharCode = right.charCodeAt(start + j);\n\t\ttemp = j++;\n\t\tresult = j;\n\n\t\tfor (i = 0; i < leftLength; i++) {\n\t\t\ttemp2 = bCharCode === charCodeCache[i] ? temp : temp + 1;\n\t\t\ttemp = array[i];\n\t\t\t// eslint-disable-next-line no-multi-assign\n\t\t\tresult = array[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;\n\t\t}\n\t}\n\n\treturn result;\n};\n\nmodule.exports = leven;\n// TODO: Remove this for the next major release\nmodule.exports.default = leven;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/leven/index.js?");

/***/ }),

/***/ "./node_modules/fsevents/fsevents.node":
/*!*********************************************!*\
  !*** ./node_modules/fsevents/fsevents.node ***!
  \*********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module.loaded, module.id, module, __webpack_require__.nmd, __webpack_require__.* */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\ntry {global.process.dlopen(module, \"/Users/eric/source/pyright/server/node_modules/fsevents/fsevents.node\"); } catch(e) {throw new Error('Cannot open ' + \"/Users/eric/source/pyright/server/node_modules/fsevents/fsevents.node\" + ': ' + e);}\n\n//# sourceURL=webpack://pyright-server/./node_modules/fsevents/fsevents.node?");

/***/ }),

/***/ "./node_modules/normalize-path/index.js":
/*!**********************************************!*\
  !*** ./node_modules/normalize-path/index.js ***!
  \**********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

eval("/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nmodule.exports = function(path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n\n  var len = path.length;\n  if (len <= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = '';\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n  return prefix + segs.join('/');\n};\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/normalize-path/index.js?");

/***/ }),

/***/ "./node_modules/picomatch/index.js":
/*!*****************************************!*\
  !*** ./node_modules/picomatch/index.js ***!
  \*****************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./lib/picomatch */ \"./node_modules/picomatch/lib/picomatch.js\");\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/picomatch/index.js?");

/***/ }),

/***/ "./node_modules/picomatch/lib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/picomatch/lib/constants.js ***!
  \*************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\");\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/picomatch/lib/constants.js?");

/***/ }),

/***/ "./node_modules/picomatch/lib/parse.js":
/*!*********************************************!*\
  !*** ./node_modules/picomatch/lib/parse.js ***!
  \*********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst constants = __webpack_require__(/*! ./constants */ \"./node_modules/picomatch/lib/constants.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/picomatch/lib/utils.js\");\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = (opts) => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index];\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = ')$))' + extglobStar;\n      }\n\n      if (token.prev.type === 'bos' && eos()) {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : '\\\\' + m;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance() || '';\n      } else {\n        value += advance() || '';\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = '\\\\' + value;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = '\\\\' + value;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = '\\\\' + value;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: '\\\\' + value });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: '\\\\' + value });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = '/' + value;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n      push({ type: 'brace', value, output: '(' });\n      continue;\n    }\n\n    if (value === '}') {\n      if (opts.nobrace === true || state.braces === 0) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (state.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      if (state.braces > 0 && stack[stack.length - 1] === 'braces') {\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        state.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = '\\\\' + value;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate(state);\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = '\\\\' + value;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = '(?:' + prior.output;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = '(?:' + prior.output;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        consume(value + advance());\n\n        push({ type: 'slash', value, output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        consume(value + advance());\n        push({ type: 'slash', value, output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = (opts) => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1], options);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/picomatch/lib/parse.js?");

/***/ }),

/***/ "./node_modules/picomatch/lib/picomatch.js":
/*!*************************************************!*\
  !*** ./node_modules/picomatch/lib/picomatch.js ***!
  \*************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\");\nconst scan = __webpack_require__(/*! ./scan */ \"./node_modules/picomatch/lib/scan.js\");\nconst parse = __webpack_require__(/*! ./parse */ \"./node_modules/picomatch/lib/parse.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/picomatch/lib/utils.js\");\nconst constants = __webpack_require__(/*! ./constants */ \"./node_modules/picomatch/lib/constants.js\");\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    return str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n  }\n\n  if (typeof glob !== 'string' || glob === '') {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = picomatch.makeRe(glob, options, false, true);\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: !!match, match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(glob[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (glob, options) => parse(glob, options);\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * // { prefix: '!./',\n * //   input: '!./foo/*.js',\n * //   base: 'foo',\n * //   glob: '*.js',\n * //   negated: true,\n * //   isGlob: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Create a regular expression from a glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.makeRe(input[, options]);\n *\n * console.log(picomatch.makeRe('*.js'));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `input` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n  let state = { negated: false, fastpaths: true };\n  let prefix = '';\n  let output;\n\n  if (input.startsWith('./')) {\n    input = input.slice(2);\n    prefix = state.prefix = './';\n  }\n\n  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    output = parse.fastpaths(input, options);\n  }\n\n  if (output === void 0) {\n    state = picomatch.parse(input, options);\n    state.prefix = prefix + (state.prefix || '');\n    output = state.output;\n  }\n\n  if (returnOutput === true) {\n    return output;\n  }\n\n  let source = `${prepend}(?:${output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/picomatch/lib/picomatch.js?");

/***/ }),

/***/ "./node_modules/picomatch/lib/scan.js":
/*!********************************************!*\
  !*** ./node_modules/picomatch/lib/scan.js ***!
  \********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/picomatch/lib/utils.js\");\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = __webpack_require__(/*! ./constants */ \"./node_modules/picomatch/lib/constants.js\");\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nmodule.exports = (input, options) => {\n  const opts = options || {};\n  const length = input.length - 1;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isGlob = false;\n  let backslashes = false;\n  let negated = false;\n  let braces = 0;\n  let prev;\n  let code;\n\n  let braceEscaped = false;\n\n  const eos = () => index >= length;\n  const advance = () => {\n    prev = code;\n    return input.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = true;\n      next = advance();\n\n      if (next === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (!eos() && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = true;\n          next = advance();\n          continue;\n        }\n\n        if (next === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (!braceEscaped && next === CHAR_DOT && (next = advance()) === CHAR_DOT) {\n          isGlob = true;\n          break;\n        }\n\n        if (!braceEscaped && next === CHAR_COMMA) {\n          isGlob = true;\n          break;\n        }\n\n        if (next === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n          if (braces === 0) {\n            braceEscaped = false;\n            break;\n          }\n        }\n      }\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (code === CHAR_ASTERISK) {\n      isGlob = true;\n      break;\n    }\n\n    if (code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK) {\n      isGlob = true;\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (!eos() && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = true;\n          next = advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isGlob = true;\n          break;\n        }\n      }\n    }\n\n    const isExtglobChar = code === CHAR_PLUS\n      || code === CHAR_AT\n      || code === CHAR_EXCLAMATION_MARK;\n\n    if (isExtglobChar && input.charCodeAt(index + 1) === CHAR_LEFT_PARENTHESES) {\n      isGlob = true;\n      break;\n    }\n\n    if (!opts.nonegate && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      while (!eos() && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = true;\n          code = advance();\n          continue;\n        }\n\n        if (code === CHAR_RIGHT_PARENTHESES) {\n          isGlob = true;\n          break;\n        }\n      }\n    }\n\n    if (isGlob) {\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isGlob = false;\n  }\n\n  let prefix = '';\n  const orig = input;\n  let base = input;\n  let glob = '';\n\n  if (start > 0) {\n    prefix = input.slice(0, start);\n    input = input.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = input.slice(0, lastIndex);\n    glob = input.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = input;\n  } else {\n    base = input;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== input) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  return { prefix, input: orig, base, glob, negated, isGlob };\n};\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/picomatch/lib/scan.js?");

/***/ }),

/***/ "./node_modules/picomatch/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/picomatch/lib/utils.js ***!
  \*********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\");\nconst win32 = process.platform === 'win32';\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = __webpack_require__(/*! ./constants */ \"./node_modules/picomatch/lib/constants.js\");\n\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n    return true;\n  }\n  return false;\n};\n\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return input.slice(0, idx) + '\\\\' + input.slice(idx);\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/picomatch/lib/utils.js?");

/***/ }),

/***/ "./node_modules/readdirp/index.js":
/*!****************************************!*\
  !*** ./node_modules/readdirp/index.js ***!
  \****************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst sysPath = __webpack_require__(/*! path */ \"path\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst picomatch = __webpack_require__(/*! picomatch */ \"./node_modules/readdirp/node_modules/picomatch/index.js\");\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat : stat;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (process.platform === 'win32' && stat.length === 3) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath.resolve(root);\n    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return {files, depth, path};\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath.resolve(sysPath.join(path, basename));\n      entry = {path: sysPath.relative(this._root, fullPath), fullPath, basename};\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      try {\n        const entryRealPath = await realpath(entry.fullPath);\n        const entryRealPathStats = await lstat(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\n\nmodule.exports = readdirp;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/readdirp/index.js?");

/***/ }),

/***/ "./node_modules/readdirp/node_modules/picomatch/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/readdirp/node_modules/picomatch/index.js ***!
  \***************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./lib/picomatch */ \"./node_modules/readdirp/node_modules/picomatch/lib/picomatch.js\");\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/readdirp/node_modules/picomatch/index.js?");

/***/ }),

/***/ "./node_modules/readdirp/node_modules/picomatch/lib/constants.js":
/*!***********************************************************************!*\
  !*** ./node_modules/readdirp/node_modules/picomatch/lib/constants.js ***!
  \***********************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\");\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/readdirp/node_modules/picomatch/lib/constants.js?");

/***/ }),

/***/ "./node_modules/readdirp/node_modules/picomatch/lib/parse.js":
/*!*******************************************************************!*\
  !*** ./node_modules/readdirp/node_modules/picomatch/lib/parse.js ***!
  \*******************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst constants = __webpack_require__(/*! ./constants */ \"./node_modules/readdirp/node_modules/picomatch/lib/constants.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/readdirp/node_modules/picomatch/lib/utils.js\");\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = (opts) => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index];\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.prev.type === 'bos' && eos()) {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance() || '';\n      } else {\n        value += advance() || '';\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = (opts) => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/readdirp/node_modules/picomatch/lib/parse.js?");

/***/ }),

/***/ "./node_modules/readdirp/node_modules/picomatch/lib/picomatch.js":
/*!***********************************************************************!*\
  !*** ./node_modules/readdirp/node_modules/picomatch/lib/picomatch.js ***!
  \***********************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\");\nconst scan = __webpack_require__(/*! ./scan */ \"./node_modules/readdirp/node_modules/picomatch/lib/scan.js\");\nconst parse = __webpack_require__(/*! ./parse */ \"./node_modules/readdirp/node_modules/picomatch/lib/parse.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/readdirp/node_modules/picomatch/lib/utils.js\");\nconst constants = __webpack_require__(/*! ./constants */ \"./node_modules/readdirp/node_modules/picomatch/lib/constants.js\");\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return parsed.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${parsed.output})${append}`;\n  if (parsed && parsed.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = parsed;\n  }\n\n  return regex;\n};\n\npicomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  const opts = options || {};\n  let parsed = { negated: false, fastpaths: true };\n  let prefix = '';\n  let output;\n\n  if (input.startsWith('./')) {\n    input = input.slice(2);\n    prefix = parsed.prefix = './';\n  }\n\n  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    output = parse.fastpaths(input, options);\n  }\n\n  if (output === undefined) {\n    parsed = parse(input, options);\n    parsed.prefix = prefix + (parsed.prefix || '');\n  } else {\n    parsed.output = output;\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/readdirp/node_modules/picomatch/lib/picomatch.js?");

/***/ }),

/***/ "./node_modules/readdirp/node_modules/picomatch/lib/scan.js":
/*!******************************************************************!*\
  !*** ./node_modules/readdirp/node_modules/picomatch/lib/scan.js ***!
  \******************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/readdirp/node_modules/picomatch/lib/utils.js\");\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = __webpack_require__(/*! ./constants */ \"./node_modules/readdirp/node_modules/picomatch/lib/constants.js\");\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n      }\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/readdirp/node_modules/picomatch/lib/scan.js?");

/***/ }),

/***/ "./node_modules/readdirp/node_modules/picomatch/lib/utils.js":
/*!*******************************************************************!*\
  !*** ./node_modules/readdirp/node_modules/picomatch/lib/utils.js ***!
  \*******************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\");\nconst win32 = process.platform === 'win32';\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = __webpack_require__(/*! ./constants */ \"./node_modules/readdirp/node_modules/picomatch/lib/constants.js\");\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n    return true;\n  }\n  return false;\n};\n\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/readdirp/node_modules/picomatch/lib/utils.js?");

/***/ }),

/***/ "./src/analyzer/analysis.ts":
/*!**********************************!*\
  !*** ./src/analyzer/analysis.ts ***!
  \**********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * analysis.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Various analysis helper types and functions\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.analyzeProgram = exports.nullCallback = void 0;\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst debug = __webpack_require__(/*! ../common/debug */ \"./src/common/debug.ts\");\nconst timing_1 = __webpack_require__(/*! ../common/timing */ \"./src/common/timing.ts\");\nexports.nullCallback = (_) => {\n    /* empty */\n};\nfunction analyzeProgram(program, maxTime, configOptions, callback, console, token) {\n    let moreToAnalyze = false;\n    callback = callback !== null && callback !== void 0 ? callback : exports.nullCallback;\n    try {\n        cancellationUtils_1.throwIfCancellationRequested(token);\n        const duration = new timing_1.Duration();\n        moreToAnalyze = program.analyze(maxTime, token);\n        const filesLeftToAnalyze = program.getFilesToAnalyzeCount();\n        debug.assert(filesLeftToAnalyze === 0 || moreToAnalyze);\n        const diagnostics = program.getDiagnostics(configOptions);\n        const diagnosticFileCount = diagnostics.length;\n        const elapsedTime = duration.getDurationInSeconds();\n        // Report any diagnostics or completion.\n        if (diagnosticFileCount > 0 || !moreToAnalyze) {\n            callback({\n                diagnostics,\n                filesInProgram: program.getFileCount(),\n                filesRequiringAnalysis: filesLeftToAnalyze,\n                checkingOnlyOpenFiles: program.isCheckingOnlyOpenFiles(),\n                fatalErrorOccurred: false,\n                configParseErrorOccurred: false,\n                elapsedTime,\n            });\n        }\n    }\n    catch (e) {\n        if (cancellationUtils_1.OperationCanceledException.is(e)) {\n            return false;\n        }\n        const message = (e.stack ? e.stack.toString() : undefined) ||\n            (typeof e.message === 'string' ? e.message : undefined) ||\n            JSON.stringify(e);\n        console.error('Error performing analysis: ' + message);\n        callback({\n            diagnostics: [],\n            filesInProgram: 0,\n            filesRequiringAnalysis: 0,\n            checkingOnlyOpenFiles: true,\n            fatalErrorOccurred: true,\n            configParseErrorOccurred: false,\n            elapsedTime: 0,\n        });\n    }\n    return moreToAnalyze;\n}\nexports.analyzeProgram = analyzeProgram;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/analysis.ts?");

/***/ }),

/***/ "./src/analyzer/analyzerNodeInfo.ts":
/*!******************************************!*\
  !*** ./src/analyzer/analyzerNodeInfo.ts ***!
  \******************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export cleanNodeAnalysisInfo [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getAfterFlowNode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getCodeFlowExpressions [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getDeclaration [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getFileInfo [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getFlowNode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getImportInfo [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getScope [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isCodeUnreachable [provided] [no usage info] [missing usage info prevents renaming] */
/*! export setAfterFlowNode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export setCodeFlowExpressions [provided] [no usage info] [missing usage info prevents renaming] */
/*! export setDeclaration [provided] [no usage info] [missing usage info prevents renaming] */
/*! export setFileInfo [provided] [no usage info] [missing usage info prevents renaming] */
/*! export setFlowNode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export setImportInfo [provided] [no usage info] [missing usage info prevents renaming] */
/*! export setScope [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * analyzerNodeInfo.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Defines objects that hang off the parse nodes in the parse tree.\n * It contains information collected during the binder phase that\n * can be used for later analysis steps or for language services\n * (e.g. hover information).\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isCodeUnreachable = exports.setCodeFlowExpressions = exports.getCodeFlowExpressions = exports.setFileInfo = exports.getFileInfo = exports.setAfterFlowNode = exports.getAfterFlowNode = exports.setFlowNode = exports.getFlowNode = exports.setDeclaration = exports.getDeclaration = exports.setScope = exports.getScope = exports.setImportInfo = exports.getImportInfo = exports.cleanNodeAnalysisInfo = void 0;\nconst codeFlow_1 = __webpack_require__(/*! ./codeFlow */ \"./src/analyzer/codeFlow.ts\");\n// Cleans out all fields that are added by the analyzer phases\n// (after the post-parse walker).\nfunction cleanNodeAnalysisInfo(node) {\n    const analyzerNode = node;\n    delete analyzerNode.scope;\n    delete analyzerNode.declaration;\n    delete analyzerNode.flowNode;\n    delete analyzerNode.afterFlowNode;\n    delete analyzerNode.fileInfo;\n}\nexports.cleanNodeAnalysisInfo = cleanNodeAnalysisInfo;\nfunction getImportInfo(node) {\n    const analyzerNode = node;\n    return analyzerNode.importInfo;\n}\nexports.getImportInfo = getImportInfo;\nfunction setImportInfo(node, importInfo) {\n    const analyzerNode = node;\n    analyzerNode.importInfo = importInfo;\n}\nexports.setImportInfo = setImportInfo;\nfunction getScope(node) {\n    const analyzerNode = node;\n    return analyzerNode.scope;\n}\nexports.getScope = getScope;\nfunction setScope(node, scope) {\n    const analyzerNode = node;\n    analyzerNode.scope = scope;\n}\nexports.setScope = setScope;\nfunction getDeclaration(node) {\n    const analyzerNode = node;\n    return analyzerNode.declaration;\n}\nexports.getDeclaration = getDeclaration;\nfunction setDeclaration(node, decl) {\n    const analyzerNode = node;\n    analyzerNode.declaration = decl;\n}\nexports.setDeclaration = setDeclaration;\nfunction getFlowNode(node) {\n    const analyzerNode = node;\n    return analyzerNode.flowNode;\n}\nexports.getFlowNode = getFlowNode;\nfunction setFlowNode(node, flowNode) {\n    const analyzerNode = node;\n    analyzerNode.flowNode = flowNode;\n}\nexports.setFlowNode = setFlowNode;\nfunction getAfterFlowNode(node) {\n    const analyzerNode = node;\n    return analyzerNode.afterFlowNode;\n}\nexports.getAfterFlowNode = getAfterFlowNode;\nfunction setAfterFlowNode(node, flowNode) {\n    const analyzerNode = node;\n    analyzerNode.afterFlowNode = flowNode;\n}\nexports.setAfterFlowNode = setAfterFlowNode;\nfunction getFileInfo(node) {\n    const analyzerNode = node;\n    return analyzerNode.fileInfo;\n}\nexports.getFileInfo = getFileInfo;\nfunction setFileInfo(node, fileInfo) {\n    const analyzerNode = node;\n    analyzerNode.fileInfo = fileInfo;\n}\nexports.setFileInfo = setFileInfo;\nfunction getCodeFlowExpressions(node) {\n    const analyzerNode = node;\n    return analyzerNode.codeFlowExpressions;\n}\nexports.getCodeFlowExpressions = getCodeFlowExpressions;\nfunction setCodeFlowExpressions(node, map) {\n    const analyzerNode = node;\n    analyzerNode.codeFlowExpressions = map;\n}\nexports.setCodeFlowExpressions = setCodeFlowExpressions;\nfunction isCodeUnreachable(node) {\n    let curNode = node;\n    // Walk up the parse tree until we find a node with\n    // an associated flow node.\n    while (curNode) {\n        const flowNode = getFlowNode(curNode);\n        if (flowNode) {\n            return !!(flowNode.flags & codeFlow_1.FlowFlags.Unreachable);\n        }\n        curNode = curNode.parent;\n    }\n    return false;\n}\nexports.isCodeUnreachable = isCodeUnreachable;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/analyzerNodeInfo.ts?");

/***/ }),

/***/ "./src/analyzer/backgroundAnalysisProgram.ts":
/*!***************************************************!*\
  !*** ./src/analyzer/backgroundAnalysisProgram.ts ***!
  \***************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * BackgroundAnalysisProgram.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Applies operations to both the foreground program and a background\n * analysis running in a worker process.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BackgroundAnalysisProgram = void 0;\nconst analysis_1 = __webpack_require__(/*! ./analysis */ \"./src/analyzer/analysis.ts\");\nconst program_1 = __webpack_require__(/*! ./program */ \"./src/analyzer/program.ts\");\nclass BackgroundAnalysisProgram {\n    constructor(_console, _configOptions, _importResolver, extension, backgroundAnalysis, maxAnalysisTime) {\n        this._console = _console;\n        this._configOptions = _configOptions;\n        this._importResolver = _importResolver;\n        this._program = new program_1.Program(this._importResolver, this._configOptions, this._console, extension);\n        this._backgroundAnalysis = backgroundAnalysis;\n        this._maxAnalysisTime = maxAnalysisTime;\n    }\n    get configOptions() {\n        return this._configOptions;\n    }\n    get importResolver() {\n        return this._importResolver;\n    }\n    get program() {\n        return this._program;\n    }\n    get backgroundAnalysis() {\n        return this._backgroundAnalysis;\n    }\n    setConfigOptions(configOptions) {\n        var _a;\n        this._configOptions = configOptions;\n        (_a = this._backgroundAnalysis) === null || _a === void 0 ? void 0 : _a.setConfigOptions(configOptions);\n        this._program.setConfigOptions(configOptions);\n    }\n    setImportResolver(importResolver) {\n        this._importResolver = importResolver;\n        this._program.setImportResolver(importResolver);\n        // Do nothing for background analysis.\n        // Background analysis updates importer when configOptions is changed rather than\n        // having two APIs to reduce the chance of the program and importer pointing to\n        // two different configOptions.\n    }\n    setTrackedFiles(filePaths) {\n        var _a;\n        (_a = this._backgroundAnalysis) === null || _a === void 0 ? void 0 : _a.setTrackedFiles(filePaths);\n        const diagnostics = this._program.setTrackedFiles(filePaths);\n        this._reportDiagnosticsForRemovedFiles(diagnostics);\n    }\n    setAllowedThirdPartyImports(importNames) {\n        var _a;\n        (_a = this._backgroundAnalysis) === null || _a === void 0 ? void 0 : _a.setAllowedThirdPartyImports(importNames);\n        this._program.setAllowedThirdPartyImports(importNames);\n    }\n    setFileOpened(filePath, version, contents) {\n        var _a;\n        (_a = this._backgroundAnalysis) === null || _a === void 0 ? void 0 : _a.setFileOpened(filePath, version, contents);\n        this._program.setFileOpened(filePath, version, contents);\n    }\n    updateOpenFileContents(path, version, contents) {\n        this.setFileOpened(path, version, contents);\n        this.markFilesDirty([path], true);\n    }\n    setFileClosed(filePath) {\n        var _a;\n        (_a = this._backgroundAnalysis) === null || _a === void 0 ? void 0 : _a.setFileClosed(filePath);\n        const diagnostics = this._program.setFileClosed(filePath);\n        this._reportDiagnosticsForRemovedFiles(diagnostics);\n    }\n    markAllFilesDirty(evenIfContentsAreSame) {\n        var _a;\n        (_a = this._backgroundAnalysis) === null || _a === void 0 ? void 0 : _a.markAllFilesDirty(evenIfContentsAreSame);\n        this._program.markAllFilesDirty(evenIfContentsAreSame);\n    }\n    markFilesDirty(filePaths, evenIfContentsAreSame) {\n        var _a;\n        (_a = this._backgroundAnalysis) === null || _a === void 0 ? void 0 : _a.markFilesDirty(filePaths, evenIfContentsAreSame);\n        this._program.markFilesDirty(filePaths, evenIfContentsAreSame);\n    }\n    setCompletionCallback(callback) {\n        var _a;\n        this._onAnalysisCompletion = callback;\n        (_a = this._backgroundAnalysis) === null || _a === void 0 ? void 0 : _a.setCompletionCallback(callback);\n    }\n    startAnalysis(token) {\n        if (this._backgroundAnalysis) {\n            this._backgroundAnalysis.startAnalysis(token);\n            return false;\n        }\n        return analysis_1.analyzeProgram(this._program, this._maxAnalysisTime, this._configOptions, this._onAnalysisCompletion, this._console, token);\n    }\n    getDiagnosticsForRange(filePath, range, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._backgroundAnalysis) {\n                return this._backgroundAnalysis.getDiagnosticsForRange(filePath, range, token);\n            }\n            return this._program.getDiagnosticsForRange(filePath, range);\n        });\n    }\n    writeTypeStub(targetImportPath, targetIsSingleFile, stubPath, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._backgroundAnalysis) {\n                return this._backgroundAnalysis.writeTypeStub(targetImportPath, targetIsSingleFile, stubPath, token);\n            }\n            analysis_1.analyzeProgram(this._program, undefined, this._configOptions, this._onAnalysisCompletion, this._console, token);\n            return this._program.writeTypeStub(targetImportPath, targetIsSingleFile, stubPath, token);\n        });\n    }\n    invalidateAndForceReanalysis() {\n        var _a;\n        (_a = this._backgroundAnalysis) === null || _a === void 0 ? void 0 : _a.invalidateAndForceReanalysis();\n        // Make sure the import resolver doesn't have invalid\n        // cached entries.\n        this._importResolver.invalidateCache();\n        // Mark all files with one or more errors dirty.\n        this._program.markAllFilesDirty(true);\n    }\n    invalidateCache() {\n        // Invalidate import resolver because it could have cached\n        // imports that are no longer valid because a source file has\n        // been deleted or added.\n        this._importResolver.invalidateCache();\n    }\n    restart() {\n        var _a;\n        (_a = this._backgroundAnalysis) === null || _a === void 0 ? void 0 : _a.restart();\n    }\n    _reportDiagnosticsForRemovedFiles(fileDiags) {\n        if (fileDiags.length > 0) {\n            // If analysis is running in the foreground process, report any\n            // diagnostics that resulted from the close operation (used to\n            // clear diagnostics that are no longer of interest).\n            if (!this._backgroundAnalysis && this._onAnalysisCompletion) {\n                this._onAnalysisCompletion({\n                    diagnostics: fileDiags,\n                    filesInProgram: this._program.getFileCount(),\n                    filesRequiringAnalysis: this._program.getFilesToAnalyzeCount(),\n                    checkingOnlyOpenFiles: this._program.isCheckingOnlyOpenFiles(),\n                    fatalErrorOccurred: false,\n                    configParseErrorOccurred: false,\n                    elapsedTime: 0,\n                });\n            }\n        }\n    }\n}\nexports.BackgroundAnalysisProgram = BackgroundAnalysisProgram;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/backgroundAnalysisProgram.ts?");

/***/ }),

/***/ "./src/analyzer/binder.ts":
/*!********************************!*\
  !*** ./src/analyzer/binder.ts ***!
  \********************************/
/*! flagged exports */
/*! export Binder [provided] [no usage info] [missing usage info prevents renaming] */
/*! export YieldFinder [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * binder.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * A parse tree walker that performs basic name binding (creation of\n * scopes and associated symbol tables).\n * The binder walks the parse tree by scopes starting at the module\n * level. When a new scope is detected, it is pushed onto a list and\n * walked separately at a later time. (The exception is a class scope,\n * which is immediately walked.) Walking the tree in this manner\n * simulates the order in which execution normally occurs in a Python\n * file. The binder attempts to statically detect runtime errors that\n * would be reported by the python interpreter when executing the code.\n * This binder doesn't perform any static type checking.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.YieldFinder = exports.Binder = void 0;\nconst debug_1 = __webpack_require__(/*! ../common/debug */ \"./src/common/debug.ts\");\nconst pathUtils_1 = __webpack_require__(/*! ../common/pathUtils */ \"./src/common/pathUtils.ts\");\nconst positionUtils_1 = __webpack_require__(/*! ../common/positionUtils */ \"./src/common/positionUtils.ts\");\nconst pythonVersion_1 = __webpack_require__(/*! ../common/pythonVersion */ \"./src/common/pythonVersion.ts\");\nconst textRange_1 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\nconst textRange_2 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\nconst localize_1 = __webpack_require__(/*! ../localization/localize */ \"./src/localization/localize.ts\");\nconst StringTokenUtils = __webpack_require__(/*! ../parser/stringTokenUtils */ \"./src/parser/stringTokenUtils.ts\");\nconst AnalyzerNodeInfo = __webpack_require__(/*! ./analyzerNodeInfo */ \"./src/analyzer/analyzerNodeInfo.ts\");\nconst codeFlow_1 = __webpack_require__(/*! ./codeFlow */ \"./src/analyzer/codeFlow.ts\");\nconst ParseTreeUtils = __webpack_require__(/*! ./parseTreeUtils */ \"./src/analyzer/parseTreeUtils.ts\");\nconst parseTreeWalker_1 = __webpack_require__(/*! ./parseTreeWalker */ \"./src/analyzer/parseTreeWalker.ts\");\nconst scope_1 = __webpack_require__(/*! ./scope */ \"./src/analyzer/scope.ts\");\nconst StaticExpressions = __webpack_require__(/*! ./staticExpressions */ \"./src/analyzer/staticExpressions.ts\");\nconst symbol_1 = __webpack_require__(/*! ./symbol */ \"./src/analyzer/symbol.ts\");\nconst symbolNameUtils_1 = __webpack_require__(/*! ./symbolNameUtils */ \"./src/analyzer/symbolNameUtils.ts\");\nclass Binder extends parseTreeWalker_1.ParseTreeWalker {\n    constructor(fileInfo) {\n        super();\n        // A queue of deferred analysis operations.\n        this._deferredBindingTasks = [];\n        // Name bindings that are not local to the current scope.\n        this._notLocalBindings = new Map();\n        // Number of nested except statements at current point of analysis.\n        // Used to determine if a naked \"raise\" statement is allowed.\n        this._nestedExceptDepth = 0;\n        // Flow nodes used within try/finally flows.\n        this._finallyTargets = [];\n        this._fileInfo = fileInfo;\n    }\n    bindModule(node) {\n        // We'll assume that if there is no builtins scope provided, we must be\n        // binding the builtins module itself.\n        const isBuiltInModule = this._fileInfo.builtinsScope === undefined;\n        this._createNewScope(isBuiltInModule ? 4 /* Builtin */ : 3 /* Module */, this._fileInfo.builtinsScope, () => {\n            AnalyzerNodeInfo.setScope(node, this._currentScope);\n            AnalyzerNodeInfo.setFlowNode(node, this._currentFlowNode);\n            // Bind implicit names.\n            // List taken from https://docs.python.org/3/reference/import.html#__name__\n            this._addBuiltInSymbolToCurrentScope('__doc__', node, 'str');\n            this._addBuiltInSymbolToCurrentScope('__name__', node, 'str');\n            this._addBuiltInSymbolToCurrentScope('__loader__', node, 'Any');\n            this._addBuiltInSymbolToCurrentScope('__package__', node, 'str');\n            this._addBuiltInSymbolToCurrentScope('__spec__', node, 'Any');\n            this._addBuiltInSymbolToCurrentScope('__path__', node, 'Iterable[str]');\n            this._addBuiltInSymbolToCurrentScope('__file__', node, 'str');\n            this._addBuiltInSymbolToCurrentScope('__cached__', node, 'str');\n            this._addBuiltInSymbolToCurrentScope('__dict__', node, 'Dict[str, Any]');\n            // Create a start node for the module.\n            this._currentFlowNode = this._createStartFlowNode();\n            this._walkStatementsAndReportUnreachable(node.statements);\n            AnalyzerNodeInfo.setCodeFlowExpressions(node, this._currentExecutionScopeReferenceMap);\n            // Associate the code flow node at the end of the module with the module.\n            AnalyzerNodeInfo.setAfterFlowNode(node, this._currentFlowNode);\n        });\n        // Perform all analysis that was deferred during the first pass.\n        this._bindDeferred();\n        return {\n            moduleDocString: ParseTreeUtils.getDocString(node.statements),\n        };\n    }\n    visitModule(node) {\n        // Tree walking should start with the children of\n        // the node, so we should never get here.\n        debug_1.fail('We should never get here');\n        return false;\n    }\n    visitSuite(node) {\n        this._walkStatementsAndReportUnreachable(node.statements);\n        return false;\n    }\n    visitModuleName(node) {\n        const importResult = AnalyzerNodeInfo.getImportInfo(node);\n        debug_1.assert(importResult !== undefined);\n        if (importResult) {\n            if (!importResult.isImportFound) {\n                this._addDiagnostic(this._fileInfo.diagnosticRuleSet.reportMissingImports, \"reportMissingImports\" /* reportMissingImports */, localize_1.Localizer.Diagnostic.importResolveFailure().format({ importName: importResult.importName }), node);\n            }\n            else {\n                // Source found, but type stub is missing\n                if (!importResult.isStubFile && importResult.importType === 1 /* ThirdParty */) {\n                    const diagnostic = this._addDiagnostic(this._fileInfo.diagnosticRuleSet.reportMissingTypeStubs, \"reportMissingTypeStubs\" /* reportMissingTypeStubs */, localize_1.Localizer.Diagnostic.stubFileMissing().format({ importName: importResult.importName }), node);\n                    if (diagnostic) {\n                        // Add a diagnostic action for resolving this diagnostic.\n                        const createTypeStubAction = {\n                            action: \"pyright.createtypestub\" /* createTypeStub */,\n                            moduleName: importResult.importName,\n                        };\n                        diagnostic.addAction(createTypeStubAction);\n                    }\n                }\n                // Type stub found, but source is missing.\n                if (importResult.isStubFile &&\n                    importResult.importType !== 0 /* BuiltIn */ &&\n                    importResult.nonStubImportResult &&\n                    !importResult.nonStubImportResult.isImportFound) {\n                    // Don't report this for stub files.\n                    if (!this._fileInfo.isStubFile) {\n                        this._addDiagnostic(this._fileInfo.diagnosticRuleSet.reportMissingModuleSource, \"reportMissingModuleSource\" /* reportMissingModuleSource */, localize_1.Localizer.Diagnostic.importSourceResolveFailure().format({\n                            importName: importResult.importName,\n                        }), node);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    visitClass(node) {\n        this.walkMultiple(node.decorators);\n        const classDeclaration = {\n            type: 4 /* Class */,\n            node,\n            path: this._fileInfo.filePath,\n            range: positionUtils_1.convertOffsetsToRange(node.name.start, textRange_2.TextRange.getEnd(node.name), this._fileInfo.lines),\n        };\n        const symbol = this._bindNameToScope(this._currentScope, node.name.value);\n        if (symbol) {\n            symbol.addDeclaration(classDeclaration);\n        }\n        // Stash the declaration in the parse node for later access.\n        AnalyzerNodeInfo.setDeclaration(node, classDeclaration);\n        this.walkMultiple(node.arguments);\n        this._createNewScope(2 /* Class */, this._currentScope, () => {\n            AnalyzerNodeInfo.setScope(node, this._currentScope);\n            // Bind implicit names.\n            // Note that __class__, __dict__ and __doc__ are skipped here\n            // because the builtins.pyi type stub declares these in the\n            // 'object' class.\n            this._addBuiltInSymbolToCurrentScope('__base__', node, 'Any');\n            this._addBuiltInSymbolToCurrentScope('__bases__', node, 'Any');\n            this._addBuiltInSymbolToCurrentScope('__basicsize__', node, 'int');\n            this._addBuiltInSymbolToCurrentScope('__dict__', node, 'Dict[str, Any]');\n            this._addBuiltInSymbolToCurrentScope('__dictoffset__', node, 'int');\n            this._addBuiltInSymbolToCurrentScope('__flags__', node, 'int');\n            this._addBuiltInSymbolToCurrentScope('__itemsize__', node, 'int');\n            this._addBuiltInSymbolToCurrentScope('__module__', node, 'str');\n            this._addBuiltInSymbolToCurrentScope('__mro__', node, 'Any');\n            this._addBuiltInSymbolToCurrentScope('__name__', node, 'str', /* isInaccessibleToInstance */ true);\n            if (this._fileInfo.executionEnvironment.pythonVersion >= pythonVersion_1.PythonVersion.V3_0) {\n                this._addBuiltInSymbolToCurrentScope('__qualname__', node, 'str');\n                this._addBuiltInSymbolToCurrentScope('__text_signature__', node, 'str');\n            }\n            this._addBuiltInSymbolToCurrentScope('__subclasses__', node, 'Any');\n            // Analyze the suite.\n            this.walk(node.suite);\n        });\n        this._addSymbolToCurrentScope(node.name.value, /* isInitiallyUnbound */ true);\n        this._createAssignmentTargetFlowNodes(node.name, /* walkTargets */ false, /* unbound */ false);\n        return false;\n    }\n    visitFunction(node) {\n        const symbol = this._bindNameToScope(this._currentScope, node.name.value);\n        const containingClassNode = ParseTreeUtils.getEnclosingClass(node, true);\n        const functionDeclaration = {\n            type: 3 /* Function */,\n            node,\n            isMethod: !!containingClassNode,\n            isGenerator: false,\n            path: this._fileInfo.filePath,\n            range: positionUtils_1.convertOffsetsToRange(node.name.start, textRange_2.TextRange.getEnd(node.name), this._fileInfo.lines),\n        };\n        if (symbol) {\n            symbol.addDeclaration(functionDeclaration);\n        }\n        // Stash the declaration in the parse node for later access.\n        AnalyzerNodeInfo.setDeclaration(node, functionDeclaration);\n        this.walkMultiple(node.decorators);\n        node.parameters.forEach((param) => {\n            if (param.defaultValue) {\n                this.walk(param.defaultValue);\n            }\n            if (param.typeAnnotation) {\n                this.walk(param.typeAnnotation);\n            }\n        });\n        if (node.returnTypeAnnotation) {\n            this.walk(node.returnTypeAnnotation);\n        }\n        // Find the function or module that contains this function and use its scope.\n        // We can't simply use this._currentScope because functions within a class use\n        // the scope of the containing function or module when they execute.\n        let functionOrModuleNode = node.parent;\n        while (functionOrModuleNode) {\n            if (functionOrModuleNode.nodeType === 37 /* Module */ ||\n                functionOrModuleNode.nodeType === 29 /* Function */) {\n                break;\n            }\n            functionOrModuleNode = functionOrModuleNode.parent;\n        }\n        debug_1.assert(functionOrModuleNode !== undefined);\n        const functionOrModuleScope = AnalyzerNodeInfo.getScope(functionOrModuleNode);\n        debug_1.assert(functionOrModuleScope !== undefined);\n        // Don't walk the body of the function until we're done analyzing\n        // the current scope.\n        this._createNewScope(1 /* Function */, functionOrModuleScope, () => {\n            AnalyzerNodeInfo.setScope(node, this._currentScope);\n            // Bind implicit names.\n            // List taken from https://docs.python.org/3/reference/datamodel.html\n            this._addBuiltInSymbolToCurrentScope('__doc__', node, 'str');\n            this._addBuiltInSymbolToCurrentScope('__name__', node, 'str');\n            if (this._fileInfo.executionEnvironment.pythonVersion >= pythonVersion_1.PythonVersion.V3_3) {\n                this._addBuiltInSymbolToCurrentScope('__qualname__', node, 'str');\n            }\n            this._addBuiltInSymbolToCurrentScope('__module__', node, 'str');\n            this._addBuiltInSymbolToCurrentScope('__defaults__', node, 'Any');\n            this._addBuiltInSymbolToCurrentScope('__code__', node, 'Any');\n            this._addBuiltInSymbolToCurrentScope('__globals__', node, 'Any');\n            this._addBuiltInSymbolToCurrentScope('__dict__', node, 'Any');\n            this._addBuiltInSymbolToCurrentScope('__closure__', node, 'Any');\n            this._addBuiltInSymbolToCurrentScope('__annotations__', node, 'Any');\n            this._addBuiltInSymbolToCurrentScope('__kwdefaults__', node, 'Any');\n            const enclosingClass = ParseTreeUtils.getEnclosingClass(node);\n            if (enclosingClass) {\n                this._addBuiltInSymbolToCurrentScope('__class__', node, 'class');\n            }\n            this._deferBinding(() => {\n                // Create a start node for the function.\n                this._currentFlowNode = this._createStartFlowNode();\n                node.parameters.forEach((paramNode) => {\n                    if (paramNode.name) {\n                        const symbol = this._bindNameToScope(this._currentScope, paramNode.name.value);\n                        if (symbol) {\n                            const paramDeclaration = {\n                                type: 2 /* Parameter */,\n                                node: paramNode,\n                                path: this._fileInfo.filePath,\n                                range: positionUtils_1.convertOffsetsToRange(paramNode.start, textRange_2.TextRange.getEnd(paramNode), this._fileInfo.lines),\n                            };\n                            symbol.addDeclaration(paramDeclaration);\n                            AnalyzerNodeInfo.setDeclaration(paramNode.name, paramDeclaration);\n                        }\n                        this._createFlowAssignment(paramNode.name);\n                    }\n                });\n                this._targetFunctionDeclaration = functionDeclaration;\n                this._currentReturnTarget = this._createBranchLabel();\n                // Walk the statements that make up the function.\n                this.walk(node.suite);\n                // Associate the code flow node at the end of the suite with\n                // the suite.\n                AnalyzerNodeInfo.setAfterFlowNode(node.suite, this._currentFlowNode);\n                // Compute the final return flow node and associate it with\n                // the function's parse node. If this node is unreachable, then\n                // the function never returns.\n                this._addAntecedent(this._currentReturnTarget, this._currentFlowNode);\n                const returnFlowNode = this._finishFlowLabel(this._currentReturnTarget);\n                AnalyzerNodeInfo.setAfterFlowNode(node, returnFlowNode);\n            });\n            AnalyzerNodeInfo.setCodeFlowExpressions(node, this._currentExecutionScopeReferenceMap);\n        });\n        this._createAssignmentTargetFlowNodes(node.name, /* walkTargets */ false, /* unbound */ false);\n        // We'll walk the child nodes in a deferred manner, so don't walk them now.\n        return false;\n    }\n    visitLambda(node) {\n        // Analyze the parameter defaults in the context of the parent's scope\n        // before we add any names from the function's scope.\n        node.parameters.forEach((param) => {\n            if (param.defaultValue) {\n                this.walk(param.defaultValue);\n            }\n        });\n        this._createNewScope(1 /* Function */, this._currentScope, () => {\n            AnalyzerNodeInfo.setScope(node, this._currentScope);\n            this._deferBinding(() => {\n                // Create a start node for the lambda.\n                this._currentFlowNode = this._createStartFlowNode();\n                node.parameters.forEach((paramNode) => {\n                    if (paramNode.name) {\n                        const symbol = this._bindNameToScope(this._currentScope, paramNode.name.value);\n                        if (symbol) {\n                            const paramDeclaration = {\n                                type: 2 /* Parameter */,\n                                node: paramNode,\n                                path: this._fileInfo.filePath,\n                                range: positionUtils_1.convertOffsetsToRange(paramNode.start, textRange_2.TextRange.getEnd(paramNode), this._fileInfo.lines),\n                            };\n                            symbol.addDeclaration(paramDeclaration);\n                            AnalyzerNodeInfo.setDeclaration(paramNode.name, paramDeclaration);\n                        }\n                        this._createFlowAssignment(paramNode.name);\n                        this.walk(paramNode.name);\n                    }\n                });\n                // Walk the expression that make up the lambda body.\n                this.walk(node.expression);\n                AnalyzerNodeInfo.setCodeFlowExpressions(node, this._currentExecutionScopeReferenceMap);\n            });\n        });\n        // We'll walk the child nodes in a deferred manner.\n        return false;\n    }\n    visitCall(node) {\n        this.walk(node.leftExpression);\n        this.walkMultiple(node.arguments);\n        this._createCallFlowNode(node);\n        return false;\n    }\n    visitAssignment(node) {\n        if (this._handleTypingStubAssignmentOrAnnotation(node)) {\n            return false;\n        }\n        this._bindPossibleTupleNamedTarget(node.leftExpression);\n        if (node.typeAnnotationComment) {\n            this.walk(node.typeAnnotationComment);\n            this._addTypeDeclarationForVariable(node.leftExpression, node.typeAnnotationComment);\n        }\n        this.walk(node.rightExpression);\n        this._addInferredTypeAssignmentForVariable(node.leftExpression, node.rightExpression);\n        this._createAssignmentTargetFlowNodes(node.leftExpression, /* walkTargets */ true, /* unbound */ false);\n        return false;\n    }\n    visitAssignmentExpression(node) {\n        this.walk(node.rightExpression);\n        const evaluationNode = ParseTreeUtils.getEvaluationNodeForAssignmentExpression(node);\n        if (!evaluationNode) {\n            this._addError(localize_1.Localizer.Diagnostic.assignmentExprContext(), node);\n        }\n        else {\n            // Bind the name to the containing scope. This special logic is required\n            // because of the behavior defined in PEP 572. Targets of assignment\n            // expressions don't bind to a list comprehension's scope but instead\n            // bind to its containing scope.\n            const containerScope = AnalyzerNodeInfo.getScope(evaluationNode);\n            // If we're in a list comprehension (possibly nested), make sure that\n            // local for targets don't collide with the target of the assignment\n            // expression.\n            let curScope = this._currentScope;\n            while (curScope && curScope !== containerScope) {\n                const localSymbol = curScope.lookUpSymbol(node.name.value);\n                if (localSymbol) {\n                    this._addError(localize_1.Localizer.Diagnostic.assignmentExprComprehension().format({ name: node.name.value }), node.name);\n                    break;\n                }\n                curScope = curScope.parent;\n            }\n            this._bindNameToScope(containerScope, node.name.value);\n            this._addInferredTypeAssignmentForVariable(node.name, node.rightExpression);\n        }\n        this._createAssignmentTargetFlowNodes(node.name, /* walkTargets */ true, /* unbound */ false);\n        return false;\n    }\n    visitAugmentedAssignment(node) {\n        this.walk(node.leftExpression);\n        this.walk(node.rightExpression);\n        this._addInferredTypeAssignmentForVariable(node.destExpression, node.rightExpression);\n        this._bindPossibleTupleNamedTarget(node.destExpression);\n        this._createAssignmentTargetFlowNodes(node.destExpression, /* walkTargets */ false, /* unbound */ false);\n        return false;\n    }\n    visitDel(node) {\n        node.expressions.forEach((expr) => {\n            this._bindPossibleTupleNamedTarget(expr);\n            this.walk(expr);\n            this._createAssignmentTargetFlowNodes(expr, /* walkTargets */ false, /* unbound */ true);\n        });\n        return false;\n    }\n    visitTypeAnnotation(node) {\n        if (this._handleTypingStubAssignmentOrAnnotation(node)) {\n            return false;\n        }\n        this._bindPossibleTupleNamedTarget(node.valueExpression);\n        this._addTypeDeclarationForVariable(node.valueExpression, node.typeAnnotation);\n        // For type annotations that are not part of assignments (e.g. simple variable\n        // annotations), we need to populate the reference map. Otherwise the type\n        // analyzer's code flow engine won't run and detect cases where the variable\n        // is unbound.\n        const expressionList = [];\n        if (this._isNarrowingExpression(node.valueExpression, expressionList)) {\n            expressionList.forEach((expr) => {\n                const referenceKey = codeFlow_1.createKeyForReference(expr);\n                this._currentExecutionScopeReferenceMap.set(referenceKey, referenceKey);\n            });\n        }\n        return true;\n    }\n    visitFor(node) {\n        this._bindPossibleTupleNamedTarget(node.targetExpression);\n        this._addInferredTypeAssignmentForVariable(node.targetExpression, node);\n        this.walk(node.iterableExpression);\n        const preForLabel = this._createLoopLabel();\n        const preElseLabel = this._createBranchLabel();\n        const postForLabel = this._createBranchLabel();\n        this._addAntecedent(preForLabel, this._currentFlowNode);\n        this._currentFlowNode = preForLabel;\n        this._addAntecedent(preElseLabel, this._currentFlowNode);\n        this._createAssignmentTargetFlowNodes(node.targetExpression, /* walkTargets */ true, /* unbound */ false);\n        this._bindLoopStatement(preForLabel, postForLabel, () => {\n            this.walk(node.forSuite);\n            this._addAntecedent(preForLabel, this._currentFlowNode);\n        });\n        this._currentFlowNode = this._finishFlowLabel(preElseLabel);\n        if (node.elseSuite) {\n            this.walk(node.elseSuite);\n        }\n        this._addAntecedent(postForLabel, this._currentFlowNode);\n        this._currentFlowNode = this._finishFlowLabel(postForLabel);\n        return false;\n    }\n    visitContinue(node) {\n        if (this._currentContinueTarget) {\n            this._addAntecedent(this._currentContinueTarget, this._currentFlowNode);\n        }\n        this._currentFlowNode = Binder._unreachableFlowNode;\n        // Continue nodes don't have any children.\n        return false;\n    }\n    visitBreak(node) {\n        if (this._currentBreakTarget) {\n            this._addAntecedent(this._currentBreakTarget, this._currentFlowNode);\n        }\n        this._currentFlowNode = Binder._unreachableFlowNode;\n        // Break nodes don't have any children.\n        return false;\n    }\n    visitReturn(node) {\n        if (this._targetFunctionDeclaration) {\n            if (!this._targetFunctionDeclaration.returnExpressions) {\n                this._targetFunctionDeclaration.returnExpressions = [];\n            }\n            this._targetFunctionDeclaration.returnExpressions.push(node);\n        }\n        if (node.returnExpression) {\n            this.walk(node.returnExpression);\n        }\n        AnalyzerNodeInfo.setFlowNode(node, this._currentFlowNode);\n        if (this._currentReturnTarget) {\n            this._addAntecedent(this._currentReturnTarget, this._currentFlowNode);\n        }\n        this._finallyTargets.forEach((target) => {\n            this._addAntecedent(target, this._currentFlowNode);\n        });\n        this._currentFlowNode = Binder._unreachableFlowNode;\n        return false;\n    }\n    visitYield(node) {\n        this._bindYield(node);\n        return false;\n    }\n    visitYieldFrom(node) {\n        this._bindYield(node);\n        return false;\n    }\n    visitMemberAccess(node) {\n        AnalyzerNodeInfo.setFlowNode(node, this._currentFlowNode);\n        return true;\n    }\n    visitName(node) {\n        AnalyzerNodeInfo.setFlowNode(node, this._currentFlowNode);\n        // Name nodes have no children.\n        return false;\n    }\n    visitIf(node) {\n        const thenLabel = this._createBranchLabel();\n        const elseLabel = this._createBranchLabel();\n        const postIfLabel = this._createBranchLabel();\n        // Determine if the test condition is always true or always false. If so,\n        // we can treat either the then or the else clause as unconditional.\n        const constExprValue = StaticExpressions.evaluateStaticBoolLikeExpression(node.testExpression, this._fileInfo.executionEnvironment);\n        this._bindConditional(node.testExpression, thenLabel, elseLabel);\n        // Handle the if clause.\n        this._currentFlowNode =\n            constExprValue === false ? Binder._unreachableFlowNode : this._finishFlowLabel(thenLabel);\n        this.walk(node.ifSuite);\n        this._addAntecedent(postIfLabel, this._currentFlowNode);\n        // Now handle the else clause if it's present. If there\n        // are chained \"else if\" statements, they'll be handled\n        // recursively here.\n        this._currentFlowNode =\n            constExprValue === true ? Binder._unreachableFlowNode : this._finishFlowLabel(elseLabel);\n        if (node.elseSuite) {\n            this.walk(node.elseSuite);\n        }\n        this._addAntecedent(postIfLabel, this._currentFlowNode);\n        this._currentFlowNode = this._finishFlowLabel(postIfLabel);\n        return false;\n    }\n    visitWhile(node) {\n        const thenLabel = this._createBranchLabel();\n        const elseLabel = this._createBranchLabel();\n        const postWhileLabel = this._createBranchLabel();\n        // Determine if the test condition is always true or always false. If so,\n        // we can treat either the while or the else clause as unconditional.\n        const constExprValue = StaticExpressions.evaluateStaticBoolLikeExpression(node.testExpression, this._fileInfo.executionEnvironment);\n        const preLoopLabel = this._createLoopLabel();\n        this._addAntecedent(preLoopLabel, this._currentFlowNode);\n        this._currentFlowNode = preLoopLabel;\n        this._bindConditional(node.testExpression, thenLabel, elseLabel);\n        // Handle the while clause.\n        this._currentFlowNode =\n            constExprValue === false ? Binder._unreachableFlowNode : this._finishFlowLabel(thenLabel);\n        this._bindLoopStatement(preLoopLabel, postWhileLabel, () => {\n            this.walk(node.whileSuite);\n        });\n        this._addAntecedent(preLoopLabel, this._currentFlowNode);\n        this._currentFlowNode =\n            constExprValue === true ? Binder._unreachableFlowNode : this._finishFlowLabel(elseLabel);\n        if (node.elseSuite) {\n            this.walk(node.elseSuite);\n        }\n        this._addAntecedent(postWhileLabel, this._currentFlowNode);\n        this._currentFlowNode = this._finishFlowLabel(postWhileLabel);\n        return false;\n    }\n    visitAssert(node) {\n        const assertTrueLabel = this._createBranchLabel();\n        const assertFalseLabel = this._createBranchLabel();\n        this._bindConditional(node.testExpression, assertTrueLabel, assertFalseLabel);\n        if (node.exceptionExpression) {\n            this._currentFlowNode = this._finishFlowLabel(assertFalseLabel);\n            this.walk(node.exceptionExpression);\n        }\n        this._currentFlowNode = this._finishFlowLabel(assertTrueLabel);\n        return false;\n    }\n    visitExcept(node) {\n        if (node.typeExpression) {\n            this.walk(node.typeExpression);\n        }\n        if (node.name) {\n            this.walk(node.name);\n            const symbol = this._bindNameToScope(this._currentScope, node.name.value);\n            this._createAssignmentTargetFlowNodes(node.name, /* walkTargets */ true, /* unbound */ false);\n            if (symbol) {\n                const declaration = {\n                    type: 1 /* Variable */,\n                    node: node.name,\n                    isConstant: symbolNameUtils_1.isConstantName(node.name.value),\n                    inferredTypeSource: node,\n                    path: this._fileInfo.filePath,\n                    range: positionUtils_1.convertOffsetsToRange(node.name.start, textRange_2.TextRange.getEnd(node.name), this._fileInfo.lines),\n                };\n                symbol.addDeclaration(declaration);\n            }\n        }\n        this.walk(node.exceptSuite);\n        if (node.name) {\n            // The exception name is implicitly unbound at the end of\n            // the except block.\n            this._createFlowAssignment(node.name, /* unbound */ true);\n        }\n        return false;\n    }\n    visitRaise(node) {\n        if (!node.typeExpression && this._nestedExceptDepth === 0) {\n            this._addError(localize_1.Localizer.Diagnostic.raiseParams(), node);\n        }\n        if (node.typeExpression) {\n            this.walk(node.typeExpression);\n        }\n        if (node.valueExpression) {\n            this.walk(node.valueExpression);\n        }\n        if (node.tracebackExpression) {\n            this.walk(node.tracebackExpression);\n        }\n        this._finallyTargets.forEach((target) => {\n            this._addAntecedent(target, this._currentFlowNode);\n        });\n        this._currentFlowNode = Binder._unreachableFlowNode;\n        return false;\n    }\n    visitTry(node) {\n        // The try/except/else/finally statement is tricky to model using static code\n        // flow rules because the finally clause is executed regardless of whether an\n        // exception is raised or a return statement is executed. Code within the finally\n        // clause needs to be reachable always, and we conservatively assume that any\n        // statement within the try block can generate an exception, so we assume that its\n        // antecedent is the pre-try flow. We implement this with a \"gate\" node in the\n        // control flow graph. If analysis starts within the finally clause, the gate is\n        // opened, and all raise/return statements within try/except/else blocks are\n        // considered antecedents. If analysis starts outside (after) the finally clause,\n        // the gate is closed, and only paths that don't hit a raise/return statement\n        // in try/except/else blocks are considered.\n        //\n        //\n        //                               1. PostElse\n        //                                    ^\n        //                                    |\n        // 3. TryExceptElseReturnOrExcept     |\n        //       ^                            |\n        //       |                            |     2. PostExcept (for each except)\n        //       |                            |            ^\n        // 4. ReturnOrRaiseLabel              |            |\n        //       ^                            |            |\n        //       |                            |   |---------\n        // 5. PreFinallyGate                  |   |\n        //       ^                            |   |\n        //       |------------------          |   |\n        //                         |          |   |\n        //                        6. PreFinallyLabel\n        //                                ^\n        //                         (finally block)\n        //                                ^\n        //                        7. PostFinally\n        //                                ^    (only if isAfterElseAndExceptsReachable)\n        //                         (after finally)\n        // Create one flow label for every except clause.\n        const curExceptTargets = node.exceptClauses.map(() => this._createBranchLabel());\n        const preFinallyLabel = this._createBranchLabel();\n        // Create a label for all of the return or raise labels that are\n        // encountered within the try/except/else blocks. This conditionally\n        // connects the return/raise statement to the finally clause.\n        const preFinallyReturnOrRaiseLabel = this._createBranchLabel();\n        let isAfterElseAndExceptsReachable = false;\n        const preFinallyGate = {\n            flags: codeFlow_1.FlowFlags.PreFinallyGate,\n            id: codeFlow_1.getUniqueFlowNodeId(),\n            antecedent: preFinallyReturnOrRaiseLabel,\n            isGateClosed: false,\n        };\n        if (node.finallySuite) {\n            this._addAntecedent(preFinallyLabel, preFinallyGate);\n        }\n        // An exception may be generated before the first flow node\n        // added by the try block, so all of the exception targets\n        // must have the pre-try flow node as an antecedent.\n        curExceptTargets.forEach((exceptLabel) => {\n            this._addAntecedent(exceptLabel, this._currentFlowNode);\n        });\n        // We don't perfectly handle nested finally clauses, which are not\n        // possible to model fully within a static analyzer, but we do handle\n        // a single level of finally statements, and we handle most cases\n        // involving nesting. Returns or raises within the try/except/raise\n        // block will execute the finally target(s).\n        if (node.finallySuite) {\n            this._finallyTargets.push(preFinallyReturnOrRaiseLabel);\n        }\n        // Handle the try block.\n        const prevExceptTargets = this._currentExceptTargets;\n        this._currentExceptTargets = curExceptTargets;\n        this.walk(node.trySuite);\n        this._currentExceptTargets = prevExceptTargets;\n        // Handle the else block, which is executed only if\n        // execution falls through the try block.\n        if (node.elseSuite) {\n            this.walk(node.elseSuite);\n        }\n        this._addAntecedent(preFinallyLabel, this._currentFlowNode);\n        if (!this._isCodeUnreachable()) {\n            isAfterElseAndExceptsReachable = true;\n        }\n        // Handle the except blocks.\n        this._nestedExceptDepth++;\n        node.exceptClauses.forEach((exceptNode, index) => {\n            this._currentFlowNode = this._finishFlowLabel(curExceptTargets[index]);\n            this.walk(exceptNode);\n            this._addAntecedent(preFinallyLabel, this._currentFlowNode);\n            if (!this._isCodeUnreachable()) {\n                isAfterElseAndExceptsReachable = true;\n            }\n        });\n        this._nestedExceptDepth--;\n        if (node.finallySuite) {\n            this._finallyTargets.pop();\n        }\n        // Handle the finally block.\n        this._currentFlowNode = this._finishFlowLabel(preFinallyLabel);\n        if (node.finallySuite) {\n            this.walk(node.finallySuite);\n            // Add a post-finally node at the end. If we traverse this node,\n            // we'll set the \"ignore\" flag in the pre-finally node.\n            const postFinallyNode = {\n                flags: codeFlow_1.FlowFlags.PostFinally,\n                id: codeFlow_1.getUniqueFlowNodeId(),\n                antecedent: this._currentFlowNode,\n                preFinallyGate,\n            };\n            this._currentFlowNode = isAfterElseAndExceptsReachable ? postFinallyNode : Binder._unreachableFlowNode;\n        }\n        return false;\n    }\n    visitAwait(node) {\n        // Make sure this is within an async lambda or function.\n        const enclosingFunction = ParseTreeUtils.getEnclosingFunction(node);\n        if (enclosingFunction === undefined || !enclosingFunction.isAsync) {\n            this._addError(localize_1.Localizer.Diagnostic.awaitNotInAsync(), node);\n        }\n        return true;\n    }\n    visitStringList(node) {\n        for (const stringNode of node.strings) {\n            if (stringNode.hasUnescapeErrors) {\n                const unescapedResult = StringTokenUtils.getUnescapedString(stringNode.token);\n                unescapedResult.unescapeErrors.forEach((error) => {\n                    const start = stringNode.token.start +\n                        stringNode.token.prefixLength +\n                        stringNode.token.quoteMarkLength +\n                        error.offset;\n                    const textRange = { start, length: error.length };\n                    if (error.errorType === 0 /* InvalidEscapeSequence */) {\n                        this._addDiagnostic(this._fileInfo.diagnosticRuleSet.reportInvalidStringEscapeSequence, \"reportInvalidStringEscapeSequence\" /* reportInvalidStringEscapeSequence */, localize_1.Localizer.Diagnostic.stringUnsupportedEscape(), textRange);\n                    }\n                    else if (error.errorType === 1 /* EscapeWithinFormatExpression */) {\n                        this._addError(localize_1.Localizer.Diagnostic.formatStringEscape(), textRange);\n                    }\n                    else if (error.errorType === 2 /* SingleCloseBraceWithinFormatLiteral */) {\n                        this._addError(localize_1.Localizer.Diagnostic.formatStringBrace(), textRange);\n                    }\n                    else if (error.errorType === 3 /* UnterminatedFormatExpression */) {\n                        this._addError(localize_1.Localizer.Diagnostic.formatStringUnterminated(), textRange);\n                    }\n                });\n            }\n        }\n        return true;\n    }\n    visitGlobal(node) {\n        const globalScope = this._currentScope.getGlobalScope();\n        node.nameList.forEach((name) => {\n            const nameValue = name.value;\n            // Is the binding inconsistent?\n            if (this._notLocalBindings.get(nameValue) === 0 /* Nonlocal */) {\n                this._addError(localize_1.Localizer.Diagnostic.nonLocalRedefinition().format({ name: nameValue }), name);\n            }\n            const valueWithScope = this._currentScope.lookUpSymbolRecursive(nameValue);\n            // Was the name already assigned within this scope before it was declared global?\n            if (valueWithScope && valueWithScope.scope === this._currentScope) {\n                this._addError(localize_1.Localizer.Diagnostic.globalReassignment().format({ name: nameValue }), name);\n            }\n            // Add it to the global scope if it's not already added.\n            this._bindNameToScope(globalScope, nameValue);\n            if (this._currentScope !== globalScope) {\n                this._notLocalBindings.set(nameValue, 1 /* Global */);\n            }\n        });\n        return true;\n    }\n    visitNonlocal(node) {\n        const globalScope = this._currentScope.getGlobalScope();\n        if (this._currentScope === globalScope) {\n            this._addError(localize_1.Localizer.Diagnostic.nonLocalInModule(), node);\n        }\n        else {\n            node.nameList.forEach((name) => {\n                const nameValue = name.value;\n                // Is the binding inconsistent?\n                if (this._notLocalBindings.get(nameValue) === 1 /* Global */) {\n                    this._addError(localize_1.Localizer.Diagnostic.globalRedefinition().format({ name: nameValue }), name);\n                }\n                const valueWithScope = this._currentScope.lookUpSymbolRecursive(nameValue);\n                // Was the name already assigned within this scope before it was declared nonlocal?\n                if (valueWithScope && valueWithScope.scope === this._currentScope) {\n                    this._addError(localize_1.Localizer.Diagnostic.nonLocalReassignment().format({ name: nameValue }), name);\n                }\n                else if (!valueWithScope || valueWithScope.scope === globalScope) {\n                    this._addError(localize_1.Localizer.Diagnostic.nonLocalNoBinding().format({ name: nameValue }), name);\n                }\n                this._notLocalBindings.set(nameValue, 0 /* Nonlocal */);\n            });\n        }\n        return true;\n    }\n    visitImportAs(node) {\n        if (node.module.nameParts.length > 0) {\n            const firstNamePartValue = node.module.nameParts[0].value;\n            let symbolName;\n            if (node.alias) {\n                // The symbol name is defined by the alias.\n                symbolName = node.alias.value;\n            }\n            else {\n                // There was no alias, so we need to use the first element of\n                // the name parts as the symbol.\n                symbolName = firstNamePartValue;\n            }\n            const symbol = this._bindNameToScope(this._currentScope, symbolName);\n            if (symbol && this._fileInfo.isStubFile && !node.alias) {\n                // PEP 484 indicates that imported symbols should not be\n                // considered \"reexported\" from a type stub file unless\n                // they are imported using the \"as\" form.\n                symbol.setIsExternallyHidden();\n            }\n            const importInfo = AnalyzerNodeInfo.getImportInfo(node.module);\n            debug_1.assert(importInfo !== undefined);\n            if (symbol) {\n                this._createAliasDeclarationForMultipartImportName(node, node.alias, importInfo, symbol);\n            }\n            this._createFlowAssignment(node.alias ? node.alias : node.module.nameParts[0]);\n        }\n        return true;\n    }\n    visitImportFrom(node) {\n        const importInfo = AnalyzerNodeInfo.getImportInfo(node.module);\n        let resolvedPath = '';\n        if (importInfo && importInfo.isImportFound) {\n            resolvedPath = importInfo.resolvedPaths[importInfo.resolvedPaths.length - 1];\n        }\n        // If this file is a module __init__.py(i), relative imports of submodules\n        // using the syntax \"from .x import y\" introduce a symbol x into the\n        // module namespace. We do this first (before adding the individual imported\n        // symbols below) in case one of the imported symbols is the same name as the\n        // submodule. In that case, we want to the symbol to appear later in the\n        // declaration list because it should \"win\" when resolving the alias.\n        const fileName = pathUtils_1.stripFileExtension(pathUtils_1.getFileName(this._fileInfo.filePath));\n        if (fileName === '__init__' && node.module.leadingDots === 1 && node.module.nameParts.length > 0) {\n            // If the symbol is going to be immediately replaced with a same-named\n            // imported symbol, skip this.\n            const isImmediatelyReplaced = !node.isWildcardImport &&\n                node.imports.some((importSymbolNode) => {\n                    const nameNode = importSymbolNode.alias || importSymbolNode.name;\n                    return nameNode.value === node.module.nameParts[0].value;\n                });\n            if (!isImmediatelyReplaced) {\n                const symbolName = node.module.nameParts[0].value;\n                const symbol = this._bindNameToScope(this._currentScope, symbolName);\n                if (symbol) {\n                    this._createAliasDeclarationForMultipartImportName(node, undefined, importInfo, symbol);\n                }\n                this._createFlowAssignment(node.module.nameParts[0]);\n            }\n        }\n        if (node.isWildcardImport) {\n            if (ParseTreeUtils.getEnclosingClass(node) || ParseTreeUtils.getEnclosingFunction(node)) {\n                this._addError(localize_1.Localizer.Diagnostic.wildcardInFunction(), node);\n            }\n            if (importInfo) {\n                const names = [];\n                const lookupInfo = this._fileInfo.importLookup(resolvedPath);\n                if (lookupInfo) {\n                    const wildcardNames = this._getWildcardImportNames(lookupInfo);\n                    wildcardNames.forEach((name) => {\n                        const symbol = lookupInfo.symbolTable.get(name);\n                        // Don't include the ignored names in the symbol table.\n                        if (!symbol.isIgnoredForProtocolMatch()) {\n                            const symbol = this._bindNameToScope(this._currentScope, name);\n                            if (symbol) {\n                                const aliasDecl = {\n                                    type: 6 /* Alias */,\n                                    node,\n                                    path: resolvedPath,\n                                    range: textRange_1.getEmptyRange(),\n                                    usesLocalName: false,\n                                    symbolName: name,\n                                };\n                                symbol.addDeclaration(aliasDecl);\n                                names.push(name);\n                            }\n                        }\n                    });\n                }\n                this._createFlowWildcardImport(node, names);\n            }\n        }\n        else {\n            node.imports.forEach((importSymbolNode) => {\n                const importedName = importSymbolNode.name.value;\n                const nameNode = importSymbolNode.alias || importSymbolNode.name;\n                const symbol = this._bindNameToScope(this._currentScope, nameNode.value);\n                if (symbol) {\n                    if (this._fileInfo.isStubFile && !importSymbolNode.alias) {\n                        // PEP 484 indicates that imported symbols should not be\n                        // considered \"reexported\" from a type stub file unless\n                        // they are imported using the \"as\" form.\n                        symbol.setIsExternallyHidden();\n                    }\n                    // Is the import referring to an implicitly-imported module?\n                    let implicitImport;\n                    if (importInfo && importInfo.implicitImports) {\n                        implicitImport = importInfo.implicitImports.find((imp) => imp.name === importedName);\n                    }\n                    let submoduleFallback;\n                    if (implicitImport) {\n                        submoduleFallback = {\n                            type: 6 /* Alias */,\n                            node: importSymbolNode,\n                            path: implicitImport.path,\n                            range: textRange_1.getEmptyRange(),\n                            usesLocalName: false,\n                        };\n                        // Handle the case of \"from . import X\". In this case,\n                        // we want to always resolve to the submodule rather than\n                        // the resolved path.\n                        if (node.module.nameParts.length === 0) {\n                            resolvedPath = '';\n                        }\n                    }\n                    const aliasDecl = {\n                        type: 6 /* Alias */,\n                        node: importSymbolNode,\n                        path: resolvedPath,\n                        usesLocalName: !!importSymbolNode.alias,\n                        symbolName: importedName,\n                        submoduleFallback,\n                        range: textRange_1.getEmptyRange(),\n                    };\n                    symbol.addDeclaration(aliasDecl);\n                    this._createFlowAssignment(importSymbolNode.alias || importSymbolNode.name);\n                }\n            });\n        }\n        return true;\n    }\n    visitWith(node) {\n        node.withItems.forEach((item) => {\n            this.walk(item.expression);\n            if (item.target) {\n                this._bindPossibleTupleNamedTarget(item.target);\n                this._addInferredTypeAssignmentForVariable(item.target, item);\n                this._createAssignmentTargetFlowNodes(item.target, /* walkTargets */ true, /* unbound */ false);\n            }\n        });\n        this.walk(node.suite);\n        return false;\n    }\n    visitTernary(node) {\n        const trueLabel = this._createBranchLabel();\n        const falseLabel = this._createBranchLabel();\n        const postExpressionLabel = this._createBranchLabel();\n        // Handle the test expression.\n        this._bindConditional(node.testExpression, trueLabel, falseLabel);\n        // Handle the \"true\" portion (the \"if\" expression).\n        this._currentFlowNode = this._finishFlowLabel(trueLabel);\n        this.walk(node.ifExpression);\n        this._addAntecedent(postExpressionLabel, this._currentFlowNode);\n        // Handle the \"false\" portion (the \"else\" expression).\n        this._currentFlowNode = this._finishFlowLabel(falseLabel);\n        this.walk(node.elseExpression);\n        this._addAntecedent(postExpressionLabel, this._currentFlowNode);\n        this._currentFlowNode = this._finishFlowLabel(postExpressionLabel);\n        return false;\n    }\n    visitUnaryOperation(node) {\n        if (node.operator === 38 /* Not */ && this._currentFalseTarget && this._currentTrueTarget) {\n            // Swap the existing true/false targets.\n            this._bindConditional(node.expression, this._currentFalseTarget, this._currentTrueTarget);\n        }\n        else {\n            const savedTrueTarget = this._currentTrueTarget;\n            const savedFalseTarget = this._currentFalseTarget;\n            // Temporarily set the true/false targets to undefined because\n            // this unary operation is not part of a chain of logical expressions\n            // (AND/OR/NOT subexpressions).\n            this._currentTrueTarget = undefined;\n            this._currentFalseTarget = undefined;\n            // Evaluate the operand expression.\n            this.walk(node.expression);\n            this._currentFalseTarget = savedFalseTarget;\n            this._currentTrueTarget = savedTrueTarget;\n        }\n        return false;\n    }\n    visitBinaryOperation(node) {\n        if (node.operator === 36 /* And */ || node.operator === 37 /* Or */) {\n            let trueTarget = this._currentTrueTarget;\n            let falseTarget = this._currentFalseTarget;\n            let postRightLabel;\n            if (!trueTarget || !falseTarget) {\n                postRightLabel = this._createBranchLabel();\n                trueTarget = falseTarget = postRightLabel;\n            }\n            const preRightLabel = this._createBranchLabel();\n            if (node.operator === 36 /* And */) {\n                this._bindConditional(node.leftExpression, preRightLabel, falseTarget);\n            }\n            else {\n                this._bindConditional(node.leftExpression, trueTarget, preRightLabel);\n            }\n            this._currentFlowNode = this._finishFlowLabel(preRightLabel);\n            this._bindConditional(node.rightExpression, trueTarget, falseTarget);\n            if (postRightLabel) {\n                this._currentFlowNode = this._finishFlowLabel(postRightLabel);\n            }\n        }\n        else {\n            const savedTrueTarget = this._currentTrueTarget;\n            const savedFalseTarget = this._currentFalseTarget;\n            // Temporarily set the true/false targets to undefined because\n            // this binary operation is not part of a chain of logical expressions\n            // (AND/OR/NOT subexpressions).\n            this._currentTrueTarget = undefined;\n            this._currentFalseTarget = undefined;\n            this.walk(node.leftExpression);\n            this.walk(node.rightExpression);\n            this._currentFalseTarget = savedFalseTarget;\n            this._currentTrueTarget = savedTrueTarget;\n        }\n        return false;\n    }\n    visitListComprehension(node) {\n        this._createNewScope(0 /* ListComprehension */, this._currentScope, () => {\n            AnalyzerNodeInfo.setScope(node, this._currentScope);\n            const falseLabel = this._createBranchLabel();\n            // We'll walk the comprehensions list twice. The first time we'll\n            // bind targets of for statements. The second time we'll walk\n            // expressions and create the control flow graph.\n            const boundSymbols = [];\n            for (let i = 0; i < node.comprehensions.length; i++) {\n                const compr = node.comprehensions[i];\n                const addedSymbols = new Map();\n                if (compr.nodeType === 34 /* ListComprehensionFor */) {\n                    this._bindPossibleTupleNamedTarget(compr.targetExpression, addedSymbols);\n                    this._addInferredTypeAssignmentForVariable(compr.targetExpression, compr);\n                }\n                boundSymbols.push(addedSymbols);\n            }\n            for (let i = 0; i < node.comprehensions.length; i++) {\n                const compr = node.comprehensions[i];\n                if (compr.nodeType === 34 /* ListComprehensionFor */) {\n                    const addedSymbols = boundSymbols[i];\n                    // Determine if we added a new symbol to this scope. If so, see\n                    // if it's the same name as a symbol in an outer scope. If so, we'll\n                    // create an alias node in the control flow graph.\n                    for (const addedSymbol of addedSymbols) {\n                        const aliasSymbol = this._currentScope.parent.lookUpSymbol(addedSymbol[0]);\n                        if (aliasSymbol) {\n                            this._createAssignmentAliasFlowNode(addedSymbol[1].id, aliasSymbol.id);\n                        }\n                    }\n                    this.walk(compr.iterableExpression);\n                    this._createAssignmentTargetFlowNodes(compr.targetExpression, \n                    /* walkTargets */ true, \n                    /* unbound */ false);\n                }\n                else {\n                    const trueLabel = this._createBranchLabel();\n                    this._bindConditional(compr.testExpression, trueLabel, falseLabel);\n                    this._currentFlowNode = this._finishFlowLabel(trueLabel);\n                }\n            }\n            this.walk(node.expression);\n            this._addAntecedent(falseLabel, this._currentFlowNode);\n            this._currentFlowNode = this._finishFlowLabel(falseLabel);\n        });\n        return false;\n    }\n    _createAliasDeclarationForMultipartImportName(node, importAlias, importInfo, symbol) {\n        const firstNamePartValue = node.module.nameParts[0].value;\n        if (importInfo && importInfo.isImportFound && !importInfo.isNativeLib && importInfo.resolvedPaths.length > 0) {\n            // See if there's already a matching alias declaration for this import.\n            // if so, we'll update it rather than creating a new one. This is required\n            // to handle cases where multiple import statements target the same\n            // starting symbol such as \"import a.b.c\" and \"import a.d\". In this case,\n            // we'll build a single declaration that describes the combined actions\n            // of both import statements, thus reflecting the behavior of the\n            // python module loader.\n            const existingDecl = symbol\n                .getDeclarations()\n                .find((decl) => decl.type === 6 /* Alias */ && decl.firstNamePart === firstNamePartValue);\n            const newDecl = existingDecl || {\n                type: 6 /* Alias */,\n                node,\n                path: '',\n                range: textRange_1.getEmptyRange(),\n                firstNamePart: firstNamePartValue,\n                usesLocalName: !!importAlias,\n            };\n            // Add the implicit imports for this module if it's the last\n            // name part we're resolving.\n            if (importAlias || node.module.nameParts.length === 1) {\n                newDecl.path = importInfo.resolvedPaths[importInfo.resolvedPaths.length - 1];\n                this._addImplicitImportsToLoaderActions(importInfo, newDecl);\n            }\n            else {\n                // Fill in the remaining name parts.\n                let curLoaderActions = newDecl;\n                for (let i = 1; i < node.module.nameParts.length; i++) {\n                    if (i >= importInfo.resolvedPaths.length) {\n                        break;\n                    }\n                    const namePartValue = node.module.nameParts[i].value;\n                    // Is there an existing loader action for this name?\n                    let loaderActions = curLoaderActions.implicitImports\n                        ? curLoaderActions.implicitImports.get(namePartValue)\n                        : undefined;\n                    if (!loaderActions) {\n                        // Allocate a new loader action.\n                        loaderActions = {\n                            path: '',\n                            implicitImports: new Map(),\n                        };\n                        if (!curLoaderActions.implicitImports) {\n                            curLoaderActions.implicitImports = new Map();\n                        }\n                        curLoaderActions.implicitImports.set(namePartValue, loaderActions);\n                    }\n                    // If this is the last name part we're resolving, add in the\n                    // implicit imports as well.\n                    if (i === node.module.nameParts.length - 1) {\n                        loaderActions.path = importInfo.resolvedPaths[i];\n                        this._addImplicitImportsToLoaderActions(importInfo, loaderActions);\n                    }\n                    curLoaderActions = loaderActions;\n                }\n            }\n            if (!existingDecl) {\n                symbol.addDeclaration(newDecl);\n            }\n        }\n        else {\n            // If we couldn't resolve the import, create a dummy declaration with a\n            // bogus path so it gets an unknown type (rather than an unbound type) at\n            // analysis time.\n            const newDecl = {\n                type: 6 /* Alias */,\n                node,\n                path: '*** unresolved ***',\n                range: textRange_1.getEmptyRange(),\n                usesLocalName: !!importAlias,\n            };\n            symbol.addDeclaration(newDecl);\n        }\n    }\n    _getWildcardImportNames(lookupInfo) {\n        const namesToImport = [];\n        // Is there an __all__ statement? If so, it overrides the normal\n        // wildcard logic.\n        const allSymbol = lookupInfo.symbolTable.get('__all__');\n        if (allSymbol) {\n            const decls = allSymbol.getDeclarations();\n            // For now, we handle only the case where __all__ is defined\n            // through a simple assignment. Some libraries use more complex\n            // logic like __all__.extend(X) or __all__ += X. We'll punt on\n            // those for now.\n            if (decls.length === 1 && decls[0].type === 1 /* Variable */) {\n                const firstDecl = decls[0];\n                if (firstDecl.node.parent && firstDecl.node.parent.nodeType === 3 /* Assignment */) {\n                    const expr = firstDecl.node.parent.rightExpression;\n                    if (expr.nodeType === 32 /* List */) {\n                        expr.entries.forEach((listEntryNode) => {\n                            if (listEntryNode.nodeType === 49 /* StringList */ &&\n                                listEntryNode.strings.length === 1 &&\n                                listEntryNode.strings[0].nodeType === 50 /* String */) {\n                                const entryName = listEntryNode.strings[0].value;\n                                if (lookupInfo.symbolTable.get(entryName)) {\n                                    namesToImport.push(entryName);\n                                }\n                            }\n                        });\n                        return namesToImport;\n                    }\n                }\n            }\n        }\n        // Import all names that don't begin with an underscore.\n        lookupInfo.symbolTable.forEach((_, name) => {\n            if (!name.startsWith('_')) {\n                namesToImport.push(name);\n            }\n        });\n        return namesToImport;\n    }\n    _walkStatementsAndReportUnreachable(statements) {\n        let foundUnreachableStatement = false;\n        for (const statement of statements) {\n            AnalyzerNodeInfo.setFlowNode(statement, this._currentFlowNode);\n            if (!foundUnreachableStatement) {\n                foundUnreachableStatement = this._isCodeUnreachable();\n            }\n            if (!foundUnreachableStatement) {\n                this.walk(statement);\n            }\n            else {\n                // If we're within a function, we need to look for unreachable yield\n                // statements because they affect the behavior of the function (making\n                // it a generator) even if they're never executed.\n                if (this._targetFunctionDeclaration && !this._targetFunctionDeclaration.isGenerator) {\n                    const yieldFinder = new YieldFinder();\n                    if (yieldFinder.checkContainsYield(statement)) {\n                        this._targetFunctionDeclaration.isGenerator = true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    _createStartFlowNode() {\n        const flowNode = {\n            flags: codeFlow_1.FlowFlags.Start,\n            id: codeFlow_1.getUniqueFlowNodeId(),\n        };\n        return flowNode;\n    }\n    _createBranchLabel() {\n        const flowNode = {\n            flags: codeFlow_1.FlowFlags.BranchLabel,\n            id: codeFlow_1.getUniqueFlowNodeId(),\n            antecedents: [],\n        };\n        return flowNode;\n    }\n    _createLoopLabel() {\n        const flowNode = {\n            flags: codeFlow_1.FlowFlags.LoopLabel,\n            id: codeFlow_1.getUniqueFlowNodeId(),\n            antecedents: [],\n        };\n        return flowNode;\n    }\n    _finishFlowLabel(node) {\n        // If there were no antecedents, this is unreachable.\n        if (node.antecedents.length === 0) {\n            return Binder._unreachableFlowNode;\n        }\n        // If there was only one antecedent, there's no need\n        // for a label to exist.\n        if (node.antecedents.length === 1) {\n            return node.antecedents[0];\n        }\n        return node;\n    }\n    _bindConditional(node, trueTarget, falseTarget) {\n        const savedTrueTarget = this._currentTrueTarget;\n        const savedFalseTarget = this._currentFalseTarget;\n        this._currentTrueTarget = trueTarget;\n        this._currentFalseTarget = falseTarget;\n        this.walk(node);\n        this._currentTrueTarget = savedTrueTarget;\n        this._currentFalseTarget = savedFalseTarget;\n        if (!this._isLogicalExpression(node)) {\n            this._addAntecedent(trueTarget, this._createFlowConditional(codeFlow_1.FlowFlags.TrueCondition, this._currentFlowNode, node));\n            this._addAntecedent(falseTarget, this._createFlowConditional(codeFlow_1.FlowFlags.FalseCondition, this._currentFlowNode, node));\n        }\n    }\n    _createFlowConditional(flags, antecedent, expression) {\n        if (antecedent.flags & codeFlow_1.FlowFlags.Unreachable) {\n            return antecedent;\n        }\n        const staticValue = StaticExpressions.evaluateStaticBoolLikeExpression(expression, this._fileInfo.executionEnvironment);\n        if ((staticValue === true && flags & codeFlow_1.FlowFlags.FalseCondition) ||\n            (staticValue === false && flags & codeFlow_1.FlowFlags.TrueCondition)) {\n            return Binder._unreachableFlowNode;\n        }\n        const expressionList = [];\n        if (!this._isNarrowingExpression(expression, expressionList)) {\n            return antecedent;\n        }\n        expressionList.forEach((expr) => {\n            const referenceKey = codeFlow_1.createKeyForReference(expr);\n            this._currentExecutionScopeReferenceMap.set(referenceKey, referenceKey);\n        });\n        const conditionalFlowNode = {\n            flags,\n            id: codeFlow_1.getUniqueFlowNodeId(),\n            expression,\n            antecedent,\n        };\n        this._addExceptTargets(conditionalFlowNode);\n        return conditionalFlowNode;\n    }\n    // Indicates whether the expression is a NOT, AND or OR expression.\n    _isLogicalExpression(expression) {\n        switch (expression.nodeType) {\n            case 56 /* UnaryOperation */: {\n                return expression.operator === 38 /* Not */;\n            }\n            case 7 /* BinaryOperation */: {\n                return expression.operator === 36 /* And */ || expression.operator === 37 /* Or */;\n            }\n        }\n        return false;\n    }\n    _isNarrowingExpression(expression, expressionList) {\n        switch (expression.nodeType) {\n            case 39 /* Name */:\n            case 36 /* MemberAccess */: {\n                if (codeFlow_1.isCodeFlowSupportedForReference(expression)) {\n                    expressionList.push(expression);\n                    return true;\n                }\n                return false;\n            }\n            case 4 /* AssignmentExpression */: {\n                expressionList.push(expression.name);\n                return true;\n            }\n            case 7 /* BinaryOperation */: {\n                const isOrIsNotOperator = expression.operator === 39 /* Is */ || expression.operator === 40 /* IsNot */;\n                const equalsOrNotEqualsOperator = expression.operator === 12 /* Equals */ || expression.operator === 28 /* NotEquals */;\n                if (isOrIsNotOperator || equalsOrNotEqualsOperator) {\n                    // Look for \"X is None\", \"X is not None\", \"X == None\", \"X != None\".\n                    // These are commonly-used patterns used in control flow.\n                    if (expression.rightExpression.nodeType === 11 /* Constant */ &&\n                        expression.rightExpression.constType === 24 /* None */) {\n                        return this._isNarrowingExpression(expression.leftExpression, expressionList);\n                    }\n                    // Look for \"type(X) is Y\" or \"type(X) is not Y\".\n                    if (isOrIsNotOperator &&\n                        expression.leftExpression.nodeType === 9 /* Call */ &&\n                        expression.leftExpression.leftExpression.nodeType === 39 /* Name */ &&\n                        expression.leftExpression.leftExpression.value === 'type' &&\n                        expression.leftExpression.arguments.length === 1 &&\n                        expression.leftExpression.arguments[0].argumentCategory === 0 /* Simple */) {\n                        return this._isNarrowingExpression(expression.leftExpression.arguments[0].valueExpression, expressionList);\n                    }\n                    const isLeftNarrowing = this._isNarrowingExpression(expression.leftExpression, expressionList);\n                    // Look for \"X is Y\" or \"X is not Y\".\n                    if (isOrIsNotOperator) {\n                        return isLeftNarrowing;\n                    }\n                    // Look for X == <literal>, X != <literal> or <literal> == X, <literal> != X\n                    if (equalsOrNotEqualsOperator) {\n                        const isRightNarrowing = this._isNarrowingExpression(expression.rightExpression, expressionList);\n                        return isLeftNarrowing || isRightNarrowing;\n                    }\n                }\n                // Look for \"X in Y\".\n                if (expression.operator === 41 /* In */) {\n                    return this._isNarrowingExpression(expression.leftExpression, expressionList);\n                }\n                return false;\n            }\n            case 56 /* UnaryOperation */: {\n                return (expression.operator === 38 /* Not */ &&\n                    this._isNarrowingExpression(expression.expression, expressionList));\n            }\n            case 5 /* AugmentedAssignment */: {\n                return this._isNarrowingExpression(expression.rightExpression, expressionList);\n            }\n            case 9 /* Call */: {\n                if (expression.leftExpression.nodeType === 39 /* Name */ &&\n                    (expression.leftExpression.value === 'isinstance' ||\n                        expression.leftExpression.value === 'issubclass') &&\n                    expression.arguments.length === 2) {\n                    return this._isNarrowingExpression(expression.arguments[0].valueExpression, expressionList);\n                }\n                if (expression.leftExpression.nodeType === 39 /* Name */ &&\n                    expression.leftExpression.value === 'callable' &&\n                    expression.arguments.length === 1) {\n                    return this._isNarrowingExpression(expression.arguments[0].valueExpression, expressionList);\n                }\n            }\n        }\n        return false;\n    }\n    _createAssignmentTargetFlowNodes(target, walkTargets, unbound) {\n        switch (target.nodeType) {\n            case 39 /* Name */:\n            case 36 /* MemberAccess */: {\n                this._createFlowAssignment(target, unbound);\n                if (walkTargets) {\n                    this.walk(target);\n                }\n                break;\n            }\n            case 53 /* Tuple */: {\n                target.expressions.forEach((expr) => {\n                    this._createAssignmentTargetFlowNodes(expr, walkTargets, unbound);\n                });\n                break;\n            }\n            case 55 /* TypeAnnotation */: {\n                this._createAssignmentTargetFlowNodes(target.valueExpression, /* walkTargets */ false, unbound);\n                if (walkTargets) {\n                    this.walk(target);\n                }\n                break;\n            }\n            case 57 /* Unpack */: {\n                this._createAssignmentTargetFlowNodes(target.expression, /* walkTargets */ false, unbound);\n                if (walkTargets) {\n                    this.walk(target);\n                }\n                break;\n            }\n            case 32 /* List */: {\n                target.entries.forEach((entry) => {\n                    this._createAssignmentTargetFlowNodes(entry, walkTargets, unbound);\n                });\n                break;\n            }\n            default: {\n                if (walkTargets) {\n                    this.walk(target);\n                }\n            }\n        }\n    }\n    _createCallFlowNode(node) {\n        if (!this._isCodeUnreachable()) {\n            const flowNode = {\n                flags: codeFlow_1.FlowFlags.Call,\n                id: codeFlow_1.getUniqueFlowNodeId(),\n                node,\n                antecedent: this._currentFlowNode,\n            };\n            this._currentFlowNode = flowNode;\n        }\n        AnalyzerNodeInfo.setFlowNode(node, this._currentFlowNode);\n    }\n    _createAssignmentAliasFlowNode(targetSymbolId, aliasSymbolId) {\n        if (!this._isCodeUnreachable()) {\n            const flowNode = {\n                flags: codeFlow_1.FlowFlags.AssignmentAlias,\n                id: codeFlow_1.getUniqueFlowNodeId(),\n                antecedent: this._currentFlowNode,\n                targetSymbolId,\n                aliasSymbolId,\n            };\n            this._currentFlowNode = flowNode;\n        }\n    }\n    _createFlowAssignment(node, unbound = false) {\n        let targetSymbolId = symbol_1.indeterminateSymbolId;\n        if (node.nodeType === 39 /* Name */) {\n            const symbolWithScope = this._currentScope.lookUpSymbolRecursive(node.value);\n            debug_1.assert(symbolWithScope !== undefined);\n            targetSymbolId = symbolWithScope.symbol.id;\n        }\n        const prevFlowNode = this._currentFlowNode;\n        if (!this._isCodeUnreachable() && codeFlow_1.isCodeFlowSupportedForReference(node)) {\n            const flowNode = {\n                flags: codeFlow_1.FlowFlags.Assignment,\n                id: codeFlow_1.getUniqueFlowNodeId(),\n                node,\n                antecedent: this._currentFlowNode,\n                targetSymbolId,\n            };\n            const referenceKey = codeFlow_1.createKeyForReference(node);\n            this._currentExecutionScopeReferenceMap.set(referenceKey, referenceKey);\n            if (unbound) {\n                flowNode.flags |= codeFlow_1.FlowFlags.Unbind;\n            }\n            this._addExceptTargets(flowNode);\n            this._currentFlowNode = flowNode;\n        }\n        // If we're marking the node as unbound and there is already a flow node\n        // associated with the node, don't replace it. This case applies for symbols\n        // introduced in except clauses. If there is no use the previous flow node\n        // associated, use the previous flow node (applies in the del case).\n        // Otherwise, the node will be evaluated as unbound at this point in the flow.\n        if (!unbound || AnalyzerNodeInfo.getFlowNode(node) === undefined) {\n            AnalyzerNodeInfo.setFlowNode(node, unbound ? prevFlowNode : this._currentFlowNode);\n        }\n    }\n    _createFlowWildcardImport(node, names) {\n        if (!this._isCodeUnreachable()) {\n            const flowNode = {\n                flags: codeFlow_1.FlowFlags.WildcardImport,\n                id: codeFlow_1.getUniqueFlowNodeId(),\n                node,\n                names,\n                antecedent: this._currentFlowNode,\n            };\n            this._addExceptTargets(flowNode);\n            this._currentFlowNode = flowNode;\n        }\n        AnalyzerNodeInfo.setFlowNode(node, this._currentFlowNode);\n    }\n    _isCodeUnreachable() {\n        return !!(this._currentFlowNode.flags & codeFlow_1.FlowFlags.Unreachable);\n    }\n    _addExceptTargets(flowNode) {\n        // If there are any except targets, then we're in a try block, and we\n        // have to assume that an exception can be raised after every assignment.\n        if (this._currentExceptTargets) {\n            this._currentExceptTargets.forEach((label) => {\n                this._addAntecedent(label, flowNode);\n            });\n        }\n    }\n    _bindLoopStatement(preLoopLabel, postLoopLabel, callback) {\n        const savedContinueTarget = this._currentContinueTarget;\n        const savedBreakTarget = this._currentBreakTarget;\n        this._currentContinueTarget = preLoopLabel;\n        this._currentBreakTarget = postLoopLabel;\n        callback();\n        this._currentContinueTarget = savedContinueTarget;\n        this._currentBreakTarget = savedBreakTarget;\n    }\n    _addAntecedent(label, antecedent) {\n        if (!(this._currentFlowNode.flags & codeFlow_1.FlowFlags.Unreachable)) {\n            // Don't add the same antecedent twice.\n            if (!label.antecedents.some((existing) => existing.id === antecedent.id)) {\n                label.antecedents.push(antecedent);\n            }\n        }\n    }\n    _bindNameToScope(scope, name, addedSymbols) {\n        if (this._notLocalBindings.get(name) === undefined) {\n            // Don't overwrite an existing symbol.\n            let symbol = scope.lookUpSymbol(name);\n            if (!symbol) {\n                symbol = scope.addSymbol(name, 1 /* InitiallyUnbound */ | 4 /* ClassMember */);\n                // Handle the case where a new symbol is being added to a class\n                // but the expression assigned to it uses a symbol of the same\n                // name that is declared in an outer scope.\n                if (scope.type === 2 /* Class */) {\n                    const aliasSymbol = scope.parent.lookUpSymbol(name);\n                    if (aliasSymbol) {\n                        this._createAssignmentAliasFlowNode(symbol.id, aliasSymbol.id);\n                    }\n                }\n                if (this._fileInfo.isStubFile && symbolNameUtils_1.isPrivateOrProtectedName(name)) {\n                    symbol.setIsExternallyHidden();\n                }\n                if (addedSymbols) {\n                    addedSymbols.set(name, symbol);\n                }\n            }\n            return symbol;\n        }\n        return undefined;\n    }\n    _bindPossibleTupleNamedTarget(target, addedSymbols) {\n        switch (target.nodeType) {\n            case 39 /* Name */: {\n                this._bindNameToScope(this._currentScope, target.value, addedSymbols);\n                break;\n            }\n            case 53 /* Tuple */: {\n                target.expressions.forEach((expr) => {\n                    this._bindPossibleTupleNamedTarget(expr, addedSymbols);\n                });\n                break;\n            }\n            case 32 /* List */: {\n                target.entries.forEach((expr) => {\n                    this._bindPossibleTupleNamedTarget(expr, addedSymbols);\n                });\n                break;\n            }\n            case 55 /* TypeAnnotation */: {\n                this._bindPossibleTupleNamedTarget(target.valueExpression, addedSymbols);\n                break;\n            }\n            case 57 /* Unpack */: {\n                this._bindPossibleTupleNamedTarget(target.expression, addedSymbols);\n                break;\n            }\n        }\n    }\n    _addBuiltInSymbolToCurrentScope(nameValue, node, type, isInaccessibleToInstance = false) {\n        const symbol = this._addSymbolToCurrentScope(nameValue, \n        /* isInitiallyUnbound */ false, isInaccessibleToInstance);\n        if (symbol) {\n            symbol.addDeclaration({\n                type: 0 /* Intrinsic */,\n                node,\n                intrinsicType: type,\n                path: this._fileInfo.filePath,\n                range: textRange_1.getEmptyRange(),\n            });\n            symbol.setIsIgnoredForProtocolMatch();\n        }\n    }\n    // Adds a new symbol with the specified name if it doesn't already exist.\n    _addSymbolToCurrentScope(nameValue, isInitiallyUnbound, isInaccessibleToInstance = false) {\n        let symbol = this._currentScope.lookUpSymbol(nameValue);\n        if (!symbol) {\n            let symbolFlags = 0 /* None */;\n            if (isInitiallyUnbound) {\n                symbolFlags |= 1 /* InitiallyUnbound */;\n            }\n            if (this._currentScope.type === 2 /* Class */) {\n                symbolFlags |= 4 /* ClassMember */;\n            }\n            if (isInaccessibleToInstance) {\n                symbolFlags |= 16 /* InaccessibleToInstance */;\n            }\n            if (this._fileInfo.isStubFile && symbolNameUtils_1.isPrivateOrProtectedName(nameValue)) {\n                symbolFlags |= 2 /* ExternallyHidden */;\n            }\n            // Add the symbol. Assume that symbols with a default type source ID\n            // are \"implicit\" symbols added to the scope. These are not initially unbound.\n            symbol = this._currentScope.addSymbol(nameValue, symbolFlags);\n        }\n        return symbol;\n    }\n    _createNewScope(scopeType, parentScope, callback) {\n        const prevScope = this._currentScope;\n        this._currentScope = new scope_1.Scope(scopeType, parentScope);\n        // If this scope is an execution scope, allocate a new reference map.\n        const isExecutionScope = scopeType === 4 /* Builtin */ || scopeType === 3 /* Module */ || scopeType === 1 /* Function */;\n        const prevReferenceMap = this._currentExecutionScopeReferenceMap;\n        if (isExecutionScope) {\n            this._currentExecutionScopeReferenceMap = new Map();\n        }\n        const prevNonLocalBindings = this._notLocalBindings;\n        this._notLocalBindings = new Map();\n        callback();\n        this._currentExecutionScopeReferenceMap = prevReferenceMap;\n        this._currentScope = prevScope;\n        this._notLocalBindings = prevNonLocalBindings;\n    }\n    _addInferredTypeAssignmentForVariable(target, source) {\n        switch (target.nodeType) {\n            case 39 /* Name */: {\n                const name = target;\n                const symbolWithScope = this._currentScope.lookUpSymbolRecursive(name.value);\n                if (symbolWithScope && symbolWithScope.symbol) {\n                    const declaration = {\n                        type: 1 /* Variable */,\n                        node: target,\n                        isConstant: symbolNameUtils_1.isConstantName(target.value),\n                        inferredTypeSource: source,\n                        path: this._fileInfo.filePath,\n                        range: positionUtils_1.convertOffsetsToRange(name.start, textRange_2.TextRange.getEnd(name), this._fileInfo.lines),\n                    };\n                    symbolWithScope.symbol.addDeclaration(declaration);\n                }\n                break;\n            }\n            case 36 /* MemberAccess */: {\n                const memberAccessInfo = this._getMemberAccessInfo(target);\n                if (memberAccessInfo) {\n                    const name = target.memberName;\n                    let symbol = memberAccessInfo.classScope.lookUpSymbol(name.value);\n                    if (!symbol) {\n                        symbol = memberAccessInfo.classScope.addSymbol(name.value, 1 /* InitiallyUnbound */);\n                        const honorPrivateNaming = this._fileInfo.diagnosticRuleSet.reportPrivateUsage !== 'none';\n                        if (symbolNameUtils_1.isPrivateOrProtectedName(name.value) && honorPrivateNaming) {\n                            symbol.setIsPrivateMember();\n                        }\n                    }\n                    if (memberAccessInfo.isInstanceMember) {\n                        // If a method (which has a declared type) is being overwritten\n                        // by an expression with no declared type, don't mark it as\n                        // an instance member because the type evaluator will think\n                        // that it doesn't need to perform object binding.\n                        if (!symbol.isClassMember() ||\n                            !symbol\n                                .getDeclarations()\n                                .some((decl) => decl.type === 3 /* Function */ && decl.isMethod)) {\n                            symbol.setIsInstanceMember();\n                        }\n                    }\n                    else {\n                        symbol.setIsClassMember();\n                    }\n                    const declaration = {\n                        type: 1 /* Variable */,\n                        node: target.memberName,\n                        isConstant: symbolNameUtils_1.isConstantName(name.value),\n                        inferredTypeSource: source,\n                        isDefinedByMemberAccess: true,\n                        path: this._fileInfo.filePath,\n                        range: positionUtils_1.convertOffsetsToRange(target.memberName.start, target.memberName.start + target.memberName.length, this._fileInfo.lines),\n                    };\n                    symbol.addDeclaration(declaration);\n                }\n                break;\n            }\n            case 53 /* Tuple */: {\n                target.expressions.forEach((expr) => {\n                    this._addInferredTypeAssignmentForVariable(expr, source);\n                });\n                break;\n            }\n            case 55 /* TypeAnnotation */: {\n                this._addInferredTypeAssignmentForVariable(target.valueExpression, source);\n                break;\n            }\n            case 57 /* Unpack */: {\n                this._addInferredTypeAssignmentForVariable(target.expression, source);\n                break;\n            }\n            case 32 /* List */: {\n                target.entries.forEach((entry) => {\n                    this._addInferredTypeAssignmentForVariable(entry, source);\n                });\n                break;\n            }\n        }\n    }\n    _addTypeDeclarationForVariable(target, typeAnnotation) {\n        let declarationHandled = false;\n        switch (target.nodeType) {\n            case 39 /* Name */: {\n                const name = target;\n                const symbolWithScope = this._currentScope.lookUpSymbolRecursive(name.value);\n                if (symbolWithScope && symbolWithScope.symbol) {\n                    const finalInfo = this._isAnnotationFinal(typeAnnotation);\n                    const isTypeAlias = this._isAnnotationTypeAlias(typeAnnotation);\n                    let typeAnnotationNode = typeAnnotation;\n                    if (isTypeAlias) {\n                        typeAnnotationNode = undefined;\n                        // Type aliases are allowed only in the global scope.\n                        if (this._currentScope.type !== 3 /* Module */) {\n                            this._addError(localize_1.Localizer.Diagnostic.typeAliasNotInModule(), typeAnnotation);\n                        }\n                    }\n                    else if (finalInfo.isFinal) {\n                        typeAnnotationNode = finalInfo.finalTypeNode;\n                    }\n                    const declaration = {\n                        type: 1 /* Variable */,\n                        node: target,\n                        isConstant: symbolNameUtils_1.isConstantName(name.value),\n                        isFinal: finalInfo.isFinal,\n                        isTypeAlias,\n                        path: this._fileInfo.filePath,\n                        typeAnnotationNode,\n                        range: positionUtils_1.convertOffsetsToRange(name.start, textRange_2.TextRange.getEnd(name), this._fileInfo.lines),\n                    };\n                    symbolWithScope.symbol.addDeclaration(declaration);\n                    // Is this annotation indicating that the variable is a \"ClassVar\"? Note\n                    // that this check is somewhat fragile because we can't verify here that\n                    // \"ClassVar\" maps to the typing module symbol by this name.\n                    const isClassVar = typeAnnotation.nodeType === 24 /* Index */ &&\n                        typeAnnotation.baseExpression.nodeType === 39 /* Name */ &&\n                        typeAnnotation.baseExpression.value === 'ClassVar';\n                    if (isClassVar) {\n                        symbolWithScope.symbol.setIsClassVar();\n                    }\n                    else {\n                        symbolWithScope.symbol.setIsInstanceMember();\n                    }\n                }\n                declarationHandled = true;\n                break;\n            }\n            case 36 /* MemberAccess */: {\n                // We need to determine whether this expression is declaring a class or\n                // instance variable. This is difficult because python doesn't provide\n                // a keyword for accessing \"this\". Instead, it uses naming conventions\n                // of \"cls\" and \"self\", but we don't want to rely on these naming\n                // conventions here. Instead, we'll apply some heuristics to determine\n                // whether the symbol on the LHS is a reference to the current class\n                // or an instance of the current class.\n                const memberAccessInfo = this._getMemberAccessInfo(target);\n                if (memberAccessInfo) {\n                    const name = target.memberName;\n                    let symbol = memberAccessInfo.classScope.lookUpSymbol(name.value);\n                    if (!symbol) {\n                        symbol = memberAccessInfo.classScope.addSymbol(name.value, 1 /* InitiallyUnbound */);\n                        const honorPrivateNaming = this._fileInfo.diagnosticRuleSet.reportPrivateUsage !== 'none';\n                        if (symbolNameUtils_1.isPrivateOrProtectedName(name.value) && honorPrivateNaming) {\n                            symbol.setIsPrivateMember();\n                        }\n                    }\n                    if (memberAccessInfo.isInstanceMember) {\n                        symbol.setIsInstanceMember();\n                    }\n                    else {\n                        symbol.setIsClassMember();\n                    }\n                    const finalInfo = this._isAnnotationFinal(typeAnnotation);\n                    const declaration = {\n                        type: 1 /* Variable */,\n                        node: target.memberName,\n                        isConstant: symbolNameUtils_1.isConstantName(name.value),\n                        isDefinedByMemberAccess: true,\n                        isFinal: finalInfo.isFinal,\n                        path: this._fileInfo.filePath,\n                        typeAnnotationNode: finalInfo.isFinal ? finalInfo.finalTypeNode : typeAnnotation,\n                        range: positionUtils_1.convertOffsetsToRange(target.memberName.start, target.memberName.start + target.memberName.length, this._fileInfo.lines),\n                    };\n                    symbol.addDeclaration(declaration);\n                    declarationHandled = true;\n                }\n                break;\n            }\n        }\n        if (!declarationHandled) {\n            this._addError(localize_1.Localizer.Diagnostic.annotationNotSupported(), typeAnnotation);\n        }\n    }\n    _isTypingAnnotation(typeAnnotation, name) {\n        if (typeAnnotation.nodeType === 39 /* Name */) {\n            // We need to make an assumption in this code that the symbol \"Final\"\n            // will resolve to typing.Final. This is because of the poor way\n            // the \"Final\" support was specified. We need to evaluate it\n            // in the binder before we have a way to resolve symbol names.\n            if (typeAnnotation.value === name) {\n                return true;\n            }\n        }\n        else if (typeAnnotation.nodeType === 36 /* MemberAccess */) {\n            if (typeAnnotation.leftExpression.nodeType === 39 /* Name */ &&\n                (typeAnnotation.leftExpression.value === 'typing' || typeAnnotation.leftExpression.value === 't') &&\n                typeAnnotation.memberName.value === name) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // Determines if the specified type annotation expression is a \"Final\".\n    // It returns two boolean values indicating if the expression is a \"Final\"\n    // expression and whether it's a \"raw\" Final with no type arguments.\n    _isAnnotationFinal(typeAnnotation) {\n        let isFinal = false;\n        let finalTypeNode;\n        if (typeAnnotation) {\n            if (this._isTypingAnnotation(typeAnnotation, 'Final')) {\n                isFinal = true;\n            }\n            else if (typeAnnotation.nodeType === 24 /* Index */ && typeAnnotation.items.items.length === 1) {\n                // Recursively call to see if the base expression is \"Final\".\n                const finalInfo = this._isAnnotationFinal(typeAnnotation.baseExpression);\n                if (finalInfo.isFinal) {\n                    isFinal = true;\n                    finalTypeNode = typeAnnotation.items.items[0];\n                }\n            }\n        }\n        return { isFinal, finalTypeNode };\n    }\n    _isAnnotationTypeAlias(typeAnnotation) {\n        if (!typeAnnotation) {\n            return false;\n        }\n        if (this._fileInfo.executionEnvironment.pythonVersion < pythonVersion_1.PythonVersion.V3_9 && !this._fileInfo.isStubFile) {\n            return false;\n        }\n        return this._isTypingAnnotation(typeAnnotation, 'TypeAlias');\n    }\n    // Determines whether a member access expression is referring to a\n    // member of a class (either a class or instance member). This will\n    // typically take the form \"self.x\" or \"cls.x\".\n    _getMemberAccessInfo(node) {\n        // We handle only simple names on the left-hand side of the expression,\n        // not calls, nested member accesses, index expressions, etc.\n        if (node.leftExpression.nodeType !== 39 /* Name */) {\n            return undefined;\n        }\n        const leftSymbolName = node.leftExpression.value;\n        // Make sure the expression is within a function (i.e. a method) that's\n        // within a class definition.\n        const methodNode = ParseTreeUtils.getEnclosingFunction(node);\n        if (!methodNode) {\n            return undefined;\n        }\n        const classNode = ParseTreeUtils.getEnclosingClass(methodNode);\n        if (!classNode) {\n            return undefined;\n        }\n        // Determine whether the left-hand side indicates a class or\n        // instance member.\n        let isInstanceMember = false;\n        if (methodNode.parameters.length < 1 || !methodNode.parameters[0].name) {\n            return undefined;\n        }\n        const className = classNode.name.value;\n        const firstParamName = methodNode.parameters[0].name.value;\n        if (leftSymbolName === className) {\n            isInstanceMember = false;\n        }\n        else {\n            if (leftSymbolName !== firstParamName) {\n                return undefined;\n            }\n            // To determine whether the first parameter of the method\n            // refers to the class or the instance, we need to apply\n            // some heuristics.\n            if (methodNode.name.value === '__new__') {\n                // The __new__ method is special. It acts as a classmethod even\n                // though it doesn't have a @classmethod decorator.\n                isInstanceMember = false;\n            }\n            else {\n                // Assume that it's an instance member unless we find\n                // a decorator that tells us otherwise.\n                isInstanceMember = true;\n                for (const decorator of methodNode.decorators) {\n                    if (decorator.leftExpression.nodeType === 39 /* Name */) {\n                        const decoratorName = decorator.leftExpression.value;\n                        if (decoratorName === 'staticmethod') {\n                            // A static method doesn't have a \"self\" or \"cls\" parameter.\n                            return undefined;\n                        }\n                        else if (decoratorName === 'classmethod') {\n                            // A classmethod implies that the first parameter is \"cls\".\n                            isInstanceMember = false;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        const classScope = AnalyzerNodeInfo.getScope(classNode);\n        debug_1.assert(classScope !== undefined);\n        return {\n            classNode,\n            methodNode,\n            classScope,\n            isInstanceMember,\n        };\n    }\n    _addImplicitImportsToLoaderActions(importResult, loaderActions) {\n        importResult.implicitImports.forEach((implicitImport) => {\n            const existingLoaderAction = loaderActions.implicitImports\n                ? loaderActions.implicitImports.get(implicitImport.name)\n                : undefined;\n            if (existingLoaderAction) {\n                existingLoaderAction.path = implicitImport.path;\n            }\n            else {\n                if (!loaderActions.implicitImports) {\n                    loaderActions.implicitImports = new Map();\n                }\n                loaderActions.implicitImports.set(implicitImport.name, {\n                    path: implicitImport.path,\n                    implicitImports: new Map(),\n                });\n            }\n        });\n    }\n    // Handles some special-case assignment statements that are found\n    // within the typings.pyi file.\n    _handleTypingStubAssignmentOrAnnotation(node) {\n        if (!this._fileInfo.isTypingStubFile) {\n            return false;\n        }\n        let annotationNode;\n        if (node.nodeType === 55 /* TypeAnnotation */) {\n            annotationNode = node;\n        }\n        else {\n            if (node.leftExpression.nodeType !== 55 /* TypeAnnotation */) {\n                return false;\n            }\n            annotationNode = node.leftExpression;\n        }\n        if (annotationNode.valueExpression.nodeType !== 39 /* Name */) {\n            return false;\n        }\n        const assignedNameNode = annotationNode.valueExpression;\n        const specialTypes = {\n            Tuple: true,\n            Generic: true,\n            Protocol: true,\n            Callable: true,\n            Type: true,\n            ClassVar: true,\n            Final: true,\n            Literal: true,\n            TypedDict: true,\n            Union: true,\n            Optional: true,\n            Annotated: true,\n            TypeAlias: true,\n            OrderedDict: true,\n        };\n        const assignedName = assignedNameNode.value;\n        if (!specialTypes[assignedName]) {\n            return false;\n        }\n        const symbol = this._bindNameToScope(this._currentScope, assignedName);\n        if (symbol) {\n            symbol.addDeclaration({\n                type: 5 /* SpecialBuiltInClass */,\n                node: annotationNode,\n                path: this._fileInfo.filePath,\n                range: positionUtils_1.convertOffsetsToRange(annotationNode.start, textRange_2.TextRange.getEnd(annotationNode), this._fileInfo.lines),\n            });\n        }\n        return true;\n    }\n    _deferBinding(callback) {\n        this._deferredBindingTasks.push({\n            scope: this._currentScope,\n            nonLocalBindingsMap: this._notLocalBindings,\n            codeFlowExpressionMap: this._currentExecutionScopeReferenceMap,\n            callback,\n        });\n    }\n    _bindDeferred() {\n        while (this._deferredBindingTasks.length > 0) {\n            const nextItem = this._deferredBindingTasks.shift();\n            // Reset the state\n            this._currentScope = nextItem.scope;\n            this._notLocalBindings = nextItem.nonLocalBindingsMap;\n            this._nestedExceptDepth = 0;\n            this._currentExecutionScopeReferenceMap = nextItem.codeFlowExpressionMap;\n            nextItem.callback();\n        }\n    }\n    _bindYield(node) {\n        const functionNode = ParseTreeUtils.getEnclosingFunction(node);\n        if (!functionNode) {\n            this._addError(localize_1.Localizer.Diagnostic.yieldOutsideFunction(), node);\n        }\n        else if (functionNode.isAsync && node.nodeType === 62 /* YieldFrom */) {\n            // PEP 525 indicates that 'yield from' is not allowed in an\n            // async function.\n            this._addError(localize_1.Localizer.Diagnostic.yieldFromOutsideAsync(), node);\n        }\n        if (this._targetFunctionDeclaration) {\n            if (!this._targetFunctionDeclaration.yieldExpressions) {\n                this._targetFunctionDeclaration.yieldExpressions = [];\n            }\n            this._targetFunctionDeclaration.yieldExpressions.push(node);\n            this._targetFunctionDeclaration.isGenerator = true;\n        }\n        if (node.expression) {\n            this.walk(node.expression);\n        }\n        AnalyzerNodeInfo.setFlowNode(node, this._currentFlowNode);\n    }\n    _addDiagnostic(diagLevel, rule, message, textRange) {\n        let diagnostic;\n        switch (diagLevel) {\n            case 'error':\n                diagnostic = this._addError(message, textRange);\n                break;\n            case 'warning':\n                diagnostic = this._addWarning(message, textRange);\n                break;\n            case 'information':\n                diagnostic = this._addInformation(message, textRange);\n                break;\n            case 'none':\n                break;\n            default:\n                return debug_1.assertNever(diagLevel, `${diagLevel} is not expected`);\n        }\n        if (diagnostic) {\n            diagnostic.setRule(rule);\n        }\n        return diagnostic;\n    }\n    _addError(message, textRange) {\n        return this._fileInfo.diagnosticSink.addDiagnosticWithTextRange('error', message, textRange);\n    }\n    _addWarning(message, textRange) {\n        return this._fileInfo.diagnosticSink.addDiagnosticWithTextRange('warning', message, textRange);\n    }\n    _addInformation(message, textRange) {\n        return this._fileInfo.diagnosticSink.addDiagnosticWithTextRange('information', message, textRange);\n    }\n}\nexports.Binder = Binder;\n// Flow node that is used for unreachable code.\nBinder._unreachableFlowNode = {\n    flags: codeFlow_1.FlowFlags.Unreachable,\n    id: codeFlow_1.getUniqueFlowNodeId(),\n};\nclass YieldFinder extends parseTreeWalker_1.ParseTreeWalker {\n    constructor() {\n        super(...arguments);\n        this._containsYield = false;\n    }\n    checkContainsYield(node) {\n        this.walk(node);\n        return this._containsYield;\n    }\n    visitYield(node) {\n        this._containsYield = true;\n        return false;\n    }\n    visitYieldFrom(node) {\n        this._containsYield = true;\n        return false;\n    }\n}\nexports.YieldFinder = YieldFinder;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/binder.ts?");

/***/ }),

/***/ "./src/analyzer/checker.ts":
/*!*********************************!*\
  !*** ./src/analyzer/checker.ts ***!
  \*********************************/
/*! flagged exports */
/*! export Checker [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * checker.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * A parse tree walker that performs static type checking for\n * a source file. Most of its work is performed by the type\n * evaluator, but this module touches every node in the file\n * to ensure that all statements and expressions are evaluated\n * and checked. It also performs some additional checks that\n * cannot (or should not be) performed lazily.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Checker = void 0;\nconst debug_1 = __webpack_require__(/*! ../common/debug */ \"./src/common/debug.ts\");\nconst diagnostic_1 = __webpack_require__(/*! ../common/diagnostic */ \"./src/common/diagnostic.ts\");\nconst textRange_1 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\nconst localize_1 = __webpack_require__(/*! ../localization/localize */ \"./src/localization/localize.ts\");\nconst parseNodes_1 = __webpack_require__(/*! ../parser/parseNodes */ \"./src/parser/parseNodes.ts\");\nconst AnalyzerNodeInfo = __webpack_require__(/*! ./analyzerNodeInfo */ \"./src/analyzer/analyzerNodeInfo.ts\");\nconst declarationUtils_1 = __webpack_require__(/*! ./declarationUtils */ \"./src/analyzer/declarationUtils.ts\");\nconst importStatementUtils_1 = __webpack_require__(/*! ./importStatementUtils */ \"./src/analyzer/importStatementUtils.ts\");\nconst ParseTreeUtils = __webpack_require__(/*! ./parseTreeUtils */ \"./src/analyzer/parseTreeUtils.ts\");\nconst parseTreeWalker_1 = __webpack_require__(/*! ./parseTreeWalker */ \"./src/analyzer/parseTreeWalker.ts\");\nconst scopeUtils_1 = __webpack_require__(/*! ./scopeUtils */ \"./src/analyzer/scopeUtils.ts\");\nconst SymbolNameUtils = __webpack_require__(/*! ./symbolNameUtils */ \"./src/analyzer/symbolNameUtils.ts\");\nconst symbolUtils_1 = __webpack_require__(/*! ./symbolUtils */ \"./src/analyzer/symbolUtils.ts\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/analyzer/types.ts\");\nconst typeUtils_1 = __webpack_require__(/*! ./typeUtils */ \"./src/analyzer/typeUtils.ts\");\nclass Checker extends parseTreeWalker_1.ParseTreeWalker {\n    constructor(node, evaluator) {\n        super();\n        // A list of all nodes that are defined within the module that\n        // have their own scopes.\n        this._scopedNodes = [];\n        this._moduleNode = node;\n        this._fileInfo = AnalyzerNodeInfo.getFileInfo(node);\n        this._evaluator = evaluator;\n    }\n    check() {\n        this._scopedNodes.push(this._moduleNode);\n        this._walkStatementsAndReportUnreachable(this._moduleNode.statements);\n        // Perform a one-time validation of symbols in all scopes\n        // defined in this module for things like unaccessed variables.\n        this._validateSymbolTables();\n        this._reportDuplicateImports();\n    }\n    walk(node) {\n        if (!AnalyzerNodeInfo.isCodeUnreachable(node)) {\n            super.walk(node);\n        }\n        else {\n            this._evaluator.suppressDiagnostics(() => {\n                super.walk(node);\n            });\n        }\n    }\n    visitSuite(node) {\n        this._walkStatementsAndReportUnreachable(node.statements);\n        return false;\n    }\n    visitStatementList(node) {\n        node.statements.forEach((statement) => {\n            if (parseNodes_1.isExpressionNode(statement) && !AnalyzerNodeInfo.isCodeUnreachable(statement)) {\n                // Evaluate the expression in case it wasn't otherwise evaluated\n                // through lazy analysis. This will mark referenced symbols as\n                // accessed and report any errors associated with it.\n                this._evaluator.getType(statement);\n            }\n        });\n        return true;\n    }\n    visitClass(node) {\n        const classTypeResult = this._evaluator.getTypeOfClass(node);\n        this.walk(node.suite);\n        this.walkMultiple(node.decorators);\n        this.walkMultiple(node.arguments);\n        if (classTypeResult) {\n            this._validateClassMethods(classTypeResult.classType);\n            this._validateFinalMemberOverrides(classTypeResult.classType);\n            if (types_1.ClassType.isTypedDictClass(classTypeResult.classType)) {\n                this._validateTypedDictClassSuite(node.suite);\n            }\n        }\n        this._scopedNodes.push(node);\n        return false;\n    }\n    visitFunction(node) {\n        const functionTypeResult = this._evaluator.getTypeOfFunction(node);\n        const containingClassNode = ParseTreeUtils.getEnclosingClass(node, true);\n        if (functionTypeResult) {\n            // Report any unknown parameter types.\n            node.parameters.forEach((param, index) => {\n                // Allow unknown param types if the param is named '_'.\n                if (param.name && param.name.value !== '_') {\n                    const paramType = functionTypeResult.functionType.details.parameters[index].type;\n                    if (types_1.isUnknown(paramType) ||\n                        (types_1.isTypeVar(paramType) && paramType.isSynthesized && !paramType.boundType)) {\n                        this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportUnknownParameterType, \"reportUnknownParameterType\" /* reportUnknownParameterType */, localize_1.Localizer.Diagnostic.paramTypeUnknown().format({ paramName: param.name.value }), param.name);\n                    }\n                    else if (typeUtils_1.isPartlyUnknown(paramType)) {\n                        const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n                        diagAddendum.addMessage(localize_1.Localizer.DiagnosticAddendum.paramType().format({\n                            paramType: this._evaluator.printType(paramType, /* expandTypeAlias */ false),\n                        }));\n                        this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportUnknownParameterType, \"reportUnknownParameterType\" /* reportUnknownParameterType */, localize_1.Localizer.Diagnostic.paramTypePartiallyUnknown().format({ paramName: param.name.value }) +\n                            diagAddendum.getString(), param.name);\n                    }\n                }\n            });\n            // If this is a stub, ensure that the return type is specified.\n            if (this._fileInfo.isStubFile) {\n                if (!node.returnTypeAnnotation) {\n                    this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportUnknownParameterType, \"reportUnknownParameterType\" /* reportUnknownParameterType */, localize_1.Localizer.Diagnostic.returnTypeUnknown(), node.name);\n                }\n            }\n            if (containingClassNode) {\n                this._validateMethod(node, functionTypeResult.functionType, containingClassNode);\n            }\n        }\n        node.parameters.forEach((param) => {\n            if (param.defaultValue) {\n                this.walk(param.defaultValue);\n            }\n            if (param.typeAnnotation) {\n                this.walk(param.typeAnnotation);\n            }\n        });\n        if (node.returnTypeAnnotation) {\n            this.walk(node.returnTypeAnnotation);\n        }\n        this.walkMultiple(node.decorators);\n        node.parameters.forEach((param) => {\n            if (param.name) {\n                this.walk(param.name);\n            }\n        });\n        this.walk(node.suite);\n        if (functionTypeResult) {\n            // Validate that the function returns the declared type.\n            this._validateFunctionReturn(node, functionTypeResult.functionType);\n        }\n        // If we're at the module level within a stub file, report a diagnostic\n        // if there is a '__getattr__' function defined when in strict mode.\n        // This signifies an incomplete stub file that obscures type errors.\n        if (this._fileInfo.isStubFile && node.name.value === '__getattr__') {\n            const scope = scopeUtils_1.getScopeForNode(node);\n            if ((scope === null || scope === void 0 ? void 0 : scope.type) === 3 /* Module */) {\n                this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportUnknownMemberType, \"reportUnknownMemberType\" /* reportUnknownMemberType */, localize_1.Localizer.Diagnostic.stubUsesGetAttr(), node.name);\n            }\n        }\n        this._scopedNodes.push(node);\n        return false;\n    }\n    visitLambda(node) {\n        this._evaluator.getType(node);\n        // Walk the children.\n        this.walkMultiple([...node.parameters, node.expression]);\n        node.parameters.forEach((param) => {\n            if (param.name) {\n                const paramType = this._evaluator.getType(param.name);\n                if (paramType) {\n                    if (types_1.isUnknown(paramType)) {\n                        this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportUnknownLambdaType, \"reportUnknownLambdaType\" /* reportUnknownLambdaType */, localize_1.Localizer.Diagnostic.paramTypeUnknown().format({ paramName: param.name.value }), param.name);\n                    }\n                    else if (typeUtils_1.isPartlyUnknown(paramType)) {\n                        this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportUnknownLambdaType, \"reportUnknownLambdaType\" /* reportUnknownLambdaType */, localize_1.Localizer.Diagnostic.paramTypePartiallyUnknown().format({ paramName: param.name.value }), param.name);\n                    }\n                }\n            }\n        });\n        const returnType = this._evaluator.getType(node.expression);\n        if (returnType) {\n            if (types_1.isUnknown(returnType)) {\n                this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportUnknownLambdaType, \"reportUnknownLambdaType\" /* reportUnknownLambdaType */, localize_1.Localizer.Diagnostic.lambdaReturnTypeUnknown(), node.expression);\n            }\n            else if (typeUtils_1.isPartlyUnknown(returnType)) {\n                this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportUnknownLambdaType, \"reportUnknownLambdaType\" /* reportUnknownLambdaType */, localize_1.Localizer.Diagnostic.lambdaReturnTypePartiallyUnknown().format({\n                    returnType: this._evaluator.printType(returnType, /* expandTypeAlias */ false),\n                }), node.expression);\n            }\n        }\n        this._scopedNodes.push(node);\n        return false;\n    }\n    visitCall(node) {\n        this._validateIsInstanceCall(node);\n        if (ParseTreeUtils.isWithinDefaultParamInitializer(node) && !this._fileInfo.isStubFile) {\n            this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportCallInDefaultInitializer, \"reportCallInDefaultInitializer\" /* reportCallInDefaultInitializer */, localize_1.Localizer.Diagnostic.defaultValueContainsCall(), node);\n        }\n        return true;\n    }\n    visitFor(node) {\n        this._evaluator.evaluateTypesForStatement(node);\n        return true;\n    }\n    visitListComprehension(node) {\n        this._scopedNodes.push(node);\n        return true;\n    }\n    visitIf(node) {\n        this._evaluator.getType(node.testExpression);\n        return true;\n    }\n    visitWhile(node) {\n        this._evaluator.getType(node.testExpression);\n        return true;\n    }\n    visitWith(node) {\n        node.withItems.forEach((item) => {\n            this._evaluator.evaluateTypesForStatement(item);\n        });\n        return true;\n    }\n    visitReturn(node) {\n        let returnType;\n        const enclosingFunctionNode = ParseTreeUtils.getEnclosingFunction(node);\n        const declaredReturnType = enclosingFunctionNode\n            ? this._evaluator.getFunctionDeclaredReturnType(enclosingFunctionNode)\n            : undefined;\n        if (node.returnExpression) {\n            returnType = this._evaluator.getType(node.returnExpression) || types_1.UnknownType.create();\n        }\n        else {\n            // There is no return expression, so \"None\" is assumed.\n            returnType = types_1.NoneType.createInstance();\n        }\n        if (this._evaluator.isNodeReachable(node) && enclosingFunctionNode) {\n            if (declaredReturnType) {\n                if (typeUtils_1.isNoReturnType(declaredReturnType)) {\n                    this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.noReturnContainsReturn(), node);\n                }\n                else {\n                    const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n                    // Specialize the return type in case it contains references to type variables.\n                    // These will be replaced with the corresponding constraint or bound types.\n                    const specializedDeclaredType = typeUtils_1.specializeType(declaredReturnType, undefined);\n                    if (!this._evaluator.canAssignType(specializedDeclaredType, returnType, diagAddendum)) {\n                        this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.returnTypeMismatch().format({\n                            exprType: this._evaluator.printType(returnType, /* expandTypeAlias */ false),\n                            returnType: this._evaluator.printType(specializedDeclaredType, \n                            /* expandTypeAlias */ false),\n                        }) + diagAddendum.getString(), node.returnExpression ? node.returnExpression : node);\n                    }\n                }\n            }\n            if (types_1.isUnknown(returnType)) {\n                this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportUnknownVariableType, \"reportUnknownVariableType\" /* reportUnknownVariableType */, localize_1.Localizer.Diagnostic.returnTypeUnknown(), node.returnExpression);\n            }\n            else if (typeUtils_1.isPartlyUnknown(returnType)) {\n                this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportUnknownVariableType, \"reportUnknownVariableType\" /* reportUnknownVariableType */, localize_1.Localizer.Diagnostic.returnTypePartiallyUnknown().format({\n                    returnType: this._evaluator.printType(returnType, /* expandTypeAlias */ false),\n                }), node.returnExpression);\n            }\n        }\n        return true;\n    }\n    visitYield(node) {\n        const yieldType = node.expression ? this._evaluator.getType(node.expression) : types_1.NoneType.createInstance();\n        // Wrap the yield type in an Iterator.\n        let adjYieldType = yieldType;\n        const iteratorType = this._evaluator.getBuiltInType(node, 'Iterator');\n        if (yieldType && types_1.isClass(iteratorType)) {\n            adjYieldType = types_1.ObjectType.create(types_1.ClassType.cloneForSpecialization(iteratorType, [yieldType], /* isTypeArgumentExplicit */ false));\n        }\n        else {\n            adjYieldType = types_1.UnknownType.create();\n        }\n        this._validateYieldType(node, adjYieldType);\n        return true;\n    }\n    visitYieldFrom(node) {\n        const yieldType = this._evaluator.getType(node.expression);\n        if (yieldType) {\n            this._validateYieldType(node, yieldType);\n        }\n        return true;\n    }\n    visitRaise(node) {\n        const baseExceptionType = this._evaluator.getBuiltInType(node, 'BaseException');\n        if (node.typeExpression) {\n            const exceptionType = this._evaluator.getType(node.typeExpression);\n            // Validate that the argument of \"raise\" is an exception object or class.\n            if (exceptionType && baseExceptionType && types_1.isClass(baseExceptionType)) {\n                const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n                typeUtils_1.doForSubtypes(exceptionType, (subtype) => {\n                    if (!types_1.isAnyOrUnknown(subtype)) {\n                        if (types_1.isClass(subtype)) {\n                            if (!typeUtils_1.derivesFromClassRecursive(subtype, baseExceptionType, /* ignoreUnknown */ false)) {\n                                diagAddendum.addMessage(localize_1.Localizer.Diagnostic.exceptionTypeIncorrect().format({\n                                    type: this._evaluator.printType(subtype, /* expandTypeAlias */ false),\n                                }));\n                            }\n                        }\n                        else if (types_1.isObject(subtype)) {\n                            if (!typeUtils_1.derivesFromClassRecursive(subtype.classType, baseExceptionType, \n                            /* ignoreUnknown */ false)) {\n                                diagAddendum.addMessage(localize_1.Localizer.Diagnostic.exceptionTypeIncorrect().format({\n                                    type: this._evaluator.printType(subtype, /* expandTypeAlias */ false),\n                                }));\n                            }\n                        }\n                        else {\n                            diagAddendum.addMessage(localize_1.Localizer.Diagnostic.exceptionTypeIncorrect().format({\n                                type: this._evaluator.printType(subtype, /* expandTypeAlias */ false),\n                            }));\n                        }\n                    }\n                    return subtype;\n                });\n                if (!diagAddendum.isEmpty()) {\n                    this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.expectedExceptionClass() + diagAddendum.getString(), node.typeExpression);\n                }\n            }\n        }\n        if (node.valueExpression) {\n            const exceptionType = this._evaluator.getType(node.valueExpression);\n            // Validate that the argument of \"raise\" is an exception object or None.\n            if (exceptionType && baseExceptionType && types_1.isClass(baseExceptionType)) {\n                const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n                typeUtils_1.doForSubtypes(exceptionType, (subtype) => {\n                    if (!types_1.isAnyOrUnknown(subtype) && !types_1.isNone(subtype)) {\n                        if (types_1.isObject(subtype)) {\n                            if (!typeUtils_1.derivesFromClassRecursive(subtype.classType, baseExceptionType, \n                            /* ignoreUnknown */ false)) {\n                                diagAddendum.addMessage(localize_1.Localizer.Diagnostic.exceptionTypeIncorrect().format({\n                                    type: this._evaluator.printType(subtype, /* expandTypeAlias */ false),\n                                }));\n                            }\n                        }\n                        else {\n                            diagAddendum.addMessage(localize_1.Localizer.Diagnostic.exceptionTypeIncorrect().format({\n                                type: this._evaluator.printType(subtype, /* expandTypeAlias */ false),\n                            }));\n                        }\n                    }\n                    return subtype;\n                });\n                if (!diagAddendum.isEmpty()) {\n                    this._evaluator.addError(localize_1.Localizer.Diagnostic.expectedExceptionObj() + diagAddendum.getString(), node.valueExpression);\n                }\n            }\n        }\n        return true;\n    }\n    visitExcept(node) {\n        if (node.typeExpression) {\n            this._evaluator.evaluateTypesForStatement(node);\n            const exceptionType = this._evaluator.getType(node.typeExpression);\n            if (exceptionType) {\n                this._validateExceptionType(exceptionType, node.typeExpression);\n            }\n        }\n        return true;\n    }\n    visitAssert(node) {\n        if (node.exceptionExpression) {\n            this._evaluator.getType(node.exceptionExpression);\n        }\n        // Specifically look for a common programming error where the two arguments\n        // to an assert are enclosed in parens and interpreted as a two-element tuple.\n        //   assert (x > 3, \"bad value x\")\n        const type = this._evaluator.getType(node.testExpression);\n        if (type && types_1.isObject(type)) {\n            if (types_1.ClassType.isBuiltIn(type.classType, 'Tuple') && type.classType.typeArguments) {\n                if (type.classType.typeArguments.length > 0) {\n                    const lastTypeArg = type.classType.typeArguments[type.classType.typeArguments.length - 1];\n                    if (!typeUtils_1.isEllipsisType(lastTypeArg)) {\n                        this._evaluator.addDiagnosticForTextRange(this._fileInfo, this._fileInfo.diagnosticRuleSet.reportAssertAlwaysTrue, \"reportAssertAlwaysTrue\" /* reportAssertAlwaysTrue */, localize_1.Localizer.Diagnostic.assertAlwaysTrue(), node.testExpression);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    visitAssignment(node) {\n        this._evaluator.evaluateTypesForStatement(node);\n        if (node.typeAnnotationComment) {\n            this._evaluator.getType(node.typeAnnotationComment);\n        }\n        return true;\n    }\n    visitAssignmentExpression(node) {\n        this._evaluator.getType(node);\n        return true;\n    }\n    visitAugmentedAssignment(node) {\n        this._evaluator.evaluateTypesForStatement(node);\n        return true;\n    }\n    visitIndex(node) {\n        this._evaluator.getType(node);\n        return true;\n    }\n    visitBinaryOperation(node) {\n        this._evaluator.getType(node);\n        return true;\n    }\n    visitSlice(node) {\n        this._evaluator.getType(node);\n        return true;\n    }\n    visitUnpack(node) {\n        this._evaluator.getType(node);\n        return true;\n    }\n    visitTuple(node) {\n        this._evaluator.getType(node);\n        return true;\n    }\n    visitUnaryOperation(node) {\n        this._evaluator.getType(node);\n        return true;\n    }\n    visitTernary(node) {\n        this._evaluator.getType(node);\n        return true;\n    }\n    visitStringList(node) {\n        if (node.typeAnnotation) {\n            this._evaluator.getType(node);\n        }\n        if (node.strings.length > 1) {\n            this._evaluator.addDiagnosticForTextRange(this._fileInfo, this._fileInfo.diagnosticRuleSet.reportImplicitStringConcatenation, \"reportImplicitStringConcatenation\" /* reportImplicitStringConcatenation */, localize_1.Localizer.Diagnostic.implicitStringConcat(), node);\n        }\n        return true;\n    }\n    visitFormatString(node) {\n        node.expressions.forEach((formatExpr) => {\n            this._evaluator.getType(formatExpr);\n        });\n        return true;\n    }\n    visitName(node) {\n        // Determine if we should log information about private usage.\n        this._conditionallyReportPrivateUsage(node);\n        return true;\n    }\n    visitDel(node) {\n        node.expressions.forEach((expr) => {\n            this._evaluator.verifyDeleteExpression(expr);\n        });\n        return true;\n    }\n    visitMemberAccess(node) {\n        this._evaluator.getType(node);\n        this._conditionallyReportPrivateUsage(node.memberName);\n        // Walk the leftExpression but not the memberName.\n        this.walk(node.leftExpression);\n        return false;\n    }\n    visitImportAs(node) {\n        this._evaluator.evaluateTypesForStatement(node);\n        return false;\n    }\n    visitImportFrom(node) {\n        if (!node.isWildcardImport) {\n            node.imports.forEach((importAs) => {\n                this._evaluator.evaluateTypesForStatement(importAs);\n            });\n        }\n        return false;\n    }\n    visitTypeAnnotation(node) {\n        this._evaluator.getType(node.typeAnnotation);\n        return true;\n    }\n    visitError(node) {\n        // Get the type of the child so it's available to\n        // the completion provider.\n        if (node.child) {\n            this._evaluator.getType(node.child);\n        }\n        // Don't explore further.\n        return false;\n    }\n    _walkStatementsAndReportUnreachable(statements) {\n        let reportedUnreachable = false;\n        for (const statement of statements) {\n            // No need to report unreachable more than once since the first time\n            // covers all remaining statements in the statement list.\n            if (!reportedUnreachable) {\n                if (!this._evaluator.isNodeReachable(statement)) {\n                    // Create a text range that covers the next statement through\n                    // the end of the statement list.\n                    const start = statement.start;\n                    const lastStatement = statements[statements.length - 1];\n                    const end = textRange_1.TextRange.getEnd(lastStatement);\n                    this._evaluator.addUnusedCode(statement, { start, length: end - start });\n                    reportedUnreachable = true;\n                }\n            }\n            if (!reportedUnreachable && this._fileInfo.isStubFile) {\n                this._validateStubStatement(statement);\n            }\n            this.walk(statement);\n        }\n    }\n    _validateStubStatement(statement) {\n        switch (statement.nodeType) {\n            case 19 /* If */:\n            case 29 /* Function */:\n            case 10 /* Class */:\n            case 0 /* Error */: {\n                // These are allowed in a stub file.\n                break;\n            }\n            case 58 /* While */:\n            case 27 /* For */:\n            case 54 /* Try */:\n            case 59 /* With */: {\n                // These are not allowed.\n                this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportInvalidStubStatement, \"reportInvalidStubStatement\" /* reportInvalidStubStatement */, localize_1.Localizer.Diagnostic.invalidStubStatement(), statement);\n                break;\n            }\n            case 48 /* StatementList */: {\n                for (const substatement of statement.statements) {\n                    switch (substatement.nodeType) {\n                        case 2 /* Assert */:\n                        case 4 /* AssignmentExpression */:\n                        case 5 /* AugmentedAssignment */:\n                        case 6 /* Await */:\n                        case 7 /* BinaryOperation */:\n                        case 9 /* Call */:\n                        case 11 /* Constant */:\n                        case 14 /* Del */:\n                        case 15 /* Dictionary */:\n                        case 24 /* Index */:\n                        case 27 /* For */:\n                        case 28 /* FormatString */:\n                        case 30 /* Global */:\n                        case 31 /* Lambda */:\n                        case 32 /* List */:\n                        case 36 /* MemberAccess */:\n                        case 39 /* Name */:\n                        case 40 /* Nonlocal */:\n                        case 41 /* Number */:\n                        case 44 /* Raise */:\n                        case 45 /* Return */:\n                        case 46 /* Set */:\n                        case 47 /* Slice */:\n                        case 52 /* Ternary */:\n                        case 53 /* Tuple */:\n                        case 54 /* Try */:\n                        case 56 /* UnaryOperation */:\n                        case 57 /* Unpack */:\n                        case 58 /* While */:\n                        case 59 /* With */:\n                        case 60 /* WithItem */:\n                        case 61 /* Yield */:\n                        case 62 /* YieldFrom */: {\n                            this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportInvalidStubStatement, \"reportInvalidStubStatement\" /* reportInvalidStubStatement */, localize_1.Localizer.Diagnostic.invalidStubStatement(), substatement);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    _validateExceptionType(exceptionType, errorNode) {\n        const baseExceptionType = this._evaluator.getBuiltInType(errorNode, 'BaseException');\n        const derivesFromBaseException = (classType) => {\n            if (!baseExceptionType || !types_1.isClass(baseExceptionType)) {\n                return true;\n            }\n            return typeUtils_1.derivesFromClassRecursive(classType, baseExceptionType, /* ignoreUnknown */ false);\n        };\n        const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n        let resultingExceptionType;\n        if (types_1.isAnyOrUnknown(exceptionType)) {\n            resultingExceptionType = exceptionType;\n        }\n        else {\n            // Handle the case where we have a Type[X] object.\n            if (types_1.isObject(exceptionType)) {\n                exceptionType = typeUtils_1.transformTypeObjectToClass(exceptionType);\n            }\n            if (types_1.isClass(exceptionType)) {\n                if (!derivesFromBaseException(exceptionType)) {\n                    diagAddendum.addMessage(localize_1.Localizer.Diagnostic.exceptionTypeIncorrect().format({\n                        type: this._evaluator.printType(exceptionType, /* expandTypeAlias */ false),\n                    }));\n                }\n                resultingExceptionType = types_1.ObjectType.create(exceptionType);\n            }\n            else if (types_1.isObject(exceptionType)) {\n                const iterableType = this._evaluator.getTypeFromIterable(exceptionType, \n                /* isAsync */ false, errorNode, false);\n                resultingExceptionType = typeUtils_1.doForSubtypes(iterableType, (subtype) => {\n                    if (types_1.isAnyOrUnknown(subtype)) {\n                        return subtype;\n                    }\n                    const transformedSubtype = typeUtils_1.transformTypeObjectToClass(subtype);\n                    if (types_1.isClass(transformedSubtype)) {\n                        if (!derivesFromBaseException(transformedSubtype)) {\n                            diagAddendum.addMessage(localize_1.Localizer.Diagnostic.exceptionTypeIncorrect().format({\n                                type: this._evaluator.printType(exceptionType, /* expandTypeAlias */ false),\n                            }));\n                        }\n                        return types_1.ObjectType.create(transformedSubtype);\n                    }\n                    diagAddendum.addMessage(localize_1.Localizer.Diagnostic.exceptionTypeIncorrect().format({\n                        type: this._evaluator.printType(exceptionType, /* expandTypeAlias */ false),\n                    }));\n                    return types_1.UnknownType.create();\n                });\n            }\n        }\n        if (!diagAddendum.isEmpty()) {\n            this._evaluator.addError(localize_1.Localizer.Diagnostic.exceptionTypeNotClass().format({\n                type: this._evaluator.printType(exceptionType, /* expandTypeAlias */ false),\n            }), errorNode);\n        }\n        return resultingExceptionType || types_1.UnknownType.create();\n    }\n    _validateSymbolTables() {\n        for (const scopedNode of this._scopedNodes) {\n            const scope = AnalyzerNodeInfo.getScope(scopedNode);\n            if (scope) {\n                scope.symbolTable.forEach((symbol, name) => {\n                    this._conditionallyReportUnusedSymbol(name, symbol, scope.type);\n                    this._reportIncompatibleDeclarations(name, symbol);\n                    this._reportMultipleFinalDeclarations(name, symbol);\n                    this._reportMultipleTypeAliasDeclarations(name, symbol);\n                });\n            }\n        }\n    }\n    _reportMultipleFinalDeclarations(name, symbol) {\n        if (!symbolUtils_1.isFinalVariable(symbol)) {\n            return;\n        }\n        const decls = symbol.getDeclarations();\n        let sawFinal = false;\n        let sawAssignment = false;\n        decls.forEach((decl) => {\n            if (declarationUtils_1.isFinalVariableDeclaration(decl)) {\n                if (sawFinal) {\n                    this._evaluator.addError(localize_1.Localizer.Diagnostic.finalRedeclaration().format({ name }), decl.node);\n                }\n                sawFinal = true;\n            }\n            if (decl.type === 1 /* Variable */ && decl.inferredTypeSource) {\n                if (sawAssignment) {\n                    this._evaluator.addError(localize_1.Localizer.Diagnostic.finalReassigned().format({ name }), decl.node);\n                }\n                sawAssignment = true;\n            }\n        });\n        // If it's not a stub file, an assignment must be provided.\n        if (!sawAssignment && !this._fileInfo.isStubFile) {\n            const firstDecl = decls.find((decl) => decl.type === 1 /* Variable */ && decl.isFinal);\n            if (firstDecl) {\n                this._evaluator.addError(localize_1.Localizer.Diagnostic.finalUnassigned().format({ name }), firstDecl.node);\n            }\n        }\n    }\n    _reportMultipleTypeAliasDeclarations(name, symbol) {\n        const decls = symbol.getDeclarations();\n        const typeAliasDecl = decls.find((decl) => declarationUtils_1.isTypeAliasDeclaration(decl));\n        // If this is a type alias, there should be only one declaration.\n        if (typeAliasDecl && decls.length > 1) {\n            decls.forEach((decl) => {\n                if (decl !== typeAliasDecl) {\n                    this._evaluator.addError(localize_1.Localizer.Diagnostic.typeAliasRedeclared().format({ name }), decl.node);\n                }\n            });\n        }\n    }\n    _reportIncompatibleDeclarations(name, symbol) {\n        // If there's one or more declaration with a declared type,\n        // all other declarations should match. The only exception is\n        // for functions that have an overload.\n        const primaryDecl = symbolUtils_1.getLastTypedDeclaredForSymbol(symbol);\n        // If there's no declaration with a declared type, we're done.\n        if (!primaryDecl) {\n            return;\n        }\n        let otherDecls = symbol.getDeclarations().filter((decl) => decl !== primaryDecl);\n        // If it's a function, we can skip any other declarations\n        // that are overloads.\n        if (primaryDecl.type === 3 /* Function */) {\n            otherDecls = otherDecls.filter((decl) => decl.type !== 3 /* Function */);\n        }\n        // If there are no other declarations to consider, we're done.\n        if (otherDecls.length === 0) {\n            return;\n        }\n        let primaryDeclInfo;\n        if (primaryDecl.type === 3 /* Function */) {\n            if (primaryDecl.isMethod) {\n                primaryDeclInfo = localize_1.Localizer.DiagnosticAddendum.seeMethodDeclaration();\n            }\n            else {\n                primaryDeclInfo = localize_1.Localizer.DiagnosticAddendum.seeFunctionDeclaration();\n            }\n        }\n        else if (primaryDecl.type === 4 /* Class */) {\n            primaryDeclInfo = localize_1.Localizer.DiagnosticAddendum.seeClassDeclaration();\n        }\n        else if (primaryDecl.type === 2 /* Parameter */) {\n            primaryDeclInfo = localize_1.Localizer.DiagnosticAddendum.seeParameterDeclaration();\n        }\n        else if (primaryDecl.type === 1 /* Variable */) {\n            primaryDeclInfo = localize_1.Localizer.DiagnosticAddendum.seeVariableDeclaration();\n        }\n        else {\n            primaryDeclInfo = localize_1.Localizer.DiagnosticAddendum.seeDeclaration();\n        }\n        const addPrimaryDeclInfo = (diag) => {\n            if (diag) {\n                let primaryDeclNode;\n                if (primaryDecl.type === 3 /* Function */ || primaryDecl.type === 4 /* Class */) {\n                    primaryDeclNode = primaryDecl.node.name;\n                }\n                else if (primaryDecl.type === 1 /* Variable */) {\n                    if (primaryDecl.node.nodeType === 39 /* Name */) {\n                        primaryDeclNode = primaryDecl.node;\n                    }\n                }\n                else if (primaryDecl.type === 2 /* Parameter */) {\n                    if (primaryDecl.node.name) {\n                        primaryDeclNode = primaryDecl.node.name;\n                    }\n                }\n                if (primaryDeclNode) {\n                    diag.addRelatedInfo(primaryDeclInfo, primaryDecl.path, primaryDecl.range);\n                }\n            }\n        };\n        for (const otherDecl of otherDecls) {\n            if (otherDecl.type === 4 /* Class */) {\n                const diag = this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.obscuredClassDeclaration().format({ name }), otherDecl.node.name);\n                addPrimaryDeclInfo(diag);\n            }\n            else if (otherDecl.type === 3 /* Function */) {\n                const diag = this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.obscuredFunctionDeclaration().format({ name }), otherDecl.node.name);\n                addPrimaryDeclInfo(diag);\n            }\n            else if (otherDecl.type === 2 /* Parameter */) {\n                if (otherDecl.node.name) {\n                    const diag = this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.obscuredParameterDeclaration().format({ name }), otherDecl.node.name);\n                    addPrimaryDeclInfo(diag);\n                }\n            }\n            else if (otherDecl.type === 1 /* Variable */) {\n                const primaryType = this._evaluator.getTypeForDeclaration(primaryDecl);\n                if (otherDecl.typeAnnotationNode) {\n                    if (otherDecl.node.nodeType === 39 /* Name */) {\n                        let duplicateIsOk = false;\n                        // If both declarations are variables, it's OK if they\n                        // both have the same declared type.\n                        if (primaryDecl.type === 1 /* Variable */) {\n                            const otherType = this._evaluator.getTypeForDeclaration(otherDecl);\n                            if (primaryType && otherType && types_1.isTypeSame(primaryType, otherType)) {\n                                duplicateIsOk = true;\n                            }\n                        }\n                        if (!duplicateIsOk) {\n                            const diag = this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.obscuredVariableDeclaration().format({ name }), otherDecl.node);\n                            addPrimaryDeclInfo(diag);\n                        }\n                    }\n                }\n                else if (primaryType && !typeUtils_1.isProperty(primaryType)) {\n                    if (primaryDecl.type === 3 /* Function */ || primaryDecl.type === 4 /* Class */) {\n                        const diag = this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.obscuredVariableDeclaration().format({ name }), otherDecl.node);\n                        addPrimaryDeclInfo(diag);\n                    }\n                }\n            }\n        }\n    }\n    _conditionallyReportUnusedSymbol(name, symbol, scopeType) {\n        const accessedSymbolMap = this._fileInfo.accessedSymbolMap;\n        if (symbol.isIgnoredForProtocolMatch() || accessedSymbolMap.has(symbol.id)) {\n            return;\n        }\n        // A name of \"_\" means \"I know this symbol isn't used\", so\n        // don't report it as unused.\n        if (name === '_') {\n            return;\n        }\n        if (SymbolNameUtils.isDunderName(name)) {\n            return;\n        }\n        const decls = symbol.getDeclarations();\n        decls.forEach((decl) => {\n            this._conditionallyReportUnusedDeclaration(decl, this._isSymbolPrivate(name, scopeType));\n        });\n    }\n    _conditionallyReportUnusedDeclaration(decl, isPrivate) {\n        let diagnosticLevel;\n        let nameNode;\n        let message;\n        let rule;\n        switch (decl.type) {\n            case 6 /* Alias */:\n                diagnosticLevel = this._fileInfo.diagnosticRuleSet.reportUnusedImport;\n                rule = \"reportUnusedImport\" /* reportUnusedImport */;\n                if (decl.node.nodeType === 21 /* ImportAs */) {\n                    if (decl.node.alias) {\n                        // Aliases in stub files are assumed to be re-exports.\n                        if (!this._fileInfo.isStubFile) {\n                            nameNode = decl.node.alias;\n                        }\n                    }\n                    else {\n                        // Handle multi-part names specially.\n                        const nameParts = decl.node.module.nameParts;\n                        if (nameParts.length > 0) {\n                            const multipartName = nameParts.map((np) => np.value).join('.');\n                            const textRange = { start: nameParts[0].start, length: nameParts[0].length };\n                            textRange_1.TextRange.extend(textRange, nameParts[nameParts.length - 1]);\n                            this._fileInfo.diagnosticSink.addUnusedCodeWithTextRange(localize_1.Localizer.Diagnostic.unaccessedSymbol().format({ name: multipartName }), textRange, { action: \"pyright.unusedImport\" /* unusedImport */ });\n                            this._evaluator.addDiagnosticForTextRange(this._fileInfo, this._fileInfo.diagnosticRuleSet.reportUnusedImport, \"reportUnusedImport\" /* reportUnusedImport */, localize_1.Localizer.Diagnostic.unaccessedImport().format({ name: multipartName }), textRange);\n                            return;\n                        }\n                    }\n                }\n                else if (decl.node.nodeType === 23 /* ImportFromAs */) {\n                    const importFrom = decl.node.parent;\n                    // If this is a stub file that is using the \"from A import B as C\" or \"from . import C\",\n                    // don't mark \"C\" as unaccessed because it's assumed to be re-exported.\n                    const isReexport = this._fileInfo.isStubFile && decl.node.alias !== undefined;\n                    // If this is a __future__ import, it's OK for the import symbol to be unaccessed.\n                    const isFuture = importFrom.module.nameParts.length === 1 &&\n                        importFrom.module.nameParts[0].value === '__future__';\n                    if (!isReexport && !isFuture) {\n                        nameNode = decl.node.alias || decl.node.name;\n                    }\n                }\n                if (nameNode) {\n                    message = localize_1.Localizer.Diagnostic.unaccessedImport().format({ name: nameNode.value });\n                }\n                break;\n            case 1 /* Variable */:\n            case 2 /* Parameter */:\n                if (!isPrivate) {\n                    return;\n                }\n                if (this._fileInfo.isStubFile) {\n                    // Don't mark variables or parameters as unaccessed in\n                    // stub files. It's typical for them to be unaccessed here.\n                    return;\n                }\n                diagnosticLevel = this._fileInfo.diagnosticRuleSet.reportUnusedVariable;\n                if (decl.node.nodeType === 39 /* Name */) {\n                    nameNode = decl.node;\n                }\n                else if (decl.node.nodeType === 42 /* Parameter */) {\n                    nameNode = decl.node.name;\n                    // Don't emit a diagnostic for unused parameters.\n                    diagnosticLevel = 'none';\n                }\n                if (nameNode) {\n                    rule = \"reportUnusedVariable\" /* reportUnusedVariable */;\n                    message = localize_1.Localizer.Diagnostic.unaccessedVariable().format({ name: nameNode.value });\n                }\n                break;\n            case 4 /* Class */:\n                if (!isPrivate) {\n                    return;\n                }\n                // If a stub is exporting a private type, we'll assume that the author\n                // knows what he or she is doing.\n                if (this._fileInfo.isStubFile) {\n                    return;\n                }\n                diagnosticLevel = this._fileInfo.diagnosticRuleSet.reportUnusedClass;\n                nameNode = decl.node.name;\n                rule = \"reportUnusedClass\" /* reportUnusedClass */;\n                message = localize_1.Localizer.Diagnostic.unaccessedClass().format({ name: nameNode.value });\n                break;\n            case 3 /* Function */:\n                if (!isPrivate) {\n                    return;\n                }\n                // If a stub is exporting a private type, we'll assume that the author\n                // knows what he or she is doing.\n                if (this._fileInfo.isStubFile) {\n                    return;\n                }\n                diagnosticLevel = this._fileInfo.diagnosticRuleSet.reportUnusedFunction;\n                nameNode = decl.node.name;\n                rule = \"reportUnusedFunction\" /* reportUnusedFunction */;\n                message = localize_1.Localizer.Diagnostic.unaccessedFunction().format({ name: nameNode.value });\n                break;\n            default:\n                return;\n        }\n        if (nameNode && rule !== undefined && message) {\n            const action = rule === \"reportUnusedImport\" /* reportUnusedImport */ ? { action: \"pyright.unusedImport\" /* unusedImport */ } : undefined;\n            this._fileInfo.diagnosticSink.addUnusedCodeWithTextRange(localize_1.Localizer.Diagnostic.unaccessedSymbol().format({ name: nameNode.value }), nameNode, action);\n            this._evaluator.addDiagnostic(diagnosticLevel, rule, message, nameNode);\n        }\n    }\n    // Validates that a call to isinstance or issubclass are necessary. This is a\n    // common source of programming errors. Also validates that arguments passed\n    // to isinstance or issubclass won't generate exceptions.\n    _validateIsInstanceCall(node) {\n        if (node.leftExpression.nodeType !== 39 /* Name */ ||\n            (node.leftExpression.value !== 'isinstance' && node.leftExpression.value !== 'issubclass') ||\n            node.arguments.length !== 2) {\n            return;\n        }\n        const callName = node.leftExpression.value;\n        const isInstanceCheck = callName === 'isinstance';\n        let arg0Type = this._evaluator.getType(node.arguments[0].valueExpression);\n        if (!arg0Type) {\n            return;\n        }\n        arg0Type = typeUtils_1.doForSubtypes(arg0Type, (subtype) => {\n            return typeUtils_1.transformTypeObjectToClass(subtype);\n        });\n        if (typeUtils_1.derivesFromAnyOrUnknown(arg0Type)) {\n            return;\n        }\n        const arg1Type = this._evaluator.getType(node.arguments[1].valueExpression);\n        if (!arg1Type) {\n            return;\n        }\n        // Create a helper function that determines whether the specified\n        // type is valid for the isinstance or issubclass call.\n        const isSupportedTypeForIsInstance = (type) => {\n            let isSupported = true;\n            typeUtils_1.doForSubtypes(type, (subtype) => {\n                subtype = typeUtils_1.makeTypeVarsConcrete(subtype);\n                switch (subtype.category) {\n                    case 2 /* Any */:\n                    case 1 /* Unknown */:\n                    case 0 /* Unbound */:\n                        break;\n                    case 7 /* Class */:\n                        // If it's a class, make sure that it has not been given explicit\n                        // type arguments. This will result in a TypeError exception.\n                        if (subtype.isTypeArgumentExplicit) {\n                            isSupported = false;\n                        }\n                        break;\n                    default:\n                        isSupported = false;\n                        break;\n                }\n                return undefined;\n            });\n            return isSupported;\n        };\n        let isValidType = true;\n        if (types_1.isObject(arg1Type) &&\n            types_1.ClassType.isBuiltIn(arg1Type.classType, 'Tuple') &&\n            arg1Type.classType.typeArguments) {\n            isValidType = !arg1Type.classType.typeArguments.some((typeArg) => !isSupportedTypeForIsInstance(typeArg));\n        }\n        else {\n            isValidType = isSupportedTypeForIsInstance(arg1Type);\n        }\n        if (!isValidType) {\n            const diag = new diagnostic_1.DiagnosticAddendum();\n            diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeVarNotAllowed());\n            this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, isInstanceCheck\n                ? localize_1.Localizer.Diagnostic.isInstanceInvalidType().format({\n                    type: this._evaluator.printType(arg1Type, /* expandTypeAlias */ false),\n                }) + diag.getString()\n                : localize_1.Localizer.Diagnostic.isSubclassInvalidType().format({\n                    type: this._evaluator.printType(arg1Type, /* expandTypeAlias */ false),\n                }) + diag.getString(), node.arguments[1]);\n        }\n        // If this call is within an assert statement, we won't check whether\n        // it's unnecessary.\n        let curNode = node;\n        while (curNode) {\n            if (curNode.nodeType === 2 /* Assert */) {\n                return;\n            }\n            curNode = curNode.parent;\n        }\n        // Several built-in classes don't follow the normal class hierarchy\n        // rules, so we'll avoid emitting false-positive diagnostics if these\n        // are used.\n        const nonstandardClassTypes = ['FunctionType', 'LambdaType', 'BuiltinFunctionType', 'BuiltinMethodType'];\n        const classTypeList = [];\n        if (types_1.isClass(arg1Type)) {\n            classTypeList.push(arg1Type);\n            if (types_1.ClassType.isBuiltIn(arg1Type) && nonstandardClassTypes.some((name) => name === arg1Type.details.name)) {\n                return;\n            }\n        }\n        else if (types_1.isObject(arg1Type)) {\n            // The isinstance and issubclass call supports a variation where the second\n            // parameter is a tuple of classes.\n            const objClass = arg1Type.classType;\n            if (types_1.ClassType.isBuiltIn(objClass, 'Tuple') && objClass.typeArguments) {\n                objClass.typeArguments.forEach((typeArg) => {\n                    if (types_1.isClass(typeArg)) {\n                        classTypeList.push(typeArg);\n                    }\n                    else {\n                        return;\n                    }\n                });\n            }\n            if (types_1.ClassType.isBuiltIn(objClass) && nonstandardClassTypes.some((name) => name === objClass.details.name)) {\n                return;\n            }\n        }\n        else {\n            return;\n        }\n        // According to PEP 544, protocol classes cannot be used as the right-hand\n        // argument to isinstance or issubclass unless they are annotated as\n        // \"runtime checkable\".\n        if (classTypeList.some((type) => types_1.ClassType.isProtocolClass(type) && !types_1.ClassType.isRuntimeCheckable(type))) {\n            this._evaluator.addError(localize_1.Localizer.Diagnostic.protocolUsedInCall().format({ name: callName }), node.arguments[1].valueExpression);\n        }\n        const finalizeFilteredTypeList = (types) => {\n            return types_1.combineTypes(types);\n        };\n        const filterType = (varType) => {\n            const filteredTypes = [];\n            for (const filterType of classTypeList) {\n                const filterIsSuperclass = types_1.ClassType.isDerivedFrom(varType, filterType);\n                const filterIsSubclass = types_1.ClassType.isDerivedFrom(filterType, varType);\n                // Normally, a class should never be both a subclass and a\n                // superclass. However, this can happen if one of the classes\n                // derives from an unknown type. In this case, we'll add an\n                // unknown type into the filtered type list to avoid any\n                // false positives.\n                const isClassRelationshipIndeterminate = filterIsSubclass && filterIsSubclass && !types_1.ClassType.isSameGenericClass(varType, filterType);\n                if (isClassRelationshipIndeterminate) {\n                    filteredTypes.push(types_1.UnknownType.create());\n                }\n                else if (filterIsSuperclass) {\n                    // If the variable type is a subclass of the isinstance\n                    // filter, we haven't learned anything new about the\n                    // variable type.\n                    filteredTypes.push(varType);\n                }\n                else if (filterIsSubclass) {\n                    // If the variable type is a superclass of the isinstance\n                    // filter, we can narrow the type to the subclass.\n                    filteredTypes.push(filterType);\n                }\n            }\n            if (!isInstanceCheck) {\n                return filteredTypes;\n            }\n            // Make all class types into object types before returning them.\n            return filteredTypes.map((t) => (types_1.isClass(t) ? types_1.ObjectType.create(t) : t));\n        };\n        let filteredType;\n        if (isInstanceCheck && types_1.isObject(arg0Type)) {\n            const remainingTypes = filterType(arg0Type.classType);\n            filteredType = finalizeFilteredTypeList(remainingTypes);\n        }\n        else if (!isInstanceCheck && types_1.isClass(arg0Type)) {\n            const remainingTypes = filterType(arg0Type);\n            filteredType = finalizeFilteredTypeList(remainingTypes);\n        }\n        else if (arg0Type.category === 10 /* Union */) {\n            let remainingTypes = [];\n            let foundAnyType = false;\n            arg0Type.subtypes.forEach((t) => {\n                if (types_1.isAnyOrUnknown(t)) {\n                    foundAnyType = true;\n                }\n                if (isInstanceCheck && types_1.isObject(t)) {\n                    remainingTypes = remainingTypes.concat(filterType(t.classType));\n                }\n                else if (!isInstanceCheck && types_1.isClass(t)) {\n                    remainingTypes = remainingTypes.concat(filterType(t));\n                }\n            });\n            filteredType = finalizeFilteredTypeList(remainingTypes);\n            // If we found an any or unknown type, all bets are off.\n            if (foundAnyType) {\n                return;\n            }\n        }\n        else {\n            return;\n        }\n        const getTestType = () => {\n            const objTypeList = classTypeList.map((t) => types_1.ObjectType.create(t));\n            return types_1.combineTypes(objTypeList);\n        };\n        if (types_1.isNever(filteredType)) {\n            this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportUnnecessaryIsInstance, \"reportUnnecessaryIsInstance\" /* reportUnnecessaryIsInstance */, isInstanceCheck\n                ? localize_1.Localizer.Diagnostic.unnecessaryIsInstanceNever().format({\n                    testType: this._evaluator.printType(arg0Type, /* expandTypeAlias */ false),\n                    classType: this._evaluator.printType(getTestType(), /* expandTypeAlias */ false),\n                })\n                : localize_1.Localizer.Diagnostic.unnecessaryIsSubclassNever().format({\n                    testType: this._evaluator.printType(arg0Type, /* expandTypeAlias */ false),\n                    classType: this._evaluator.printType(getTestType(), /* expandTypeAlias */ false),\n                }), node);\n        }\n        else if (types_1.isTypeSame(filteredType, arg0Type)) {\n            this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportUnnecessaryIsInstance, \"reportUnnecessaryIsInstance\" /* reportUnnecessaryIsInstance */, isInstanceCheck\n                ? localize_1.Localizer.Diagnostic.unnecessaryIsInstanceAlways().format({\n                    testType: this._evaluator.printType(arg0Type, /* expandTypeAlias */ false),\n                    classType: this._evaluator.printType(getTestType(), /* expandTypeAlias */ false),\n                })\n                : localize_1.Localizer.Diagnostic.unnecessaryIsSubclassAlways().format({\n                    testType: this._evaluator.printType(arg0Type, /* expandTypeAlias */ false),\n                    classType: this._evaluator.printType(getTestType(), /* expandTypeAlias */ false),\n                }), node);\n        }\n    }\n    _isSymbolPrivate(nameValue, scopeType) {\n        // All variables within the scope of a function or a list\n        // comprehension are considered private.\n        if (scopeType === 1 /* Function */ || scopeType === 0 /* ListComprehension */) {\n            return true;\n        }\n        // See if the symbol is private.\n        if (SymbolNameUtils.isPrivateName(nameValue)) {\n            return true;\n        }\n        if (SymbolNameUtils.isProtectedName(nameValue)) {\n            // Protected names outside of a class scope are considered private.\n            const isClassScope = scopeType === 2 /* Class */;\n            return !isClassScope;\n        }\n        return false;\n    }\n    _conditionallyReportPrivateUsage(node) {\n        if (this._fileInfo.diagnosticRuleSet.reportPrivateUsage === 'none') {\n            return;\n        }\n        // Ignore privates in type stubs.\n        if (this._fileInfo.isStubFile) {\n            return;\n        }\n        const nameValue = node.value;\n        const isPrivateName = SymbolNameUtils.isPrivateName(nameValue);\n        const isProtectedName = SymbolNameUtils.isProtectedName(nameValue);\n        // If it's not a protected or private name, don't bother with\n        // any further checks.\n        if (!isPrivateName && !isProtectedName) {\n            return;\n        }\n        const declarations = this._evaluator.getDeclarationsForNameNode(node);\n        let primaryDeclaration = declarations && declarations.length > 0 ? declarations[declarations.length - 1] : undefined;\n        if (!primaryDeclaration || primaryDeclaration.node === node) {\n            return;\n        }\n        // If this symbol is an import alias (i.e. it's a local name rather than the original\n        // imported name), skip the private check.\n        if (primaryDeclaration.type === 6 /* Alias */ && primaryDeclaration.usesLocalName) {\n            return;\n        }\n        primaryDeclaration = this._evaluator.resolveAliasDeclaration(primaryDeclaration, /* resolveLocalNames */ true);\n        if (!primaryDeclaration || primaryDeclaration.node === node) {\n            return;\n        }\n        let classOrModuleNode;\n        if (primaryDeclaration.node) {\n            classOrModuleNode = ParseTreeUtils.getEnclosingClassOrModule(primaryDeclaration.node);\n        }\n        // If this is the name of a class, find the module or class that contains it rather\n        // than constraining the use of the class name within the class itself.\n        if (primaryDeclaration.node &&\n            primaryDeclaration.node.parent &&\n            primaryDeclaration.node.parent === classOrModuleNode &&\n            classOrModuleNode.nodeType === 10 /* Class */) {\n            classOrModuleNode = ParseTreeUtils.getEnclosingClassOrModule(classOrModuleNode);\n        }\n        // If it's a class member, check whether it's a legal protected access.\n        let isProtectedAccess = false;\n        if (classOrModuleNode && classOrModuleNode.nodeType === 10 /* Class */) {\n            if (isProtectedName) {\n                const declClassTypeInfo = this._evaluator.getTypeOfClass(classOrModuleNode);\n                if (declClassTypeInfo && types_1.isClass(declClassTypeInfo.decoratedType)) {\n                    // Note that the access is to a protected class member.\n                    isProtectedAccess = true;\n                    const enclosingClassNode = ParseTreeUtils.getEnclosingClass(node);\n                    if (enclosingClassNode) {\n                        isProtectedAccess = true;\n                        const enclosingClassTypeInfo = this._evaluator.getTypeOfClass(enclosingClassNode);\n                        // If the referencing class is a subclass of the declaring class, it's\n                        // allowed to access a protected name.\n                        if (enclosingClassTypeInfo && types_1.isClass(enclosingClassTypeInfo.decoratedType)) {\n                            if (typeUtils_1.derivesFromClassRecursive(enclosingClassTypeInfo.decoratedType, declClassTypeInfo.decoratedType, \n                            /* ignoreUnknown */ true)) {\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (classOrModuleNode && !ParseTreeUtils.isNodeContainedWithin(node, classOrModuleNode)) {\n            if (isProtectedAccess) {\n                this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportPrivateUsage, \"reportPrivateUsage\" /* reportPrivateUsage */, localize_1.Localizer.Diagnostic.protectedUsedOutsideOfClass().format({ name: nameValue }), node);\n            }\n            else {\n                this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportPrivateUsage, \"reportPrivateUsage\" /* reportPrivateUsage */, classOrModuleNode.nodeType === 10 /* Class */\n                    ? localize_1.Localizer.Diagnostic.privateUsedOutsideOfClass().format({ name: nameValue })\n                    : localize_1.Localizer.Diagnostic.privateUsedOutsideOfModule().format({ name: nameValue }), node);\n            }\n        }\n    }\n    // Verifies the rules specified in PEP 589 about TypedDict classes.\n    // They cannot have statements other than type annotations, doc\n    // strings, and \"pass\" statements or ellipses.\n    _validateTypedDictClassSuite(suiteNode) {\n        const emitBadStatementError = (node) => {\n            this._evaluator.addError(localize_1.Localizer.Diagnostic.typedDictBadVar(), node);\n        };\n        suiteNode.statements.forEach((statement) => {\n            if (!AnalyzerNodeInfo.isCodeUnreachable(statement)) {\n                if (statement.nodeType === 48 /* StatementList */) {\n                    for (const substatement of statement.statements) {\n                        if (substatement.nodeType !== 55 /* TypeAnnotation */ &&\n                            substatement.nodeType !== 18 /* Ellipsis */ &&\n                            substatement.nodeType !== 49 /* StringList */ &&\n                            substatement.nodeType !== 43 /* Pass */) {\n                            emitBadStatementError(substatement);\n                        }\n                    }\n                }\n                else {\n                    emitBadStatementError(statement);\n                }\n            }\n        });\n    }\n    _validateFunctionReturn(node, functionType) {\n        // Stub files are allowed not to return an actual value,\n        // so skip this if it's a stub file.\n        if (this._fileInfo.isStubFile) {\n            return;\n        }\n        if (node.returnTypeAnnotation) {\n            const functionNeverReturns = !this._evaluator.isAfterNodeReachable(node);\n            const implicitlyReturnsNone = this._evaluator.isAfterNodeReachable(node.suite);\n            let declaredReturnType = functionType.details.declaredReturnType;\n            if (declaredReturnType) {\n                if (types_1.isUnknown(declaredReturnType)) {\n                    this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportUnknownVariableType, \"reportUnknownVariableType\" /* reportUnknownVariableType */, localize_1.Localizer.Diagnostic.declaredReturnTypeUnknown(), node.returnTypeAnnotation);\n                }\n                else if (typeUtils_1.isPartlyUnknown(declaredReturnType)) {\n                    this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportUnknownVariableType, \"reportUnknownVariableType\" /* reportUnknownVariableType */, localize_1.Localizer.Diagnostic.declaredReturnTypePartiallyUnknown().format({\n                        returnType: this._evaluator.printType(declaredReturnType, /* expandTypeAlias */ false),\n                    }), node.returnTypeAnnotation);\n                }\n            }\n            // Wrap the declared type in a generator type if the function is a generator.\n            if (types_1.FunctionType.isGenerator(functionType)) {\n                declaredReturnType = typeUtils_1.getDeclaredGeneratorReturnType(functionType);\n            }\n            // The types of all return statement expressions were already checked\n            // against the declared type, but we need to verify the implicit None\n            // at the end of the function.\n            if (declaredReturnType && !functionNeverReturns && implicitlyReturnsNone) {\n                if (typeUtils_1.isNoReturnType(declaredReturnType)) {\n                    // If the function consists entirely of \"...\", assume that it's\n                    // an abstract method or a protocol method and don't require that\n                    // the return type matches.\n                    if (!ParseTreeUtils.isSuiteEmpty(node.suite)) {\n                        this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.noReturnReturnsNone(), node.returnTypeAnnotation);\n                    }\n                }\n                else if (!types_1.FunctionType.isAbstractMethod(functionType)) {\n                    // Make sure that the function doesn't implicitly return None if the declared\n                    // type doesn't allow it. Skip this check for abstract methods.\n                    const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n                    // If the declared type isn't compatible with 'None', flag an error.\n                    if (!this._evaluator.canAssignType(declaredReturnType, types_1.NoneType.createInstance(), diagAddendum)) {\n                        // If the function consists entirely of \"...\", assume that it's\n                        // an abstract method or a protocol method and don't require that\n                        // the return type matches.\n                        if (!ParseTreeUtils.isSuiteEmpty(node.suite)) {\n                            this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.returnMissing().format({\n                                returnType: this._evaluator.printType(declaredReturnType, \n                                /* expandTypeAlias */ false),\n                            }) + diagAddendum.getString(), node.returnTypeAnnotation);\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            const inferredReturnType = this._evaluator.getFunctionInferredReturnType(functionType);\n            if (types_1.isUnknown(inferredReturnType)) {\n                this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportUnknownParameterType, \"reportUnknownParameterType\" /* reportUnknownParameterType */, localize_1.Localizer.Diagnostic.returnTypeUnknown(), node.name);\n            }\n            else if (typeUtils_1.isPartlyUnknown(inferredReturnType)) {\n                this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportUnknownParameterType, \"reportUnknownParameterType\" /* reportUnknownParameterType */, localize_1.Localizer.Diagnostic.returnTypePartiallyUnknown().format({\n                    returnType: this._evaluator.printType(inferredReturnType, /* expandTypeAlias */ false),\n                }), node.name);\n            }\n        }\n    }\n    // Validates that any overridden member variables are not marked\n    // as Final in parent classes.\n    _validateFinalMemberOverrides(classType) {\n        classType.details.fields.forEach((localSymbol, name) => {\n            const parentSymbol = typeUtils_1.lookUpClassMember(classType, name, 1 /* SkipOriginalClass */);\n            if (parentSymbol && types_1.isClass(parentSymbol.classType) && symbolUtils_1.isFinalVariable(parentSymbol.symbol)) {\n                const decl = localSymbol.getDeclarations()[0];\n                this._evaluator.addError(localize_1.Localizer.Diagnostic.finalRedeclarationBySubclass().format({\n                    name,\n                    className: parentSymbol.classType.details.name,\n                }), decl.node);\n            }\n        });\n    }\n    // Validates that any overridden methods contain the same signatures\n    // as the original method. Also marks the class as abstract if one or\n    // more abstract methods are not overridden.\n    _validateClassMethods(classType) {\n        // Skip the overrides check for stub files. Many of the built-in\n        // typeshed stub files trigger this diagnostic.\n        if (!this._fileInfo.isStubFile) {\n            this._validateBaseClassOverrides(classType);\n        }\n    }\n    _validateBaseClassOverrides(classType) {\n        classType.details.fields.forEach((symbol, name) => {\n            // Don't check magic functions or private symbols.\n            if (!symbol.isClassMember() ||\n                SymbolNameUtils.isDunderName(name) ||\n                SymbolNameUtils.isPrivateOrProtectedName(name)) {\n                return;\n            }\n            // Get the symbol type defined in this class.\n            const typeOfSymbol = this._evaluator.getEffectiveTypeOfSymbol(symbol);\n            // If the type of the override symbol isn't known, stop here.\n            if (types_1.isAnyOrUnknown(typeOfSymbol)) {\n                return;\n            }\n            // Get the symbol defined in the base class.\n            const baseClassAndSymbol = typeUtils_1.lookUpClassMember(classType, name, 1 /* SkipOriginalClass */);\n            if (!baseClassAndSymbol || !types_1.isClass(baseClassAndSymbol.classType)) {\n                return;\n            }\n            // If the base class doesn't provide a type declaration, we won't bother\n            // proceeding with additional checks. Type inference is too inaccurate\n            // in this case, plus it would be very slow.\n            if (!baseClassAndSymbol.symbol.hasTypedDeclarations()) {\n                return;\n            }\n            const baseClassSymbolType = this._evaluator.getEffectiveTypeOfSymbol(baseClassAndSymbol.symbol);\n            const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n            if (baseClassSymbolType.category === 5 /* Function */ ||\n                baseClassSymbolType.category === 6 /* OverloadedFunction */) {\n                if (typeOfSymbol.category === 5 /* Function */) {\n                    if (!this._evaluator.canOverrideMethod(baseClassSymbolType, typeOfSymbol, diagAddendum)) {\n                        const decl = symbolUtils_1.getLastTypedDeclaredForSymbol(symbol);\n                        if (decl && decl.type === 3 /* Function */) {\n                            const diag = this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportIncompatibleMethodOverride, \"reportIncompatibleMethodOverride\" /* reportIncompatibleMethodOverride */, localize_1.Localizer.Diagnostic.incompatibleMethodOverride().format({\n                                name,\n                                className: baseClassAndSymbol.classType.details.name,\n                            }) + diagAddendum.getString(), decl.node.name);\n                            const origDecl = symbolUtils_1.getLastTypedDeclaredForSymbol(baseClassAndSymbol.symbol);\n                            if (diag && origDecl) {\n                                diag.addRelatedInfo(localize_1.Localizer.DiagnosticAddendum.overriddenMethod(), origDecl.path, origDecl.range);\n                            }\n                        }\n                    }\n                    if (baseClassSymbolType.category === 5 /* Function */) {\n                        if (types_1.FunctionType.isFinal(baseClassSymbolType)) {\n                            const decl = symbolUtils_1.getLastTypedDeclaredForSymbol(symbol);\n                            if (decl && decl.type === 3 /* Function */) {\n                                const diag = this._evaluator.addError(localize_1.Localizer.Diagnostic.finalMethodOverride().format({\n                                    name,\n                                    className: baseClassAndSymbol.classType.details.name,\n                                }), decl.node.name);\n                                const origDecl = symbolUtils_1.getLastTypedDeclaredForSymbol(baseClassAndSymbol.symbol);\n                                if (diag && origDecl) {\n                                    diag.addRelatedInfo(localize_1.Localizer.DiagnosticAddendum.finalMethod(), origDecl.path, origDecl.range);\n                                }\n                            }\n                        }\n                    }\n                }\n                else if (!types_1.isAnyOrUnknown(typeOfSymbol)) {\n                    const decls = symbol.getDeclarations();\n                    if (decls.length > 0) {\n                        const lastDecl = decls[decls.length - 1];\n                        const diag = this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportIncompatibleMethodOverride, \"reportIncompatibleMethodOverride\" /* reportIncompatibleMethodOverride */, localize_1.Localizer.Diagnostic.methodOverridden().format({\n                            name,\n                            className: baseClassAndSymbol.classType.details.name,\n                        }) + diagAddendum.getString(), lastDecl.node);\n                        const origDecl = symbolUtils_1.getLastTypedDeclaredForSymbol(baseClassAndSymbol.symbol);\n                        if (diag && origDecl) {\n                            diag.addRelatedInfo(localize_1.Localizer.DiagnosticAddendum.overriddenMethod(), origDecl.path, origDecl.range);\n                        }\n                    }\n                }\n            }\n            else {\n                // This check can be expensive, so don't perform it if the corresponding\n                // rule is disabled.\n                if (this._fileInfo.diagnosticRuleSet.reportIncompatibleVariableOverride !== 'none') {\n                    // Verify that the override type is assignable to (same or narrower than)\n                    // the declared type of the base symbol.\n                    if (!this._evaluator.canAssignType(baseClassSymbolType, typeOfSymbol, diagAddendum)) {\n                        const decls = symbol.getDeclarations();\n                        if (decls.length > 0) {\n                            const lastDecl = decls[decls.length - 1];\n                            if (lastDecl) {\n                                const diag = this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportIncompatibleVariableOverride, \"reportIncompatibleVariableOverride\" /* reportIncompatibleVariableOverride */, localize_1.Localizer.Diagnostic.symbolOverridden().format({\n                                    name,\n                                    className: baseClassAndSymbol.classType.details.name,\n                                }) + diagAddendum.getString(), lastDecl.node);\n                                const origDecl = symbolUtils_1.getLastTypedDeclaredForSymbol(baseClassAndSymbol.symbol);\n                                if (diag && origDecl) {\n                                    diag.addRelatedInfo(localize_1.Localizer.DiagnosticAddendum.overriddenSymbol(), origDecl.path, origDecl.range);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n    // Performs checks on a function that is located within a class\n    // and has been determined not to be a property accessor.\n    _validateMethod(node, functionType, classNode) {\n        if (node.name && node.name.value === '__new__') {\n            // __new__ overrides should have a \"cls\" parameter.\n            if (node.parameters.length === 0 ||\n                !node.parameters[0].name ||\n                (node.parameters[0].name.value !== 'cls' && node.parameters[0].name.value !== 'mcs')) {\n                this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportSelfClsParameterName, \"reportSelfClsParameterName\" /* reportSelfClsParameterName */, localize_1.Localizer.Diagnostic.newClsParam(), node.parameters.length > 0 ? node.parameters[0] : node.name);\n            }\n        }\n        else if (node.name && node.name.value === '__init_subclass__') {\n            // __init_subclass__ overrides should have a \"cls\" parameter.\n            if (node.parameters.length === 0 || !node.parameters[0].name || node.parameters[0].name.value !== 'cls') {\n                this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportSelfClsParameterName, \"reportSelfClsParameterName\" /* reportSelfClsParameterName */, localize_1.Localizer.Diagnostic.initSubclassClsParam(), node.parameters.length > 0 ? node.parameters[0] : node.name);\n            }\n        }\n        else if (types_1.FunctionType.isStaticMethod(functionType)) {\n            // Static methods should not have \"self\" or \"cls\" parameters.\n            if (node.parameters.length > 0 && node.parameters[0].name) {\n                const paramName = node.parameters[0].name.value;\n                if (paramName === 'self' || paramName === 'cls') {\n                    this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportSelfClsParameterName, \"reportSelfClsParameterName\" /* reportSelfClsParameterName */, localize_1.Localizer.Diagnostic.staticClsSelfParam(), node.parameters[0].name);\n                }\n            }\n        }\n        else if (types_1.FunctionType.isClassMethod(functionType)) {\n            let paramName = '';\n            if (node.parameters.length > 0 && node.parameters[0].name) {\n                paramName = node.parameters[0].name.value;\n            }\n            // Class methods should have a \"cls\" parameter. We'll exempt parameter\n            // names that start with an underscore since those are used in a few\n            // cases in the stdlib pyi files.\n            if (paramName !== 'cls') {\n                if (!this._fileInfo.isStubFile || (!paramName.startsWith('_') && paramName !== 'metacls')) {\n                    this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportSelfClsParameterName, \"reportSelfClsParameterName\" /* reportSelfClsParameterName */, localize_1.Localizer.Diagnostic.classMethodClsParam(), node.parameters.length > 0 ? node.parameters[0] : node.name);\n                }\n            }\n        }\n        else {\n            // The presence of a decorator can change the behavior, so we need\n            // to back off from this check if a decorator is present.\n            if (node.decorators.length === 0) {\n                let paramName = '';\n                let firstParamIsSimple = true;\n                if (node.parameters.length > 0) {\n                    if (node.parameters[0].name) {\n                        paramName = node.parameters[0].name.value;\n                    }\n                    if (node.parameters[0].category !== 0 /* Simple */) {\n                        firstParamIsSimple = false;\n                    }\n                }\n                // Instance methods should have a \"self\" parameter.\n                if (firstParamIsSimple && paramName !== 'self') {\n                    // Special-case metaclasses, which can use \"cls\".\n                    let isLegalMetaclassName = false;\n                    if (paramName === 'cls') {\n                        const classTypeInfo = this._evaluator.getTypeOfClass(classNode);\n                        const typeType = this._evaluator.getBuiltInType(classNode, 'type');\n                        if (typeType && types_1.isClass(typeType) && classTypeInfo && types_1.isClass(classTypeInfo.classType)) {\n                            if (typeUtils_1.derivesFromClassRecursive(classTypeInfo.classType, typeType, /* ignoreUnknown */ true)) {\n                                isLegalMetaclassName = true;\n                            }\n                        }\n                    }\n                    if (!isLegalMetaclassName) {\n                        this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportSelfClsParameterName, \"reportSelfClsParameterName\" /* reportSelfClsParameterName */, localize_1.Localizer.Diagnostic.instanceMethodSelfParam(), node.parameters.length > 0 ? node.parameters[0] : node.name);\n                    }\n                }\n            }\n        }\n    }\n    _validateYieldType(node, adjustedYieldType) {\n        let declaredYieldType;\n        const enclosingFunctionNode = ParseTreeUtils.getEnclosingFunction(node);\n        if (enclosingFunctionNode) {\n            const functionTypeResult = this._evaluator.getTypeOfFunction(enclosingFunctionNode);\n            if (functionTypeResult) {\n                debug_1.assert(functionTypeResult.functionType.category === 5 /* Function */);\n                const iterableType = this._evaluator.getBuiltInType(node, 'Iterable');\n                declaredYieldType = typeUtils_1.getDeclaredGeneratorYieldType(functionTypeResult.functionType, iterableType);\n            }\n        }\n        if (this._evaluator.isNodeReachable(node)) {\n            if (declaredYieldType) {\n                if (typeUtils_1.isNoReturnType(declaredYieldType)) {\n                    this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.noReturnContainsYield(), node);\n                }\n                else {\n                    const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n                    if (!this._evaluator.canAssignType(declaredYieldType, adjustedYieldType, diagAddendum)) {\n                        this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.yieldTypeMismatch().format({\n                            exprType: this._evaluator.printType(adjustedYieldType, /* expandTypeAlias */ false),\n                            yieldType: this._evaluator.printType(declaredYieldType, /* expandTypeAlias */ false),\n                        }) + diagAddendum.getString(), node.expression || node);\n                    }\n                }\n            }\n        }\n    }\n    _reportDuplicateImports() {\n        const importStatements = importStatementUtils_1.getTopLevelImports(this._moduleNode);\n        const importModuleMap = new Map();\n        importStatements.orderedImports.forEach((importStatement) => {\n            if (importStatement.node.nodeType === 22 /* ImportFrom */) {\n                const symbolMap = new Map();\n                importStatement.node.imports.forEach((importFromAs) => {\n                    // Ignore duplicates if they're aliased.\n                    if (!importFromAs.alias) {\n                        const prevImport = symbolMap.get(importFromAs.name.value);\n                        if (prevImport) {\n                            this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportDuplicateImport, \"reportDuplicateImport\" /* reportDuplicateImport */, localize_1.Localizer.Diagnostic.duplicateImport().format({ importName: importFromAs.name.value }), importFromAs.name);\n                        }\n                        else {\n                            symbolMap.set(importFromAs.name.value, importFromAs);\n                        }\n                    }\n                });\n            }\n            else if (importStatement.subnode) {\n                // Ignore duplicates if they're aliased.\n                if (!importStatement.subnode.alias) {\n                    const prevImport = importModuleMap.get(importStatement.moduleName);\n                    if (prevImport) {\n                        this._evaluator.addDiagnostic(this._fileInfo.diagnosticRuleSet.reportDuplicateImport, \"reportDuplicateImport\" /* reportDuplicateImport */, localize_1.Localizer.Diagnostic.duplicateImport().format({ importName: importStatement.moduleName }), importStatement.subnode);\n                    }\n                    else {\n                        importModuleMap.set(importStatement.moduleName, importStatement.subnode);\n                    }\n                }\n            }\n        });\n    }\n}\nexports.Checker = Checker;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/checker.ts?");

/***/ }),

/***/ "./src/analyzer/circularDependency.ts":
/*!********************************************!*\
  !*** ./src/analyzer/circularDependency.ts ***!
  \********************************************/
/*! flagged exports */
/*! export CircularDependency [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * circularDependency.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * A list of file paths that are part of a circular dependency\n * chain (i.e. a chain of imports). Since these are circular, there\n * no defined \"start\", but this module helps normalize the start\n * by picking the alphabetically-first module in the cycle.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CircularDependency = void 0;\nclass CircularDependency {\n    constructor() {\n        this._paths = [];\n    }\n    appendPath(path) {\n        this._paths.push(path);\n    }\n    getPaths() {\n        return this._paths;\n    }\n    normalizeOrder() {\n        // Find the path that is alphabetically first and reorder\n        // based on that.\n        let firstIndex = 0;\n        this._paths.forEach((path, index) => {\n            if (path < this._paths[firstIndex]) {\n                firstIndex = index;\n            }\n        });\n        if (firstIndex !== 0) {\n            this._paths = this._paths.slice(firstIndex).concat(this._paths.slice(0, firstIndex));\n        }\n    }\n    isEqual(circDependency) {\n        if (circDependency._paths.length !== this._paths.length) {\n            return false;\n        }\n        for (let i = 0; i < this._paths.length; i++) {\n            if (this._paths[i] !== circDependency._paths[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nexports.CircularDependency = CircularDependency;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/circularDependency.ts?");

/***/ }),

/***/ "./src/analyzer/codeFlow.ts":
/*!**********************************!*\
  !*** ./src/analyzer/codeFlow.ts ***!
  \**********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * codeFlow.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Data structures that track the code flow (or more accurately,\n * the inverse of code flow) starting with return statements and\n * working back to the entry. This allows us to work out the\n * types at each point of the code flow.\n *\n * This is largely based on the code flow engine in the\n * TypeScript compiler.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createKeyForReference = exports.isCodeFlowSupportedForReference = exports.getUniqueFlowNodeId = exports.FlowFlags = void 0;\nconst debug_1 = __webpack_require__(/*! ../common/debug */ \"./src/common/debug.ts\");\nvar FlowFlags;\n(function (FlowFlags) {\n    FlowFlags[FlowFlags[\"Unreachable\"] = 1] = \"Unreachable\";\n    FlowFlags[FlowFlags[\"Start\"] = 2] = \"Start\";\n    FlowFlags[FlowFlags[\"BranchLabel\"] = 4] = \"BranchLabel\";\n    FlowFlags[FlowFlags[\"LoopLabel\"] = 8] = \"LoopLabel\";\n    FlowFlags[FlowFlags[\"Assignment\"] = 16] = \"Assignment\";\n    FlowFlags[FlowFlags[\"Unbind\"] = 32] = \"Unbind\";\n    FlowFlags[FlowFlags[\"WildcardImport\"] = 64] = \"WildcardImport\";\n    FlowFlags[FlowFlags[\"TrueCondition\"] = 128] = \"TrueCondition\";\n    FlowFlags[FlowFlags[\"FalseCondition\"] = 512] = \"FalseCondition\";\n    FlowFlags[FlowFlags[\"Call\"] = 1024] = \"Call\";\n    FlowFlags[FlowFlags[\"PreFinallyGate\"] = 2048] = \"PreFinallyGate\";\n    FlowFlags[FlowFlags[\"PostFinally\"] = 4096] = \"PostFinally\";\n    FlowFlags[FlowFlags[\"AssignmentAlias\"] = 8192] = \"AssignmentAlias\";\n})(FlowFlags = exports.FlowFlags || (exports.FlowFlags = {}));\nlet _nextFlowNodeId = 1;\nfunction getUniqueFlowNodeId() {\n    return _nextFlowNodeId++;\n}\nexports.getUniqueFlowNodeId = getUniqueFlowNodeId;\nfunction isCodeFlowSupportedForReference(reference) {\n    if (reference.nodeType === 39 /* Name */) {\n        return true;\n    }\n    if (reference.nodeType === 36 /* MemberAccess */) {\n        return isCodeFlowSupportedForReference(reference.leftExpression);\n    }\n    return false;\n}\nexports.isCodeFlowSupportedForReference = isCodeFlowSupportedForReference;\nfunction createKeyForReference(reference) {\n    let key;\n    if (reference.nodeType === 39 /* Name */) {\n        key = reference.value;\n    }\n    else {\n        key = reference.memberName.value;\n        let leftNode = reference.leftExpression;\n        while (leftNode.nodeType === 36 /* MemberAccess */) {\n            key = leftNode.memberName.value + `.${key}`;\n            leftNode = leftNode.leftExpression;\n        }\n        debug_1.assert(leftNode.nodeType === 39 /* Name */);\n        key = leftNode.value + `.${key}`;\n    }\n    return key;\n}\nexports.createKeyForReference = createKeyForReference;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/codeFlow.ts?");

/***/ }),

/***/ "./src/analyzer/commentUtils.ts":
/*!**************************************!*\
  !*** ./src/analyzer/commentUtils.ts ***!
  \**************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getFileLevelDirectives [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * commentUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Utility functions that parse comments and extract commands\n * or other directives from them.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getFileLevelDirectives = void 0;\nconst configOptions_1 = __webpack_require__(/*! ../common/configOptions */ \"./src/common/configOptions.ts\");\nfunction getFileLevelDirectives(tokens, defaultRuleSet, useStrict) {\n    let ruleSet = configOptions_1.cloneDiagnosticRuleSet(defaultRuleSet);\n    if (useStrict) {\n        _applyStrictRules(ruleSet);\n    }\n    for (let i = 0; i < tokens.count; i++) {\n        const token = tokens.getItemAt(i);\n        if (token.comments) {\n            for (const comment of token.comments) {\n                const value = comment.value.trim();\n                ruleSet = _parsePyrightComment(value, ruleSet);\n            }\n        }\n    }\n    return ruleSet;\n}\nexports.getFileLevelDirectives = getFileLevelDirectives;\nfunction _applyStrictRules(ruleSet) {\n    const strictRuleSet = configOptions_1.getStrictDiagnosticRuleSet();\n    const boolRuleNames = configOptions_1.getBooleanDiagnosticRules();\n    const diagRuleNames = configOptions_1.getDiagLevelDiagnosticRules();\n    const skipRuleNames = configOptions_1.getStrictModeNotOverriddenRules();\n    // Enable the strict rules as appropriate.\n    for (const ruleName of boolRuleNames) {\n        if (skipRuleNames.find((r) => r === ruleName)) {\n            continue;\n        }\n        if (strictRuleSet[ruleName]) {\n            ruleSet[ruleName] = true;\n        }\n    }\n    for (const ruleName of diagRuleNames) {\n        if (skipRuleNames.find((r) => r === ruleName)) {\n            continue;\n        }\n        const strictValue = strictRuleSet[ruleName];\n        const prevValue = ruleSet[ruleName];\n        if (strictValue === 'error' ||\n            (strictValue === 'warning' && prevValue !== 'error') ||\n            (strictValue === 'information' && prevValue !== 'error' && prevValue !== 'warning')) {\n            ruleSet[ruleName] = strictValue;\n        }\n    }\n}\nfunction _parsePyrightComment(commentValue, ruleSet) {\n    // Is this a pyright or mspython-specific comment?\n    const validPrefixes = ['pyright:', 'mspython:'];\n    const prefix = validPrefixes.find((p) => commentValue.startsWith(p));\n    if (prefix) {\n        const operands = commentValue.substr(prefix.length).trim();\n        const operandList = operands.split(',').map((s) => s.trim());\n        // If it contains a \"strict\" operand, replace the existing\n        // diagnostic rules with their strict counterparts.\n        if (operandList.some((s) => s === 'strict')) {\n            _applyStrictRules(ruleSet);\n        }\n        for (const operand of operandList) {\n            ruleSet = _parsePyrightOperand(operand, ruleSet);\n        }\n    }\n    return ruleSet;\n}\nfunction _parsePyrightOperand(operand, ruleSet) {\n    const operandSplit = operand.split('=').map((s) => s.trim());\n    if (operandSplit.length !== 2) {\n        return ruleSet;\n    }\n    const ruleName = operandSplit[0];\n    const boolRules = configOptions_1.getBooleanDiagnosticRules();\n    const diagLevelRules = configOptions_1.getDiagLevelDiagnosticRules();\n    if (diagLevelRules.find((r) => r === ruleName)) {\n        const diagLevelValue = _parseDiagLevel(operandSplit[1]);\n        if (diagLevelValue !== undefined) {\n            ruleSet[ruleName] = diagLevelValue;\n        }\n    }\n    else if (boolRules.find((r) => r === ruleName)) {\n        const boolValue = _parseBoolSetting(operandSplit[1]);\n        if (boolValue !== undefined) {\n            ruleSet[ruleName] = boolValue;\n        }\n    }\n    return ruleSet;\n}\nfunction _parseDiagLevel(value) {\n    switch (value) {\n        case 'false':\n        case 'none':\n            return 'none';\n        case 'true':\n        case 'error':\n            return 'error';\n        case 'warning':\n            return 'warning';\n        case 'information':\n            return 'information';\n        default:\n            return undefined;\n    }\n}\nfunction _parseBoolSetting(value) {\n    if (value === 'false') {\n        return false;\n    }\n    else if (value === 'true') {\n        return true;\n    }\n    return undefined;\n}\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/commentUtils.ts?");

/***/ }),

/***/ "./src/analyzer/declarationUtils.ts":
/*!******************************************!*\
  !*** ./src/analyzer/declarationUtils.ts ***!
  \******************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export areDeclarationsSame [provided] [no usage info] [missing usage info prevents renaming] */
/*! export hasTypeForDeclaration [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isFinalVariableDeclaration [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isTypeAliasDeclaration [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * declarationUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Collection of static methods that operate on declarations.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isTypeAliasDeclaration = exports.isFinalVariableDeclaration = exports.areDeclarationsSame = exports.hasTypeForDeclaration = void 0;\nfunction hasTypeForDeclaration(declaration) {\n    switch (declaration.type) {\n        case 0 /* Intrinsic */:\n        case 4 /* Class */:\n        case 5 /* SpecialBuiltInClass */:\n        case 3 /* Function */:\n            return true;\n        case 2 /* Parameter */:\n            return !!declaration.node.typeAnnotation;\n        case 1 /* Variable */:\n            return !!declaration.typeAnnotationNode;\n        case 6 /* Alias */:\n            return false;\n    }\n}\nexports.hasTypeForDeclaration = hasTypeForDeclaration;\nfunction areDeclarationsSame(decl1, decl2) {\n    if (decl1.type !== decl2.type) {\n        return false;\n    }\n    if (decl1.path !== decl2.path) {\n        return false;\n    }\n    if (decl1.range.start.line !== decl2.range.start.line ||\n        decl1.range.start.character !== decl2.range.start.character) {\n        return false;\n    }\n    // Alias declarations refer to the entire import statement.\n    // We need to further differentiate.\n    if (decl1.type === 6 /* Alias */ && decl2.type === 6 /* Alias */) {\n        if (decl1.symbolName !== decl2.symbolName ||\n            decl1.firstNamePart !== decl2.firstNamePart ||\n            decl1.usesLocalName !== decl2.usesLocalName) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.areDeclarationsSame = areDeclarationsSame;\nfunction isFinalVariableDeclaration(decl) {\n    return decl.type === 1 /* Variable */ && !!decl.isFinal;\n}\nexports.isFinalVariableDeclaration = isFinalVariableDeclaration;\nfunction isTypeAliasDeclaration(decl) {\n    return decl.type === 1 /* Variable */ && !!decl.isTypeAlias;\n}\nexports.isTypeAliasDeclaration = isTypeAliasDeclaration;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/declarationUtils.ts?");

/***/ }),

/***/ "./src/analyzer/docStringToMarkdown.ts":
/*!*********************************************!*\
  !*** ./src/analyzer/docStringToMarkdown.ts ***!
  \*********************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export convertDocStringToMarkdown [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * docStringToMarkdown.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Python doc string to markdown converter.\n *\n * This does various things, including removing common indention, escaping\n * characters, handling code blocks, and more.\n *\n * This is a straight port of\n * https://github.com/microsoft/python-language-server/blob/master/src/LanguageServer/Impl/Documentation/DocstringConverter.cs\n *\n * The restructured npm library was evaluated, and while it worked well for\n * parsing valid input, it was going to be more difficult to handle invalid\n * RST input.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertDocStringToMarkdown = void 0;\nfunction convertDocStringToMarkdown(docString) {\n    return new DocStringConverter(docString).convert();\n}\nexports.convertDocStringToMarkdown = convertDocStringToMarkdown;\n// Regexes for one match\nconst LeadingSpaceCountRegEx = /\\S|$/;\nconst CrLfRegEx = /\\r?\\n/;\nconst NonWhitespaceRegEx = /\\S/;\nconst TildaHeaderRegex = /^\\s*~~~+$/;\nconst PlusHeaderRegex = /^\\s*\\+\\+\\++$/;\nconst LeadingAsteriskRegex = /^(\\s+\\* )(.*)$/;\nconst SpaceDotDotRegex = /^\\s*\\.\\. /;\nconst DirectiveLikeRegex = /^\\s*\\.\\.\\s+(\\w+)::\\s*(.*)$/;\nconst DoctestRegex = / *>>> /;\nconst DirectivesExtraNewlineRegex = /^\\s*:(param|arg|type|return|rtype|raise|except|var|ivar|cvar|copyright|license)/;\nconst PotentialHeaders = [\n    { exp: /^\\s*=+(\\s+=+)+$/, replacement: '=' },\n    { exp: /^\\s*-+(\\s+-+)+$/, replacement: '-' },\n    { exp: /^\\s*~+(\\s+-+)+$/, replacement: '~' },\n    { exp: /^\\s*\\++(\\s+\\++)+$/, replacement: '+' },\n];\n// Regexes for replace all\nconst WhitespaceRegex = /\\s/g;\nconst DoubleTickRegEx = /``/g;\nconst TabRegEx = /\\t/g;\nconst TildeRegEx = /~/g;\nconst PlusRegEx = /\\+/g;\nconst UnescapedMarkdownCharsRegex = /(?<!\\\\)([_*~[\\]])/g;\n// http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#literal-blocks\nconst LiteralBlockEmptyRegex = /^\\s*::$/;\nconst LiteralBlockReplacements = [\n    { exp: /\\s+::$/g, replacement: '' },\n    { exp: /(\\S)\\s*::$/g, replacement: '$1:' },\n    // http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#interpreted-text\n    { exp: /:[\\w_\\-+:.]+:`/g, replacement: '`' },\n    { exp: /`:[\\w_\\-+:.]+:/g, replacement: '`' },\n];\nclass DocStringConverter {\n    constructor(input) {\n        this._builder = '';\n        this._skipAppendEmptyLine = true;\n        this._insideInlineCode = false;\n        this._appendDirectiveBlock = false;\n        this._stateStack = [];\n        this._lineNum = 0;\n        this._blockIndent = 0;\n        this._state = this._parseText;\n        this._lines = _splitDocString(input);\n    }\n    convert() {\n        while (this._currentLineOrUndefined() !== undefined) {\n            const before = this._state;\n            const beforeLine = this._lineNum;\n            this._state();\n            // Parser must make progress; either the state or line number must change.\n            if (this._state === before && this._lineNum === beforeLine) {\n                break;\n            }\n        }\n        // Close out any outstanding code blocks.\n        if (this._state === this._parseBacktickBlock ||\n            this._state === this._parseDocTest ||\n            this._state === this._parseLiteralBlock) {\n            this._trimOutputAndAppendLine('```');\n        }\n        else if (this._insideInlineCode) {\n            this._trimOutputAndAppendLine('`', true);\n        }\n        return this._builder.trim();\n    }\n    _eatLine() {\n        this._lineNum++;\n    }\n    _currentLineOrUndefined() {\n        return this._lineNum < this._lines.length ? this._lines[this._lineNum] : undefined;\n    }\n    _currentLine() {\n        return this._currentLineOrUndefined() || '';\n    }\n    _currentIndent() {\n        return _countLeadingSpaces(this._currentLine());\n    }\n    _lineAt(i) {\n        return i < this._lines.length ? this._lines[i] : undefined;\n    }\n    _nextBlockIndent() {\n        return _countLeadingSpaces(this._lines.slice(this._lineNum + 1).find((v) => !_isUndefinedOrWhitespace(v)) || '');\n    }\n    _currentLineIsOutsideBlock() {\n        return this._currentIndent() < this._blockIndent;\n    }\n    _currentLineWithinBlock() {\n        return this._currentLine().substr(this._blockIndent);\n    }\n    _pushAndSetState(next) {\n        if (this._state === this._parseText) {\n            this._insideInlineCode = false;\n        }\n        this._stateStack.push(this._state);\n        this._state = next;\n    }\n    _popState() {\n        this._state = this._stateStack.splice(0, 1)[0];\n        if (this._state === this._parseText) {\n            // Terminate inline code when leaving a block.\n            this._insideInlineCode = false;\n        }\n    }\n    _parseText() {\n        if (_isUndefinedOrWhitespace(this._currentLineOrUndefined())) {\n            this._state = this._parseEmpty;\n            return;\n        }\n        if (this._beginBacktickBlock()) {\n            return;\n        }\n        if (this._beginLiteralBlock()) {\n            return;\n        }\n        if (this._beginDocTest()) {\n            return;\n        }\n        if (this._beginDirective()) {\n            return;\n        }\n        // TODO: Push into Google/Numpy style list parser.\n        this._appendTextLine(this._currentLine());\n        this._eatLine();\n    }\n    _appendTextLine(line) {\n        line = this._preprocessTextLine(line);\n        // Attempt to put directives lines into their own paragraphs.\n        // This should be removed once proper list-like parsing is written.\n        if (!this._insideInlineCode && DirectivesExtraNewlineRegex.test(line)) {\n            this._appendLine();\n        }\n        const parts = line.split('`');\n        for (let i = 0; i < parts.length; i++) {\n            let part = parts[i];\n            if (i > 0) {\n                this._insideInlineCode = !this._insideInlineCode;\n                this._append('`');\n            }\n            if (this._insideInlineCode) {\n                this._append(part);\n                continue;\n            }\n            if (i === 0) {\n                // Only one part, and not inside code, so check header cases.\n                if (parts.length === 1) {\n                    // Handle weird separator lines which contain random spaces.\n                    for (const expReplacement of PotentialHeaders) {\n                        if (expReplacement.exp.test(part)) {\n                            part = part.replace(WhitespaceRegex, expReplacement.replacement);\n                            break;\n                        }\n                    }\n                    // Replace ReST style ~~~ header to prevent it being interpreted as a code block\n                    // (an alternative in Markdown to triple backtick blocks).\n                    if (TildaHeaderRegex.test(part)) {\n                        this._append(part.replace(TildeRegEx, '-'));\n                        continue;\n                    }\n                    // Replace +++ heading too.\n                    // TODO: Handle the rest of these, and the precedence order (which depends on the\n                    // order heading lines are seen, not what the line contains).\n                    // http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#sections\n                    if (PlusHeaderRegex.test(part)) {\n                        this._append(part.replace(PlusRegEx, '-'));\n                        continue;\n                    }\n                }\n                // Don't strip away asterisk-based bullet point lists.\n                //\n                // TODO: Replace this with real list parsing. This may have\n                // false positives and cause random italics when the ReST list\n                // doesn't match Markdown's specification.\n                const match = LeadingAsteriskRegex.exec(part);\n                if (match !== null && match.length === 3) {\n                    this._append(match[1]);\n                    part = match[2];\n                }\n            }\n            // TODO: Find a better way to handle this; the below breaks escaped\n            // characters which appear at the beginning or end of a line.\n            // Applying this only when i == 0 or i == parts.Length-1 may work.\n            // http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#hyperlink-references\n            // part = Regex.Replace(part, @\"^_+\", \"\");\n            // http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-internal-targets\n            // part = Regex.Replace(part, @\"_+$\", \"\");\n            // TODO: Strip footnote/citation references.\n            // Escape _, *, and ~, but ignore things like \":param \\*\\*kwargs:\".\n            part = part.replace(UnescapedMarkdownCharsRegex, '\\\\$1');\n            this._append(part);\n        }\n        // Go straight to the builder so that _appendLine doesn't think\n        // we're actually trying to insert an extra blank line and skip\n        // future whitespace. Empty line deduplication is already handled\n        // because Append is used above.\n        this._builder += '\\n';\n    }\n    _preprocessTextLine(line) {\n        // http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#literal-blocks\n        if (LiteralBlockEmptyRegex.test(line)) {\n            return '';\n        }\n        LiteralBlockReplacements.forEach((item) => (line = line.replace(item.exp, item.replacement)));\n        line = line.replace(DoubleTickRegEx, '`');\n        return line;\n    }\n    _parseEmpty() {\n        if (_isUndefinedOrWhitespace(this._currentLineOrUndefined())) {\n            this._appendLine();\n            this._eatLine();\n            return;\n        }\n        this._state = this._parseText;\n    }\n    _beginMinIndentCodeBlock(state) {\n        this._appendLine('```');\n        this._pushAndSetState(state);\n        this._blockIndent = this._currentIndent();\n    }\n    _beginBacktickBlock() {\n        if (this._currentLine().startsWith('```')) {\n            this._appendLine(this._currentLine());\n            this._pushAndSetState(this._parseBacktickBlock);\n            this._eatLine();\n            return true;\n        }\n        return false;\n    }\n    _parseBacktickBlock() {\n        if (this._currentLine().startsWith('```')) {\n            this._appendLine('```');\n            this._appendLine();\n            this._popState();\n        }\n        else {\n            this._appendLine(this._currentLine());\n        }\n        this._eatLine();\n    }\n    _beginDocTest() {\n        if (!DoctestRegex.test(this._currentLine())) {\n            return false;\n        }\n        this._beginMinIndentCodeBlock(this._parseDocTest);\n        this._appendLine(this._currentLineWithinBlock());\n        this._eatLine();\n        return true;\n    }\n    _parseDocTest() {\n        if (this._currentLineIsOutsideBlock() || _isUndefinedOrWhitespace(this._currentLine())) {\n            this._trimOutputAndAppendLine('```');\n            this._appendLine();\n            this._popState();\n            return;\n        }\n        this._appendLine(this._currentLineWithinBlock());\n        this._eatLine();\n    }\n    _beginLiteralBlock() {\n        // The previous line must be empty.\n        const prev = this._lineAt(this._lineNum - 1);\n        if (prev === undefined) {\n            return false;\n        }\n        else if (!_isUndefinedOrWhitespace(prev)) {\n            return false;\n        }\n        // Find the previous paragraph and check that it ends with ::\n        let i = this._lineNum - 2;\n        for (; i >= 0; i--) {\n            const line = this._lineAt(i);\n            if (_isUndefinedOrWhitespace(line)) {\n                continue;\n            }\n            // Safe to ignore whitespace after the :: because all lines have been trimRight'd.\n            if (line.endsWith('::')) {\n                break;\n            }\n            return false;\n        }\n        if (i < 0) {\n            return false;\n        }\n        // Special case: allow one-liners at the same indent level.\n        if (this._currentIndent() === 0) {\n            this._appendLine('```');\n            this._pushAndSetState(this._parseLiteralBlockSingleLine);\n            return true;\n        }\n        this._beginMinIndentCodeBlock(this._parseLiteralBlock);\n        return true;\n    }\n    _parseLiteralBlock() {\n        // Slightly different than doctest, wait until the first non-empty unindented line to exit.\n        if (_isUndefinedOrWhitespace(this._currentLineOrUndefined())) {\n            this._appendLine();\n            this._eatLine();\n            return;\n        }\n        if (this._currentLineIsOutsideBlock()) {\n            this._trimOutputAndAppendLine('```');\n            this._appendLine();\n            this._popState();\n            return;\n        }\n        this._appendLine(this._currentLineWithinBlock());\n        this._eatLine();\n    }\n    _parseLiteralBlockSingleLine() {\n        this._appendLine(this._currentLine());\n        this._appendLine('```');\n        this._appendLine();\n        this._popState();\n        this._eatLine();\n    }\n    _beginDirective() {\n        if (!SpaceDotDotRegex.test(this._currentLine())) {\n            return false;\n        }\n        this._pushAndSetState(this._parseDirective);\n        this._blockIndent = this._nextBlockIndent();\n        this._appendDirectiveBlock = false;\n        return true;\n    }\n    _parseDirective() {\n        // http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#directives\n        const match = DirectiveLikeRegex.exec(this._currentLine());\n        if (match !== null && match.length === 3) {\n            const directiveType = match[1];\n            const directive = match[2];\n            if (directiveType === 'class') {\n                this._appendDirectiveBlock = true;\n                this._appendLine();\n                this._appendLine('```');\n                this._appendLine(directive);\n                this._appendLine('```');\n                this._appendLine();\n            }\n        }\n        if (this._blockIndent === 0) {\n            // This is a one-liner directive, so pop back.\n            this._popState();\n        }\n        else {\n            this._state = this._parseDirectiveBlock;\n        }\n        this._eatLine();\n    }\n    _parseDirectiveBlock() {\n        if (!_isUndefinedOrWhitespace(this._currentLineOrUndefined()) && this._currentLineIsOutsideBlock()) {\n            this._popState();\n            return;\n        }\n        if (this._appendDirectiveBlock) {\n            // This is a bit of a hack. This just trims the text and appends it\n            // like top-level text, rather than doing actual indent-based recursion.\n            this._appendTextLine(this._currentLine().trimLeft());\n        }\n        this._eatLine();\n    }\n    _appendLine(line) {\n        if (!_isUndefinedOrWhitespace(line)) {\n            this._builder += line + '\\n';\n            this._skipAppendEmptyLine = false;\n        }\n        else if (!this._skipAppendEmptyLine) {\n            this._builder += '\\n';\n            this._skipAppendEmptyLine = true;\n        }\n    }\n    _append(text) {\n        this._builder += text;\n        this._skipAppendEmptyLine = false;\n    }\n    _trimOutputAndAppendLine(line, noNewLine = false) {\n        this._builder = this._builder.trimRight();\n        this._skipAppendEmptyLine = false;\n        if (!noNewLine) {\n            this._appendLine();\n        }\n        this._appendLine(line);\n    }\n}\nfunction _splitDocString(docstring) {\n    // As done by inspect.cleandoc.\n    docstring = docstring.replace(TabRegEx, ' '.repeat(8));\n    let lines = docstring.split(CrLfRegEx).map((v) => v.trimRight());\n    if (lines.length > 0) {\n        let first = lines[0].trimLeft();\n        if (first === '') {\n            first = undefined;\n        }\n        else {\n            lines.splice(0, 1);\n        }\n        lines = _stripLeadingWhitespace(lines);\n        if (first !== undefined) {\n            lines.splice(0, 0, first);\n        }\n    }\n    return lines;\n}\nfunction _stripLeadingWhitespace(lines, trim) {\n    const amount = trim === undefined ? _largestTrim(lines) : trim;\n    return lines.map((line) => (amount > line.length ? '' : line.substr(amount)));\n}\nfunction _largestTrim(lines) {\n    const nonEmptyLines = lines.filter((s) => !_isUndefinedOrWhitespace(s));\n    const counts = nonEmptyLines.map(_countLeadingSpaces);\n    const largest = counts.length > 0 ? Math.min(...counts) : 0;\n    return largest;\n}\nfunction _countLeadingSpaces(s) {\n    return s.search(LeadingSpaceCountRegEx);\n}\nfunction _isUndefinedOrWhitespace(s) {\n    return s === undefined || !NonWhitespaceRegEx.test(s);\n}\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/docStringToMarkdown.ts?");

/***/ }),

/***/ "./src/analyzer/docStringUtils.ts":
/*!****************************************!*\
  !*** ./src/analyzer/docStringUtils.ts ***!
  \****************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export decodeDocString [provided] [no usage info] [missing usage info prevents renaming] */
/*! export extractParameterDocumentation [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * docStringUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Static methods that format and parse doc strings based on\n * the rules specified in PEP 257\n * (https://www.python.org/dev/peps/pep-0257/).\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extractParameterDocumentation = exports.decodeDocString = void 0;\nfunction decodeDocString(rawString) {\n    // Remove carriage returns and replace tabs.\n    const unescaped = rawString.replace(/\\r/g, '').replace(/\\t/g, '        ');\n    // Split into lines.\n    const lines = unescaped.split('\\n');\n    // Determine the max indent amount.\n    let leftSpacesToRemove = Number.MAX_VALUE;\n    lines.forEach((line, index) => {\n        // First line is special.\n        if (lines.length <= 1 || index > 0) {\n            const trimmed = line.trimLeft();\n            if (trimmed) {\n                leftSpacesToRemove = Math.min(leftSpacesToRemove, line.length - trimmed.length);\n            }\n        }\n    });\n    // If there was only\n    if (leftSpacesToRemove >= Number.MAX_VALUE) {\n        leftSpacesToRemove = 0;\n    }\n    // Trim the lines.\n    const trimmedLines = [];\n    lines.forEach((line, index) => {\n        if (index === 0) {\n            trimmedLines.push(line.trimRight());\n        }\n        else {\n            trimmedLines.push(line.substr(leftSpacesToRemove).trimRight());\n        }\n    });\n    // Strip off leading and trailing blank lines.\n    while (trimmedLines.length > 0 && trimmedLines[0].length === 0) {\n        trimmedLines.shift();\n    }\n    while (trimmedLines.length > 0 && trimmedLines[trimmedLines.length - 1].length === 0) {\n        trimmedLines.pop();\n    }\n    return trimmedLines.join('\\n');\n}\nexports.decodeDocString = decodeDocString;\nfunction extractParameterDocumentation(functionDocString, paramName) {\n    if (!functionDocString || !paramName) {\n        return undefined;\n    }\n    // Python doesn't have a single standard for param documentation. There are three\n    // popular styles.\n    //\n    // 1. Epytext:\n    //      @param param1: description\n    // 2. reST:\n    //      :param param1: description\n    // 3. Google (variant 1):\n    //      Args:\n    //          param1: description\n    // 4. Google (variant 2):\n    //      Args:\n    //          param1 (type): description\n    const docStringLines = functionDocString.split('\\n');\n    for (const line of docStringLines) {\n        const trimmedLine = line.trim();\n        // Check for Epytext\n        let paramOffset = trimmedLine.indexOf('@param ' + paramName);\n        if (paramOffset >= 0) {\n            return trimmedLine.substr(paramOffset + 7);\n        }\n        // Check for reST format\n        paramOffset = trimmedLine.indexOf(':param ' + paramName);\n        if (paramOffset >= 0) {\n            return trimmedLine.substr(paramOffset + 7);\n        }\n        // Check for Google (variant 1) format\n        paramOffset = trimmedLine.indexOf(paramName + ': ');\n        if (paramOffset >= 0) {\n            return trimmedLine.substr(paramOffset);\n        }\n        // Check for Google (variant 1) format\n        paramOffset = trimmedLine.indexOf(paramName + ' (');\n        if (paramOffset >= 0) {\n            return trimmedLine.substr(paramOffset);\n        }\n    }\n    return undefined;\n}\nexports.extractParameterDocumentation = extractParameterDocumentation;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/docStringUtils.ts?");

/***/ }),

/***/ "./src/analyzer/importResolver.ts":
/*!****************************************!*\
  !*** ./src/analyzer/importResolver.ts ***!
  \****************************************/
/*! flagged exports */
/*! export ImportResolver [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * importResolver.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Provides the logic for resolving imports according to the\n * runtime rules of Python.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImportResolver = void 0;\nconst pathUtils_1 = __webpack_require__(/*! ../common/pathUtils */ \"./src/common/pathUtils.ts\");\nconst pythonVersion_1 = __webpack_require__(/*! ../common/pythonVersion */ \"./src/common/pythonVersion.ts\");\nconst stringUtils_1 = __webpack_require__(/*! ../common/stringUtils */ \"./src/common/stringUtils.ts\");\nconst StringUtils = __webpack_require__(/*! ../common/stringUtils */ \"./src/common/stringUtils.ts\");\nconst PythonPathUtils = __webpack_require__(/*! ./pythonPathUtils */ \"./src/analyzer/pythonPathUtils.ts\");\nconst symbolNameUtils_1 = __webpack_require__(/*! ./symbolNameUtils */ \"./src/analyzer/symbolNameUtils.ts\");\nconst supportedNativeLibExtensions = ['.pyd', '.so', '.dylib'];\nconst supportedFileExtensions = ['.py', '.pyi', ...supportedNativeLibExtensions];\nconst stubsSuffix = '-stubs';\nclass ImportResolver {\n    constructor(fs, configOptions) {\n        this._cachedPythonSearchPaths = new Map();\n        this._cachedImportResults = new Map();\n        this.fileSystem = fs;\n        this._configOptions = configOptions;\n    }\n    invalidateCache() {\n        this._cachedPythonSearchPaths = new Map();\n        this._cachedImportResults = new Map();\n    }\n    // Resolves the import and returns the path if it exists, otherwise\n    // returns undefined.\n    resolveImport(sourceFilePath, execEnv, moduleDescriptor) {\n        const importName = this._formatImportName(moduleDescriptor);\n        const importFailureInfo = [];\n        const notFoundResult = {\n            importName,\n            isRelative: false,\n            isImportFound: false,\n            isNamespacePackage: false,\n            importFailureInfo,\n            resolvedPaths: [],\n            importType: 2 /* Local */,\n            isStubFile: false,\n            isNativeLib: false,\n            implicitImports: [],\n            nonStubImportResult: undefined,\n        };\n        // Is it a relative import?\n        if (moduleDescriptor.leadingDots > 0) {\n            const relativeImport = this._resolveRelativeImport(sourceFilePath, moduleDescriptor, importName, importFailureInfo);\n            if (relativeImport) {\n                relativeImport.isRelative = true;\n                return relativeImport;\n            }\n        }\n        else {\n            // Is it already cached?\n            const cachedResults = this._lookUpResultsInCache(execEnv, importName, moduleDescriptor.importedSymbols);\n            if (cachedResults) {\n                return cachedResults;\n            }\n            const bestImport = this._resolveBestAbsoluteImport(sourceFilePath, execEnv, moduleDescriptor, true);\n            if (bestImport) {\n                if (bestImport.isStubFile) {\n                    bestImport.nonStubImportResult =\n                        this._resolveBestAbsoluteImport(sourceFilePath, execEnv, moduleDescriptor, false) ||\n                            notFoundResult;\n                }\n                return this._addResultsToCache(execEnv, importName, bestImport, moduleDescriptor.importedSymbols);\n            }\n        }\n        return this._addResultsToCache(execEnv, importName, notFoundResult, undefined);\n    }\n    _resolveBestAbsoluteImport(sourceFilePath, execEnv, moduleDescriptor, allowPyi) {\n        const importName = this._formatImportName(moduleDescriptor);\n        const importFailureInfo = [];\n        // First check for a stdlib typeshed file.\n        if (allowPyi && moduleDescriptor.nameParts.length > 0) {\n            const builtInImport = this._findTypeshedPath(execEnv, moduleDescriptor, importName, \n            /* isStdLib */ true, importFailureInfo);\n            if (builtInImport) {\n                builtInImport.isTypeshedFile = true;\n                return builtInImport;\n            }\n        }\n        if (allowPyi) {\n            // Check for a local stub file using stubPath.\n            if (this._configOptions.stubPath) {\n                importFailureInfo.push(`Looking in stubPath '${this._configOptions.stubPath}'`);\n                const typingsImport = this.resolveAbsoluteImport(this._configOptions.stubPath, moduleDescriptor, importName, importFailureInfo);\n                if (typingsImport && typingsImport.isImportFound) {\n                    // We will treat typings files as \"local\" rather than \"third party\".\n                    typingsImport.importType = 2 /* Local */;\n                    typingsImport.isLocalTypingsFile = true;\n                    return typingsImport;\n                }\n            }\n        }\n        let bestResultSoFar;\n        // Look for it in the root directory of the execution environment.\n        importFailureInfo.push(`Looking in root directory of execution environment ` + `'${execEnv.root}'`);\n        let localImport = this.resolveAbsoluteImport(execEnv.root, moduleDescriptor, importName, importFailureInfo, undefined, undefined, undefined, allowPyi);\n        if (localImport && localImport.isImportFound && !localImport.isNamespacePackage) {\n            return localImport;\n        }\n        bestResultSoFar = localImport;\n        for (const extraPath of execEnv.extraPaths) {\n            importFailureInfo.push(`Looking in extraPath '${extraPath}'`);\n            localImport = this.resolveAbsoluteImport(extraPath, moduleDescriptor, importName, importFailureInfo, undefined, undefined, undefined, allowPyi);\n            if (localImport && localImport.isImportFound) {\n                return localImport;\n            }\n            if (localImport &&\n                (bestResultSoFar === undefined ||\n                    (!bestResultSoFar.isImportFound && localImport.isImportFound) ||\n                    (bestResultSoFar.isNamespacePackage && !localImport.isNamespacePackage) ||\n                    localImport.resolvedPaths.length > bestResultSoFar.resolvedPaths.length)) {\n                bestResultSoFar = localImport;\n            }\n        }\n        // Look for the import in the list of third-party packages.\n        const pythonSearchPaths = this._getPythonSearchPaths(execEnv, importFailureInfo);\n        if (pythonSearchPaths.length > 0) {\n            for (const searchPath of pythonSearchPaths) {\n                // Allow partial resolution because some third-party packages\n                // use tricks to populate their package namespaces.\n                importFailureInfo.push(`Looking in python search path '${searchPath}'`);\n                const thirdPartyImport = this.resolveAbsoluteImport(searchPath, moduleDescriptor, importName, importFailureInfo, \n                /* allowPartial */ true, \n                /* allowNativeLib */ true, \n                /* allowStubPackages */ true, allowPyi);\n                if (thirdPartyImport) {\n                    thirdPartyImport.importType = 1 /* ThirdParty */;\n                    if (thirdPartyImport.isImportFound && thirdPartyImport.isStubFile) {\n                        return thirdPartyImport;\n                    }\n                    // We did not find it, or we did and it's not from a\n                    // stub, so give chance for resolveImportEx to find\n                    // one from a stub.\n                    if (bestResultSoFar === undefined ||\n                        (!bestResultSoFar.isImportFound && thirdPartyImport.isImportFound) ||\n                        (bestResultSoFar.isNamespacePackage &&\n                            thirdPartyImport.isImportFound &&\n                            !thirdPartyImport.isNamespacePackage) ||\n                        (thirdPartyImport.isImportFound &&\n                            thirdPartyImport.resolvedPaths.length > bestResultSoFar.resolvedPaths.length)) {\n                        bestResultSoFar = thirdPartyImport;\n                    }\n                }\n            }\n        }\n        else {\n            importFailureInfo.push('No python interpreter search path');\n        }\n        const extraResults = this.resolveImportEx(sourceFilePath, execEnv, moduleDescriptor, importName, importFailureInfo, allowPyi);\n        if (extraResults !== undefined) {\n            return extraResults;\n        }\n        if (allowPyi) {\n            // Check for a third-party typeshed file.\n            importFailureInfo.push(`Looking for typeshed path`);\n            const typeshedImport = this._findTypeshedPath(execEnv, moduleDescriptor, importName, \n            /* isStdLib */ false, importFailureInfo);\n            if (typeshedImport) {\n                typeshedImport.isTypeshedFile = true;\n                return typeshedImport;\n            }\n        }\n        // We weren't able to find an exact match, so return the best\n        // partial match.\n        return bestResultSoFar;\n    }\n    // Intended to be overridden by subclasses to provide additional stub\n    // resolving capabilities. Return undefined if no stubs were found for\n    // this import.\n    resolveImportEx(sourceFilePath, execEnv, moduleDescriptor, importName, importFailureInfo = [], allowPyi = true) {\n        return undefined;\n    }\n    getCompletionSuggestions(sourceFilePath, execEnv, moduleDescriptor, similarityLimit) {\n        const importFailureInfo = [];\n        const suggestions = [];\n        // Is it a relative import?\n        if (moduleDescriptor.leadingDots > 0) {\n            this._getCompletionSuggestionsRelative(sourceFilePath, moduleDescriptor, suggestions, similarityLimit);\n        }\n        else {\n            // First check for a typeshed file.\n            if (moduleDescriptor.nameParts.length > 0) {\n                this._getCompletionSuggestionsTypeshedPath(execEnv, moduleDescriptor, true, suggestions, similarityLimit);\n            }\n            // Look for it in the root directory of the execution environment.\n            this._getCompletionSuggestionsAbsolute(execEnv.root, moduleDescriptor, suggestions, similarityLimit);\n            for (const extraPath of execEnv.extraPaths) {\n                this._getCompletionSuggestionsAbsolute(extraPath, moduleDescriptor, suggestions, similarityLimit);\n            }\n            // Check for a typings file.\n            if (this._configOptions.stubPath) {\n                this._getCompletionSuggestionsAbsolute(this._configOptions.stubPath, moduleDescriptor, suggestions, similarityLimit);\n            }\n            // Check for a typeshed file.\n            this._getCompletionSuggestionsTypeshedPath(execEnv, moduleDescriptor, false, suggestions, similarityLimit);\n            // Look for the import in the list of third-party packages.\n            const pythonSearchPaths = this._getPythonSearchPaths(execEnv, importFailureInfo);\n            for (const searchPath of pythonSearchPaths) {\n                this._getCompletionSuggestionsAbsolute(searchPath, moduleDescriptor, suggestions, similarityLimit);\n            }\n        }\n        return suggestions;\n    }\n    // Returns the implementation file(s) for the given stub file.\n    getSourceFilesFromStub(stubFilePath, execEnv) {\n        const sourceFilePaths = [];\n        // When ImportResolver resolves an import to a stub file, a second resolve is done\n        // ignoring stub files, which gives us an approximation of where the implementation\n        // for that stub is located.\n        this._cachedImportResults.forEach((map, env) => {\n            map.forEach((result, importName) => {\n                if (result.isStubFile && result.isImportFound && result.nonStubImportResult) {\n                    if (result.resolvedPaths.some((f) => f === stubFilePath)) {\n                        if (result.nonStubImportResult.isImportFound) {\n                            const nonEmptyPaths = result.nonStubImportResult.resolvedPaths.filter((p) => p.endsWith('.py'));\n                            sourceFilePaths.push(...nonEmptyPaths);\n                        }\n                    }\n                }\n            });\n        });\n        // We haven't seen an import of that stub, attempt to find the source\n        // in some other ways.\n        if (sourceFilePaths.length === 0) {\n            // Simple case where the stub and source files are next to each other.\n            const sourceFilePath = pathUtils_1.changeAnyExtension(stubFilePath, '.py');\n            if (this.fileSystem.existsSync(sourceFilePath)) {\n                sourceFilePaths.push(sourceFilePath);\n            }\n        }\n        if (sourceFilePaths.length === 0) {\n            // The stub and the source file may have the same name, but be located\n            // in different folder hierarchies.\n            // Example:\n            // <stubPath>\\package\\module.pyi\n            // <site-packages>\\package\\module.py\n            // We get the relative path(s) of the stub to its import root(s),\n            // in theory there can be more than one, then look for source\n            // files in all the import roots using the same relative path(s).\n            const importRootPaths = this.getImportRoots(execEnv, /* useTypeshedVersionedFolders */ true);\n            const relativeStubPaths = [];\n            for (const importRootPath of importRootPaths) {\n                if (pathUtils_1.containsPath(importRootPath, stubFilePath, true)) {\n                    const parts = pathUtils_1.getRelativePathComponentsFromDirectory(importRootPath, stubFilePath, true);\n                    // Note that relative paths have an empty parts[0]\n                    if (parts.length > 1) {\n                        // Handle the case where the symbol was resolved to a stubs package\n                        // rather than the real package. We'll strip off the \"-stubs\" suffix\n                        // in this case.\n                        if (parts[1].endsWith(stubsSuffix)) {\n                            parts[1] = parts[1].substr(0, parts[1].length - stubsSuffix.length);\n                        }\n                        const relativeStubPath = pathUtils_1.combinePathComponents(parts);\n                        if (relativeStubPath) {\n                            relativeStubPaths.push(relativeStubPath);\n                        }\n                    }\n                }\n            }\n            for (const relativeStubPath of relativeStubPaths) {\n                for (const importRootPath of importRootPaths) {\n                    const absoluteStubPath = pathUtils_1.resolvePaths(importRootPath, relativeStubPath);\n                    let absoluteSourcePath = pathUtils_1.changeAnyExtension(absoluteStubPath, '.py');\n                    if (this.fileSystem.existsSync(absoluteSourcePath)) {\n                        sourceFilePaths.push(absoluteSourcePath);\n                    }\n                    else {\n                        const filePathWithoutExtension = pathUtils_1.stripFileExtension(absoluteSourcePath);\n                        if (filePathWithoutExtension.endsWith('__init__')) {\n                            // Did not match: <root>/package/__init__.py\n                            // Try equivalent: <root>/package.py\n                            absoluteSourcePath =\n                                filePathWithoutExtension.substr(0, filePathWithoutExtension.length - 9) + '.py';\n                            if (this.fileSystem.existsSync(absoluteSourcePath)) {\n                                sourceFilePaths.push(absoluteSourcePath);\n                            }\n                        }\n                        else {\n                            // Did not match: <root>/package.py\n                            // Try equivalent: <root>/package/__init__.py\n                            absoluteSourcePath = pathUtils_1.combinePaths(filePathWithoutExtension, '__init__.py');\n                            if (this.fileSystem.existsSync(absoluteSourcePath)) {\n                                sourceFilePaths.push(absoluteSourcePath);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return sourceFilePaths;\n    }\n    // Returns the module name (of the form X.Y.Z) that needs to be imported\n    // from the current context to access the module with the specified file path.\n    // In a sense, it's performing the inverse of resolveImport.\n    getModuleNameForImport(filePath, execEnv) {\n        let moduleName;\n        let importType = 0 /* BuiltIn */;\n        let isLocalTypingsFile = false;\n        const importFailureInfo = [];\n        // Is this a stdlib typeshed path?\n        const stdLibTypeshedPath = this._getTypeshedPath(true, execEnv, importFailureInfo);\n        if (stdLibTypeshedPath) {\n            moduleName = this._getModuleNameFromPath(stdLibTypeshedPath, filePath, true);\n            if (moduleName) {\n                return { moduleName, importType, isLocalTypingsFile };\n            }\n        }\n        // Look for it in the root directory of the execution environment.\n        moduleName = this._getModuleNameFromPath(execEnv.root, filePath);\n        for (const extraPath of execEnv.extraPaths) {\n            const candidateModuleName = this._getModuleNameFromPath(extraPath, filePath);\n            // Does this candidate look better than the previous best module name?\n            // We'll always try to use the shortest version.\n            if (!moduleName || (candidateModuleName && candidateModuleName.length < moduleName.length)) {\n                moduleName = candidateModuleName;\n                importType = 2 /* Local */;\n            }\n        }\n        // Check for a typings file.\n        if (this._configOptions.stubPath) {\n            const candidateModuleName = this._getModuleNameFromPath(this._configOptions.stubPath, filePath);\n            // Does this candidate look better than the previous best module name?\n            // We'll always try to use the shortest version.\n            if (!moduleName || (candidateModuleName && candidateModuleName.length < moduleName.length)) {\n                moduleName = candidateModuleName;\n                // Treat the typings path as a local import so errors are reported for it.\n                importType = 2 /* Local */;\n                isLocalTypingsFile = true;\n            }\n        }\n        // Check for a typeshed file.\n        const thirdPartyTypeshedPath = this._getTypeshedPath(false, execEnv, importFailureInfo);\n        if (thirdPartyTypeshedPath) {\n            const candidateModuleName = this._getModuleNameFromPath(thirdPartyTypeshedPath, filePath, true);\n            // Does this candidate look better than the previous best module name?\n            // We'll always try to use the shortest version.\n            if (!moduleName || (candidateModuleName && candidateModuleName.length < moduleName.length)) {\n                moduleName = candidateModuleName;\n                importType = 1 /* ThirdParty */;\n            }\n        }\n        // Look for the import in the list of third-party packages.\n        const pythonSearchPaths = this._getPythonSearchPaths(execEnv, importFailureInfo);\n        for (const searchPath of pythonSearchPaths) {\n            const candidateModuleName = this._getModuleNameFromPath(searchPath, filePath);\n            // Does this candidate look better than the previous best module name?\n            // We'll always try to use the shortest version.\n            if (!moduleName || (candidateModuleName && candidateModuleName.length < moduleName.length)) {\n                moduleName = candidateModuleName;\n                importType = 1 /* ThirdParty */;\n            }\n        }\n        if (moduleName) {\n            return { moduleName, importType, isLocalTypingsFile };\n        }\n        // We didn't find any module name.\n        return { moduleName: '', importType: 2 /* Local */, isLocalTypingsFile };\n    }\n    getImportRoots(execEnv, useTypeshedVersionedFolders) {\n        const importFailureInfo = [];\n        const roots = [];\n        const pythonVersion = execEnv.pythonVersion;\n        const minorVersion = pythonVersion & 0xff;\n        const versionFolders = ['2and3', '3'];\n        if (minorVersion > 0) {\n            versionFolders.push(pythonVersion_1.versionToString(0x300 + minorVersion));\n        }\n        const stdTypeshed = this._getTypeshedPath(true, execEnv, importFailureInfo);\n        if (stdTypeshed) {\n            if (useTypeshedVersionedFolders) {\n                roots.push(...versionFolders.map((vf) => pathUtils_1.combinePaths(stdTypeshed, vf)));\n            }\n            else {\n                roots.push(stdTypeshed);\n            }\n        }\n        roots.push(execEnv.root);\n        roots.push(...execEnv.extraPaths);\n        if (this._configOptions.stubPath) {\n            roots.push(this._configOptions.stubPath);\n        }\n        const typeshedPath = this._getTypeshedPath(false, execEnv, importFailureInfo);\n        if (typeshedPath) {\n            if (useTypeshedVersionedFolders) {\n                roots.push(...versionFolders.map((vf) => pathUtils_1.combinePaths(typeshedPath, vf)));\n            }\n            else {\n                roots.push(typeshedPath);\n            }\n        }\n        const pythonSearchPaths = this._getPythonSearchPaths(execEnv, importFailureInfo);\n        if (pythonSearchPaths.length > 0) {\n            roots.push(...pythonSearchPaths);\n        }\n        return roots;\n    }\n    _lookUpResultsInCache(execEnv, importName, importedSymbols) {\n        const cacheForExecEnv = this._cachedImportResults.get(execEnv.root);\n        if (!cacheForExecEnv) {\n            return undefined;\n        }\n        const cachedEntry = cacheForExecEnv.get(importName);\n        if (!cachedEntry) {\n            return undefined;\n        }\n        return this._filterImplicitImports(cachedEntry, importedSymbols);\n    }\n    _addResultsToCache(execEnv, importName, importResult, importedSymbols) {\n        let cacheForExecEnv = this._cachedImportResults.get(execEnv.root);\n        if (!cacheForExecEnv) {\n            cacheForExecEnv = new Map();\n            this._cachedImportResults.set(execEnv.root, cacheForExecEnv);\n        }\n        cacheForExecEnv.set(importName, importResult);\n        return this._filterImplicitImports(importResult, importedSymbols);\n    }\n    _getModuleNameFromPath(containerPath, filePath, stripTopContainerDir = false) {\n        containerPath = pathUtils_1.ensureTrailingDirectorySeparator(containerPath);\n        let filePathWithoutExtension = pathUtils_1.stripFileExtension(filePath);\n        if (!filePathWithoutExtension.startsWith(containerPath)) {\n            return undefined;\n        }\n        // Strip off the '/__init__' if it's present.\n        if (filePathWithoutExtension.endsWith('__init__')) {\n            filePathWithoutExtension = filePathWithoutExtension.substr(0, filePathWithoutExtension.length - 9);\n        }\n        const relativeFilePath = filePathWithoutExtension.substr(containerPath.length);\n        const parts = pathUtils_1.getPathComponents(relativeFilePath);\n        parts.shift();\n        if (stripTopContainerDir) {\n            if (parts.length === 0) {\n                return undefined;\n            }\n            parts.shift();\n        }\n        if (parts.length === 0) {\n            return undefined;\n        }\n        // Handle the case where the symbol was resolved to a stubs package\n        // rather than the real package. We'll strip off the \"-stubs\" suffix\n        // in this case.\n        if (parts[0].endsWith(stubsSuffix)) {\n            parts[0] = parts[0].substr(0, parts[0].length - stubsSuffix.length);\n        }\n        return parts.join('.');\n    }\n    _getPythonSearchPaths(execEnv, importFailureInfo) {\n        const cacheKey = execEnv.venv ? execEnv.venv : '<default>';\n        // Find the site packages for the configured virtual environment.\n        if (!this._cachedPythonSearchPaths.has(cacheKey)) {\n            this._cachedPythonSearchPaths.set(cacheKey, PythonPathUtils.findPythonSearchPaths(this.fileSystem, this._configOptions, execEnv.venv, importFailureInfo) || []);\n        }\n        return this._cachedPythonSearchPaths.get(cacheKey);\n    }\n    _findTypeshedPath(execEnv, moduleDescriptor, importName, isStdLib, importFailureInfo) {\n        importFailureInfo.push(`Looking for typeshed ${isStdLib ? 'stdlib' : 'third_party'} path`);\n        const typeshedPath = this._getTypeshedPath(isStdLib, execEnv, importFailureInfo);\n        if (!typeshedPath) {\n            return undefined;\n        }\n        const pythonVersion = execEnv.pythonVersion;\n        let minorVersion = pythonVersion & 0xff;\n        // Search for module starting at \"3.x\" down to \"3.1\", then \"3\", then \"2and3\".\n        while (true) {\n            const pythonVersionString = minorVersion > 0 ? pythonVersion_1.versionToString(0x300 + minorVersion) : minorVersion === 0 ? '3' : '2and3';\n            const testPath = pathUtils_1.combinePaths(typeshedPath, pythonVersionString);\n            if (this.fileSystem.existsSync(testPath)) {\n                const importInfo = this.resolveAbsoluteImport(testPath, moduleDescriptor, importName, importFailureInfo);\n                if (importInfo && importInfo.isImportFound) {\n                    importInfo.importType = isStdLib ? 0 /* BuiltIn */ : 1 /* ThirdParty */;\n                    return importInfo;\n                }\n            }\n            // We use -1 to indicate \"2and3\", which is searched after \"3.0\".\n            if (minorVersion === -1) {\n                break;\n            }\n            minorVersion--;\n        }\n        importFailureInfo.push(`Typeshed path not found`);\n        return undefined;\n    }\n    _getCompletionSuggestionsTypeshedPath(execEnv, moduleDescriptor, isStdLib, suggestions, similarityLimit) {\n        const importFailureInfo = [];\n        const typeshedPath = this._getTypeshedPath(isStdLib, execEnv, importFailureInfo);\n        if (!typeshedPath) {\n            return;\n        }\n        const pythonVersion = execEnv.pythonVersion;\n        let minorVersion = pythonVersion & 0xff;\n        // Search for module starting at \"3.x\" down to \"3.1\", then \"3\", then \"2and3\".\n        while (true) {\n            const pythonVersionString = minorVersion > 0 ? pythonVersion_1.versionToString(0x300 + minorVersion) : minorVersion === 0 ? '3' : '2and3';\n            const testPath = pathUtils_1.combinePaths(typeshedPath, pythonVersionString);\n            if (this.fileSystem.existsSync(testPath)) {\n                this._getCompletionSuggestionsAbsolute(testPath, moduleDescriptor, suggestions, similarityLimit);\n            }\n            // We use -1 to indicate \"2and3\", which is searched after \"3.0\".\n            if (minorVersion === -1) {\n                break;\n            }\n            minorVersion--;\n        }\n    }\n    _getTypeshedPath(isStdLib, execEnv, importFailureInfo) {\n        // See if we have it cached.\n        if (isStdLib) {\n            if (this._cachedTypeshedStdLibPath !== undefined) {\n                return this._cachedTypeshedStdLibPath;\n            }\n        }\n        else {\n            if (this._cachedTypeshedThirdPartyPath !== undefined) {\n                return this._cachedTypeshedThirdPartyPath;\n            }\n        }\n        let typeshedPath = '';\n        // Did the user specify a typeshed path? If not, we'll look in the\n        // python search paths, then in the typeshed-fallback directory.\n        if (this._configOptions.typeshedPath) {\n            const possibleTypeshedPath = this._configOptions.typeshedPath;\n            if (this.fileSystem.existsSync(possibleTypeshedPath) &&\n                pathUtils_1.isDirectory(this.fileSystem, possibleTypeshedPath)) {\n                typeshedPath = possibleTypeshedPath;\n            }\n        }\n        else {\n            const pythonSearchPaths = this._getPythonSearchPaths(execEnv, importFailureInfo);\n            for (const searchPath of pythonSearchPaths) {\n                const possibleTypeshedPath = pathUtils_1.combinePaths(searchPath, 'typeshed');\n                if (this.fileSystem.existsSync(possibleTypeshedPath) &&\n                    pathUtils_1.isDirectory(this.fileSystem, possibleTypeshedPath)) {\n                    typeshedPath = possibleTypeshedPath;\n                    break;\n                }\n            }\n        }\n        // If typeshed directory wasn't found in other locations, use the fallback.\n        if (!typeshedPath) {\n            typeshedPath = PythonPathUtils.getTypeShedFallbackPath(this.fileSystem) || '';\n        }\n        typeshedPath = PythonPathUtils.getTypeshedSubdirectory(typeshedPath, isStdLib);\n        if (!this.fileSystem.existsSync(typeshedPath) || !pathUtils_1.isDirectory(this.fileSystem, typeshedPath)) {\n            return undefined;\n        }\n        // Cache the results.\n        if (isStdLib) {\n            this._cachedTypeshedStdLibPath = typeshedPath;\n        }\n        else {\n            this._cachedTypeshedThirdPartyPath = typeshedPath;\n        }\n        return typeshedPath;\n    }\n    _resolveRelativeImport(sourceFilePath, moduleDescriptor, importName, importFailureInfo) {\n        importFailureInfo.push('Attempting to resolve relative import');\n        // Determine which search path this file is part of.\n        let curDir = pathUtils_1.getDirectoryPath(sourceFilePath);\n        for (let i = 1; i < moduleDescriptor.leadingDots; i++) {\n            if (curDir === '') {\n                importFailureInfo.push(`Invalid relative path '${importName}'`);\n                return undefined;\n            }\n            curDir = pathUtils_1.getDirectoryPath(curDir);\n        }\n        // Now try to match the module parts from the current directory location.\n        const absImport = this.resolveAbsoluteImport(curDir, moduleDescriptor, importName, importFailureInfo);\n        if (!absImport) {\n            return undefined;\n        }\n        return this._filterImplicitImports(absImport, moduleDescriptor.importedSymbols);\n    }\n    _getCompletionSuggestionsRelative(sourceFilePath, moduleDescriptor, suggestions, similarityLimit) {\n        // Determine which search path this file is part of.\n        let curDir = pathUtils_1.getDirectoryPath(sourceFilePath);\n        for (let i = 1; i < moduleDescriptor.leadingDots; i++) {\n            if (curDir === '') {\n                return;\n            }\n            curDir = pathUtils_1.getDirectoryPath(curDir);\n        }\n        // Now try to match the module parts from the current directory location.\n        this._getCompletionSuggestionsAbsolute(curDir, moduleDescriptor, suggestions, similarityLimit);\n    }\n    // Follows import resolution algorithm defined in PEP-420:\n    // https://www.python.org/dev/peps/pep-0420/\n    resolveAbsoluteImport(rootPath, moduleDescriptor, importName, importFailureInfo, allowPartial = false, allowNativeLib = false, allowStubPackages = false, allowPyi = true) {\n        importFailureInfo.push(`Attempting to resolve using root path '${rootPath}'`);\n        // Starting at the specified path, walk the file system to find the\n        // specified module.\n        const resolvedPaths = [];\n        let dirPath = rootPath;\n        let isNamespacePackage = false;\n        let isStubFile = false;\n        let isNativeLib = false;\n        let implicitImports = [];\n        // Handle the \"from . import XXX\" case.\n        if (moduleDescriptor.nameParts.length === 0) {\n            const fileNameWithoutExtension = '__init__';\n            const pyFilePath = pathUtils_1.combinePaths(dirPath, fileNameWithoutExtension + '.py');\n            const pyiFilePath = pathUtils_1.combinePaths(dirPath, fileNameWithoutExtension + '.pyi');\n            if (allowPyi && this.fileSystem.existsSync(pyiFilePath) && pathUtils_1.isFile(this.fileSystem, pyiFilePath)) {\n                importFailureInfo.push(`Resolved import with file '${pyiFilePath}'`);\n                resolvedPaths.push(pyiFilePath);\n                isStubFile = true;\n            }\n            else if (this.fileSystem.existsSync(pyFilePath) && pathUtils_1.isFile(this.fileSystem, pyFilePath)) {\n                importFailureInfo.push(`Resolved import with file '${pyFilePath}'`);\n                resolvedPaths.push(pyFilePath);\n            }\n            else {\n                importFailureInfo.push(`Partially resolved import with directory '${dirPath}'`);\n                resolvedPaths.push('');\n                isNamespacePackage = true;\n            }\n            implicitImports = this._findImplicitImports(dirPath, [pyFilePath, pyiFilePath]);\n        }\n        else {\n            for (let i = 0; i < moduleDescriptor.nameParts.length; i++) {\n                const isLastPart = i === moduleDescriptor.nameParts.length - 1;\n                dirPath = pathUtils_1.combinePaths(dirPath, moduleDescriptor.nameParts[i]);\n                let foundDirectory = false;\n                if (allowPyi && allowStubPackages) {\n                    // PEP 561 indicates that package authors can ship their stubs\n                    // separately from their package implementation by appending\n                    // the string '-stubs' to its top-level directory name. We'll\n                    // look there first.\n                    const stubsDirPath = dirPath + stubsSuffix;\n                    foundDirectory =\n                        this.fileSystem.existsSync(stubsDirPath) && pathUtils_1.isDirectory(this.fileSystem, stubsDirPath);\n                    if (foundDirectory) {\n                        dirPath = stubsDirPath;\n                    }\n                }\n                if (!foundDirectory) {\n                    foundDirectory = this.fileSystem.existsSync(dirPath) && pathUtils_1.isDirectory(this.fileSystem, dirPath);\n                }\n                if (foundDirectory) {\n                    if (!isLastPart) {\n                        // We are not at the last part, and we found a directory,\n                        // so continue to look for the next part.\n                        resolvedPaths.push('');\n                        continue;\n                    }\n                    // See if we can find an __init__.py[i] in this directory.\n                    const fileNameWithoutExtension = '__init__';\n                    const pyFilePath = pathUtils_1.combinePaths(dirPath, fileNameWithoutExtension + '.py');\n                    const pyiFilePath = pathUtils_1.combinePaths(dirPath, fileNameWithoutExtension + '.pyi');\n                    let foundInit = false;\n                    if (allowPyi && this.fileSystem.existsSync(pyiFilePath) && pathUtils_1.isFile(this.fileSystem, pyiFilePath)) {\n                        importFailureInfo.push(`Resolved import with file '${pyiFilePath}'`);\n                        resolvedPaths.push(pyiFilePath);\n                        if (isLastPart) {\n                            isStubFile = true;\n                        }\n                        foundInit = true;\n                    }\n                    else if (this.fileSystem.existsSync(pyFilePath) && pathUtils_1.isFile(this.fileSystem, pyFilePath)) {\n                        importFailureInfo.push(`Resolved import with file '${pyFilePath}'`);\n                        resolvedPaths.push(pyFilePath);\n                        foundInit = true;\n                    }\n                    if (foundInit) {\n                        implicitImports = this._findImplicitImports(dirPath, [pyFilePath, pyiFilePath]);\n                        break;\n                    }\n                }\n                // We weren't able to find a directory or we found a directory with\n                // no __init__.py[i] file. See if we can find a \".py\" or \".pyi\" file\n                // with this name.\n                let fileDirectory = pathUtils_1.stripTrailingDirectorySeparator(dirPath);\n                const fileNameWithoutExtension = pathUtils_1.getFileName(fileDirectory);\n                fileDirectory = pathUtils_1.getDirectoryPath(fileDirectory);\n                const pyFilePath = pathUtils_1.combinePaths(fileDirectory, fileNameWithoutExtension + '.py');\n                const pyiFilePath = pathUtils_1.combinePaths(fileDirectory, fileNameWithoutExtension + '.pyi');\n                if (allowPyi && this.fileSystem.existsSync(pyiFilePath) && pathUtils_1.isFile(this.fileSystem, pyiFilePath)) {\n                    importFailureInfo.push(`Resolved import with file '${pyiFilePath}'`);\n                    resolvedPaths.push(pyiFilePath);\n                    if (isLastPart) {\n                        isStubFile = true;\n                    }\n                }\n                else if (this.fileSystem.existsSync(pyFilePath) && pathUtils_1.isFile(this.fileSystem, pyFilePath)) {\n                    importFailureInfo.push(`Resolved import with file '${pyFilePath}'`);\n                    resolvedPaths.push(pyFilePath);\n                }\n                else {\n                    if (allowNativeLib) {\n                        const filesInDir = this._getFilesInDirectory(fileDirectory);\n                        const nativeLibFileName = filesInDir.find((f) => {\n                            // Strip off the final file extension and the part of the file name\n                            // that excludes all (multi-part) file extensions. This allows us to\n                            // handle file names like \"foo.cpython-32m.so\".\n                            const fileExtension = pathUtils_1.getFileExtension(f, /* multiDotExtension */ false).toLowerCase();\n                            const withoutExtension = pathUtils_1.stripFileExtension(f, /* multiDotExtension */ true);\n                            if (supportedNativeLibExtensions.some((ext) => ext === fileExtension)) {\n                                if (stringUtils_1.equateStringsCaseInsensitive(fileNameWithoutExtension, withoutExtension)) {\n                                    return true;\n                                }\n                            }\n                            return false;\n                        });\n                        if (nativeLibFileName) {\n                            const nativeLibPath = pathUtils_1.combinePaths(fileDirectory, nativeLibFileName);\n                            importFailureInfo.push(`Resolved import with file '${nativeLibPath}'`);\n                            resolvedPaths.push(nativeLibPath);\n                            isNativeLib = true;\n                        }\n                    }\n                    if (!isNativeLib && foundDirectory) {\n                        importFailureInfo.push(`Partially resolved import with directory '${dirPath}'`);\n                        resolvedPaths.push('');\n                        if (isLastPart) {\n                            implicitImports = this._findImplicitImports(dirPath, [pyFilePath, pyiFilePath]);\n                            isNamespacePackage = true;\n                        }\n                    }\n                    else {\n                        importFailureInfo.push(`Did not find file '${pyiFilePath}' or '${pyFilePath}'`);\n                    }\n                }\n                break;\n            }\n        }\n        let importFound;\n        if (allowPartial) {\n            importFound = resolvedPaths.length > 0;\n        }\n        else {\n            importFound = resolvedPaths.length >= moduleDescriptor.nameParts.length;\n            // Empty namespace packages are not allowed.\n            if (isNamespacePackage && implicitImports.length === 0) {\n                importFound = false;\n            }\n        }\n        return {\n            importName,\n            isRelative: false,\n            isNamespacePackage,\n            isImportFound: importFound,\n            importFailureInfo,\n            importType: 2 /* Local */,\n            resolvedPaths,\n            searchPath: rootPath,\n            isStubFile,\n            isNativeLib,\n            implicitImports,\n        };\n    }\n    _getFilesInDirectory(dirPath) {\n        return this.fileSystem\n            .readdirEntriesSync(dirPath)\n            .filter((f) => f.isFile())\n            .map((f) => f.name);\n    }\n    _getCompletionSuggestionsAbsolute(rootPath, moduleDescriptor, suggestions, similarityLimit) {\n        // Starting at the specified path, walk the file system to find the\n        // specified module.\n        let dirPath = rootPath;\n        // Copy the nameParts into a new directory and add an extra empty\n        // part if there is a trailing dot.\n        const nameParts = moduleDescriptor.nameParts.map((name) => name);\n        if (moduleDescriptor.hasTrailingDot) {\n            nameParts.push('');\n        }\n        // Handle the case where the user has typed the first\n        // dot (or multiple) in a relative path.\n        if (nameParts.length === 0) {\n            this._addFilteredSuggestions(dirPath, '', suggestions, similarityLimit);\n        }\n        else {\n            for (let i = 0; i < nameParts.length; i++) {\n                // Provide completions only if we're on the last part\n                // of the name.\n                if (i === nameParts.length - 1) {\n                    this._addFilteredSuggestions(dirPath, nameParts[i], suggestions, similarityLimit);\n                }\n                dirPath = pathUtils_1.combinePaths(dirPath, nameParts[i]);\n                if (!this.fileSystem.existsSync(dirPath) || !pathUtils_1.isDirectory(this.fileSystem, dirPath)) {\n                    break;\n                }\n            }\n        }\n    }\n    _addFilteredSuggestions(dirPath, filter, suggestions, similarityLimit) {\n        const entries = pathUtils_1.getFileSystemEntries(this.fileSystem, dirPath);\n        entries.files.forEach((file) => {\n            // Strip multi-dot extensions to handle file names like \"foo.cpython-32m.so\". We want\n            // to detect the \".so\" but strip off the entire \".cpython-32m.so\" extension.\n            const fileExtension = pathUtils_1.getFileExtension(file, /* multiDotExtension */ false).toLowerCase();\n            const fileWithoutExtension = pathUtils_1.stripFileExtension(file, /* multiDotExtension */ true);\n            if (supportedFileExtensions.some((ext) => ext === fileExtension)) {\n                if (fileWithoutExtension !== '__init__') {\n                    if (!filter ||\n                        StringUtils.computeCompletionSimilarity(filter, fileWithoutExtension) >= similarityLimit) {\n                        this._addUniqueSuggestion(fileWithoutExtension, suggestions);\n                    }\n                }\n            }\n        });\n        entries.directories.forEach((dir) => {\n            if (!filter || dir.startsWith(filter)) {\n                this._addUniqueSuggestion(dir, suggestions);\n            }\n        });\n    }\n    _addUniqueSuggestion(suggestionToAdd, suggestions) {\n        if (suggestions.some((s) => s === suggestionToAdd)) {\n            return;\n        }\n        // Don't add directories with illegal module names.\n        if (/[.-]/.test(suggestionToAdd)) {\n            return;\n        }\n        // Don't add directories with dunder names like \"__pycache__\".\n        if (symbolNameUtils_1.isDunderName(suggestionToAdd)) {\n            return;\n        }\n        suggestions.push(suggestionToAdd);\n    }\n    // Potentially modifies the ImportResult by removing some or all of the\n    // implicit import entries. Only the imported symbols should be included.\n    _filterImplicitImports(importResult, importedSymbols) {\n        if (importedSymbols === undefined) {\n            const newImportResult = Object.assign({}, importResult);\n            newImportResult.implicitImports = [];\n            return newImportResult;\n        }\n        if (importedSymbols.length === 0) {\n            return importResult;\n        }\n        if (importResult.implicitImports.length === 0) {\n            return importResult;\n        }\n        const filteredImplicitImports = importResult.implicitImports.filter((implicitImport) => {\n            return importedSymbols.some((sym) => sym === implicitImport.name);\n        });\n        if (filteredImplicitImports.length === importResult.implicitImports.length) {\n            return importResult;\n        }\n        const newImportResult = Object.assign({}, importResult);\n        newImportResult.implicitImports = filteredImplicitImports;\n        return newImportResult;\n    }\n    _findImplicitImports(dirPath, exclusions) {\n        const implicitImportMap = new Map();\n        // Enumerate all of the files and directories in the path.\n        const entries = pathUtils_1.getFileSystemEntries(this.fileSystem, dirPath);\n        // Add implicit file-based modules.\n        for (const fileName of entries.files) {\n            if (fileName.endsWith('.py') || fileName.endsWith('.pyi')) {\n                const filePath = pathUtils_1.combinePaths(dirPath, fileName);\n                if (!exclusions.find((exclusion) => exclusion === filePath)) {\n                    const strippedFileName = pathUtils_1.stripFileExtension(fileName);\n                    const implicitImport = {\n                        isStubFile: fileName.endsWith('.pyi'),\n                        name: strippedFileName,\n                        path: filePath,\n                    };\n                    // Always prefer stub files over non-stub files.\n                    const entry = implicitImportMap.get(implicitImport.name);\n                    if (!entry || !entry.isStubFile) {\n                        implicitImportMap.set(implicitImport.name, implicitImport);\n                    }\n                }\n            }\n        }\n        // Add implicit directory-based modules.\n        for (const dirName of entries.directories) {\n            const pyFilePath = pathUtils_1.combinePaths(dirPath, dirName, '__init__.py');\n            const pyiFilePath = pyFilePath + 'i';\n            let isStubFile = false;\n            let path = '';\n            if (this.fileSystem.existsSync(pyiFilePath) && pathUtils_1.isFile(this.fileSystem, pyiFilePath)) {\n                isStubFile = true;\n                path = pyiFilePath;\n            }\n            else if (this.fileSystem.existsSync(pyFilePath) && pathUtils_1.isFile(this.fileSystem, pyFilePath)) {\n                path = pyFilePath;\n            }\n            if (path) {\n                if (!exclusions.find((exclusion) => exclusion === path)) {\n                    const implicitImport = {\n                        isStubFile,\n                        name: dirName,\n                        path,\n                    };\n                    implicitImportMap.set(implicitImport.name, implicitImport);\n                }\n            }\n        }\n        return [...implicitImportMap.values()];\n    }\n    _formatImportName(moduleDescriptor) {\n        let name = '';\n        for (let i = 0; i < moduleDescriptor.leadingDots; i++) {\n            name += '.';\n        }\n        return name + moduleDescriptor.nameParts.map((part) => part).join('.');\n    }\n}\nexports.ImportResolver = ImportResolver;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/importResolver.ts?");

/***/ }),

/***/ "./src/analyzer/importStatementUtils.ts":
/*!**********************************************!*\
  !*** ./src/analyzer/importStatementUtils.ts ***!
  \**********************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export compareImportStatements [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getAllImportNames [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getContainingImportStatement [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getImportGroup [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getTextEditsForAutoImportInsertion [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getTextEditsForAutoImportSymbolAddition [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getTopLevelImports [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * importStatementUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Utility routines for summarizing and manipulating\n * import statements in a python source file.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAllImportNames = exports.getContainingImportStatement = exports.getTextEditsForAutoImportInsertion = exports.getTextEditsForAutoImportSymbolAddition = exports.getTopLevelImports = exports.compareImportStatements = exports.getImportGroup = void 0;\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst positionUtils_1 = __webpack_require__(/*! ../common/positionUtils */ \"./src/common/positionUtils.ts\");\nconst textRange_1 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\nconst AnalyzerNodeInfo = __webpack_require__(/*! ./analyzerNodeInfo */ \"./src/analyzer/analyzerNodeInfo.ts\");\nconst SymbolNameUtils = __webpack_require__(/*! ./symbolNameUtils */ \"./src/analyzer/symbolNameUtils.ts\");\n// Determines which import grouping should be used when sorting imports.\nfunction getImportGroup(statement) {\n    if (statement.importResult) {\n        if (statement.importResult.importType === 0 /* BuiltIn */) {\n            return 0 /* BuiltIn */;\n        }\n        else if (statement.importResult.importType === 1 /* ThirdParty */ ||\n            statement.importResult.isLocalTypingsFile) {\n            return 1 /* ThirdParty */;\n        }\n        if (statement.importResult.isRelative) {\n            return 3 /* LocalRelative */;\n        }\n        return 2 /* Local */;\n    }\n    else {\n        return 2 /* Local */;\n    }\n}\nexports.getImportGroup = getImportGroup;\n// Compares sort order of two import statements.\nfunction compareImportStatements(a, b) {\n    const aImportGroup = getImportGroup(a);\n    const bImportGroup = getImportGroup(b);\n    if (aImportGroup < bImportGroup) {\n        return -1;\n    }\n    else if (aImportGroup > bImportGroup) {\n        return 1;\n    }\n    return a.moduleName < b.moduleName ? -1 : 1;\n}\nexports.compareImportStatements = compareImportStatements;\n// Looks for top-level 'import' and 'import from' statements and provides\n// an ordered list and a map (by file path).\nfunction getTopLevelImports(parseTree) {\n    const localImports = {\n        orderedImports: [],\n        mapByFilePath: new Map(),\n    };\n    let followsNonImportStatement = false;\n    let foundFirstImportStatement = false;\n    parseTree.statements.forEach((statement) => {\n        if (statement.nodeType === 48 /* StatementList */) {\n            statement.statements.forEach((subStatement) => {\n                if (subStatement.nodeType === 20 /* Import */) {\n                    foundFirstImportStatement = true;\n                    _processImportNode(subStatement, localImports, followsNonImportStatement);\n                    followsNonImportStatement = false;\n                }\n                else if (subStatement.nodeType === 22 /* ImportFrom */) {\n                    foundFirstImportStatement = true;\n                    _processImportFromNode(subStatement, localImports, followsNonImportStatement);\n                    followsNonImportStatement = false;\n                }\n                else {\n                    followsNonImportStatement = foundFirstImportStatement;\n                }\n            });\n        }\n        else {\n            followsNonImportStatement = foundFirstImportStatement;\n        }\n    });\n    return localImports;\n}\nexports.getTopLevelImports = getTopLevelImports;\nfunction getTextEditsForAutoImportSymbolAddition(symbolName, importStatement, parseResults, aliasName) {\n    const textEditList = [];\n    // Scan through the import symbols to find the right insertion point,\n    // assuming we want to keep the imports alphabetized.\n    let priorImport;\n    if (importStatement.node && importStatement.node.nodeType === 22 /* ImportFrom */) {\n        // Make sure we're not attempting to auto-import a symbol that\n        // already exists in the import list.\n        if (!importStatement.node.imports.some((importAs) => importAs.name.value === symbolName)) {\n            for (const curImport of importStatement.node.imports) {\n                if (curImport.name.value > symbolName) {\n                    break;\n                }\n                priorImport = curImport;\n            }\n            const insertionOffset = priorImport\n                ? textRange_1.TextRange.getEnd(priorImport)\n                : importStatement.node.imports.length > 0\n                    ? importStatement.node.imports[0].start\n                    : importStatement.node.start + importStatement.node.length;\n            const insertionPosition = positionUtils_1.convertOffsetToPosition(insertionOffset, parseResults.tokenizerOutput.lines);\n            const insertText = aliasName ? `${symbolName} as ${aliasName}` : symbolName;\n            textEditList.push({\n                range: { start: insertionPosition, end: insertionPosition },\n                replacementText: priorImport ? ', ' + insertText : insertText + ', ',\n            });\n        }\n    }\n    return textEditList;\n}\nexports.getTextEditsForAutoImportSymbolAddition = getTextEditsForAutoImportSymbolAddition;\nfunction getTextEditsForAutoImportInsertion(symbolName, importStatements, moduleName, importGroup, parseResults, aliasName) {\n    const textEditList = [];\n    // We need to emit a new 'from import' statement if symbolName is given. otherwise, use 'import' statement.\n    const importText = symbolName ? symbolName : moduleName;\n    const importTextWithAlias = aliasName ? `${importText} as ${aliasName}` : importText;\n    let newImportStatement = symbolName\n        ? `from ${moduleName} import ${importTextWithAlias}`\n        : `import ${importTextWithAlias}`;\n    let insertionPosition;\n    if (importStatements.orderedImports.length > 0) {\n        let insertBefore = true;\n        let insertionImport = importStatements.orderedImports[0];\n        // Find a good spot to insert the new import statement. Follow\n        // the PEP8 standard sorting order whereby built-in imports are\n        // followed by third-party, which are followed by local.\n        let prevImportGroup = 0 /* BuiltIn */;\n        for (const curImport of importStatements.orderedImports) {\n            // If the import was resolved, use its import type. If it wasn't\n            // resolved, assume that it's the same import type as the previous\n            // one.\n            const curImportGroup = curImport.importResult ? getImportGroup(curImport) : prevImportGroup;\n            if (importGroup < curImportGroup) {\n                if (!insertBefore && prevImportGroup < importGroup) {\n                    // Add an extra line to create a new group.\n                    newImportStatement = parseResults.tokenizerOutput.predominantEndOfLineSequence + newImportStatement;\n                }\n                break;\n            }\n            if (importGroup === curImportGroup && curImport.moduleName > moduleName) {\n                break;\n            }\n            // If we're about to hit the end of the import statements, don't go\n            // any further.\n            if (curImport.followsNonImportStatement) {\n                if (importGroup > prevImportGroup) {\n                    // Add an extra line to create a new group.\n                    newImportStatement = parseResults.tokenizerOutput.predominantEndOfLineSequence + newImportStatement;\n                }\n                break;\n            }\n            // If this is the last import, see if we need to create a new group.\n            if (curImport === importStatements.orderedImports[importStatements.orderedImports.length - 1]) {\n                if (importGroup > curImportGroup) {\n                    // Add an extra line to create a new group.\n                    newImportStatement = parseResults.tokenizerOutput.predominantEndOfLineSequence + newImportStatement;\n                }\n            }\n            // Are we starting a new group?\n            if (!insertBefore && importGroup < prevImportGroup && importGroup === curImportGroup) {\n                insertBefore = true;\n            }\n            else {\n                insertBefore = false;\n            }\n            prevImportGroup = curImportGroup;\n            insertionImport = curImport;\n        }\n        if (insertionImport) {\n            if (insertBefore) {\n                newImportStatement = newImportStatement + parseResults.tokenizerOutput.predominantEndOfLineSequence;\n            }\n            else {\n                newImportStatement = parseResults.tokenizerOutput.predominantEndOfLineSequence + newImportStatement;\n            }\n            insertionPosition = positionUtils_1.convertOffsetToPosition(insertBefore ? insertionImport.node.start : textRange_1.TextRange.getEnd(insertionImport.node), parseResults.tokenizerOutput.lines);\n        }\n        else {\n            insertionPosition = { line: 0, character: 0 };\n        }\n    }\n    else {\n        // Insert at or near the top of the file. See if there's a doc string and\n        // copyright notice, etc. at the top. If so, move past those.\n        insertionPosition = { line: 0, character: 0 };\n        let addNewLineBefore = false;\n        for (const statement of parseResults.parseTree.statements) {\n            let stopHere = true;\n            if (statement.nodeType === 48 /* StatementList */ && statement.statements.length === 1) {\n                const simpleStatement = statement.statements[0];\n                if (simpleStatement.nodeType === 49 /* StringList */) {\n                    // Assume that it's a file header doc string.\n                    stopHere = false;\n                }\n                else if (simpleStatement.nodeType === 3 /* Assignment */) {\n                    if (simpleStatement.leftExpression.nodeType === 39 /* Name */) {\n                        if (SymbolNameUtils.isDunderName(simpleStatement.leftExpression.value)) {\n                            // Assume that it's an assignment of __copyright__, __author__, etc.\n                            stopHere = false;\n                        }\n                    }\n                }\n            }\n            if (stopHere) {\n                insertionPosition = positionUtils_1.convertOffsetToPosition(statement.start, parseResults.tokenizerOutput.lines);\n                addNewLineBefore = false;\n                break;\n            }\n            else {\n                insertionPosition = positionUtils_1.convertOffsetToPosition(statement.start + statement.length, parseResults.tokenizerOutput.lines);\n                addNewLineBefore = true;\n            }\n        }\n        newImportStatement +=\n            parseResults.tokenizerOutput.predominantEndOfLineSequence +\n                parseResults.tokenizerOutput.predominantEndOfLineSequence;\n        if (addNewLineBefore) {\n            newImportStatement = parseResults.tokenizerOutput.predominantEndOfLineSequence + newImportStatement;\n        }\n        else {\n            newImportStatement += parseResults.tokenizerOutput.predominantEndOfLineSequence;\n        }\n    }\n    textEditList.push({\n        range: { start: insertionPosition, end: insertionPosition },\n        replacementText: newImportStatement,\n    });\n    return textEditList;\n}\nexports.getTextEditsForAutoImportInsertion = getTextEditsForAutoImportInsertion;\nfunction _processImportNode(node, localImports, followsNonImportStatement) {\n    node.list.forEach((importAsNode) => {\n        const importResult = AnalyzerNodeInfo.getImportInfo(importAsNode.module);\n        let resolvedPath;\n        if (importResult && importResult.isImportFound) {\n            resolvedPath = importResult.resolvedPaths[importResult.resolvedPaths.length - 1];\n        }\n        const localImport = {\n            node,\n            subnode: importAsNode,\n            importResult,\n            resolvedPath,\n            moduleName: _formatModuleName(importAsNode.module),\n            followsNonImportStatement,\n        };\n        localImports.orderedImports.push(localImport);\n        // Add it to the map.\n        if (resolvedPath) {\n            // Don't overwrite existing import or import from statements\n            // because we always want to prefer 'import from' over 'import'\n            // in the map.\n            if (!localImports.mapByFilePath.has(resolvedPath)) {\n                localImports.mapByFilePath.set(resolvedPath, localImport);\n            }\n        }\n    });\n}\nfunction _processImportFromNode(node, localImports, followsNonImportStatement) {\n    const importResult = AnalyzerNodeInfo.getImportInfo(node.module);\n    let resolvedPath;\n    if (importResult && importResult.isImportFound) {\n        resolvedPath = importResult.resolvedPaths[importResult.resolvedPaths.length - 1];\n    }\n    const localImport = {\n        node,\n        importResult,\n        resolvedPath,\n        moduleName: _formatModuleName(node.module),\n        followsNonImportStatement,\n    };\n    localImports.orderedImports.push(localImport);\n    // Add it to the map.\n    if (resolvedPath) {\n        const prevEntry = localImports.mapByFilePath.get(resolvedPath);\n        // Overwrite existing import statements because we always want to prefer\n        // 'import from' over 'import'. Also, overwrite existing 'import from' if\n        // the module name is shorter.\n        if (!prevEntry ||\n            prevEntry.node.nodeType === 20 /* Import */ ||\n            prevEntry.moduleName.length > localImport.moduleName.length) {\n            localImports.mapByFilePath.set(resolvedPath, localImport);\n        }\n    }\n}\nfunction _formatModuleName(node) {\n    let moduleName = '';\n    for (let i = 0; i < node.leadingDots; i++) {\n        moduleName = moduleName + '.';\n    }\n    moduleName += node.nameParts.map((part) => part.value).join('.');\n    return moduleName;\n}\nfunction getContainingImportStatement(node, token) {\n    while (node) {\n        cancellationUtils_1.throwIfCancellationRequested(token);\n        if (node.nodeType === 20 /* Import */ || node.nodeType === 22 /* ImportFrom */) {\n            break;\n        }\n        node = node.parent;\n    }\n    return node;\n}\nexports.getContainingImportStatement = getContainingImportStatement;\nfunction getAllImportNames(node) {\n    if (node.nodeType === 20 /* Import */) {\n        const importNode = node;\n        return importNode.list;\n    }\n    const importFromNode = node;\n    return importFromNode.imports;\n}\nexports.getAllImportNames = getAllImportNames;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/importStatementUtils.ts?");

/***/ }),

/***/ "./src/analyzer/parseTreeCleaner.ts":
/*!******************************************!*\
  !*** ./src/analyzer/parseTreeCleaner.ts ***!
  \******************************************/
/*! flagged exports */
/*! export ParseTreeCleanerWalker [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * parseTreeCleaner.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * A parse tree walker that's used to clean any analysis\n * information hanging off the parse tree. It's used when\n * dependent files have been modified and the file requires\n * reanalysis. Without this, we'd need to generate a fresh\n * parse tree from scratch.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ParseTreeCleanerWalker = void 0;\nconst AnalyzerNodeInfo = __webpack_require__(/*! ./analyzerNodeInfo */ \"./src/analyzer/analyzerNodeInfo.ts\");\nconst parseTreeWalker_1 = __webpack_require__(/*! ./parseTreeWalker */ \"./src/analyzer/parseTreeWalker.ts\");\nclass ParseTreeCleanerWalker extends parseTreeWalker_1.ParseTreeWalker {\n    constructor(parseTree) {\n        super();\n        this._parseTree = parseTree;\n    }\n    clean() {\n        this.walk(this._parseTree);\n    }\n    visitNode(node) {\n        AnalyzerNodeInfo.cleanNodeAnalysisInfo(node);\n        return super.visitNode(node);\n    }\n}\nexports.ParseTreeCleanerWalker = ParseTreeCleanerWalker;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/parseTreeCleaner.ts?");

/***/ }),

/***/ "./src/analyzer/parseTreeUtils.ts":
/*!****************************************!*\
  !*** ./src/analyzer/parseTreeUtils.ts ***!
  \****************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export findNodeByOffset [provided] [no usage info] [missing usage info prevents renaming] */
/*! export findNodeByPosition [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getDocString [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getEnclosingClass [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getEnclosingClassOrModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getEnclosingFunction [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getEnclosingModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getEnclosingSuiteOrModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getEvaluationNodeForAssignmentExpression [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getEvaluationScopeNode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getExecutionScopeNode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getNodeDepth [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isAssignmentToDefaultsFollowingNamedTuple [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isFinalAllowedForAssignmentTarget [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isMatchingExpression [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isNodeContainedWithin [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isSuiteEmpty [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isWithinDefaultParamInitializer [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isWithinTypeAnnotation [provided] [no usage info] [missing usage info prevents renaming] */
/*! export printExpression [provided] [no usage info] [missing usage info prevents renaming] */
/*! export printOperator [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * parseTreeUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Utility routines for traversing a parse tree.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isAssignmentToDefaultsFollowingNamedTuple = exports.getDocString = exports.isWithinTypeAnnotation = exports.isWithinDefaultParamInitializer = exports.isMatchingExpression = exports.isSuiteEmpty = exports.isNodeContainedWithin = exports.isFinalAllowedForAssignmentTarget = exports.getExecutionScopeNode = exports.getEvaluationScopeNode = exports.getEvaluationNodeForAssignmentExpression = exports.getEnclosingSuiteOrModule = exports.getEnclosingFunction = exports.getEnclosingClassOrModule = exports.getEnclosingModule = exports.getEnclosingClass = exports.printOperator = exports.printExpression = exports.findNodeByOffset = exports.findNodeByPosition = exports.getNodeDepth = void 0;\nconst debug_1 = __webpack_require__(/*! ../common/debug */ \"./src/common/debug.ts\");\nconst positionUtils_1 = __webpack_require__(/*! ../common/positionUtils */ \"./src/common/positionUtils.ts\");\nconst textRange_1 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\nconst parseNodes_1 = __webpack_require__(/*! ../parser/parseNodes */ \"./src/parser/parseNodes.ts\");\nconst analyzerNodeInfo_1 = __webpack_require__(/*! ./analyzerNodeInfo */ \"./src/analyzer/analyzerNodeInfo.ts\");\nconst docStringUtils_1 = __webpack_require__(/*! ./docStringUtils */ \"./src/analyzer/docStringUtils.ts\");\nconst parseTreeWalker_1 = __webpack_require__(/*! ./parseTreeWalker */ \"./src/analyzer/parseTreeWalker.ts\");\nfunction getNodeDepth(node) {\n    let depth = 0;\n    let curNode = node;\n    while (curNode) {\n        depth++;\n        curNode = curNode.parent;\n    }\n    return depth;\n}\nexports.getNodeDepth = getNodeDepth;\n// Returns the deepest node that contains the specified position.\nfunction findNodeByPosition(node, position, lines) {\n    const offset = positionUtils_1.convertPositionToOffset(position, lines);\n    if (offset === undefined) {\n        return undefined;\n    }\n    return findNodeByOffset(node, offset);\n}\nexports.findNodeByPosition = findNodeByPosition;\n// Returns the deepest node that contains the specified offset.\nfunction findNodeByOffset(node, offset) {\n    if (offset < node.start || offset > textRange_1.TextRange.getEnd(node)) {\n        return undefined;\n    }\n    const parseTreeWalker = new parseTreeWalker_1.ParseTreeWalker();\n    // The range is found within this node. See if we can localize it\n    // further by checking its children.\n    const children = parseTreeWalker.visitNode(node);\n    for (const child of children) {\n        if (child) {\n            const containingChild = findNodeByOffset(child, offset);\n            if (containingChild) {\n                return containingChild;\n            }\n        }\n    }\n    return node;\n}\nexports.findNodeByOffset = findNodeByOffset;\nfunction printExpression(node, flags = 0 /* None */) {\n    switch (node.nodeType) {\n        case 39 /* Name */: {\n            return node.value;\n        }\n        case 36 /* MemberAccess */: {\n            return printExpression(node.leftExpression, flags) + '.' + node.memberName.value;\n        }\n        case 9 /* Call */: {\n            return (printExpression(node.leftExpression, flags) +\n                '(' +\n                node.arguments\n                    .map((arg) => {\n                    let argStr = '';\n                    if (arg.argumentCategory === 1 /* UnpackedList */) {\n                        argStr = '*';\n                    }\n                    else if (arg.argumentCategory === 2 /* UnpackedDictionary */) {\n                        argStr = '**';\n                    }\n                    if (arg.name) {\n                        argStr += arg.name.value + '=';\n                    }\n                    argStr += printExpression(arg.valueExpression, flags);\n                    return argStr;\n                })\n                    .join(', ') +\n                ')');\n        }\n        case 24 /* Index */: {\n            return (printExpression(node.baseExpression, flags) +\n                '[' +\n                node.items.items.map((item) => printExpression(item, flags)).join(', ') +\n                ']');\n        }\n        case 56 /* UnaryOperation */: {\n            return printOperator(node.operator) + ' ' + printExpression(node.expression, flags);\n        }\n        case 7 /* BinaryOperation */: {\n            return (printExpression(node.leftExpression, flags) +\n                ' ' +\n                printOperator(node.operator) +\n                ' ' +\n                printExpression(node.rightExpression, flags));\n        }\n        case 41 /* Number */: {\n            let value = node.value.toString();\n            if (node.isImaginary) {\n                value += 'j';\n            }\n            return value;\n        }\n        case 49 /* StringList */: {\n            if (flags & 1 /* ForwardDeclarations */ && node.typeAnnotation) {\n                return printExpression(node.typeAnnotation, flags);\n            }\n            else {\n                return node.strings\n                    .map((str) => {\n                    return printExpression(str, flags);\n                })\n                    .join(' ');\n            }\n        }\n        case 50 /* String */: {\n            let exprString = '';\n            if (node.token.flags & 8 /* Raw */) {\n                exprString += 'r';\n            }\n            if (node.token.flags & 16 /* Unicode */) {\n                exprString += 'u';\n            }\n            if (node.token.flags & 32 /* Bytes */) {\n                exprString += 'b';\n            }\n            if (node.token.flags & 64 /* Format */) {\n                exprString += 'f';\n            }\n            if (node.token.flags & 4 /* Triplicate */) {\n                if (node.token.flags & 1 /* SingleQuote */) {\n                    exprString += `'''${node.token.escapedValue}'''`;\n                }\n                else {\n                    exprString += `\"\"\"${node.token.escapedValue}\"\"\"`;\n                }\n            }\n            else {\n                if (node.token.flags & 1 /* SingleQuote */) {\n                    exprString += `'${node.token.escapedValue}'`;\n                }\n                else {\n                    exprString += `\"${node.token.escapedValue}\"`;\n                }\n            }\n            return exprString;\n        }\n        case 3 /* Assignment */: {\n            return printExpression(node.leftExpression, flags) + ' = ' + printExpression(node.rightExpression, flags);\n        }\n        case 4 /* AssignmentExpression */: {\n            return printExpression(node.name, flags) + ' := ' + printExpression(node.rightExpression, flags);\n        }\n        case 55 /* TypeAnnotation */: {\n            return printExpression(node.valueExpression, flags) + ': ' + printExpression(node.typeAnnotation, flags);\n        }\n        case 5 /* AugmentedAssignment */: {\n            return (printExpression(node.leftExpression, flags) +\n                ' ' +\n                printOperator(node.operator) +\n                ' ' +\n                printExpression(node.rightExpression, flags));\n        }\n        case 6 /* Await */: {\n            return 'await ' + printExpression(node.expression, flags);\n        }\n        case 52 /* Ternary */: {\n            return (printExpression(node.ifExpression, flags) +\n                ' if ' +\n                printExpression(node.testExpression, flags) +\n                ' else ' +\n                printExpression(node.elseExpression, flags));\n        }\n        case 32 /* List */: {\n            const expressions = node.entries.map((expr) => {\n                return printExpression(expr, flags);\n            });\n            return `[${expressions.join(', ')}]`;\n        }\n        case 57 /* Unpack */: {\n            return '*' + printExpression(node.expression, flags);\n        }\n        case 53 /* Tuple */: {\n            const expressions = node.expressions.map((expr) => {\n                return printExpression(expr, flags);\n            });\n            if (expressions.length === 1) {\n                return `(${expressions[0]}, )`;\n            }\n            return `(${expressions.join(', ')})`;\n        }\n        case 61 /* Yield */: {\n            if (node.expression) {\n                return 'yield ' + printExpression(node.expression, flags);\n            }\n            else {\n                return 'yield';\n            }\n        }\n        case 62 /* YieldFrom */: {\n            return 'yield from ' + printExpression(node.expression, flags);\n        }\n        case 18 /* Ellipsis */: {\n            return '...';\n        }\n        case 33 /* ListComprehension */: {\n            let listStr = '<ListExpression>';\n            if (parseNodes_1.isExpressionNode(node.expression)) {\n                listStr = printExpression(node.expression, flags);\n            }\n            else if (node.expression.nodeType === 17 /* DictionaryKeyEntry */) {\n                const keyStr = printExpression(node.expression.keyExpression, flags);\n                const valueStr = printExpression(node.expression.valueExpression, flags);\n                listStr = `${keyStr}: ${valueStr}`;\n            }\n            return (listStr +\n                ' ' +\n                node.comprehensions\n                    .map((expr) => {\n                    if (expr.nodeType === 34 /* ListComprehensionFor */) {\n                        return (`${expr.isAsync ? 'async ' : ''}for ` +\n                            printExpression(expr.targetExpression, flags) +\n                            ` in ${printExpression(expr.iterableExpression, flags)}`);\n                    }\n                    else {\n                        return `if ${printExpression(expr.testExpression, flags)}`;\n                    }\n                })\n                    .join(' '));\n        }\n        case 47 /* Slice */: {\n            let result = '';\n            if (node.startValue) {\n                result += printExpression(node.startValue, flags);\n            }\n            if (node.endValue) {\n                result += ': ' + printExpression(node.endValue, flags);\n            }\n            if (node.stepValue) {\n                result += ': ' + printExpression(node.stepValue, flags);\n            }\n            return result;\n        }\n        case 31 /* Lambda */: {\n            return ('lambda ' +\n                node.parameters\n                    .map((param) => {\n                    let paramStr = '';\n                    if (param.category === 1 /* VarArgList */) {\n                        paramStr += '*';\n                    }\n                    else if (param.category === 2 /* VarArgDictionary */) {\n                        paramStr += '**';\n                    }\n                    if (param.name) {\n                        paramStr += param.name.value;\n                    }\n                    if (param.defaultValue) {\n                        paramStr += ' = ' + printExpression(param.defaultValue, flags);\n                    }\n                    return paramStr;\n                })\n                    .join(', ') +\n                ': ' +\n                printExpression(node.expression, flags));\n        }\n        case 11 /* Constant */: {\n            if (node.constType === 31 /* True */) {\n                return 'True';\n            }\n            else if (node.constType === 14 /* False */) {\n                return 'False';\n            }\n            else if (node.constType === 8 /* Debug */) {\n                return '__debug__';\n            }\n            else if (node.constType === 24 /* None */) {\n                return 'None';\n            }\n            break;\n        }\n        case 15 /* Dictionary */: {\n            return `{ ${node.entries.map((entry) => {\n                if (entry.nodeType === 17 /* DictionaryKeyEntry */) {\n                    return (`${printExpression(entry.keyExpression, flags)}: ` +\n                        `${printExpression(entry.valueExpression, flags)}`);\n                }\n                else {\n                    return printExpression(entry, flags);\n                }\n            })} }`;\n        }\n        case 16 /* DictionaryExpandEntry */: {\n            return `**${printExpression(node.expandExpression, flags)}`;\n        }\n        case 46 /* Set */: {\n            return node.entries.map((entry) => printExpression(entry, flags)).join(', ');\n        }\n    }\n    return '<Expression>';\n}\nexports.printExpression = printExpression;\nfunction printOperator(operator) {\n    const operatorMap = {\n        [0 /* Add */]: '+',\n        [1 /* AddEqual */]: '+=',\n        [2 /* Assign */]: '=',\n        [3 /* BitwiseAnd */]: '&',\n        [4 /* BitwiseAndEqual */]: '&=',\n        [5 /* BitwiseInvert */]: '~',\n        [6 /* BitwiseOr */]: '|',\n        [7 /* BitwiseOrEqual */]: '|=',\n        [8 /* BitwiseXor */]: '^',\n        [9 /* BitwiseXorEqual */]: '^=',\n        [10 /* Divide */]: '/',\n        [11 /* DivideEqual */]: '/=',\n        [12 /* Equals */]: '==',\n        [13 /* FloorDivide */]: '//',\n        [14 /* FloorDivideEqual */]: '//=',\n        [15 /* GreaterThan */]: '>',\n        [16 /* GreaterThanOrEqual */]: '>=',\n        [17 /* LeftShift */]: '<<',\n        [18 /* LeftShiftEqual */]: '<<=',\n        [19 /* LessOrGreaterThan */]: '<>',\n        [20 /* LessThan */]: '<',\n        [21 /* LessThanOrEqual */]: '<=',\n        [22 /* MatrixMultiply */]: '@',\n        [23 /* MatrixMultiplyEqual */]: '@=',\n        [24 /* Mod */]: '%',\n        [25 /* ModEqual */]: '%=',\n        [26 /* Multiply */]: '*',\n        [27 /* MultiplyEqual */]: '*=',\n        [28 /* NotEquals */]: '!=',\n        [29 /* Power */]: '**',\n        [30 /* PowerEqual */]: '**=',\n        [31 /* RightShift */]: '>>',\n        [32 /* RightShiftEqual */]: '>>=',\n        [33 /* Subtract */]: '-',\n        [34 /* SubtractEqual */]: '-=',\n        [36 /* And */]: 'and',\n        [37 /* Or */]: 'or',\n        [38 /* Not */]: 'not',\n        [39 /* Is */]: 'is',\n        [40 /* IsNot */]: 'is not',\n        [41 /* In */]: 'in',\n        [42 /* NotIn */]: 'not in',\n    };\n    if (operatorMap[operator]) {\n        return operatorMap[operator];\n    }\n    return 'unknown';\n}\nexports.printOperator = printOperator;\nfunction getEnclosingClass(node, stopAtFunction = false) {\n    let curNode = node.parent;\n    while (curNode) {\n        if (curNode.nodeType === 10 /* Class */) {\n            return curNode;\n        }\n        if (curNode.nodeType === 37 /* Module */) {\n            return undefined;\n        }\n        if (curNode.nodeType === 29 /* Function */) {\n            if (stopAtFunction) {\n                return undefined;\n            }\n        }\n        curNode = curNode.parent;\n    }\n    return undefined;\n}\nexports.getEnclosingClass = getEnclosingClass;\nfunction getEnclosingModule(node) {\n    let curNode = node.parent;\n    while (curNode) {\n        if (curNode.nodeType === 37 /* Module */) {\n            return curNode;\n        }\n        curNode = curNode.parent;\n    }\n    debug_1.fail('Module node not found');\n    return undefined;\n}\nexports.getEnclosingModule = getEnclosingModule;\nfunction getEnclosingClassOrModule(node, stopAtFunction = false) {\n    let curNode = node.parent;\n    while (curNode) {\n        if (curNode.nodeType === 10 /* Class */) {\n            return curNode;\n        }\n        if (curNode.nodeType === 37 /* Module */) {\n            return curNode;\n        }\n        if (curNode.nodeType === 29 /* Function */) {\n            if (stopAtFunction) {\n                return undefined;\n            }\n        }\n        curNode = curNode.parent;\n    }\n    return undefined;\n}\nexports.getEnclosingClassOrModule = getEnclosingClassOrModule;\nfunction getEnclosingFunction(node) {\n    let curNode = node.parent;\n    while (curNode) {\n        if (curNode.nodeType === 29 /* Function */) {\n            return curNode;\n        }\n        if (curNode.nodeType === 10 /* Class */) {\n            return undefined;\n        }\n        curNode = curNode.parent;\n    }\n    return undefined;\n}\nexports.getEnclosingFunction = getEnclosingFunction;\nfunction getEnclosingSuiteOrModule(node) {\n    let curNode = node.parent;\n    while (curNode) {\n        if (curNode.nodeType === 51 /* Suite */) {\n            return curNode;\n        }\n        if (curNode.nodeType === 37 /* Module */) {\n            return curNode;\n        }\n        if (curNode.nodeType === 31 /* Lambda */) {\n            return undefined;\n        }\n        curNode = curNode.parent;\n    }\n    return undefined;\n}\nexports.getEnclosingSuiteOrModule = getEnclosingSuiteOrModule;\nfunction getEvaluationNodeForAssignmentExpression(node) {\n    // PEP 572 indicates that the evaluation node for an assignment expression\n    // target is the containing lambda, function or module, but not a class.\n    let curNode = getEvaluationScopeNode(node);\n    while (curNode !== undefined) {\n        switch (curNode.nodeType) {\n            case 29 /* Function */:\n            case 31 /* Lambda */:\n            case 37 /* Module */:\n                return curNode;\n            case 10 /* Class */:\n                return undefined;\n        }\n        curNode = curNode.parent;\n    }\n    return undefined;\n}\nexports.getEvaluationNodeForAssignmentExpression = getEvaluationNodeForAssignmentExpression;\n// Returns the parse node corresponding to the scope that is used to evaluate\n// a symbol referenced in the specified node.\nfunction getEvaluationScopeNode(node) {\n    let prevNode;\n    let curNode = node;\n    let isParamNameNode = false;\n    while (curNode) {\n        if (curNode.nodeType === 42 /* Parameter */ && prevNode === curNode.name) {\n            // Note that we passed through a parameter name node.\n            isParamNameNode = true;\n        }\n        // We found a scope associated with this node. In most cases,\n        // we'll return this scope, but in a few cases we need to return\n        // the enclosing scope instead.\n        switch (curNode.nodeType) {\n            case 29 /* Function */: {\n                if (curNode.parameters.some((param) => param === prevNode)) {\n                    if (isParamNameNode) {\n                        if (analyzerNodeInfo_1.getScope(curNode) !== undefined) {\n                            return curNode;\n                        }\n                    }\n                }\n                else if (prevNode === curNode.suite) {\n                    if (analyzerNodeInfo_1.getScope(curNode) !== undefined) {\n                        return curNode;\n                    }\n                }\n                break;\n            }\n            case 31 /* Lambda */: {\n                if (curNode.parameters.some((param) => param === prevNode)) {\n                    if (isParamNameNode) {\n                        if (analyzerNodeInfo_1.getScope(curNode) !== undefined) {\n                            return curNode;\n                        }\n                    }\n                }\n                else if (prevNode === curNode.expression) {\n                    if (analyzerNodeInfo_1.getScope(curNode) !== undefined) {\n                        return curNode;\n                    }\n                }\n                break;\n            }\n            case 10 /* Class */: {\n                if (prevNode === curNode.suite) {\n                    if (analyzerNodeInfo_1.getScope(curNode) !== undefined) {\n                        return curNode;\n                    }\n                }\n                break;\n            }\n            case 33 /* ListComprehension */:\n            case 37 /* Module */: {\n                if (analyzerNodeInfo_1.getScope(curNode) !== undefined) {\n                    return curNode;\n                }\n            }\n        }\n        prevNode = curNode;\n        curNode = curNode.parent;\n    }\n    debug_1.fail('Did not find evaluation scope');\n    return undefined;\n}\nexports.getEvaluationScopeNode = getEvaluationScopeNode;\n// Returns the parse node corresponding to the scope that is used\n// for executing the code referenced in the specified node.\nfunction getExecutionScopeNode(node) {\n    let evaluationScope = getEvaluationScopeNode(node);\n    // Classes are not considered execution scope because they are executed\n    // within the context of their containing module or function. Likewise, list\n    // comprehensions are executed within their container.\n    while (evaluationScope.nodeType === 10 /* Class */ ||\n        evaluationScope.nodeType === 33 /* ListComprehension */) {\n        evaluationScope = getEvaluationScopeNode(evaluationScope.parent);\n    }\n    return evaluationScope;\n}\nexports.getExecutionScopeNode = getExecutionScopeNode;\n// PEP 591 spells out certain limited cases where an assignment target\n// can be annotated with a \"Final\" annotation. This function determines\n// whether Final is allowed for the specified node.\nfunction isFinalAllowedForAssignmentTarget(targetNode) {\n    // Simple names always support Final.\n    if (targetNode.nodeType === 39 /* Name */) {\n        return true;\n    }\n    // Member access expressions like \"self.x\" are permitted only\n    // within __init__ methods.\n    if (targetNode.nodeType === 36 /* MemberAccess */) {\n        if (targetNode.leftExpression.nodeType !== 39 /* Name */) {\n            return false;\n        }\n        const classNode = getEnclosingClass(targetNode);\n        if (!classNode) {\n            return false;\n        }\n        const methodNode = getEnclosingFunction(targetNode);\n        if (!methodNode) {\n            return false;\n        }\n        if (methodNode.name.value !== '__init__') {\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\nexports.isFinalAllowedForAssignmentTarget = isFinalAllowedForAssignmentTarget;\nfunction isNodeContainedWithin(node, potentialContainer) {\n    let curNode = node;\n    while (curNode) {\n        if (curNode === potentialContainer) {\n            return true;\n        }\n        curNode = curNode.parent;\n    }\n    return false;\n}\nexports.isNodeContainedWithin = isNodeContainedWithin;\nfunction isSuiteEmpty(node) {\n    for (const statement of node.statements) {\n        if (statement.nodeType === 48 /* StatementList */) {\n            for (const substatement of statement.statements) {\n                if (substatement.nodeType === 18 /* Ellipsis */) {\n                    // Allow an ellipsis\n                }\n                else if (substatement.nodeType === 49 /* StringList */) {\n                    // Allow doc strings\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isSuiteEmpty = isSuiteEmpty;\nfunction isMatchingExpression(expression1, expression2) {\n    if (expression1.nodeType === 39 /* Name */ && expression2.nodeType === 39 /* Name */) {\n        return expression1.value === expression2.value;\n    }\n    else if (expression1.nodeType === 36 /* MemberAccess */ &&\n        expression2.nodeType === 36 /* MemberAccess */) {\n        return (isMatchingExpression(expression1.leftExpression, expression2.leftExpression) &&\n            expression1.memberName.value === expression2.memberName.value);\n    }\n    return false;\n}\nexports.isMatchingExpression = isMatchingExpression;\nfunction isWithinDefaultParamInitializer(node) {\n    let curNode = node;\n    let prevNode;\n    while (curNode) {\n        if (curNode.nodeType === 42 /* Parameter */ && prevNode === curNode.defaultValue) {\n            return true;\n        }\n        if (curNode.nodeType === 31 /* Lambda */ ||\n            curNode.nodeType === 29 /* Function */ ||\n            curNode.nodeType === 10 /* Class */ ||\n            curNode.nodeType === 37 /* Module */) {\n            return false;\n        }\n        prevNode = curNode;\n        curNode = curNode.parent;\n    }\n    return false;\n}\nexports.isWithinDefaultParamInitializer = isWithinDefaultParamInitializer;\nfunction isWithinTypeAnnotation(node, requireQuotedAnnotation) {\n    let curNode = node;\n    let prevNode;\n    let isQuoted = false;\n    while (curNode) {\n        if (curNode.nodeType === 42 /* Parameter */ && prevNode === curNode.typeAnnotation) {\n            return isQuoted || !requireQuotedAnnotation;\n        }\n        if (curNode.nodeType === 29 /* Function */ && prevNode === curNode.returnTypeAnnotation) {\n            return isQuoted || !requireQuotedAnnotation;\n        }\n        if (curNode.nodeType === 55 /* TypeAnnotation */ && prevNode === curNode.typeAnnotation) {\n            return isQuoted || !requireQuotedAnnotation;\n        }\n        if (curNode.nodeType === 3 /* Assignment */ && prevNode === curNode.typeAnnotationComment) {\n            // Type comments are always considered forward declarations even though\n            // they're not \"quoted\".\n            return true;\n        }\n        if (curNode.nodeType === 49 /* StringList */ && prevNode === curNode.typeAnnotation) {\n            isQuoted = true;\n        }\n        if (curNode.nodeType === 31 /* Lambda */ ||\n            curNode.nodeType === 29 /* Function */ ||\n            curNode.nodeType === 10 /* Class */ ||\n            curNode.nodeType === 37 /* Module */) {\n            return false;\n        }\n        prevNode = curNode;\n        curNode = curNode.parent;\n    }\n    return false;\n}\nexports.isWithinTypeAnnotation = isWithinTypeAnnotation;\nfunction getDocString(statements) {\n    // See if the first statement in the suite is a triple-quote string.\n    if (statements.length === 0) {\n        return undefined;\n    }\n    if (statements[0].nodeType !== 48 /* StatementList */) {\n        return undefined;\n    }\n    // If the first statement in the suite isn't a StringNode,\n    // assume there is no docString.\n    const statementList = statements[0];\n    if (statementList.statements.length === 0 || statementList.statements[0].nodeType !== 49 /* StringList */) {\n        return undefined;\n    }\n    const docStringNode = statementList.statements[0];\n    const docStringToken = docStringNode.strings[0].token;\n    // Ignore f-strings.\n    if ((docStringToken.flags & 64 /* Format */) !== 0) {\n        return undefined;\n    }\n    return docStringUtils_1.decodeDocString(docStringNode.strings[0].value);\n}\nexports.getDocString = getDocString;\n// Sometimes a NamedTuple assignment statement is followed by a statement\n// that looks like the following:\n//    MyNamedTuple.__new__.__defaults__ = ...\n// This pattern is commonly used to set the default values that are\n// not specified in the original list.\nfunction isAssignmentToDefaultsFollowingNamedTuple(callNode) {\n    if (callNode.nodeType !== 9 /* Call */ ||\n        !callNode.parent ||\n        callNode.parent.nodeType !== 3 /* Assignment */ ||\n        callNode.parent.leftExpression.nodeType !== 39 /* Name */ ||\n        !callNode.parent.parent ||\n        callNode.parent.parent.nodeType !== 48 /* StatementList */) {\n        return false;\n    }\n    const namedTupleAssignedName = callNode.parent.leftExpression.value;\n    const statementList = callNode.parent.parent;\n    if (statementList.statements[0] !== callNode.parent ||\n        !statementList.parent ||\n        !(statementList.parent.nodeType === 37 /* Module */ ||\n            statementList.parent.nodeType === 51 /* Suite */)) {\n        return false;\n    }\n    const moduleOrSuite = statementList.parent;\n    let statementIndex = moduleOrSuite.statements.findIndex((s) => s === statementList);\n    if (statementIndex < 0) {\n        return false;\n    }\n    statementIndex++;\n    while (statementIndex < moduleOrSuite.statements.length) {\n        const nextStatement = moduleOrSuite.statements[statementIndex];\n        if (nextStatement.nodeType !== 48 /* StatementList */) {\n            break;\n        }\n        if (nextStatement.statements[0].nodeType === 49 /* StringList */) {\n            // Skip over comments\n            statementIndex++;\n            continue;\n        }\n        if (nextStatement.statements[0].nodeType === 3 /* Assignment */) {\n            const assignNode = nextStatement.statements[0];\n            if (assignNode.leftExpression.nodeType === 36 /* MemberAccess */ &&\n                assignNode.leftExpression.memberName.value === '__defaults__') {\n                const defaultTarget = assignNode.leftExpression.leftExpression;\n                if (defaultTarget.nodeType === 36 /* MemberAccess */ &&\n                    defaultTarget.memberName.value === '__new__' &&\n                    defaultTarget.leftExpression.nodeType === 39 /* Name */ &&\n                    defaultTarget.leftExpression.value === namedTupleAssignedName) {\n                    return true;\n                }\n            }\n        }\n        break;\n    }\n    return false;\n}\nexports.isAssignmentToDefaultsFollowingNamedTuple = isAssignmentToDefaultsFollowingNamedTuple;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/parseTreeUtils.ts?");

/***/ }),

/***/ "./src/analyzer/parseTreeWalker.ts":
/*!*****************************************!*\
  !*** ./src/analyzer/parseTreeWalker.ts ***!
  \*****************************************/
/*! flagged exports */
/*! export ParseTreeWalker [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * parseTreeWalker.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Class that traverses a parse tree.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ParseTreeWalker = void 0;\nconst debug_1 = __webpack_require__(/*! ../common/debug */ \"./src/common/debug.ts\");\n// To use this class, create a subclass and override the\n// visitXXX methods that you want to handle.\nclass ParseTreeWalker {\n    walk(node) {\n        const childrenToWalk = this.visitNode(node);\n        if (childrenToWalk.length > 0) {\n            this.walkMultiple(childrenToWalk);\n        }\n    }\n    walkMultiple(nodes) {\n        nodes.forEach((node) => {\n            if (node) {\n                this.walk(node);\n            }\n        });\n    }\n    // Calls the node-specific method (visitXXXX). If the method\n    // returns true, all child nodes for the node are returned.\n    // If the method returns false, we assume that the handler\n    // has already handled the child nodes, so an empty list is\n    // returned.\n    visitNode(node) {\n        switch (node.nodeType) {\n            case 1 /* Argument */:\n                if (this.visitArgument(node)) {\n                    return [node.name, node.valueExpression];\n                }\n                break;\n            case 2 /* Assert */:\n                if (this.visitAssert(node)) {\n                    return [node.testExpression, node.exceptionExpression];\n                }\n                break;\n            case 3 /* Assignment */:\n                if (this.visitAssignment(node)) {\n                    return [node.leftExpression, node.rightExpression, node.typeAnnotationComment];\n                }\n                break;\n            case 4 /* AssignmentExpression */:\n                if (this.visitAssignmentExpression(node)) {\n                    return [node.name, node.rightExpression];\n                }\n                break;\n            case 5 /* AugmentedAssignment */:\n                if (this.visitAugmentedAssignment(node)) {\n                    return [node.leftExpression, node.rightExpression];\n                }\n                break;\n            case 6 /* Await */:\n                if (this.visitAwait(node)) {\n                    return [node.expression];\n                }\n                break;\n            case 7 /* BinaryOperation */:\n                if (this.visitBinaryOperation(node)) {\n                    return [node.leftExpression, node.rightExpression];\n                }\n                break;\n            case 8 /* Break */:\n                if (this.visitBreak(node)) {\n                    return [];\n                }\n                break;\n            case 9 /* Call */:\n                if (this.visitCall(node)) {\n                    return [node.leftExpression, ...node.arguments];\n                }\n                break;\n            case 10 /* Class */:\n                if (this.visitClass(node)) {\n                    return [...node.decorators, node.name, ...node.arguments, node.suite];\n                }\n                break;\n            case 52 /* Ternary */:\n                if (this.visitTernary(node)) {\n                    return [node.ifExpression, node.testExpression, node.elseExpression];\n                }\n                break;\n            case 11 /* Constant */:\n                if (this.visitConstant(node)) {\n                    return [];\n                }\n                break;\n            case 12 /* Continue */:\n                if (this.visitContinue(node)) {\n                    return [];\n                }\n                break;\n            case 13 /* Decorator */:\n                if (this.visitDecorator(node)) {\n                    return [node.leftExpression, ...(node.arguments || [])];\n                }\n                break;\n            case 14 /* Del */:\n                if (this.visitDel(node)) {\n                    return node.expressions;\n                }\n                break;\n            case 15 /* Dictionary */:\n                if (this.visitDictionary(node)) {\n                    return node.entries;\n                }\n                break;\n            case 17 /* DictionaryKeyEntry */:\n                if (this.visitDictionaryKeyEntry(node)) {\n                    return [node.keyExpression, node.valueExpression];\n                }\n                break;\n            case 16 /* DictionaryExpandEntry */:\n                if (this.visitDictionaryExpandEntry(node)) {\n                    return [node.expandExpression];\n                }\n                break;\n            case 0 /* Error */:\n                if (this.visitError(node)) {\n                    return [node.child];\n                }\n                break;\n            case 19 /* If */:\n                if (this.visitIf(node)) {\n                    return [node.testExpression, node.ifSuite, node.elseSuite];\n                }\n                break;\n            case 20 /* Import */:\n                if (this.visitImport(node)) {\n                    return node.list;\n                }\n                break;\n            case 21 /* ImportAs */:\n                if (this.visitImportAs(node)) {\n                    return [node.module, node.alias];\n                }\n                break;\n            case 22 /* ImportFrom */:\n                if (this.visitImportFrom(node)) {\n                    return [node.module, ...node.imports];\n                }\n                break;\n            case 23 /* ImportFromAs */:\n                if (this.visitImportFromAs(node)) {\n                    return [node.name, node.alias];\n                }\n                break;\n            case 24 /* Index */:\n                if (this.visitIndex(node)) {\n                    return [node.baseExpression, node.items];\n                }\n                break;\n            case 25 /* IndexItems */:\n                if (this.visitIndexItems(node)) {\n                    return node.items;\n                }\n                break;\n            case 18 /* Ellipsis */:\n                if (this.visitEllipsis(node)) {\n                    return [];\n                }\n                break;\n            case 26 /* Except */:\n                if (this.visitExcept(node)) {\n                    return [node.typeExpression, node.name, node.exceptSuite];\n                }\n                break;\n            case 27 /* For */:\n                if (this.visitFor(node)) {\n                    return [node.targetExpression, node.iterableExpression, node.forSuite, node.elseSuite];\n                }\n                break;\n            case 28 /* FormatString */:\n                if (this.visitFormatString(node)) {\n                    return node.expressions;\n                }\n                break;\n            case 29 /* Function */:\n                if (this.visitFunction(node)) {\n                    return [...node.decorators, node.name, ...node.parameters, node.returnTypeAnnotation, node.suite];\n                }\n                break;\n            case 30 /* Global */:\n                if (this.visitGlobal(node)) {\n                    return node.nameList;\n                }\n                break;\n            case 31 /* Lambda */:\n                if (this.visitLambda(node)) {\n                    return [...node.parameters, node.expression];\n                }\n                break;\n            case 32 /* List */:\n                if (this.visitList(node)) {\n                    return node.entries;\n                }\n                break;\n            case 33 /* ListComprehension */:\n                if (this.visitListComprehension(node)) {\n                    return [node.expression, ...node.comprehensions];\n                }\n                break;\n            case 34 /* ListComprehensionFor */:\n                if (this.visitListComprehensionFor(node)) {\n                    return [node.targetExpression, node.iterableExpression];\n                }\n                break;\n            case 35 /* ListComprehensionIf */:\n                if (this.visitListComprehensionIf(node)) {\n                    return [node.testExpression];\n                }\n                break;\n            case 36 /* MemberAccess */:\n                if (this.visitMemberAccess(node)) {\n                    return [node.leftExpression, node.memberName];\n                }\n                break;\n            case 37 /* Module */:\n                if (this.visitModule(node)) {\n                    return [...node.statements];\n                }\n                break;\n            case 38 /* ModuleName */:\n                if (this.visitModuleName(node)) {\n                    return node.nameParts;\n                }\n                break;\n            case 39 /* Name */:\n                if (this.visitName(node)) {\n                    return [];\n                }\n                break;\n            case 40 /* Nonlocal */:\n                if (this.visitNonlocal(node)) {\n                    return node.nameList;\n                }\n                break;\n            case 41 /* Number */:\n                if (this.visitNumber(node)) {\n                    return [];\n                }\n                break;\n            case 42 /* Parameter */:\n                if (this.visitParameter(node)) {\n                    return [node.name, node.typeAnnotation, node.defaultValue];\n                }\n                break;\n            case 43 /* Pass */:\n                if (this.visitPass(node)) {\n                    return [];\n                }\n                break;\n            case 44 /* Raise */:\n                if (this.visitRaise(node)) {\n                    return [node.typeExpression, node.valueExpression, node.tracebackExpression];\n                }\n                break;\n            case 45 /* Return */:\n                if (this.visitReturn(node)) {\n                    return [node.returnExpression];\n                }\n                break;\n            case 46 /* Set */:\n                if (this.visitSet(node)) {\n                    return node.entries;\n                }\n                break;\n            case 47 /* Slice */:\n                if (this.visitSlice(node)) {\n                    return [node.startValue, node.endValue, node.stepValue];\n                }\n                break;\n            case 48 /* StatementList */:\n                if (this.visitStatementList(node)) {\n                    return node.statements;\n                }\n                break;\n            case 50 /* String */:\n                if (this.visitString(node)) {\n                    return [];\n                }\n                break;\n            case 49 /* StringList */:\n                if (this.visitStringList(node)) {\n                    return [node.typeAnnotation, ...node.strings];\n                }\n                break;\n            case 51 /* Suite */:\n                if (this.visitSuite(node)) {\n                    return [...node.statements];\n                }\n                break;\n            case 53 /* Tuple */:\n                if (this.visitTuple(node)) {\n                    return node.expressions;\n                }\n                break;\n            case 54 /* Try */:\n                if (this.visitTry(node)) {\n                    return [node.trySuite, ...node.exceptClauses, node.elseSuite, node.finallySuite];\n                }\n                break;\n            case 55 /* TypeAnnotation */:\n                if (this.visitTypeAnnotation(node)) {\n                    return [node.valueExpression, node.typeAnnotation];\n                }\n                break;\n            case 56 /* UnaryOperation */:\n                if (this.visitUnaryOperation(node)) {\n                    return [node.expression];\n                }\n                break;\n            case 57 /* Unpack */:\n                if (this.visitUnpack(node)) {\n                    return [node.expression];\n                }\n                break;\n            case 58 /* While */:\n                if (this.visitWhile(node)) {\n                    return [node.testExpression, node.whileSuite, node.elseSuite];\n                }\n                break;\n            case 59 /* With */:\n                if (this.visitWith(node)) {\n                    return [...node.withItems, node.suite];\n                }\n                break;\n            case 60 /* WithItem */:\n                if (this.visitWithItem(node)) {\n                    return [node.expression, node.target];\n                }\n                break;\n            case 61 /* Yield */:\n                if (this.visitYield(node)) {\n                    return [node.expression];\n                }\n                break;\n            case 62 /* YieldFrom */:\n                if (this.visitYieldFrom(node)) {\n                    return [node.expression];\n                }\n                break;\n            default:\n                debug_1.fail('Unexpected node type');\n                break;\n        }\n        return [];\n    }\n    // Override these methods as necessary.\n    visitArgument(node) {\n        return true;\n    }\n    visitAssert(node) {\n        return true;\n    }\n    visitAssignment(node) {\n        return true;\n    }\n    visitAssignmentExpression(node) {\n        return true;\n    }\n    visitAugmentedAssignment(node) {\n        return true;\n    }\n    visitAwait(node) {\n        return true;\n    }\n    visitBinaryOperation(node) {\n        return true;\n    }\n    visitBreak(node) {\n        return true;\n    }\n    visitCall(node) {\n        return true;\n    }\n    visitClass(node) {\n        return true;\n    }\n    visitTernary(node) {\n        return true;\n    }\n    visitContinue(node) {\n        return true;\n    }\n    visitConstant(node) {\n        return true;\n    }\n    visitDecorator(node) {\n        return true;\n    }\n    visitDel(node) {\n        return true;\n    }\n    visitDictionary(node) {\n        return true;\n    }\n    visitDictionaryKeyEntry(node) {\n        return true;\n    }\n    visitDictionaryExpandEntry(node) {\n        return true;\n    }\n    visitError(node) {\n        return true;\n    }\n    visitEllipsis(node) {\n        return true;\n    }\n    visitIf(node) {\n        return true;\n    }\n    visitImport(node) {\n        return true;\n    }\n    visitImportAs(node) {\n        return true;\n    }\n    visitImportFrom(node) {\n        return true;\n    }\n    visitImportFromAs(node) {\n        return true;\n    }\n    visitIndex(node) {\n        return true;\n    }\n    visitIndexItems(node) {\n        return true;\n    }\n    visitExcept(node) {\n        return true;\n    }\n    visitFor(node) {\n        return true;\n    }\n    visitFormatString(node) {\n        return true;\n    }\n    visitFunction(node) {\n        return true;\n    }\n    visitGlobal(node) {\n        return true;\n    }\n    visitLambda(node) {\n        return true;\n    }\n    visitList(node) {\n        return true;\n    }\n    visitListComprehension(node) {\n        return true;\n    }\n    visitListComprehensionFor(node) {\n        return true;\n    }\n    visitListComprehensionIf(node) {\n        return true;\n    }\n    visitMemberAccess(node) {\n        return true;\n    }\n    visitModule(node) {\n        return true;\n    }\n    visitModuleName(node) {\n        return true;\n    }\n    visitName(node) {\n        return true;\n    }\n    visitNonlocal(node) {\n        return true;\n    }\n    visitNumber(node) {\n        return true;\n    }\n    visitParameter(node) {\n        return true;\n    }\n    visitPass(node) {\n        return true;\n    }\n    visitRaise(node) {\n        return true;\n    }\n    visitReturn(node) {\n        return true;\n    }\n    visitSet(node) {\n        return true;\n    }\n    visitSlice(node) {\n        return true;\n    }\n    visitStatementList(node) {\n        return true;\n    }\n    visitString(node) {\n        return true;\n    }\n    visitStringList(node) {\n        return true;\n    }\n    visitSuite(node) {\n        return true;\n    }\n    visitTuple(node) {\n        return true;\n    }\n    visitTry(node) {\n        return true;\n    }\n    visitTypeAnnotation(node) {\n        return true;\n    }\n    visitUnaryOperation(node) {\n        return true;\n    }\n    visitUnpack(node) {\n        return true;\n    }\n    visitWhile(node) {\n        return true;\n    }\n    visitWith(node) {\n        return true;\n    }\n    visitWithItem(node) {\n        return true;\n    }\n    visitYield(node) {\n        return true;\n    }\n    visitYieldFrom(node) {\n        return true;\n    }\n}\nexports.ParseTreeWalker = ParseTreeWalker;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/parseTreeWalker.ts?");

/***/ }),

/***/ "./src/analyzer/program.ts":
/*!*********************************!*\
  !*** ./src/analyzer/program.ts ***!
  \*********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * program.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * An object that tracks all of the source files being analyzed\n * and all of their recursive imports.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Program = void 0;\nconst vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ \"./node_modules/vscode-languageserver/lib/node/main.js\");\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst console_1 = __webpack_require__(/*! ../common/console */ \"./src/common/console.ts\");\nconst core_1 = __webpack_require__(/*! ../common/core */ \"./src/common/core.ts\");\nconst debug_1 = __webpack_require__(/*! ../common/debug */ \"./src/common/debug.ts\");\nconst logTracker_1 = __webpack_require__(/*! ../common/logTracker */ \"./src/common/logTracker.ts\");\nconst pathUtils_1 = __webpack_require__(/*! ../common/pathUtils */ \"./src/common/pathUtils.ts\");\nconst positionUtils_1 = __webpack_require__(/*! ../common/positionUtils */ \"./src/common/positionUtils.ts\");\nconst textRange_1 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\nconst timing_1 = __webpack_require__(/*! ../common/timing */ \"./src/common/timing.ts\");\nconst autoImporter_1 = __webpack_require__(/*! ../languageService/autoImporter */ \"./src/languageService/autoImporter.ts\");\nconst callHierarchyProvider_1 = __webpack_require__(/*! ../languageService/callHierarchyProvider */ \"./src/languageService/callHierarchyProvider.ts\");\nconst AnalyzerNodeInfo = __webpack_require__(/*! ./analyzerNodeInfo */ \"./src/analyzer/analyzerNodeInfo.ts\");\nconst circularDependency_1 = __webpack_require__(/*! ./circularDependency */ \"./src/analyzer/circularDependency.ts\");\nconst parseTreeUtils_1 = __webpack_require__(/*! ./parseTreeUtils */ \"./src/analyzer/parseTreeUtils.ts\");\nconst scopeUtils_1 = __webpack_require__(/*! ./scopeUtils */ \"./src/analyzer/scopeUtils.ts\");\nconst sourceFile_1 = __webpack_require__(/*! ./sourceFile */ \"./src/analyzer/sourceFile.ts\");\nconst sourceMapper_1 = __webpack_require__(/*! ./sourceMapper */ \"./src/analyzer/sourceMapper.ts\");\nconst typeEvaluator_1 = __webpack_require__(/*! ./typeEvaluator */ \"./src/analyzer/typeEvaluator.ts\");\nconst typeStubWriter_1 = __webpack_require__(/*! ./typeStubWriter */ \"./src/analyzer/typeStubWriter.ts\");\nconst _maxImportDepth = 256;\n// Container for all of the files that are being analyzed. Files\n// can fall into one or more of the following categories:\n//  Tracked - specified by the config options\n//  Referenced - part of the transitive closure\n//  Opened - temporarily opened in the editor\n//  Shadowed - implementation file that shadows a type stub file\nclass Program {\n    constructor(initialImportResolver, initialConfigOptions, console, _extension, logPrefix = 'FG') {\n        this._extension = _extension;\n        this._sourceFileList = [];\n        this._sourceFileMap = new Map();\n        this._lookUpImport = (filePath) => {\n            const sourceFileInfo = this._sourceFileMap.get(filePath);\n            if (!sourceFileInfo) {\n                return undefined;\n            }\n            if (sourceFileInfo.sourceFile.isBindingRequired()) {\n                // Bind the file if it's not already bound. Don't count this time\n                // against the type checker.\n                timing_1.timingStats.typeCheckerTime.subtractFromTime(() => {\n                    this._bindFile(sourceFileInfo);\n                });\n            }\n            const symbolTable = sourceFileInfo.sourceFile.getModuleSymbolTable();\n            if (!symbolTable) {\n                return undefined;\n            }\n            const docString = sourceFileInfo.sourceFile.getModuleDocString();\n            return {\n                symbolTable,\n                docString,\n            };\n        };\n        this._console = console || new console_1.StandardConsole();\n        this._logTracker = new logTracker_1.LogTracker(console, logPrefix);\n        this._importResolver = initialImportResolver;\n        this._configOptions = initialConfigOptions;\n        this._createNewEvaluator();\n    }\n    setConfigOptions(configOptions) {\n        this._configOptions = configOptions;\n        // Create a new evaluator with the updated config options.\n        this._createNewEvaluator();\n    }\n    setImportResolver(importResolver) {\n        this._importResolver = importResolver;\n    }\n    // Sets the list of tracked files that make up the program.\n    setTrackedFiles(filePaths) {\n        if (this._sourceFileList.length > 0) {\n            // We need to determine which files to remove from the existing file list.\n            const newFileMap = new Map();\n            filePaths.forEach((path) => {\n                newFileMap.set(path, path);\n            });\n            // Files that are not in the tracked file list are\n            // marked as no longer tracked.\n            this._sourceFileList.forEach((oldFile) => {\n                const filePath = oldFile.sourceFile.getFilePath();\n                if (!newFileMap.has(filePath)) {\n                    oldFile.isTracked = false;\n                }\n            });\n        }\n        // Add the new files. Only the new items will be added.\n        this.addTrackedFiles(filePaths);\n        return this._removeUnneededFiles();\n    }\n    // By default, no third-party imports are allowed. This enables\n    // third-party imports for a specified import and its children.\n    // For example, if importNames is ['tensorflow'], then third-party\n    // (absolute) imports are allowed for 'import tensorflow',\n    // 'import tensorflow.optimizers', etc.\n    setAllowedThirdPartyImports(importNames) {\n        this._allowedThirdPartyImports = importNames;\n    }\n    addTrackedFiles(filePaths) {\n        filePaths.forEach((filePath) => {\n            this.addTrackedFile(filePath);\n        });\n    }\n    addTrackedFile(filePath) {\n        let sourceFileInfo = this._sourceFileMap.get(filePath);\n        if (sourceFileInfo) {\n            sourceFileInfo.isTracked = true;\n            return sourceFileInfo.sourceFile;\n        }\n        const sourceFile = new sourceFile_1.SourceFile(this._fs, filePath, false, this._console, this._logTracker);\n        sourceFileInfo = {\n            sourceFile,\n            isTracked: true,\n            isOpenByClient: false,\n            isTypeshedFile: false,\n            isThirdPartyImport: false,\n            diagnosticsVersion: undefined,\n            imports: [],\n            importedBy: [],\n            shadows: [],\n            shadowedBy: [],\n        };\n        this._addToSourceFileListAndMap(sourceFileInfo);\n        return sourceFile;\n    }\n    setFileOpened(filePath, version, contents) {\n        let sourceFileInfo = this._sourceFileMap.get(filePath);\n        if (!sourceFileInfo) {\n            const sourceFile = new sourceFile_1.SourceFile(this._fs, filePath, false, this._console, this._logTracker);\n            sourceFileInfo = {\n                sourceFile,\n                isTracked: false,\n                isOpenByClient: true,\n                isTypeshedFile: false,\n                isThirdPartyImport: false,\n                diagnosticsVersion: undefined,\n                imports: [],\n                importedBy: [],\n                shadows: [],\n                shadowedBy: [],\n            };\n            this._addToSourceFileListAndMap(sourceFileInfo);\n        }\n        else {\n            sourceFileInfo.isOpenByClient = true;\n            // Reset the diagnostic version so we force an update\n            // to the diagnostics, which can change based on whether\n            // the file is open.\n            sourceFileInfo.diagnosticsVersion = undefined;\n        }\n        sourceFileInfo.sourceFile.setClientVersion(version, contents);\n    }\n    setFileClosed(filePath) {\n        const sourceFileInfo = this._sourceFileMap.get(filePath);\n        if (sourceFileInfo) {\n            sourceFileInfo.isOpenByClient = false;\n            sourceFileInfo.sourceFile.setClientVersion(null, '');\n        }\n        return this._removeUnneededFiles();\n    }\n    markAllFilesDirty(evenIfContentsAreSame) {\n        const markDirtyMap = new Map();\n        this._sourceFileList.forEach((sourceFileInfo) => {\n            if (evenIfContentsAreSame) {\n                sourceFileInfo.sourceFile.markDirty();\n            }\n            else if (sourceFileInfo.sourceFile.didContentsChangeOnDisk()) {\n                sourceFileInfo.sourceFile.markDirty();\n                // Mark any files that depend on this file as dirty\n                // also. This will retrigger analysis of these other files.\n                this._markFileDirtyRecursive(sourceFileInfo, markDirtyMap);\n            }\n        });\n        if (markDirtyMap.size > 0) {\n            this._createNewEvaluator();\n        }\n    }\n    markFilesDirty(filePaths, evenIfContentsAreSame) {\n        const markDirtyMap = new Map();\n        filePaths.forEach((filePath) => {\n            const sourceFileInfo = this._sourceFileMap.get(filePath);\n            if (sourceFileInfo) {\n                // If !evenIfContentsAreSame, see if the on-disk contents have\n                // changed. If the file is open, the on-disk contents don't matter\n                // because we'll receive updates directly from the client.\n                if (evenIfContentsAreSame ||\n                    (!sourceFileInfo.isOpenByClient && sourceFileInfo.sourceFile.didContentsChangeOnDisk())) {\n                    sourceFileInfo.sourceFile.markDirty();\n                    // Mark any files that depend on this file as dirty\n                    // also. This will retrigger analysis of these other files.\n                    this._markFileDirtyRecursive(sourceFileInfo, markDirtyMap);\n                }\n            }\n        });\n        if (markDirtyMap.size > 0) {\n            this._createNewEvaluator();\n        }\n    }\n    getFileCount() {\n        return this._sourceFileList.length;\n    }\n    getFilesToAnalyzeCount() {\n        let sourceFileCount = 0;\n        this._sourceFileList.forEach((fileInfo) => {\n            if (fileInfo.sourceFile.isParseRequired() ||\n                fileInfo.sourceFile.isBindingRequired() ||\n                fileInfo.sourceFile.isCheckingRequired()) {\n                if (this._shouldCheckFile(fileInfo)) {\n                    sourceFileCount++;\n                }\n            }\n        });\n        return sourceFileCount;\n    }\n    isCheckingOnlyOpenFiles() {\n        return this._configOptions.checkOnlyOpenFiles;\n    }\n    getSourceFile(filePath) {\n        const sourceFileInfo = this._sourceFileMap.get(filePath);\n        if (!sourceFileInfo) {\n            return undefined;\n        }\n        return sourceFileInfo.sourceFile;\n    }\n    getBoundSourceFile(filePath) {\n        const sourceFileInfo = this._sourceFileMap.get(filePath);\n        if (!sourceFileInfo) {\n            return undefined;\n        }\n        this._bindFile(sourceFileInfo);\n        return this.getSourceFile(filePath);\n    }\n    // Performs parsing and analysis of any source files in the program\n    // that require it. If a limit time is specified, the operation\n    // is interrupted when the time expires. The return value indicates\n    // whether the method needs to be called again to complete the\n    // analysis. In interactive mode, the timeout is always limited\n    // to the smaller value to maintain responsiveness.\n    analyze(maxTime, token = vscode_languageserver_1.CancellationToken.None) {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const elapsedTime = new timing_1.Duration();\n            const openFiles = this._sourceFileList.filter((sf) => sf.isOpenByClient && sf.sourceFile.isCheckingRequired());\n            if (openFiles.length > 0) {\n                const effectiveMaxTime = maxTime ? maxTime.openFilesTimeInMs : Number.MAX_VALUE;\n                // Check the open files.\n                for (const sourceFileInfo of openFiles) {\n                    if (this._checkTypes(sourceFileInfo)) {\n                        if (elapsedTime.getDurationInMilliseconds() > effectiveMaxTime) {\n                            return true;\n                        }\n                    }\n                }\n                // If the caller specified a maxTime, return at this point\n                // since we've finalized all open files. We want to get\n                // the results to the user as quickly as possible.\n                if (maxTime !== undefined) {\n                    return true;\n                }\n            }\n            if (!this._configOptions.checkOnlyOpenFiles) {\n                // Do type analysis of remaining files.\n                const allFiles = this._sourceFileList;\n                const effectiveMaxTime = maxTime ? maxTime.noOpenFilesTimeInMs : Number.MAX_VALUE;\n                // Now do type parsing and analysis of the remaining.\n                for (const sourceFileInfo of allFiles) {\n                    if (this._checkTypes(sourceFileInfo)) {\n                        if (elapsedTime.getDurationInMilliseconds() > effectiveMaxTime) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        });\n    }\n    // Prints import dependency information for each of the files in\n    // the program, skipping any typeshed files.\n    printDependencies(projectRootDir, verbose) {\n        const sortedFiles = this._sourceFileList\n            .filter((s) => !s.isTypeshedFile)\n            .sort((a, b) => {\n            return a.sourceFile.getFilePath() < b.sourceFile.getFilePath() ? 1 : -1;\n        });\n        const zeroImportFiles = [];\n        sortedFiles.forEach((sfInfo) => {\n            this._console.info('');\n            let filePath = sfInfo.sourceFile.getFilePath();\n            const relPath = pathUtils_1.getRelativePath(filePath, projectRootDir);\n            if (relPath) {\n                filePath = relPath;\n            }\n            this._console.info(`${filePath}`);\n            this._console.info(` Imports     ${sfInfo.imports.length} ` + `file${sfInfo.imports.length === 1 ? '' : 's'}`);\n            if (verbose) {\n                sfInfo.imports.forEach((importInfo) => {\n                    this._console.info(`    ${importInfo.sourceFile.getFilePath()}`);\n                });\n            }\n            this._console.info(` Imported by ${sfInfo.importedBy.length} ` + `file${sfInfo.importedBy.length === 1 ? '' : 's'}`);\n            if (verbose) {\n                sfInfo.importedBy.forEach((importInfo) => {\n                    this._console.info(`    ${importInfo.sourceFile.getFilePath()}`);\n                });\n            }\n            if (sfInfo.importedBy.length === 0) {\n                zeroImportFiles.push(sfInfo.sourceFile);\n            }\n        });\n        if (zeroImportFiles.length > 0) {\n            this._console.info('');\n            this._console.info(`${zeroImportFiles.length} file${zeroImportFiles.length === 1 ? '' : 's'}` + ` not explicitly imported`);\n            zeroImportFiles.forEach((importFile) => {\n                this._console.info(`    ${importFile.getFilePath()}`);\n            });\n        }\n    }\n    writeTypeStub(targetImportPath, targetIsSingleFile, stubPath, token) {\n        for (const sourceFileInfo of this._sourceFileList) {\n            cancellationUtils_1.throwIfCancellationRequested(token);\n            const filePath = sourceFileInfo.sourceFile.getFilePath();\n            // Generate type stubs only for the files within the target path,\n            // not any files that the target module happened to import.\n            const relativePath = pathUtils_1.getRelativePath(filePath, targetImportPath);\n            if (relativePath !== undefined) {\n                let typeStubPath = pathUtils_1.normalizePath(pathUtils_1.combinePaths(stubPath, relativePath));\n                // If the target is a single file implementation, as opposed to\n                // a package in a directory, transform the name of the type stub\n                // to __init__.pyi because we're placing it in a directory.\n                if (targetIsSingleFile) {\n                    typeStubPath = pathUtils_1.combinePaths(pathUtils_1.getDirectoryPath(typeStubPath), '__init__.pyi');\n                }\n                else {\n                    typeStubPath = pathUtils_1.stripFileExtension(typeStubPath) + '.pyi';\n                }\n                const typeStubDir = pathUtils_1.getDirectoryPath(typeStubPath);\n                try {\n                    pathUtils_1.makeDirectories(this._fs, typeStubDir, stubPath);\n                }\n                catch (e) {\n                    const errMsg = `Could not create directory for '${typeStubDir}'`;\n                    throw new Error(errMsg);\n                }\n                this._bindFile(sourceFileInfo);\n                this._runEvaluatorWithCancellationToken(token, () => {\n                    const writer = new typeStubWriter_1.TypeStubWriter(typeStubPath, sourceFileInfo.sourceFile);\n                    writer.write();\n                });\n            }\n        }\n    }\n    static _getPrintTypeFlags(configOptions) {\n        let flags = 0 /* None */;\n        if (configOptions.diagnosticRuleSet.printUnknownAsAny) {\n            flags |= 1 /* PrintUnknownWithAny */;\n        }\n        if (configOptions.diagnosticRuleSet.omitTypeArgsIfAny) {\n            flags |= 2 /* OmitTypeArgumentsIfAny */;\n        }\n        if (configOptions.diagnosticRuleSet.omitUnannotatedParamType) {\n            flags |= 4 /* OmitUnannotatedParamType */;\n        }\n        if (configOptions.diagnosticRuleSet.pep604Printing) {\n            flags |= 8 /* PEP604 */;\n        }\n        return flags;\n    }\n    get _fs() {\n        return this._importResolver.fileSystem;\n    }\n    // A \"shadowed\" file is a python source file that has been added to the program because\n    // it \"shadows\" a type stub file for purposes of finding doc strings and definitions.\n    // We need to track the relationship so if the original type stub is removed from the\n    // program, we can remove the corresponding shadowed file and any files it imports.\n    _addShadowedFile(stubFile, shadowImplPath) {\n        let shadowFileInfo = this._sourceFileMap.get(shadowImplPath);\n        if (!shadowFileInfo) {\n            const sourceFile = new sourceFile_1.SourceFile(this._fs, shadowImplPath, false, this._console, this._logTracker);\n            shadowFileInfo = {\n                sourceFile,\n                isTracked: false,\n                isOpenByClient: false,\n                isTypeshedFile: false,\n                isThirdPartyImport: false,\n                diagnosticsVersion: undefined,\n                imports: [],\n                importedBy: [],\n                shadows: [],\n                shadowedBy: [],\n            };\n            this._addToSourceFileListAndMap(shadowFileInfo);\n        }\n        if (!shadowFileInfo.shadows.includes(stubFile)) {\n            shadowFileInfo.shadows.push(stubFile);\n        }\n        if (!stubFile.shadowedBy.includes(shadowFileInfo)) {\n            stubFile.shadowedBy.push(shadowFileInfo);\n        }\n        return shadowFileInfo.sourceFile;\n    }\n    _createNewEvaluator() {\n        this._evaluator = typeEvaluator_1.createTypeEvaluator(this._lookUpImport, Program._getPrintTypeFlags(this._configOptions));\n    }\n    _parseFile(fileToParse) {\n        if (!this._isFileNeeded(fileToParse) || !fileToParse.sourceFile.isParseRequired()) {\n            return;\n        }\n        if (fileToParse.sourceFile.parse(this._configOptions, this._importResolver)) {\n            this._updateSourceFileImports(fileToParse, this._configOptions);\n        }\n        if (fileToParse.sourceFile.isFileDeleted()) {\n            fileToParse.isTracked = false;\n            // Mark any files that depend on this file as dirty\n            // also. This will retrigger analysis of these other files.\n            const markDirtyMap = new Map();\n            this._markFileDirtyRecursive(fileToParse, markDirtyMap);\n            // Invalidate the import resolver's cache as well.\n            this._importResolver.invalidateCache();\n        }\n    }\n    // Binds the specified file and all of its dependencies, recursively. If\n    // it runs out of time, it returns true. If it completes, it returns false.\n    _bindFile(fileToAnalyze) {\n        if (!this._isFileNeeded(fileToAnalyze) || !fileToAnalyze.sourceFile.isBindingRequired()) {\n            return;\n        }\n        this._parseFile(fileToAnalyze);\n        // We need to parse and bind the builtins import first.\n        let builtinsScope;\n        if (fileToAnalyze.builtinsImport) {\n            this._bindFile(fileToAnalyze.builtinsImport);\n            // Get the builtins scope to pass to the binding pass.\n            const parseResults = fileToAnalyze.builtinsImport.sourceFile.getParseResults();\n            if (parseResults) {\n                builtinsScope = AnalyzerNodeInfo.getScope(parseResults.parseTree);\n                debug_1.assert(builtinsScope !== undefined);\n            }\n        }\n        fileToAnalyze.sourceFile.bind(this._configOptions, this._lookUpImport, builtinsScope);\n    }\n    // Build a map of all modules within this program and the module-\n    // level scope that contains the symbol table for the module.\n    _buildModuleSymbolsMap(sourceFileToExclude, token) {\n        return autoImporter_1.buildModuleSymbolsMap(this._sourceFileList.filter((s) => s !== sourceFileToExclude), token);\n    }\n    _shouldCheckFile(fileInfo) {\n        // Always do a full checking for a file that's open in the editor.\n        if (fileInfo.isOpenByClient) {\n            return true;\n        }\n        // If the file isn't currently open, only perform full checking for\n        // files that are tracked, and only if the checkOnlyOpenFiles is disabled.\n        if (!this._configOptions.checkOnlyOpenFiles && fileInfo.isTracked) {\n            return true;\n        }\n        return false;\n    }\n    _checkTypes(fileToCheck) {\n        return this._logTracker.log(`analyzing: ${fileToCheck.sourceFile.getFilePath()}`, (ls) => {\n            // If the file isn't needed because it was eliminated from the\n            // transitive closure or deleted, skip the file rather than wasting\n            // time on it.\n            if (!this._isFileNeeded(fileToCheck)) {\n                ls.add(`analysis not needed`);\n                return false;\n            }\n            if (!fileToCheck.sourceFile.isCheckingRequired()) {\n                ls.add(`cache hit`);\n                return false;\n            }\n            if (!this._shouldCheckFile(fileToCheck)) {\n                ls.add(`analysis not needed`);\n                return false;\n            }\n            this._bindFile(fileToCheck);\n            // For very large programs, we may need to discard the evaluator and\n            // its cached types to avoid running out of heap space.\n            const typeCacheSize = this._evaluator.getTypeCacheSize();\n            // If the type cache size has exceeded a high-water mark, query the heap usage.\n            // Don't bother doing this until we hit this point because the heap usage may not\n            // drop immediately after we empty the cache due to garbage collection timing.\n            if (typeCacheSize > 750000) {\n                const heapSizeInMb = Math.round(process.memoryUsage().heapUsed / (1024 * 1024));\n                // Don't allow the heap to get close to the 2GB limit imposed by\n                // the OS when running Node in a 32-bit process.\n                if (heapSizeInMb > 1536) {\n                    this._console.info(`Emptying type cache to avoid heap overflow. Heap size used: ${heapSizeInMb}MB`);\n                    this._createNewEvaluator();\n                }\n            }\n            fileToCheck.sourceFile.check(this._evaluator);\n            // Detect import cycles that involve the file.\n            if (this._configOptions.diagnosticRuleSet.reportImportCycles !== 'none') {\n                // Don't detect import cycles when doing type stub generation. Some\n                // third-party modules are pretty convoluted.\n                if (!this._allowedThirdPartyImports) {\n                    // We need to force all of the files to be parsed and build\n                    // a closure map for the files.\n                    const closureMap = new Map();\n                    this._getImportsRecursive(fileToCheck, closureMap, 0);\n                    closureMap.forEach((file) => {\n                        timing_1.timingStats.cycleDetectionTime.timeOperation(() => {\n                            this._detectAndReportImportCycles(file);\n                        });\n                    });\n                }\n            }\n            return true;\n        });\n    }\n    // Builds a map of files that includes the specified file and all of the files\n    // it imports (recursively) and ensures that all such files. If any of these files\n    // have already been checked (they and their recursive imports have completed the\n    // check phase), they are not included in the results.\n    _getImportsRecursive(file, closureMap, recursionCount) {\n        // If the file is already in the closure map, we found a cyclical\n        // dependency. Don't recur further.\n        const filePath = file.sourceFile.getFilePath();\n        if (closureMap.has(filePath)) {\n            return;\n        }\n        // If the import chain is too long, emit an error. Otherwise we\n        // risk blowing the stack.\n        if (recursionCount > _maxImportDepth) {\n            file.sourceFile.setHitMaxImportDepth(_maxImportDepth);\n            return;\n        }\n        // Add the file to the closure map.\n        closureMap.set(filePath, file);\n        // Recursively add the file's imports.\n        for (const importedFileInfo of file.imports) {\n            this._getImportsRecursive(importedFileInfo, closureMap, recursionCount + 1);\n        }\n    }\n    _detectAndReportImportCycles(sourceFileInfo, dependencyChain = [], dependencyMap = new Map()) {\n        // Don't bother checking for typestub files or third-party files.\n        if (sourceFileInfo.sourceFile.isStubFile() || sourceFileInfo.isThirdPartyImport) {\n            return;\n        }\n        const filePath = sourceFileInfo.sourceFile.getFilePath();\n        if (dependencyMap.has(filePath)) {\n            // Look for chains at least two in length. A file that contains\n            // an \"import . from X\" will technically create a cycle with\n            // itself, but those are not interesting to report.\n            if (dependencyChain.length > 1 && sourceFileInfo === dependencyChain[0]) {\n                this._logImportCycle(dependencyChain);\n            }\n        }\n        else {\n            // If we've already checked this dependency along\n            // some other path, we can skip it.\n            if (dependencyMap.has(filePath)) {\n                return;\n            }\n            // We use both a map (for fast lookups) and a list\n            // (for ordering information). Set the dependency map\n            // entry to true to indicate that we're actively exploring\n            // that dependency.\n            dependencyMap.set(filePath, true);\n            dependencyChain.push(sourceFileInfo);\n            for (const imp of sourceFileInfo.imports) {\n                this._detectAndReportImportCycles(imp, dependencyChain, dependencyMap);\n            }\n            // Set the dependencyMap entry to false to indicate that we have\n            // already explored this file and don't need to explore it again.\n            dependencyMap.set(filePath, false);\n            dependencyChain.pop();\n        }\n    }\n    _logImportCycle(dependencyChain) {\n        const circDep = new circularDependency_1.CircularDependency();\n        dependencyChain.forEach((sourceFileInfo) => {\n            circDep.appendPath(sourceFileInfo.sourceFile.getFilePath());\n        });\n        circDep.normalizeOrder();\n        const firstFilePath = circDep.getPaths()[0];\n        const firstSourceFile = this._sourceFileMap.get(firstFilePath);\n        debug_1.assert(firstSourceFile !== undefined);\n        firstSourceFile.sourceFile.addCircularDependency(circDep);\n    }\n    _markFileDirtyRecursive(sourceFileInfo, markMap) {\n        const filePath = sourceFileInfo.sourceFile.getFilePath();\n        // Don't mark it again if it's already been visited.\n        if (!markMap.has(filePath)) {\n            sourceFileInfo.sourceFile.markReanalysisRequired();\n            markMap.set(filePath, true);\n            sourceFileInfo.importedBy.forEach((dep) => {\n                this._markFileDirtyRecursive(dep, markMap);\n            });\n        }\n    }\n    getAutoImports(filePath, range, similarityLimit, nameMap, importMap, token) {\n        const sourceFileInfo = this._sourceFileMap.get(filePath);\n        if (!sourceFileInfo) {\n            return [];\n        }\n        const sourceFile = sourceFileInfo.sourceFile;\n        const fileContents = sourceFile.getFileContents();\n        if (!fileContents) {\n            // this only works with opened file\n            return [];\n        }\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            this._bindFile(sourceFileInfo);\n            const parseTree = sourceFile.getParseResults();\n            const textRange = positionUtils_1.convertRangeToTextRange(range, parseTree.tokenizerOutput.lines);\n            if (!textRange) {\n                return [];\n            }\n            const currentNode = parseTreeUtils_1.findNodeByOffset(parseTree.parseTree, textRange.start);\n            if (!currentNode) {\n                return [];\n            }\n            const writtenWord = fileContents.substr(textRange.start, textRange.length);\n            const map = this._buildModuleSymbolsMap(sourceFileInfo, token);\n            const autoImporter = new autoImporter_1.AutoImporter(this._configOptions, sourceFile.getFilePath(), this._importResolver, parseTree, map, importMap);\n            // Filter out any name that is already defined in the current scope.\n            const results = [];\n            const currentScope = scopeUtils_1.getScopeForNode(currentNode);\n            if (currentScope) {\n                const translatedWord = nameMap === null || nameMap === void 0 ? void 0 : nameMap.get(writtenWord);\n                if (translatedWord) {\n                    // No filter is needed since we only do exact match.\n                    const exactMatch = 1;\n                    results.push(...autoImporter.getAutoImportCandidates(translatedWord, exactMatch, [], writtenWord, token));\n                }\n                results.push(...autoImporter\n                    .getAutoImportCandidates(writtenWord, similarityLimit, [], undefined, token)\n                    .filter((r) => !currentScope.lookUpSymbolRecursive(r.name)));\n            }\n            return results;\n        });\n    }\n    getDiagnostics(options) {\n        const fileDiagnostics = this._removeUnneededFiles();\n        this._sourceFileList.forEach((sourceFileInfo) => {\n            if (this._shouldCheckFile(sourceFileInfo)) {\n                const diagnostics = sourceFileInfo.sourceFile.getDiagnostics(options, sourceFileInfo.diagnosticsVersion);\n                if (diagnostics !== undefined) {\n                    fileDiagnostics.push({\n                        filePath: sourceFileInfo.sourceFile.getFilePath(),\n                        diagnostics,\n                    });\n                    // Update the cached diagnosticsVersion so we can determine\n                    // whether there are any updates next time we call getDiagnostics.\n                    sourceFileInfo.diagnosticsVersion = sourceFileInfo.sourceFile.getDiagnosticVersion();\n                }\n            }\n            else if (!sourceFileInfo.isOpenByClient &&\n                options.checkOnlyOpenFiles &&\n                sourceFileInfo.diagnosticsVersion !== undefined) {\n                // This condition occurs when the user switches from workspace to\n                // \"open files only\" mode. Clear all diagnostics for this file.\n                fileDiagnostics.push({\n                    filePath: sourceFileInfo.sourceFile.getFilePath(),\n                    diagnostics: [],\n                });\n                sourceFileInfo.diagnosticsVersion = undefined;\n            }\n        });\n        return fileDiagnostics;\n    }\n    getDiagnosticsForRange(filePath, range) {\n        const sourceFile = this.getSourceFile(filePath);\n        if (!sourceFile) {\n            return [];\n        }\n        const unfilteredDiagnostics = sourceFile.getDiagnostics(this._configOptions);\n        if (!unfilteredDiagnostics) {\n            return [];\n        }\n        return unfilteredDiagnostics.filter((diag) => {\n            return textRange_1.doRangesIntersect(diag.range, range);\n        });\n    }\n    getDefinitionsForPosition(filePath, position, token) {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const sourceFileInfo = this._sourceFileMap.get(filePath);\n            if (!sourceFileInfo) {\n                return undefined;\n            }\n            this._bindFile(sourceFileInfo);\n            const execEnv = this._configOptions.findExecEnvironment(filePath);\n            return sourceFileInfo.sourceFile.getDefinitionsForPosition(this._createSourceMapper(execEnv), position, this._evaluator, token);\n        });\n    }\n    getReferencesForPosition(filePath, position, includeDeclaration, token) {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const sourceFileInfo = this._sourceFileMap.get(filePath);\n            if (!sourceFileInfo) {\n                return undefined;\n            }\n            const invokedFromUserFile = this._isUserCode(sourceFileInfo);\n            this._bindFile(sourceFileInfo);\n            const execEnv = this._configOptions.findExecEnvironment(filePath);\n            const referencesResult = sourceFileInfo.sourceFile.getDeclarationForPosition(this._createSourceMapper(execEnv), position, this._evaluator, token);\n            if (!referencesResult) {\n                return undefined;\n            }\n            // Do we need to do a global search as well?\n            if (referencesResult.requiresGlobalSearch) {\n                for (const curSourceFileInfo of this._sourceFileList) {\n                    cancellationUtils_1.throwIfCancellationRequested(token);\n                    // \"Find all references\" will only include references from user code\n                    // unless the file is explicitly opened in the editor or it is invoked from non user files.\n                    if (curSourceFileInfo.isOpenByClient ||\n                        !invokedFromUserFile ||\n                        this._isUserCode(curSourceFileInfo)) {\n                        this._bindFile(curSourceFileInfo);\n                        curSourceFileInfo.sourceFile.addReferences(referencesResult, includeDeclaration, this._evaluator, token);\n                    }\n                }\n                // Make sure to include declarations regardless where they are defined\n                // if includeDeclaration is set.\n                if (includeDeclaration) {\n                    for (const decl of referencesResult.declarations) {\n                        cancellationUtils_1.throwIfCancellationRequested(token);\n                        if (referencesResult.locations.some((l) => l.path === decl.path)) {\n                            // Already included.\n                            continue;\n                        }\n                        const declFileInfo = this._sourceFileMap.get(decl.path);\n                        if (!declFileInfo) {\n                            // The file the declaration belongs to doesn't belong to the program.\n                            continue;\n                        }\n                        const tempResult = {\n                            requiresGlobalSearch: referencesResult.requiresGlobalSearch,\n                            nodeAtOffset: referencesResult.nodeAtOffset,\n                            symbolName: referencesResult.symbolName,\n                            declarations: referencesResult.declarations,\n                            locations: [],\n                        };\n                        declFileInfo.sourceFile.addReferences(tempResult, includeDeclaration, this._evaluator, token);\n                        for (const loc of tempResult.locations) {\n                            // Include declarations only. And throw away any references\n                            if (loc.path === decl.path && textRange_1.doesRangeContain(decl.range, loc.range)) {\n                                referencesResult.locations.push(loc);\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                sourceFileInfo.sourceFile.addReferences(referencesResult, includeDeclaration, this._evaluator, token);\n            }\n            return referencesResult.locations;\n        });\n    }\n    addSymbolsForDocument(filePath, symbolList, token) {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const sourceFileInfo = this._sourceFileMap.get(filePath);\n            if (sourceFileInfo) {\n                this._bindFile(sourceFileInfo);\n                sourceFileInfo.sourceFile.addHierarchicalSymbolsForDocument(symbolList, this._evaluator, token);\n            }\n        });\n    }\n    addSymbolsForWorkspace(symbolList, query, token) {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            // Don't do a search if the query is empty. We'll return\n            // too many results in this case.\n            if (!query) {\n                return;\n            }\n            for (const sourceFileInfo of this._sourceFileList) {\n                this._bindFile(sourceFileInfo);\n                sourceFileInfo.sourceFile.addSymbolsForDocument(symbolList, this._evaluator, query, token);\n            }\n        });\n    }\n    getHoverForPosition(filePath, position, token) {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const sourceFileInfo = this._sourceFileMap.get(filePath);\n            if (!sourceFileInfo) {\n                return undefined;\n            }\n            this._bindFile(sourceFileInfo);\n            const execEnv = this._configOptions.findExecEnvironment(filePath);\n            return sourceFileInfo.sourceFile.getHoverForPosition(this._createSourceMapper(execEnv), position, this._evaluator, token);\n        });\n    }\n    getDocumentHighlight(filePath, position, token) {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const sourceFileInfo = this._sourceFileMap.get(filePath);\n            if (!sourceFileInfo) {\n                return undefined;\n            }\n            this._bindFile(sourceFileInfo);\n            const execEnv = this._configOptions.findExecEnvironment(filePath);\n            return sourceFileInfo.sourceFile.getDocumentHighlight(this._createSourceMapper(execEnv), position, this._evaluator, token);\n        });\n    }\n    getSignatureHelpForPosition(filePath, position, token) {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const sourceFileInfo = this._sourceFileMap.get(filePath);\n            if (!sourceFileInfo) {\n                return undefined;\n            }\n            this._bindFile(sourceFileInfo);\n            return sourceFileInfo.sourceFile.getSignatureHelpForPosition(position, this._lookUpImport, this._evaluator, token);\n        });\n    }\n    getCompletionsForPosition(filePath, position, workspacePath, token) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const sourceFileInfo = this._sourceFileMap.get(filePath);\n            if (!sourceFileInfo) {\n                return undefined;\n            }\n            let completionList = this._runEvaluatorWithCancellationToken(token, () => {\n                this._bindFile(sourceFileInfo);\n                const execEnv = this._configOptions.findExecEnvironment(filePath);\n                return sourceFileInfo.sourceFile.getCompletionsForPosition(position, workspacePath, this._configOptions, this._importResolver, this._lookUpImport, this._evaluator, this._createSourceMapper(execEnv), () => this._buildModuleSymbolsMap(sourceFileInfo, token), token);\n            });\n            if (!completionList || !((_a = this._extension) === null || _a === void 0 ? void 0 : _a.completionListExtension)) {\n                return completionList;\n            }\n            const pr = sourceFileInfo.sourceFile.getParseResults();\n            const content = sourceFileInfo.sourceFile.getFileContents();\n            if ((pr === null || pr === void 0 ? void 0 : pr.parseTree) && content) {\n                const offset = positionUtils_1.convertPositionToOffset(position, pr.tokenizerOutput.lines);\n                if (offset !== undefined) {\n                    completionList = yield this._extension.completionListExtension.updateCompletionList(completionList, pr.parseTree, content, offset, this._configOptions, token);\n                }\n            }\n            return completionList;\n        });\n    }\n    resolveCompletionItem(filePath, completionItem, token) {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const sourceFileInfo = this._sourceFileMap.get(filePath);\n            if (!sourceFileInfo) {\n                return;\n            }\n            this._bindFile(sourceFileInfo);\n            const execEnv = this._configOptions.findExecEnvironment(filePath);\n            sourceFileInfo.sourceFile.resolveCompletionItem(this._configOptions, this._importResolver, this._lookUpImport, this._evaluator, this._createSourceMapper(execEnv), () => this._buildModuleSymbolsMap(sourceFileInfo, token), completionItem, token);\n        });\n    }\n    renameSymbolAtPosition(filePath, position, newName, token) {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const sourceFileInfo = this._sourceFileMap.get(filePath);\n            if (!sourceFileInfo) {\n                return undefined;\n            }\n            this._bindFile(sourceFileInfo);\n            const execEnv = this._configOptions.findExecEnvironment(filePath);\n            const referencesResult = sourceFileInfo.sourceFile.getDeclarationForPosition(this._createSourceMapper(execEnv), position, this._evaluator, token);\n            if (!referencesResult) {\n                return undefined;\n            }\n            if (referencesResult.declarations.some((d) => !this._isUserCode(this._sourceFileMap.get(d.path)))) {\n                // Some declarations come from non-user code, so do not allow rename\n                return undefined;\n            }\n            if (referencesResult.declarations.length === 0) {\n                // There is no symbol we can rename\n                return undefined;\n            }\n            // Do we need to do a global search as well?\n            if (referencesResult.requiresGlobalSearch) {\n                for (const curSourceFileInfo of this._sourceFileList) {\n                    // Make sure we only add user code to the references to prevent us\n                    // from accidentally changing third party library or type stub.\n                    if (this._isUserCode(curSourceFileInfo)) {\n                        this._bindFile(curSourceFileInfo);\n                        curSourceFileInfo.sourceFile.addReferences(referencesResult, true, this._evaluator, token);\n                    }\n                }\n            }\n            else if (this._isUserCode(sourceFileInfo)) {\n                sourceFileInfo.sourceFile.addReferences(referencesResult, true, this._evaluator, token);\n            }\n            const editActions = [];\n            referencesResult.locations.forEach((loc) => {\n                editActions.push({\n                    filePath: loc.path,\n                    range: loc.range,\n                    replacementText: newName,\n                });\n            });\n            return editActions;\n        });\n    }\n    getCallForPosition(filePath, position, token) {\n        const sourceFileInfo = this._sourceFileMap.get(filePath);\n        if (!sourceFileInfo) {\n            return undefined;\n        }\n        this._bindFile(sourceFileInfo);\n        const execEnv = this._configOptions.findExecEnvironment(filePath);\n        const referencesResult = sourceFileInfo.sourceFile.getDeclarationForPosition(this._createSourceMapper(execEnv), position, this._evaluator, token);\n        if (!referencesResult || referencesResult.declarations.length === 0) {\n            return undefined;\n        }\n        const targetDecl = callHierarchyProvider_1.CallHierarchyProvider.getTargetDeclaration(referencesResult.declarations, referencesResult.nodeAtOffset);\n        return callHierarchyProvider_1.CallHierarchyProvider.getCallForDeclaration(referencesResult.symbolName, targetDecl, this._evaluator, token);\n    }\n    getIncomingCallsForPosition(filePath, position, token) {\n        const sourceFileInfo = this._sourceFileMap.get(filePath);\n        if (!sourceFileInfo) {\n            return undefined;\n        }\n        this._bindFile(sourceFileInfo);\n        const execEnv = this._configOptions.findExecEnvironment(filePath);\n        const referencesResult = sourceFileInfo.sourceFile.getDeclarationForPosition(this._createSourceMapper(execEnv), position, this._evaluator, token);\n        if (!referencesResult || referencesResult.declarations.length === 0) {\n            return undefined;\n        }\n        const targetDecl = callHierarchyProvider_1.CallHierarchyProvider.getTargetDeclaration(referencesResult.declarations, referencesResult.nodeAtOffset);\n        let items = [];\n        for (const curSourceFileInfo of this._sourceFileList) {\n            if (this._isUserCode(curSourceFileInfo) || curSourceFileInfo.isOpenByClient) {\n                this._bindFile(curSourceFileInfo);\n                const itemsToAdd = callHierarchyProvider_1.CallHierarchyProvider.getIncomingCallsForDeclaration(curSourceFileInfo.sourceFile.getFilePath(), referencesResult.symbolName, targetDecl, curSourceFileInfo.sourceFile.getParseResults(), this._evaluator, token);\n                if (itemsToAdd) {\n                    items = items.concat(...itemsToAdd);\n                }\n            }\n        }\n        return items;\n    }\n    getOutgoingCallsForPosition(filePath, position, token) {\n        const sourceFileInfo = this._sourceFileMap.get(filePath);\n        if (!sourceFileInfo) {\n            return undefined;\n        }\n        this._bindFile(sourceFileInfo);\n        const execEnv = this._configOptions.findExecEnvironment(filePath);\n        const referencesResult = sourceFileInfo.sourceFile.getDeclarationForPosition(this._createSourceMapper(execEnv), position, this._evaluator, token);\n        if (!referencesResult || referencesResult.declarations.length === 0) {\n            return undefined;\n        }\n        const targetDecl = callHierarchyProvider_1.CallHierarchyProvider.getTargetDeclaration(referencesResult.declarations, referencesResult.nodeAtOffset);\n        return callHierarchyProvider_1.CallHierarchyProvider.getOutgoingCallsForDeclaration(targetDecl, sourceFileInfo.sourceFile.getParseResults(), this._evaluator, token);\n    }\n    performQuickAction(filePath, command, args, token) {\n        const sourceFileInfo = this._sourceFileMap.get(filePath);\n        if (!sourceFileInfo) {\n            return undefined;\n        }\n        this._bindFile(sourceFileInfo);\n        return sourceFileInfo.sourceFile.performQuickAction(command, args, token);\n    }\n    _isUserCode(fileInfo) {\n        return fileInfo && fileInfo.isTracked && !fileInfo.isThirdPartyImport && !fileInfo.isTypeshedFile;\n    }\n    // Wrapper function that should be used when invoking this._evaluator\n    // with a cancellation token. It handles cancellation exceptions and\n    // any other unexpected exceptions.\n    _runEvaluatorWithCancellationToken(token, callback) {\n        try {\n            // Don't support cancellation in debug mode because cancellation\n            // checks and exceptions interfere with debugging.\n            if (token && !core_1.isDebugMode()) {\n                return this._evaluator.runWithCancellationToken(token, callback);\n            }\n            else {\n                return callback();\n            }\n        }\n        catch (e) {\n            // An unexpected exception occurred, potentially leaving the current evaluator\n            // in an inconsistent state. Discard it and replace it with a fresh one. It is\n            // Cancellation exceptions are known to handle this correctly.\n            if (!(e instanceof cancellationUtils_1.OperationCanceledException)) {\n                this._createNewEvaluator();\n            }\n            throw e;\n        }\n    }\n    // Returns a list of empty file diagnostic entries for the files\n    // that have been removed. This is needed to clear out the\n    // errors for files that have been deleted or closed.\n    _removeUnneededFiles() {\n        const fileDiagnostics = [];\n        // If a file is no longer tracked, opened or shadowed, it can\n        // be removed from the program.\n        for (let i = 0; i < this._sourceFileList.length;) {\n            const fileInfo = this._sourceFileList[i];\n            if (!this._isFileNeeded(fileInfo)) {\n                fileDiagnostics.push({\n                    filePath: fileInfo.sourceFile.getFilePath(),\n                    diagnostics: [],\n                });\n                fileInfo.sourceFile.prepareForClose();\n                this._sourceFileMap.delete(fileInfo.sourceFile.getFilePath());\n                this._sourceFileList.splice(i, 1);\n                // Unlink any imports and remove them from the list if\n                // they are no longer referenced.\n                fileInfo.imports.forEach((importedFile) => {\n                    const indexToRemove = importedFile.importedBy.findIndex((fi) => fi === fileInfo);\n                    debug_1.assert(indexToRemove >= 0);\n                    importedFile.importedBy.splice(indexToRemove, 1);\n                    // See if we need to remove the imported file because it\n                    // is no longer needed. If its index is >= i, it will be\n                    // removed when we get to it.\n                    if (!this._isFileNeeded(importedFile)) {\n                        const indexToRemove = this._sourceFileList.findIndex((fi) => fi === importedFile);\n                        if (indexToRemove >= 0 && indexToRemove < i) {\n                            fileDiagnostics.push({\n                                filePath: importedFile.sourceFile.getFilePath(),\n                                diagnostics: [],\n                            });\n                            importedFile.sourceFile.prepareForClose();\n                            this._sourceFileMap.delete(importedFile.sourceFile.getFilePath());\n                            this._sourceFileList.splice(indexToRemove, 1);\n                            i--;\n                        }\n                    }\n                });\n                // Remove any shadowed files corresponding to this file.\n                fileInfo.shadowedBy.forEach((shadowedFile) => {\n                    shadowedFile.shadows = shadowedFile.shadows.filter((f) => f !== fileInfo);\n                });\n                fileInfo.shadowedBy = [];\n            }\n            else {\n                // If we're showing the user errors only for open files, clear\n                // out the errors for the now-closed file.\n                if (!this._shouldCheckFile(fileInfo) && fileInfo.diagnosticsVersion !== undefined) {\n                    fileDiagnostics.push({\n                        filePath: fileInfo.sourceFile.getFilePath(),\n                        diagnostics: [],\n                    });\n                    fileInfo.diagnosticsVersion = undefined;\n                }\n                i++;\n            }\n        }\n        return fileDiagnostics;\n    }\n    _isFileNeeded(fileInfo) {\n        if (fileInfo.sourceFile.isFileDeleted()) {\n            return false;\n        }\n        if (fileInfo.isTracked || fileInfo.isOpenByClient) {\n            return true;\n        }\n        if (fileInfo.shadows.length > 0) {\n            return true;\n        }\n        if (fileInfo.importedBy.length === 0) {\n            return false;\n        }\n        // It's possible for a cycle of files to be imported\n        // by a tracked file but then abandoned. The import cycle\n        // will keep the entire group \"alive\" if we don't detect\n        // the condition and garbage collect them.\n        return this._isImportNeededRecursive(fileInfo, new Map());\n    }\n    _isImportNeededRecursive(fileInfo, recursionMap) {\n        if (fileInfo.isTracked || fileInfo.isOpenByClient || fileInfo.shadows.length > 0) {\n            return true;\n        }\n        const filePath = fileInfo.sourceFile.getFilePath();\n        // Avoid infinite recursion.\n        if (recursionMap.has(filePath)) {\n            return false;\n        }\n        recursionMap.set(filePath, true);\n        for (const importerInfo of fileInfo.importedBy) {\n            if (this._isImportNeededRecursive(importerInfo, recursionMap)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _createSourceMapper(execEnv) {\n        const sourceMapper = new sourceMapper_1.SourceMapper(this._importResolver, execEnv, this._evaluator, (stubFilePath, implFilePath) => {\n            const stubFileInfo = this._sourceFileMap.get(stubFilePath);\n            if (!stubFileInfo) {\n                return undefined;\n            }\n            this._addShadowedFile(stubFileInfo, implFilePath);\n            return this.getBoundSourceFile(implFilePath);\n        });\n        return sourceMapper;\n    }\n    _isImportAllowed(importer, importResult, isImportStubFile) {\n        // Don't import native libs. We don't want to track these files,\n        // and we definitely don't want to attempt to parse them.\n        if (importResult.isNativeLib) {\n            return false;\n        }\n        let thirdPartyImportAllowed = this._configOptions.useLibraryCodeForTypes;\n        if (importResult.importType === 1 /* ThirdParty */ ||\n            (importer.isThirdPartyImport && importResult.importType === 2 /* Local */)) {\n            if (this._allowedThirdPartyImports) {\n                if (importResult.isRelative) {\n                    // If it's a relative import, we'll allow it because the\n                    // importer was already deemed to be allowed.\n                    thirdPartyImportAllowed = true;\n                }\n                else if (this._allowedThirdPartyImports.some((importName) => {\n                    // If this import name is the one that was explicitly\n                    // allowed or is a child of that import name,\n                    // it's considered allowed.\n                    if (importResult.importName === importName) {\n                        return true;\n                    }\n                    if (importResult.importName.startsWith(importName + '.')) {\n                        return true;\n                    }\n                    return false;\n                })) {\n                    thirdPartyImportAllowed = true;\n                }\n            }\n            // Some libraries ship with stub files that import from non-stubs. Don't\n            // explore those.\n            // Don't explore any third-party files unless they're type stub files\n            // or we've been told explicitly that third-party imports are OK.\n            if (!isImportStubFile) {\n                return thirdPartyImportAllowed;\n            }\n        }\n        return true;\n    }\n    _updateSourceFileImports(sourceFileInfo, options) {\n        const filesAdded = [];\n        // Get the new list of imports and see if it changed from the last\n        // list of imports for this file.\n        const imports = sourceFileInfo.sourceFile.getImports();\n        // Create a map of unique imports, since imports can appear more than once.\n        const newImportPathMap = new Map();\n        imports.forEach((importResult) => {\n            if (importResult.isImportFound) {\n                if (this._isImportAllowed(sourceFileInfo, importResult, importResult.isStubFile)) {\n                    if (importResult.resolvedPaths.length > 0) {\n                        const filePath = importResult.resolvedPaths[importResult.resolvedPaths.length - 1];\n                        if (filePath) {\n                            newImportPathMap.set(filePath, {\n                                isTypeshedFile: !!importResult.isTypeshedFile,\n                                isThirdPartyImport: importResult.importType === 1 /* ThirdParty */ ||\n                                    (sourceFileInfo.isThirdPartyImport && importResult.importType === 2 /* Local */),\n                            });\n                        }\n                    }\n                }\n                importResult.implicitImports.forEach((implicitImport) => {\n                    if (this._isImportAllowed(sourceFileInfo, importResult, implicitImport.isStubFile)) {\n                        newImportPathMap.set(implicitImport.path, {\n                            isTypeshedFile: !!importResult.isTypeshedFile,\n                            isThirdPartyImport: importResult.importType === 1 /* ThirdParty */ ||\n                                (sourceFileInfo.isThirdPartyImport && importResult.importType === 2 /* Local */),\n                        });\n                    }\n                });\n            }\n            else if (options.verboseOutput) {\n                this._console.info(`Could not import '${importResult.importName}' ` +\n                    `in file '${sourceFileInfo.sourceFile.getFilePath()}'`);\n                if (importResult.importFailureInfo) {\n                    importResult.importFailureInfo.forEach((diag) => {\n                        this._console.info(`  ${diag}`);\n                    });\n                }\n            }\n        });\n        const updatedImportMap = new Map();\n        sourceFileInfo.imports.forEach((importInfo) => {\n            const oldFilePath = importInfo.sourceFile.getFilePath();\n            // A previous import was removed.\n            if (!newImportPathMap.has(oldFilePath)) {\n                importInfo.importedBy = importInfo.importedBy.filter((fi) => fi.sourceFile.getFilePath() !== sourceFileInfo.sourceFile.getFilePath());\n            }\n            else {\n                updatedImportMap.set(oldFilePath, importInfo);\n            }\n        });\n        // See if there are any new imports to be added.\n        newImportPathMap.forEach((importInfo, importPath) => {\n            if (!updatedImportMap.has(importPath)) {\n                // We found a new import to add. See if it's already part\n                // of the program.\n                let importedFileInfo;\n                if (this._sourceFileMap.has(importPath)) {\n                    importedFileInfo = this._sourceFileMap.get(importPath);\n                }\n                else {\n                    const sourceFile = new sourceFile_1.SourceFile(this._fs, importPath, importInfo.isThirdPartyImport, this._console, this._logTracker);\n                    importedFileInfo = {\n                        sourceFile,\n                        isTracked: false,\n                        isOpenByClient: false,\n                        isTypeshedFile: importInfo.isTypeshedFile,\n                        isThirdPartyImport: importInfo.isThirdPartyImport,\n                        diagnosticsVersion: undefined,\n                        imports: [],\n                        importedBy: [],\n                        shadows: [],\n                        shadowedBy: [],\n                    };\n                    this._addToSourceFileListAndMap(importedFileInfo);\n                    filesAdded.push(importedFileInfo);\n                }\n                importedFileInfo.importedBy.push(sourceFileInfo);\n                updatedImportMap.set(importPath, importedFileInfo);\n            }\n        });\n        // Update the imports list. It should now map the set of imports\n        // specified by the source file.\n        sourceFileInfo.imports = [];\n        newImportPathMap.forEach((_, path) => {\n            if (this._sourceFileMap.has(path)) {\n                sourceFileInfo.imports.push(this._sourceFileMap.get(path));\n            }\n        });\n        // Resolve the builtins import for the file. This needs to be\n        // analyzed before the file can be analyzed.\n        sourceFileInfo.builtinsImport = undefined;\n        const builtinsImport = sourceFileInfo.sourceFile.getBuiltinsImport();\n        if (builtinsImport) {\n            const resolvedBuiltinsPath = builtinsImport.resolvedPaths[builtinsImport.resolvedPaths.length - 1];\n            sourceFileInfo.builtinsImport = this._sourceFileMap.get(resolvedBuiltinsPath);\n        }\n        return filesAdded;\n    }\n    _addToSourceFileListAndMap(fileInfo) {\n        const filePath = fileInfo.sourceFile.getFilePath();\n        // We should never add a file with the same path twice.\n        debug_1.assert(!this._sourceFileMap.has(filePath));\n        this._sourceFileList.push(fileInfo);\n        this._sourceFileMap.set(filePath, fileInfo);\n    }\n}\nexports.Program = Program;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/program.ts?");

/***/ }),

/***/ "./src/analyzer/pythonPathUtils.ts":
/*!*****************************************!*\
  !*** ./src/analyzer/pythonPathUtils.ts ***!
  \*****************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export findPythonSearchPaths [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getPythonPathFromPythonInterpreter [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getTypeShedFallbackPath [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getTypeshedSubdirectory [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * pythonPathUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Utility routines used to resolve various paths in python.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getPythonPathFromPythonInterpreter = exports.findPythonSearchPaths = exports.getTypeshedSubdirectory = exports.getTypeShedFallbackPath = void 0;\nconst child_process = __webpack_require__(/*! child_process */ \"child_process\");\nconst pathConsts = __webpack_require__(/*! ../common/pathConsts */ \"./src/common/pathConsts.ts\");\nconst pathUtils_1 = __webpack_require__(/*! ../common/pathUtils */ \"./src/common/pathUtils.ts\");\nconst cachedSearchPaths = new Map();\nfunction getTypeShedFallbackPath(fs) {\n    let moduleDirectory = fs.getModulePath();\n    if (!moduleDirectory) {\n        return undefined;\n    }\n    moduleDirectory = pathUtils_1.getDirectoryPath(pathUtils_1.ensureTrailingDirectorySeparator(pathUtils_1.normalizePath(moduleDirectory)));\n    const typeshedPath = pathUtils_1.combinePaths(moduleDirectory, pathConsts.typeshedFallback);\n    if (fs.existsSync(typeshedPath)) {\n        return typeshedPath;\n    }\n    // In the debug version of Pyright, the code is one level\n    // deeper, so we need to look one level up for the typeshed fallback.\n    const debugTypeshedPath = pathUtils_1.combinePaths(pathUtils_1.getDirectoryPath(moduleDirectory), pathConsts.typeshedFallback);\n    if (fs.existsSync(debugTypeshedPath)) {\n        return debugTypeshedPath;\n    }\n    return undefined;\n}\nexports.getTypeShedFallbackPath = getTypeShedFallbackPath;\nfunction getTypeshedSubdirectory(typeshedPath, isStdLib) {\n    return pathUtils_1.combinePaths(typeshedPath, isStdLib ? 'stdlib' : 'third_party');\n}\nexports.getTypeshedSubdirectory = getTypeshedSubdirectory;\nfunction findPythonSearchPaths(fs, configOptions, venv, importFailureInfo, includeWatchPathsOnly, workspaceRoot) {\n    importFailureInfo.push('Finding python search paths');\n    let venvPath;\n    if (venv !== undefined) {\n        if (configOptions.venvPath) {\n            venvPath = pathUtils_1.combinePaths(configOptions.venvPath, venv);\n        }\n    }\n    else if (configOptions.defaultVenv) {\n        if (configOptions.venvPath) {\n            venvPath = pathUtils_1.combinePaths(configOptions.venvPath, configOptions.defaultVenv);\n        }\n    }\n    if (venvPath) {\n        let libPath = pathUtils_1.combinePaths(venvPath, pathConsts.lib);\n        if (fs.existsSync(libPath)) {\n            importFailureInfo.push(`Found path '${libPath}'; looking for ${pathConsts.sitePackages}`);\n        }\n        else {\n            importFailureInfo.push(`Did not find '${libPath}'; trying 'Lib' instead`);\n            libPath = pathUtils_1.combinePaths(venvPath, 'Lib');\n            if (fs.existsSync(libPath)) {\n                importFailureInfo.push(`Found path '${libPath}'; looking for ${pathConsts.sitePackages}`);\n            }\n            else {\n                importFailureInfo.push(`Did not find '${libPath}'`);\n                libPath = '';\n            }\n        }\n        if (libPath) {\n            const sitePackagesPath = pathUtils_1.combinePaths(libPath, pathConsts.sitePackages);\n            if (fs.existsSync(sitePackagesPath)) {\n                importFailureInfo.push(`Found path '${sitePackagesPath}'`);\n                return [sitePackagesPath];\n            }\n            else {\n                importFailureInfo.push(`Did not find '${sitePackagesPath}', so looking for python subdirectory`);\n            }\n            // We didn't find a site-packages directory directly in the lib\n            // directory. Scan for a \"python*\" directory instead.\n            const entries = pathUtils_1.getFileSystemEntries(fs, libPath);\n            for (let i = 0; i < entries.directories.length; i++) {\n                const dirName = entries.directories[i];\n                if (dirName.startsWith('python')) {\n                    const dirPath = pathUtils_1.combinePaths(libPath, dirName, pathConsts.sitePackages);\n                    if (fs.existsSync(dirPath)) {\n                        importFailureInfo.push(`Found path '${dirPath}'`);\n                        return [dirPath];\n                    }\n                    else {\n                        importFailureInfo.push(`Path '${dirPath}' is not a valid directory`);\n                    }\n                }\n            }\n        }\n        importFailureInfo.push(`Did not find '${pathConsts.sitePackages}'. Falling back on python interpreter.`);\n    }\n    // Fall back on the python interpreter.\n    const pathResult = getPythonPathFromPythonInterpreter(fs, configOptions.pythonPath, importFailureInfo);\n    if (includeWatchPathsOnly && workspaceRoot) {\n        const paths = pathResult.paths.filter((p) => !pathUtils_1.containsPath(workspaceRoot, p, true) || pathUtils_1.containsPath(pathResult.prefix, p, true));\n        return paths;\n    }\n    return pathResult.paths;\n}\nexports.findPythonSearchPaths = findPythonSearchPaths;\nfunction getPathResultFromInterpreter(fs, interpreter, importFailureInfo) {\n    const result = {\n        paths: [],\n        prefix: '',\n    };\n    try {\n        const commandLineArgs = [\n            '-c',\n            'import sys, json; json.dump(dict(path=sys.path, prefix=sys.prefix), sys.stdout)',\n        ];\n        importFailureInfo.push(`Executing interpreter: '${interpreter}'`);\n        const execOutput = child_process.execFileSync(interpreter, commandLineArgs, { encoding: 'utf8' });\n        // Parse the execOutput. It should be a JSON-encoded array of paths.\n        try {\n            const execSplit = JSON.parse(execOutput);\n            for (let execSplitEntry of execSplit.path) {\n                execSplitEntry = execSplitEntry.trim();\n                if (execSplitEntry) {\n                    const normalizedPath = pathUtils_1.normalizePath(execSplitEntry);\n                    // Make sure the path exists and is a directory. We don't currently\n                    // support zip files and other formats.\n                    if (fs.existsSync(normalizedPath) && pathUtils_1.isDirectory(fs, normalizedPath)) {\n                        result.paths.push(normalizedPath);\n                    }\n                    else {\n                        importFailureInfo.push(`Skipping '${normalizedPath}' because it is not a valid directory`);\n                    }\n                }\n            }\n            result.prefix = execSplit.prefix;\n            if (result.paths.length === 0) {\n                importFailureInfo.push(`Found no valid directories`);\n            }\n        }\n        catch (err) {\n            importFailureInfo.push(`Could not parse output: '${execOutput}'`);\n            throw err;\n        }\n    }\n    catch (_a) {\n        return undefined;\n    }\n    return result;\n}\nfunction getPythonPathFromPythonInterpreter(fs, interpreterPath, importFailureInfo) {\n    const searchKey = interpreterPath || '';\n    // If we've seen this request before, return the cached results.\n    const cachedPath = cachedSearchPaths.get(searchKey);\n    if (cachedPath) {\n        return cachedPath;\n    }\n    let result;\n    if (interpreterPath) {\n        result = getPathResultFromInterpreter(fs, interpreterPath, importFailureInfo);\n    }\n    else {\n        // On non-Windows platforms, always default to python3 first. We want to\n        // avoid this on Windows because it might invoke a script that displays\n        // a dialog box indicating that python can be downloaded from the app store.\n        if (process.platform !== 'win32') {\n            result = getPathResultFromInterpreter(fs, 'python3', importFailureInfo);\n        }\n        // On some platforms, 'python3' might not exist. Try 'python' instead.\n        if (!result) {\n            result = getPathResultFromInterpreter(fs, 'python', importFailureInfo);\n        }\n    }\n    if (!result) {\n        result = {\n            paths: [],\n            prefix: '',\n        };\n    }\n    cachedSearchPaths.set(searchKey, result);\n    importFailureInfo.push(`Received ${result.paths.length} paths from interpreter`);\n    result.paths.forEach((path) => {\n        importFailureInfo.push(`  ${path}`);\n    });\n    return result;\n}\nexports.getPythonPathFromPythonInterpreter = getPythonPathFromPythonInterpreter;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/pythonPathUtils.ts?");

/***/ }),

/***/ "./src/analyzer/scope.ts":
/*!*******************************!*\
  !*** ./src/analyzer/scope.ts ***!
  \*******************************/
/*! flagged exports */
/*! export Scope [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * scope.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Represents an evaluation scope and its defined symbols.\n * It also contains a link to a parent scope (except for the\n * top-most built-in scope).\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Scope = void 0;\nconst debug_1 = __webpack_require__(/*! ../common/debug */ \"./src/common/debug.ts\");\nconst symbol_1 = __webpack_require__(/*! ./symbol */ \"./src/analyzer/symbol.ts\");\nclass Scope {\n    constructor(type, parent) {\n        // Association between names and symbols.\n        this.symbolTable = new Map();\n        this.type = type;\n        this.parent = parent;\n    }\n    getGlobalScope() {\n        let curScope = this;\n        while (curScope) {\n            if (curScope.type === 3 /* Module */ || curScope.type === 4 /* Builtin */) {\n                return curScope;\n            }\n            curScope = curScope.parent;\n        }\n        debug_1.fail('failed to find scope');\n        return this;\n    }\n    // Independently-executable scopes are those that are executed independently\n    // of their parent scopes. Classes are executed in the context of their parent\n    // scope, so they don't fit this category.\n    isIndependentlyExecutable() {\n        return this.type === 3 /* Module */ || this.type === 1 /* Function */;\n    }\n    lookUpSymbol(name) {\n        return this.symbolTable.get(name);\n    }\n    lookUpSymbolRecursive(name) {\n        return this._lookUpSymbolRecursiveInternal(name, \n        /* isOutsideCallerModule */ false, \n        /* isBeyondExecutionScope */ false);\n    }\n    addSymbol(name, flags) {\n        const symbol = new symbol_1.Symbol(flags);\n        this.symbolTable.set(name, symbol);\n        return symbol;\n    }\n    _lookUpSymbolRecursiveInternal(name, isOutsideCallerModule, isBeyondExecutionScope) {\n        const symbol = this.symbolTable.get(name);\n        if (symbol) {\n            // If we're searching outside of the original caller's module (global) scope,\n            // hide any names that are not meant to be visible to importers.\n            if (isOutsideCallerModule && symbol.isExternallyHidden()) {\n                return undefined;\n            }\n            // If the symbol is a class variable that is defined only in terms of\n            // member accesses, it is not accessible directly by name, so hide it.\n            const decls = symbol.getDeclarations();\n            if (decls.length === 0 ||\n                decls.some((decl) => decl.type !== 1 /* Variable */ || !decl.isDefinedByMemberAccess)) {\n                return {\n                    symbol,\n                    isOutsideCallerModule,\n                    isBeyondExecutionScope,\n                    scope: this,\n                };\n            }\n        }\n        if (this.parent) {\n            // If our recursion is about to take us outside the scope of the current\n            // module (i.e. into a built-in scope), indicate as such with the second\n            // parameter.\n            return this.parent._lookUpSymbolRecursiveInternal(name, isOutsideCallerModule || this.type === 3 /* Module */, isBeyondExecutionScope || this.isIndependentlyExecutable());\n        }\n        return undefined;\n    }\n}\nexports.Scope = Scope;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/scope.ts?");

/***/ }),

/***/ "./src/analyzer/scopeUtils.ts":
/*!************************************!*\
  !*** ./src/analyzer/scopeUtils.ts ***!
  \************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getBuiltInScope [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getScopeForNode [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * scopeUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Static utility methods related to scopes and their related\n * symbol tables.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getScopeForNode = exports.getBuiltInScope = void 0;\nconst analyzerNodeInfo_1 = __webpack_require__(/*! ./analyzerNodeInfo */ \"./src/analyzer/analyzerNodeInfo.ts\");\nconst parseTreeUtils_1 = __webpack_require__(/*! ./parseTreeUtils */ \"./src/analyzer/parseTreeUtils.ts\");\nfunction getBuiltInScope(currentScope) {\n    // Starting at the current scope, find the built-in scope, which should\n    // be the top-most parent.\n    let builtInScope = currentScope;\n    while (builtInScope.type !== 4 /* Builtin */) {\n        builtInScope = builtInScope.parent;\n    }\n    return builtInScope;\n}\nexports.getBuiltInScope = getBuiltInScope;\n// Locates the evaluation scope associated with the specified parse node.\nfunction getScopeForNode(node) {\n    const scopeNode = parseTreeUtils_1.getEvaluationScopeNode(node);\n    return analyzerNodeInfo_1.getScope(scopeNode);\n}\nexports.getScopeForNode = getScopeForNode;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/scopeUtils.ts?");

/***/ }),

/***/ "./src/analyzer/service.ts":
/*!*********************************!*\
  !*** ./src/analyzer/service.ts ***!
  \*********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * service.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * A persistent service that is able to analyze a collection of\n * Python files.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AnalyzerService = exports.configFileNames = void 0;\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst configOptions_1 = __webpack_require__(/*! ../common/configOptions */ \"./src/common/configOptions.ts\");\nconst console_1 = __webpack_require__(/*! ../common/console */ \"./src/common/console.ts\");\nconst pathUtils_1 = __webpack_require__(/*! ../common/pathUtils */ \"./src/common/pathUtils.ts\");\nconst timing_1 = __webpack_require__(/*! ../common/timing */ \"./src/common/timing.ts\");\nconst backgroundAnalysisProgram_1 = __webpack_require__(/*! ./backgroundAnalysisProgram */ \"./src/analyzer/backgroundAnalysisProgram.ts\");\nconst importResolver_1 = __webpack_require__(/*! ./importResolver */ \"./src/analyzer/importResolver.ts\");\nconst pythonPathUtils_1 = __webpack_require__(/*! ./pythonPathUtils */ \"./src/analyzer/pythonPathUtils.ts\");\nexports.configFileNames = ['pyrightconfig.json', 'mspythonconfig.json'];\n// How long since the last user activity should we wait until running\n// the analyzer on any files that have not yet been analyzed?\nconst _userActivityBackoffTimeInMs = 250;\nclass AnalyzerService {\n    constructor(instanceName, fs, console, importResolverFactory, configOptions, extension, backgroundAnalysis, maxAnalysisTime) {\n        this._typeStubTargetIsSingleFile = false;\n        this._requireTrackedFileUpdate = true;\n        this._lastUserInteractionTime = Date.now();\n        this._disposed = false;\n        this._instanceName = instanceName;\n        this._console = console || new console_1.StandardConsole();\n        this._executionRootPath = '';\n        this._extension = extension;\n        this._importResolverFactory = importResolverFactory || AnalyzerService.createImportResolver;\n        this._maxAnalysisTimeInForeground = maxAnalysisTime;\n        configOptions = configOptions !== null && configOptions !== void 0 ? configOptions : new configOptions_1.ConfigOptions(process.cwd());\n        const importResolver = this._importResolverFactory(fs, configOptions);\n        this._backgroundAnalysisProgram = new backgroundAnalysisProgram_1.BackgroundAnalysisProgram(this._console, configOptions, importResolver, this._extension, backgroundAnalysis, this._maxAnalysisTimeInForeground);\n    }\n    clone(instanceName, backgroundAnalysis) {\n        return new AnalyzerService(instanceName, this._fs, this._console, this._importResolverFactory, this._backgroundAnalysisProgram.configOptions, this._extension, backgroundAnalysis, this._maxAnalysisTimeInForeground);\n    }\n    dispose() {\n        this._disposed = true;\n        this._removeSourceFileWatchers();\n        this._removeConfigFileWatcher();\n        this._removeLibraryFileWatcher();\n        this._clearReloadConfigTimer();\n        this._clearReanalysisTimer();\n        this._clearLibraryReanalysisTimer();\n    }\n    static createImportResolver(fs, options) {\n        return new importResolver_1.ImportResolver(fs, options);\n    }\n    setCompletionCallback(callback) {\n        this._onCompletionCallback = callback;\n        this._backgroundAnalysisProgram.setCompletionCallback(callback);\n    }\n    setOptions(commandLineOptions, reanalyze = true) {\n        this._commandLineOptions = commandLineOptions;\n        const configOptions = this._getConfigOptions(commandLineOptions);\n        if (configOptions.pythonPath) {\n            // Make sure we have default python environment set.\n            configOptions.ensureDefaultPythonVersion(configOptions.pythonPath, this._console);\n        }\n        configOptions.ensureDefaultPythonPlatform(this._console);\n        this._backgroundAnalysisProgram.setConfigOptions(configOptions);\n        this._executionRootPath = pathUtils_1.normalizePath(pathUtils_1.combinePaths(commandLineOptions.executionRoot, configOptions.projectRoot));\n        this._applyConfigOptions(reanalyze);\n    }\n    setFileOpened(path, version, contents) {\n        this._backgroundAnalysisProgram.setFileOpened(path, version, contents);\n        this._scheduleReanalysis(false);\n    }\n    updateOpenFileContents(path, version, contents) {\n        this._backgroundAnalysisProgram.updateOpenFileContents(path, version, contents);\n        this._scheduleReanalysis(false);\n    }\n    setFileClosed(path) {\n        this._backgroundAnalysisProgram.setFileClosed(path);\n        this._scheduleReanalysis(false);\n    }\n    getParseResult(path) {\n        var _a;\n        return (_a = this._program.getBoundSourceFile(path)) === null || _a === void 0 ? void 0 : _a.getParseResults();\n    }\n    getAutoImports(filePath, range, similarityLimit, nameMap, importMap, token) {\n        return this._program.getAutoImports(filePath, range, similarityLimit, nameMap, importMap, token);\n    }\n    getDefinitionForPosition(filePath, position, token) {\n        return this._program.getDefinitionsForPosition(filePath, position, token);\n    }\n    getReferencesForPosition(filePath, position, includeDeclaration, token) {\n        return this._program.getReferencesForPosition(filePath, position, includeDeclaration, token);\n    }\n    addSymbolsForDocument(filePath, symbolList, token) {\n        this._program.addSymbolsForDocument(filePath, symbolList, token);\n    }\n    addSymbolsForWorkspace(symbolList, query, token) {\n        this._program.addSymbolsForWorkspace(symbolList, query, token);\n    }\n    getHoverForPosition(filePath, position, token) {\n        return this._program.getHoverForPosition(filePath, position, token);\n    }\n    getDocumentHighlight(filePath, position, token) {\n        return this._program.getDocumentHighlight(filePath, position, token);\n    }\n    getSignatureHelpForPosition(filePath, position, token) {\n        return this._program.getSignatureHelpForPosition(filePath, position, token);\n    }\n    getCompletionsForPosition(filePath, position, workspacePath, token) {\n        return this._program.getCompletionsForPosition(filePath, position, workspacePath, token);\n    }\n    resolveCompletionItem(filePath, completionItem, token) {\n        this._program.resolveCompletionItem(filePath, completionItem, token);\n    }\n    performQuickAction(filePath, command, args, token) {\n        return this._program.performQuickAction(filePath, command, args, token);\n    }\n    renameSymbolAtPosition(filePath, position, newName, token) {\n        return this._program.renameSymbolAtPosition(filePath, position, newName, token);\n    }\n    getCallForPosition(filePath, position, token) {\n        return this._program.getCallForPosition(filePath, position, token);\n    }\n    getIncomingCallsForPosition(filePath, position, token) {\n        return this._program.getIncomingCallsForPosition(filePath, position, token);\n    }\n    getOutgoingCallsForPosition(filePath, position, token) {\n        return this._program.getOutgoingCallsForPosition(filePath, position, token);\n    }\n    printStats() {\n        this._console.info('');\n        this._console.info('Analysis stats');\n        const fileCount = this._program.getFileCount();\n        this._console.info('Total files analyzed: ' + fileCount.toString());\n    }\n    printDependencies(verbose) {\n        this._program.printDependencies(this._executionRootPath, verbose);\n    }\n    getDiagnosticsForRange(filePath, range, token) {\n        return this._backgroundAnalysisProgram.getDiagnosticsForRange(filePath, range, token);\n    }\n    getConfigOptions() {\n        return this._configOptions;\n    }\n    getImportResolver() {\n        return this._backgroundAnalysisProgram.importResolver;\n    }\n    recordUserInteractionTime() {\n        this._lastUserInteractionTime = Date.now();\n        // If we have a pending timer for reanalysis, cancel it\n        // and reschedule for some time in the future.\n        if (this._analyzeTimer) {\n            this._scheduleReanalysis(false);\n        }\n    }\n    // test only APIs\n    get test_program() {\n        return this._program;\n    }\n    test_getConfigOptions(commandLineOptions) {\n        return this._getConfigOptions(commandLineOptions);\n    }\n    test_getFileNamesFromFileSpecs() {\n        return this._getFileNamesFromFileSpecs();\n    }\n    // Calculates the effective options based on the command-line options,\n    // an optional config file, and default values.\n    _getConfigOptions(commandLineOptions) {\n        var _a;\n        let projectRoot = commandLineOptions.executionRoot;\n        let configFilePath;\n        if (commandLineOptions.fileSpecs && commandLineOptions.fileSpecs.length > 0) {\n            // If file specs were passed in to the command line, no config file\n            // will be used. In this case, all file specs are assumed to be\n            // relative to the current working directory.\n            if (commandLineOptions.configFilePath) {\n                this._console.info('Project cannot be mixed with source files on a command line.');\n            }\n        }\n        else if (commandLineOptions.configFilePath) {\n            // If the config file path was specified, determine whether it's\n            // a directory (in which case the default config file name is assumed)\n            // or a file.\n            configFilePath = pathUtils_1.combinePaths(commandLineOptions.executionRoot, pathUtils_1.normalizePath(commandLineOptions.configFilePath));\n            if (!this._fs.existsSync(configFilePath)) {\n                this._console.info(`Configuration file not found at ${configFilePath}.`);\n                configFilePath = commandLineOptions.executionRoot;\n            }\n            else {\n                if (configFilePath.toLowerCase().endsWith('.json')) {\n                    projectRoot = pathUtils_1.getDirectoryPath(configFilePath);\n                }\n                else {\n                    projectRoot = configFilePath;\n                    configFilePath = this._findConfigFile(configFilePath);\n                    if (!configFilePath) {\n                        this._console.info(`Configuration file not found at ${projectRoot}.`);\n                    }\n                }\n            }\n        }\n        else if (projectRoot) {\n            configFilePath = this._findConfigFileHereOrUp(projectRoot);\n            if (configFilePath) {\n                projectRoot = pathUtils_1.getDirectoryPath(configFilePath);\n            }\n            else {\n                this._console.info(`No configuration file found.`);\n                configFilePath = undefined;\n            }\n        }\n        const configOptions = new configOptions_1.ConfigOptions(projectRoot, this._typeCheckingMode);\n        const defaultExcludes = ['**/node_modules', '**/__pycache__', '.git'];\n        if (commandLineOptions.fileSpecs.length > 0) {\n            commandLineOptions.fileSpecs.forEach((fileSpec) => {\n                configOptions.include.push(pathUtils_1.getFileSpec(projectRoot, fileSpec));\n            });\n        }\n        else if (!configFilePath) {\n            // If no config file was found and there are no explicit include\n            // paths specified, assume the caller wants to include all source\n            // files under the execution root path.\n            if (commandLineOptions.executionRoot) {\n                configOptions.include.push(pathUtils_1.getFileSpec(commandLineOptions.executionRoot, '.'));\n                // Add a few common excludes to avoid long scan times.\n                defaultExcludes.forEach((exclude) => {\n                    configOptions.exclude.push(pathUtils_1.getFileSpec(commandLineOptions.executionRoot, exclude));\n                });\n            }\n        }\n        this._configFilePath = configFilePath;\n        // If we found a config file, parse it to compute the effective options.\n        if (configFilePath) {\n            this._console.info(`Loading configuration file at ${configFilePath}`);\n            const configJsonObj = this._parseConfigFile(configFilePath);\n            if (configJsonObj) {\n                configOptions.initializeFromJson(configJsonObj, this._typeCheckingMode, this._console, commandLineOptions.diagnosticSeverityOverrides, commandLineOptions.pythonPath);\n                const configFileDir = pathUtils_1.getDirectoryPath(configFilePath);\n                // If no include paths were provided, assume that all files within\n                // the project should be included.\n                if (configOptions.include.length === 0) {\n                    this._console.info(`No include entries specified; assuming ${configFileDir}`);\n                    configOptions.include.push(pathUtils_1.getFileSpec(configFileDir, '.'));\n                }\n                // If there was no explicit set of excludes, add a few common ones to avoid long scan times.\n                if (configOptions.exclude.length === 0) {\n                    defaultExcludes.forEach((exclude) => {\n                        this._console.info(`Auto-excluding ${exclude}`);\n                        configOptions.exclude.push(pathUtils_1.getFileSpec(configFileDir, exclude));\n                    });\n                    if (configOptions.autoExcludeVenv === undefined) {\n                        configOptions.autoExcludeVenv = true;\n                    }\n                }\n                // If the user has defined execution environments, then we ignore\n                // autoSearchPaths, extraPaths and leave it up to them to set\n                // extraPaths on the execution environments.\n                if (configOptions.executionEnvironments.length === 0) {\n                    configOptions.addExecEnvironmentForExtraPaths(this._fs, commandLineOptions.autoSearchPaths || false, commandLineOptions.extraPaths || []);\n                }\n            }\n            this._updateLibraryFileWatcher();\n        }\n        else {\n            configOptions.addExecEnvironmentForExtraPaths(this._fs, commandLineOptions.autoSearchPaths || false, commandLineOptions.extraPaths || []);\n            configOptions.autoExcludeVenv = true;\n            configOptions.applyDiagnosticOverrides(commandLineOptions.diagnosticSeverityOverrides);\n        }\n        const reportDuplicateSetting = (settingName) => {\n            const settingSource = commandLineOptions.fromVsCodeExtension\n                ? 'the VS Code settings'\n                : 'a command-line option';\n            this._console.warn(`The ${settingName} has been specified in both the config file and ` +\n                `${settingSource}. The value in the config file (${configOptions.venvPath}) ` +\n                `will take precedence`);\n        };\n        // Apply the command-line options if the corresponding\n        // item wasn't already set in the config file. Report any\n        // duplicates.\n        if (commandLineOptions.venvPath) {\n            if (!configOptions.venvPath) {\n                configOptions.venvPath = commandLineOptions.venvPath;\n            }\n            else {\n                reportDuplicateSetting('venvPath');\n            }\n        }\n        if (commandLineOptions.pythonPath) {\n            this._console.info(`Setting pythonPath for service \"${this._instanceName}\": ` + `\"${commandLineOptions.pythonPath}\"`);\n            configOptions.pythonPath = commandLineOptions.pythonPath;\n        }\n        if (commandLineOptions.typeshedPath) {\n            if (!configOptions.typeshedPath) {\n                configOptions.typeshedPath = commandLineOptions.typeshedPath;\n            }\n            else {\n                reportDuplicateSetting('typeshedPath');\n            }\n        }\n        configOptions.verboseOutput = !!commandLineOptions.verboseOutput;\n        configOptions.checkOnlyOpenFiles = !!commandLineOptions.checkOnlyOpenFiles;\n        configOptions.useLibraryCodeForTypes = !!commandLineOptions.useLibraryCodeForTypes;\n        configOptions.autoImportCompletions = !!commandLineOptions.autoImportCompletions;\n        // If there was no stub path specified, use a default path.\n        if (commandLineOptions.stubPath) {\n            if (!configOptions.stubPath) {\n                configOptions.stubPath = commandLineOptions.stubPath;\n            }\n            else {\n                reportDuplicateSetting('stubPath');\n            }\n        }\n        else {\n            if (!configOptions.stubPath) {\n                configOptions.stubPath = pathUtils_1.normalizePath(pathUtils_1.combinePaths(configOptions.projectRoot, 'typings'));\n            }\n        }\n        // Do some sanity checks on the specified settings and report missing\n        // or inconsistent information.\n        if (configOptions.venvPath) {\n            if (!this._fs.existsSync(configOptions.venvPath) || !pathUtils_1.isDirectory(this._fs, configOptions.venvPath)) {\n                this._console.error(`venvPath ${configOptions.venvPath} is not a valid directory.`);\n            }\n            // venvPath without defaultVenv means it won't do anything while resolveImport.\n            // so first, try to set defaultVenv from existing configOption if it is null. if both are null,\n            // then, resolveImport won't consider venv\n            configOptions.defaultVenv = (_a = configOptions.defaultVenv) !== null && _a !== void 0 ? _a : this._configOptions.defaultVenv;\n            if (configOptions.defaultVenv) {\n                const fullVenvPath = pathUtils_1.combinePaths(configOptions.venvPath, configOptions.defaultVenv);\n                if (!this._fs.existsSync(fullVenvPath) || !pathUtils_1.isDirectory(this._fs, fullVenvPath)) {\n                    this._console.error(`venv ${configOptions.defaultVenv} subdirectory not found ` +\n                        `in venv path ${configOptions.venvPath}.`);\n                }\n                else {\n                    const importFailureInfo = [];\n                    if (pythonPathUtils_1.findPythonSearchPaths(this._fs, configOptions, undefined, importFailureInfo) === undefined) {\n                        this._console.error(`site-packages directory cannot be located for venvPath ` +\n                            `${configOptions.venvPath} and venv ${configOptions.defaultVenv}.`);\n                        if (configOptions.verboseOutput) {\n                            importFailureInfo.forEach((diag) => {\n                                this._console.error(`  ${diag}`);\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            const importFailureInfo = [];\n            const pythonPaths = pythonPathUtils_1.getPythonPathFromPythonInterpreter(this._fs, configOptions.pythonPath, importFailureInfo).paths;\n            if (pythonPaths.length === 0) {\n                if (configOptions.verboseOutput) {\n                    this._console.error(`No search paths found for configured python interpreter.`);\n                }\n            }\n            else {\n                if (configOptions.verboseOutput) {\n                    this._console.info(`Search paths found for configured python interpreter:`);\n                    pythonPaths.forEach((path) => {\n                        this._console.info(`  ${path}`);\n                    });\n                }\n            }\n            if (configOptions.verboseOutput) {\n                if (importFailureInfo.length > 0) {\n                    this._console.info(`When attempting to get search paths from python interpreter:`);\n                    importFailureInfo.forEach((diag) => {\n                        this._console.info(`  ${diag}`);\n                    });\n                }\n            }\n        }\n        // Is there a reference to a venv? If so, there needs to be a valid venvPath.\n        if (configOptions.defaultVenv || configOptions.executionEnvironments.find((e) => !!e.venv)) {\n            if (!configOptions.venvPath) {\n                this._console.warn(`venvPath not specified, so venv settings will be ignored.`);\n            }\n        }\n        if (configOptions.typeshedPath) {\n            if (!this._fs.existsSync(configOptions.typeshedPath) ||\n                !pathUtils_1.isDirectory(this._fs, configOptions.typeshedPath)) {\n                this._console.error(`typeshedPath ${configOptions.typeshedPath} is not a valid directory.`);\n            }\n        }\n        if (configOptions.stubPath) {\n            if (!this._fs.existsSync(configOptions.stubPath) || !pathUtils_1.isDirectory(this._fs, configOptions.stubPath)) {\n                this._console.error(`stubPath ${configOptions.stubPath} is not a valid directory.`);\n            }\n        }\n        return configOptions;\n    }\n    writeTypeStub(token) {\n        const typingsSubdirPath = this._getTypeStubFolder();\n        this._program.writeTypeStub(this._typeStubTargetPath, this._typeStubTargetIsSingleFile, typingsSubdirPath, token);\n    }\n    writeTypeStubInBackground(token) {\n        const typingsSubdirPath = this._getTypeStubFolder();\n        return this._backgroundAnalysisProgram.writeTypeStub(this._typeStubTargetPath, this._typeStubTargetIsSingleFile, typingsSubdirPath, token);\n    }\n    // This is called after a new type stub has been created. It allows\n    // us to invalidate caches and force reanalysis of files that potentially\n    // are affected by the appearance of a new type stub.\n    invalidateAndForceReanalysis() {\n        // Mark all files with one or more errors dirty.\n        this._backgroundAnalysisProgram.invalidateAndForceReanalysis();\n    }\n    // Forces the service to stop all analysis, discard all its caches,\n    // and research for files.\n    restart() {\n        this._applyConfigOptions();\n        this._backgroundAnalysisProgram.restart();\n    }\n    get _fs() {\n        return this._backgroundAnalysisProgram.importResolver.fileSystem;\n    }\n    get _program() {\n        return this._backgroundAnalysisProgram.program;\n    }\n    get _configOptions() {\n        return this._backgroundAnalysisProgram.configOptions;\n    }\n    get _watchForSourceChanges() {\n        var _a;\n        return !!((_a = this._commandLineOptions) === null || _a === void 0 ? void 0 : _a.watchForSourceChanges);\n    }\n    get _watchForLibraryChanges() {\n        var _a;\n        return !!((_a = this._commandLineOptions) === null || _a === void 0 ? void 0 : _a.watchForLibraryChanges);\n    }\n    get _typeCheckingMode() {\n        var _a;\n        return (_a = this._commandLineOptions) === null || _a === void 0 ? void 0 : _a.typeCheckingMode;\n    }\n    get _verboseOutput() {\n        var _a;\n        return !!((_a = this._commandLineOptions) === null || _a === void 0 ? void 0 : _a.verboseOutput);\n    }\n    get _typeStubTargetImportName() {\n        var _a;\n        return (_a = this._commandLineOptions) === null || _a === void 0 ? void 0 : _a.typeStubTargetImportName;\n    }\n    _getTypeStubFolder() {\n        const stubPath = this._configOptions.stubPath;\n        if (!this._typeStubTargetPath || !this._typeStubTargetImportName) {\n            const errMsg = `Import '${this._typeStubTargetImportName}'` + ` could not be resolved`;\n            this._console.error(errMsg);\n            throw new Error(errMsg);\n        }\n        if (!stubPath) {\n            // We should never get here because we always generate a\n            // default typings path if none was specified.\n            const errMsg = 'No typings path was specified';\n            this._console.info(errMsg);\n            throw new Error(errMsg);\n        }\n        const typeStubInputTargetParts = this._typeStubTargetImportName.split('.');\n        if (typeStubInputTargetParts[0].length === 0) {\n            // We should never get here because the import resolution\n            // would have failed.\n            const errMsg = `Import '${this._typeStubTargetImportName}'` + ` could not be resolved`;\n            this._console.error(errMsg);\n            throw new Error(errMsg);\n        }\n        try {\n            // Generate a new typings directory if necessary.\n            if (!this._fs.existsSync(stubPath)) {\n                this._fs.mkdirSync(stubPath);\n            }\n        }\n        catch (e) {\n            const errMsg = `Could not create typings directory '${stubPath}'`;\n            this._console.error(errMsg);\n            throw new Error(errMsg);\n        }\n        // Generate a typings subdirectory.\n        const typingsSubdirPath = pathUtils_1.combinePaths(stubPath, typeStubInputTargetParts[0]);\n        try {\n            // Generate a new typings subdirectory if necessary.\n            if (!this._fs.existsSync(typingsSubdirPath)) {\n                this._fs.mkdirSync(typingsSubdirPath);\n            }\n        }\n        catch (e) {\n            const errMsg = `Could not create typings subdirectory '${typingsSubdirPath}'`;\n            this._console.error(errMsg);\n            throw new Error(errMsg);\n        }\n        return typingsSubdirPath;\n    }\n    _findConfigFileHereOrUp(searchPath) {\n        return pathUtils_1.forEachAncestorDirectory(searchPath, (ancestor) => this._findConfigFile(ancestor));\n    }\n    _findConfigFile(searchPath) {\n        for (const name of exports.configFileNames) {\n            const fileName = pathUtils_1.combinePaths(searchPath, name);\n            if (this._fs.existsSync(fileName)) {\n                return fileName;\n            }\n        }\n        return undefined;\n    }\n    _parseConfigFile(configPath) {\n        let configContents = '';\n        let parseAttemptCount = 0;\n        while (true) {\n            // Attempt to read the config file contents.\n            try {\n                configContents = this._fs.readFileSync(configPath, 'utf8');\n            }\n            catch (_a) {\n                this._console.error(`Config file \"${configPath}\" could not be read.`);\n                this._reportConfigParseError();\n                return undefined;\n            }\n            // Attempt to parse the config file.\n            let configObj;\n            let parseFailed = false;\n            try {\n                configObj = JSON.parse(configContents);\n                return configObj;\n            }\n            catch (_b) {\n                parseFailed = true;\n            }\n            if (!parseFailed) {\n                break;\n            }\n            // If we attempt to read the config file immediately after it\n            // was saved, it may have been partially written when we read it,\n            // resulting in parse errors. We'll give it a little more time and\n            // try again.\n            if (parseAttemptCount++ >= 5) {\n                this._console.error(`Config file \"${configPath}\" could not be parsed. Verify that JSON is correct.`);\n                this._reportConfigParseError();\n                return undefined;\n            }\n        }\n    }\n    _getFileNamesFromFileSpecs() {\n        // Use a map to generate a list of unique files.\n        const fileMap = new Map();\n        timing_1.timingStats.findFilesTime.timeOperation(() => {\n            const matchedFiles = this._matchFiles(this._configOptions.include, this._configOptions.exclude);\n            for (const file of matchedFiles) {\n                fileMap.set(file, file);\n            }\n        });\n        return [...fileMap.values()];\n    }\n    // If markFilesDirtyUnconditionally is true, we need to reparse\n    // and reanalyze all files in the program. If false, we will\n    // reparse and reanalyze only those files whose on-disk contents\n    // have changed. Unconditional dirtying is needed in the case where\n    // configuration options have changed.\n    _updateTrackedFileList(markFilesDirtyUnconditionally) {\n        // Are we in type stub generation mode? If so, we need to search\n        // for a different set of files.\n        if (this._typeStubTargetImportName) {\n            const execEnv = this._configOptions.findExecEnvironment(this._executionRootPath);\n            const moduleDescriptor = {\n                leadingDots: 0,\n                nameParts: this._typeStubTargetImportName.split('.'),\n                importedSymbols: [],\n            };\n            const importResult = this._backgroundAnalysisProgram.importResolver.resolveImport('', execEnv, moduleDescriptor);\n            if (importResult.isImportFound) {\n                const filesToImport = [];\n                // Namespace packages resolve to a directory name, so\n                // don't include those.\n                const resolvedPath = importResult.resolvedPaths[importResult.resolvedPaths.length - 1];\n                // Get the directory that contains the root package.\n                let targetPath = pathUtils_1.getDirectoryPath(resolvedPath);\n                let prevResolvedPath = resolvedPath;\n                for (let i = importResult.resolvedPaths.length - 2; i >= 0; i--) {\n                    const resolvedPath = importResult.resolvedPaths[i];\n                    if (resolvedPath) {\n                        targetPath = pathUtils_1.getDirectoryPath(resolvedPath);\n                        prevResolvedPath = resolvedPath;\n                    }\n                    else {\n                        // If there was no file corresponding to this portion\n                        // of the name path, assume that it's contained\n                        // within its parent directory.\n                        targetPath = pathUtils_1.getDirectoryPath(prevResolvedPath);\n                        prevResolvedPath = targetPath;\n                    }\n                }\n                if (pathUtils_1.isDirectory(this._fs, targetPath)) {\n                    this._typeStubTargetPath = targetPath;\n                }\n                if (!resolvedPath) {\n                    this._typeStubTargetIsSingleFile = false;\n                }\n                else {\n                    filesToImport.push(resolvedPath);\n                    this._typeStubTargetIsSingleFile =\n                        importResult.resolvedPaths.length === 1 &&\n                            pathUtils_1.stripFileExtension(pathUtils_1.getFileName(importResult.resolvedPaths[0])) !== '__init__';\n                }\n                // Add the implicit import paths.\n                importResult.implicitImports.forEach((implicitImport) => {\n                    filesToImport.push(implicitImport.path);\n                });\n                this._backgroundAnalysisProgram.setAllowedThirdPartyImports([this._typeStubTargetImportName]);\n                this._backgroundAnalysisProgram.setTrackedFiles(filesToImport);\n            }\n            else {\n                this._console.info(`Import '${this._typeStubTargetImportName}' not found`);\n            }\n        }\n        else {\n            let fileList = [];\n            this._console.info(`Searching for source files`);\n            fileList = this._getFileNamesFromFileSpecs();\n            this._backgroundAnalysisProgram.setTrackedFiles(fileList);\n            this._backgroundAnalysisProgram.markAllFilesDirty(markFilesDirtyUnconditionally);\n            if (fileList.length === 0) {\n                this._console.info(`No source files found.`);\n            }\n            else {\n                this._console.info(`Found ${fileList.length} ` + `source ${fileList.length === 1 ? 'file' : 'files'}`);\n            }\n        }\n        this._requireTrackedFileUpdate = false;\n    }\n    _isInExcludePath(path, excludePaths) {\n        return !!excludePaths.find((excl) => excl.regExp.test(path));\n    }\n    _matchFiles(include, exclude) {\n        const includeFileRegex = /\\.pyi?$/;\n        const envMarkers = [['bin', 'activate'], ['Scripts', 'activate'], ['pyvenv.cfg']];\n        const results = [];\n        const visitDirectory = (absolutePath, includeRegExp) => {\n            if (this._configOptions.autoExcludeVenv) {\n                if (envMarkers.some((f) => this._fs.existsSync(pathUtils_1.combinePaths(absolutePath, ...f)))) {\n                    this._console.info(`Auto-excluding ${absolutePath}`);\n                    return;\n                }\n            }\n            const { files, directories } = pathUtils_1.getFileSystemEntries(this._fs, absolutePath);\n            for (const file of files) {\n                const filePath = pathUtils_1.combinePaths(absolutePath, file);\n                if (includeRegExp.test(filePath)) {\n                    if (!this._isInExcludePath(filePath, exclude) && includeFileRegex.test(filePath)) {\n                        results.push(filePath);\n                    }\n                }\n            }\n            for (const directory of directories) {\n                const dirPath = pathUtils_1.combinePaths(absolutePath, directory);\n                if (includeRegExp.test(dirPath)) {\n                    if (!this._isInExcludePath(dirPath, exclude)) {\n                        visitDirectory(dirPath, includeRegExp);\n                    }\n                }\n            }\n        };\n        include.forEach((includeSpec) => {\n            let foundFileSpec = false;\n            if (!this._isInExcludePath(includeSpec.wildcardRoot, exclude)) {\n                try {\n                    const stat = this._fs.statSync(includeSpec.wildcardRoot);\n                    if (stat.isFile()) {\n                        if (includeFileRegex.test(includeSpec.wildcardRoot)) {\n                            results.push(includeSpec.wildcardRoot);\n                            foundFileSpec = true;\n                        }\n                    }\n                    else if (stat.isDirectory()) {\n                        visitDirectory(includeSpec.wildcardRoot, includeSpec.regExp);\n                        foundFileSpec = true;\n                    }\n                }\n                catch (_a) {\n                    // Ignore the exception.\n                }\n            }\n            if (!foundFileSpec) {\n                this._console.error(`File or directory \"${includeSpec.wildcardRoot}\" does not exist.`);\n            }\n        });\n        return results;\n    }\n    _removeSourceFileWatchers() {\n        if (this._sourceFileWatcher) {\n            this._sourceFileWatcher.close();\n            this._sourceFileWatcher = undefined;\n        }\n    }\n    _updateSourceFileWatchers() {\n        this._removeSourceFileWatchers();\n        this._backgroundAnalysisProgram.invalidateCache();\n        if (!this._watchForSourceChanges) {\n            return;\n        }\n        if (this._configOptions.include.length > 0) {\n            const fileList = this._configOptions.include.map((spec) => {\n                return pathUtils_1.combinePaths(this._executionRootPath, spec.wildcardRoot);\n            });\n            try {\n                if (this._verboseOutput) {\n                    this._console.info(`Adding fs watcher for directories:\\n ${fileList.join('\\n')}`);\n                }\n                this._sourceFileWatcher = this._fs.createFileSystemWatcher(fileList, (event, path) => {\n                    if (this._verboseOutput) {\n                        this._console.info(`Received fs event '${event}' for path '${path}'`);\n                    }\n                    // Delete comes in as a change event, so try to distinguish here.\n                    if (event === 'change' && this._fs.existsSync(path)) {\n                        this._backgroundAnalysisProgram.markFilesDirty([path], false);\n                        this._scheduleReanalysis(false);\n                    }\n                    else {\n                        // Determine if this is an add or delete event related to a temporary\n                        // file. Some tools (like auto-formatters) create temporary files\n                        // alongside the original file and name them \"x.py.<temp-id>.py\" where\n                        // <temp-id> is a 32-character random string of hex digits. We don't\n                        // want these events to trigger a full reanalysis.\n                        const fileName = pathUtils_1.getFileName(path);\n                        const fileNameSplit = fileName.split('.');\n                        let isTemporaryFile = false;\n                        if (fileNameSplit.length === 4) {\n                            if (fileNameSplit[3] === fileNameSplit[1] && fileNameSplit[2].length === 32) {\n                                isTemporaryFile = true;\n                            }\n                        }\n                        if (!isTemporaryFile) {\n                            // Added/deleted/renamed files impact imports,\n                            // clear the import resolver cache and reanalyze everything.\n                            this.invalidateAndForceReanalysis();\n                            this._scheduleReanalysis(true);\n                        }\n                    }\n                });\n            }\n            catch (_a) {\n                this._console.error(`Exception caught when installing fs watcher for:\\n ${fileList.join('\\n')}`);\n            }\n        }\n    }\n    _removeLibraryFileWatcher() {\n        if (this._libraryFileWatcher) {\n            this._libraryFileWatcher.close();\n            this._libraryFileWatcher = undefined;\n        }\n    }\n    _updateLibraryFileWatcher() {\n        this._removeLibraryFileWatcher();\n        this._backgroundAnalysisProgram.invalidateCache();\n        if (!this._watchForLibraryChanges) {\n            return;\n        }\n        // Watch the library paths for package install/uninstall.\n        const importFailureInfo = [];\n        const watchList = pythonPathUtils_1.findPythonSearchPaths(this._fs, this._backgroundAnalysisProgram.configOptions, undefined, importFailureInfo, true, this._executionRootPath);\n        if (watchList && watchList.length > 0) {\n            try {\n                if (this._verboseOutput) {\n                    this._console.info(`Adding fs watcher for library directories:\\n ${watchList.join('\\n')}`);\n                }\n                this._libraryFileWatcher = this._fs.createFileSystemWatcher(watchList, (event, path) => {\n                    if (this._verboseOutput) {\n                        this._console.info(`Received fs event '${event}' for path '${path}'`);\n                    }\n                    this._scheduleLibraryAnalysis();\n                });\n            }\n            catch (_a) {\n                this._console.error(`Exception caught when installing fs watcher for:\\n ${watchList.join('\\n')}`);\n            }\n        }\n    }\n    _clearLibraryReanalysisTimer() {\n        if (this._libraryReanalysisTimer) {\n            clearTimeout(this._libraryReanalysisTimer);\n            this._libraryReanalysisTimer = undefined;\n        }\n    }\n    _scheduleLibraryAnalysis() {\n        if (this._disposed) {\n            // Already disposed.\n            return;\n        }\n        this._clearLibraryReanalysisTimer();\n        // Wait for a little while, since library changes\n        // tend to happen in big batches when packages\n        // are installed or uninstalled.\n        this._libraryReanalysisTimer = setTimeout(() => {\n            this._clearLibraryReanalysisTimer();\n            // Invalidate import resolver, mark all files dirty unconditionally,\n            // and reanalyze.\n            this.invalidateAndForceReanalysis();\n            this._scheduleReanalysis(false);\n        }, 100);\n    }\n    _removeConfigFileWatcher() {\n        if (this._configFileWatcher) {\n            this._configFileWatcher.close();\n            this._configFileWatcher = undefined;\n        }\n    }\n    _updateConfigFileWatcher() {\n        this._removeConfigFileWatcher();\n        if (this._configFilePath) {\n            this._configFileWatcher = this._fs.createFileSystemWatcher([this._configFilePath], (event) => {\n                if (this._verboseOutput) {\n                    this._console.info(`Received fs event '${event}' for config file`);\n                }\n                this._scheduleReloadConfigFile();\n            });\n        }\n        else if (this._executionRootPath) {\n            this._configFileWatcher = this._fs.createFileSystemWatcher([this._executionRootPath], (event, path) => {\n                if (event === 'add' || event === 'change') {\n                    const fileName = pathUtils_1.getFileName(path);\n                    if (fileName && exports.configFileNames.some((name) => name === fileName)) {\n                        if (this._verboseOutput) {\n                            this._console.info(`Received fs event '${event}' for config file`);\n                        }\n                        if (this._commandLineOptions) {\n                            this.setOptions(this._commandLineOptions);\n                        }\n                    }\n                }\n            });\n        }\n    }\n    _clearReloadConfigTimer() {\n        if (this._reloadConfigTimer) {\n            clearTimeout(this._reloadConfigTimer);\n            this._reloadConfigTimer = undefined;\n        }\n    }\n    _scheduleReloadConfigFile() {\n        this._clearReloadConfigTimer();\n        // Wait for a little while after we receive the\n        // change update event because it may take a while\n        // for the file to be written out. Plus, there may\n        // be multiple changes.\n        this._reloadConfigTimer = setTimeout(() => {\n            this._clearReloadConfigTimer();\n            this._reloadConfigFile();\n        }, 100);\n    }\n    _reloadConfigFile() {\n        this._updateConfigFileWatcher();\n        if (this._configFilePath) {\n            this._console.info(`Reloading configuration file at ${this._configFilePath}`);\n            // We can't just reload config file when it is changed; we need to consider\n            // command line options as well to construct new config Options.\n            const configOptions = this._getConfigOptions(this._commandLineOptions);\n            this._backgroundAnalysisProgram.setConfigOptions(configOptions);\n            this._applyConfigOptions();\n        }\n    }\n    _applyConfigOptions(reanalyze = true) {\n        // Allocate a new import resolver because the old one has information\n        // cached based on the previous config options.\n        const importResolver = this._importResolverFactory(this._fs, this._backgroundAnalysisProgram.configOptions);\n        this._backgroundAnalysisProgram.setImportResolver(importResolver);\n        this._updateLibraryFileWatcher();\n        this._updateConfigFileWatcher();\n        this._updateSourceFileWatchers();\n        this._updateTrackedFileList(true);\n        if (reanalyze) {\n            this._scheduleReanalysis(false);\n        }\n    }\n    _clearReanalysisTimer() {\n        if (this._analyzeTimer) {\n            clearTimeout(this._analyzeTimer);\n            this._analyzeTimer = undefined;\n        }\n    }\n    _scheduleReanalysis(requireTrackedFileUpdate) {\n        var _a;\n        if (this._disposed) {\n            // already disposed\n            return;\n        }\n        if (requireTrackedFileUpdate) {\n            this._requireTrackedFileUpdate = true;\n        }\n        (_a = this._backgroundAnalysisCancellationSource) === null || _a === void 0 ? void 0 : _a.cancel();\n        // Remove any existing analysis timer.\n        this._clearReanalysisTimer();\n        // How long has it been since the user interacted with the service?\n        // If the user is actively typing, back off to let him or her finish.\n        const timeSinceLastUserInteractionInMs = Date.now() - this._lastUserInteractionTime;\n        const minBackoffTimeInMs = _userActivityBackoffTimeInMs;\n        // We choose a small non-zero value here. If this value\n        // is too small (like zero), the VS Code extension becomes\n        // unresponsive during heavy analysis. If this number is too\n        // large, analysis takes longer.\n        const minTimeBetweenAnalysisPassesInMs = 20;\n        const timeUntilNextAnalysisInMs = Math.max(minBackoffTimeInMs - timeSinceLastUserInteractionInMs, minTimeBetweenAnalysisPassesInMs);\n        // Schedule a new timer.\n        this._analyzeTimer = setTimeout(() => {\n            this._analyzeTimer = undefined;\n            if (this._requireTrackedFileUpdate) {\n                this._updateTrackedFileList(false);\n            }\n            // This creates a cancellation source only if it actually gets used.\n            this._backgroundAnalysisCancellationSource = cancellationUtils_1.createAnalysisCancellationTokenSource();\n            const moreToAnalyze = this._backgroundAnalysisProgram.startAnalysis(this._backgroundAnalysisCancellationSource.token);\n            if (moreToAnalyze) {\n                this._scheduleReanalysis(false);\n            }\n        }, timeUntilNextAnalysisInMs);\n    }\n    _reportConfigParseError() {\n        if (this._onCompletionCallback) {\n            this._onCompletionCallback({\n                diagnostics: [],\n                filesInProgram: 0,\n                filesRequiringAnalysis: 0,\n                checkingOnlyOpenFiles: true,\n                fatalErrorOccurred: false,\n                configParseErrorOccurred: true,\n                elapsedTime: 0,\n            });\n        }\n    }\n}\nexports.AnalyzerService = AnalyzerService;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/service.ts?");

/***/ }),

/***/ "./src/analyzer/sourceFile.ts":
/*!************************************!*\
  !*** ./src/analyzer/sourceFile.ts ***!
  \************************************/
/*! flagged exports */
/*! export SourceFile [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * sourceFile.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Class that represents a single python source file.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SourceFile = void 0;\nconst worker_threads_1 = __webpack_require__(/*! worker_threads */ \"worker_threads\");\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst configOptions_1 = __webpack_require__(/*! ../common/configOptions */ \"./src/common/configOptions.ts\");\nconst console_1 = __webpack_require__(/*! ../common/console */ \"./src/common/console.ts\");\nconst debug_1 = __webpack_require__(/*! ../common/debug */ \"./src/common/debug.ts\");\nconst diagnostic_1 = __webpack_require__(/*! ../common/diagnostic */ \"./src/common/diagnostic.ts\");\nconst diagnosticSink_1 = __webpack_require__(/*! ../common/diagnosticSink */ \"./src/common/diagnosticSink.ts\");\nconst logTracker_1 = __webpack_require__(/*! ../common/logTracker */ \"./src/common/logTracker.ts\");\nconst pathUtils_1 = __webpack_require__(/*! ../common/pathUtils */ \"./src/common/pathUtils.ts\");\nconst StringUtils = __webpack_require__(/*! ../common/stringUtils */ \"./src/common/stringUtils.ts\");\nconst textRange_1 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\nconst textRangeCollection_1 = __webpack_require__(/*! ../common/textRangeCollection */ \"./src/common/textRangeCollection.ts\");\nconst timing_1 = __webpack_require__(/*! ../common/timing */ \"./src/common/timing.ts\");\nconst completionProvider_1 = __webpack_require__(/*! ../languageService/completionProvider */ \"./src/languageService/completionProvider.ts\");\nconst definitionProvider_1 = __webpack_require__(/*! ../languageService/definitionProvider */ \"./src/languageService/definitionProvider.ts\");\nconst documentHighlightProvider_1 = __webpack_require__(/*! ../languageService/documentHighlightProvider */ \"./src/languageService/documentHighlightProvider.ts\");\nconst documentSymbolProvider_1 = __webpack_require__(/*! ../languageService/documentSymbolProvider */ \"./src/languageService/documentSymbolProvider.ts\");\nconst hoverProvider_1 = __webpack_require__(/*! ../languageService/hoverProvider */ \"./src/languageService/hoverProvider.ts\");\nconst quickActions_1 = __webpack_require__(/*! ../languageService/quickActions */ \"./src/languageService/quickActions.ts\");\nconst referencesProvider_1 = __webpack_require__(/*! ../languageService/referencesProvider */ \"./src/languageService/referencesProvider.ts\");\nconst signatureHelpProvider_1 = __webpack_require__(/*! ../languageService/signatureHelpProvider */ \"./src/languageService/signatureHelpProvider.ts\");\nconst localize_1 = __webpack_require__(/*! ../localization/localize */ \"./src/localization/localize.ts\");\nconst parseNodes_1 = __webpack_require__(/*! ../parser/parseNodes */ \"./src/parser/parseNodes.ts\");\nconst parser_1 = __webpack_require__(/*! ../parser/parser */ \"./src/parser/parser.ts\");\nconst AnalyzerNodeInfo = __webpack_require__(/*! ./analyzerNodeInfo */ \"./src/analyzer/analyzerNodeInfo.ts\");\nconst binder_1 = __webpack_require__(/*! ./binder */ \"./src/analyzer/binder.ts\");\nconst checker_1 = __webpack_require__(/*! ./checker */ \"./src/analyzer/checker.ts\");\nconst CommentUtils = __webpack_require__(/*! ./commentUtils */ \"./src/analyzer/commentUtils.ts\");\nconst parseTreeCleaner_1 = __webpack_require__(/*! ./parseTreeCleaner */ \"./src/analyzer/parseTreeCleaner.ts\");\nconst testWalker_1 = __webpack_require__(/*! ./testWalker */ \"./src/analyzer/testWalker.ts\");\nconst _maxImportCyclesPerFile = 4;\nclass SourceFile {\n    constructor(fs, filePath, isThirdPartyImport, console, logTracker) {\n        // True if the file appears to have been deleted.\n        this._isFileDeleted = false;\n        // Number that is incremented every time the diagnostics\n        // are updated.\n        this._diagnosticVersion = 0;\n        // Generation count of the file contents. When the contents\n        // change, this is incremented.\n        this._fileContentsVersion = 0;\n        // Length and hash of the file the last time it was read from disk.\n        this._lastFileContentLength = undefined;\n        this._lastFileContentHash = undefined;\n        // Client's version of the file. Null implies that contents\n        // need to be read from disk.\n        this._clientVersion = null;\n        // Version of file contents that have been analyzed.\n        this._analyzedFileContentsVersion = -1;\n        // Do we need to walk the parse tree and clean\n        // the binder information hanging from it?\n        this._parseTreeNeedsCleaning = false;\n        // Reentrancy check for binding.\n        this._isBindingInProgress = false;\n        // Diagnostics generated during different phases of analysis.\n        this._parseDiagnostics = [];\n        this._bindDiagnostics = [];\n        this._checkerDiagnostics = [];\n        // Settings that control which diagnostics should be output.\n        this._diagnosticRuleSet = configOptions_1.getBasicDiagnosticRuleSet();\n        // Circular dependencies that have been reported in this file.\n        this._circularDependencies = [];\n        // Do we need to perform a binding step?\n        this._isBindingNeeded = true;\n        // Do we need to perform an additional type analysis pass?\n        this._isCheckingNeeded = true;\n        this.fileSystem = fs;\n        this._console = console || new console_1.StandardConsole();\n        this._filePath = filePath;\n        this._isStubFile = filePath.endsWith('.pyi');\n        this._isThirdPartyImport = isThirdPartyImport;\n        const fileName = pathUtils_1.getFileName(filePath);\n        this._isTypingStubFile =\n            this._isStubFile && (fileName === 'typing.pyi' || fileName === 'typing_extensions.pyi');\n        this._isTypingExtensionsStubFile = this._isStubFile && fileName === 'typing_extensions.pyi';\n        this._isBuiltInStubFile = false;\n        if (this._isStubFile) {\n            if (this._filePath.endsWith(pathUtils_1.normalizeSlashes('/collections/__init__.pyi')) ||\n                fileName === 'builtins.pyi' ||\n                fileName === '_importlib_modulespec.pyi' ||\n                fileName === 'dataclasses.pyi' ||\n                fileName === 'abc.pyi' ||\n                fileName === 'enum.pyi' ||\n                fileName === 'types.pyi') {\n                this._isBuiltInStubFile = true;\n            }\n        }\n        // 'FG' or 'BG' based on current thread.\n        this._logTracker = logTracker !== null && logTracker !== void 0 ? logTracker : new logTracker_1.LogTracker(console, worker_threads_1.isMainThread ? 'FG' : 'BG');\n    }\n    getFilePath() {\n        return this._filePath;\n    }\n    getDiagnosticVersion() {\n        return this._diagnosticVersion;\n    }\n    isStubFile() {\n        return this._isStubFile;\n    }\n    // Returns a list of cached diagnostics from the latest analysis job.\n    // If the prevVersion is specified, the method returns undefined if\n    // the diagnostics haven't changed.\n    getDiagnostics(options, prevDiagnosticVersion) {\n        if (this._diagnosticVersion === prevDiagnosticVersion) {\n            return undefined;\n        }\n        let includeWarningsAndErrors = true;\n        // If a file was imported as a third-party file, don't report\n        // any errors for it. The user can't fix them anyway.\n        if (this._isThirdPartyImport) {\n            includeWarningsAndErrors = false;\n        }\n        let diagList = [];\n        diagList = diagList.concat(this._parseDiagnostics, this._bindDiagnostics, this._checkerDiagnostics);\n        // Filter the diagnostics based on \"type: ignore\" lines.\n        if (options.diagnosticRuleSet.enableTypeIgnoreComments) {\n            const typeIgnoreLines = this._parseResults ? this._parseResults.tokenizerOutput.typeIgnoreLines : {};\n            if (Object.keys(typeIgnoreLines).length > 0) {\n                diagList = diagList.filter((d) => {\n                    if (d.category !== 3 /* UnusedCode */) {\n                        for (let line = d.range.start.line; line <= d.range.end.line; line++) {\n                            if (typeIgnoreLines[line]) {\n                                return false;\n                            }\n                        }\n                    }\n                    return true;\n                });\n            }\n        }\n        if (options.diagnosticRuleSet.reportImportCycles !== 'none' && this._circularDependencies.length > 0) {\n            const category = diagnostic_1.convertLevelToCategory(options.diagnosticRuleSet.reportImportCycles);\n            this._circularDependencies.forEach((cirDep) => {\n                diagList.push(new diagnostic_1.Diagnostic(category, localize_1.Localizer.Diagnostic.importCycleDetected() +\n                    '\\n' +\n                    cirDep\n                        .getPaths()\n                        .map((path) => '  ' + path)\n                        .join('\\n'), textRange_1.getEmptyRange()));\n            });\n        }\n        if (this._hitMaxImportDepth !== undefined) {\n            diagList.push(new diagnostic_1.Diagnostic(0 /* Error */, localize_1.Localizer.Diagnostic.importDepthExceeded().format({ depth: this._hitMaxImportDepth }), textRange_1.getEmptyRange()));\n        }\n        // If the file is in the ignore list, clear the diagnostic list.\n        if (options.ignore.find((ignoreFileSpec) => ignoreFileSpec.regExp.test(this._filePath))) {\n            diagList = [];\n        }\n        // If there is a \"type: ignore\" comment at the top of the file, clear\n        // the diagnostic list.\n        if (options.diagnosticRuleSet.enableTypeIgnoreComments) {\n            if (this._parseResults && this._parseResults.tokenizerOutput.typeIgnoreAll) {\n                diagList = [];\n            }\n        }\n        // If we're not returning any diagnostics, filter out all of\n        // the errors and warnings, leaving only the unreachable code\n        // diagnostics.\n        if (!includeWarningsAndErrors) {\n            diagList = diagList.filter((diag) => diag.category === 3 /* UnusedCode */);\n        }\n        return diagList;\n    }\n    getImports() {\n        return this._imports || [];\n    }\n    getBuiltinsImport() {\n        return this._builtinsImport;\n    }\n    getModuleSymbolTable() {\n        return this._moduleSymbolTable;\n    }\n    getModuleDocString() {\n        return this._binderResults ? this._binderResults.moduleDocString : undefined;\n    }\n    // Indicates whether the contents of the file have changed since\n    // the last analysis was performed.\n    didContentsChangeOnDisk() {\n        // If this is an open file any content changes will be\n        // provided through the editor. We can assume contents\n        // didn't change without us knowing about them.\n        if (this._clientVersion !== null) {\n            return false;\n        }\n        // If the file was never read previously, no need to check for a change.\n        if (this._lastFileContentLength === undefined) {\n            return false;\n        }\n        // Read in the latest file contents and see if the hash matches\n        // that of the previous contents.\n        try {\n            // Read the file's contents.\n            const fileContents = this.fileSystem.readFileSync(this._filePath, 'utf8');\n            if (fileContents.length !== this._lastFileContentLength) {\n                return true;\n            }\n            if (StringUtils.hashString(fileContents) !== this._lastFileContentHash) {\n                return true;\n            }\n        }\n        catch (error) {\n            return true;\n        }\n        return false;\n    }\n    markDirty() {\n        this._fileContentsVersion++;\n        this._isCheckingNeeded = true;\n        this._moduleSymbolTable = undefined;\n        this._binderResults = undefined;\n    }\n    markReanalysisRequired() {\n        // Keep the parse info, but reset the analysis to the beginning.\n        this._isCheckingNeeded = true;\n        // If the file contains a wildcard import, we need to rebind\n        // also because the dependent import may have changed.\n        if (this._parseResults && this._parseResults.containsWildcardImport) {\n            this._parseTreeNeedsCleaning = true;\n            this._isBindingNeeded = true;\n            this._moduleSymbolTable = undefined;\n            this._binderResults = undefined;\n        }\n    }\n    getClientVersion() {\n        return this._clientVersion;\n    }\n    getFileContents() {\n        return this._fileContents;\n    }\n    setClientVersion(version, contents) {\n        this._clientVersion = version;\n        if (version === null) {\n            this._fileContents = undefined;\n        }\n        else {\n            if (this._fileContents !== undefined) {\n                if (this._fileContents !== contents) {\n                    this.markDirty();\n                }\n            }\n            this._fileContents = contents;\n        }\n    }\n    prepareForClose() {\n        // Nothing to do currently.\n    }\n    isFileDeleted() {\n        return this._isFileDeleted;\n    }\n    isParseRequired() {\n        return this._analyzedFileContentsVersion !== this._fileContentsVersion;\n    }\n    isBindingRequired() {\n        if (this._isBindingInProgress) {\n            return false;\n        }\n        if (this.isParseRequired()) {\n            return true;\n        }\n        return this._isBindingNeeded;\n    }\n    isCheckingRequired() {\n        if (this.isBindingRequired()) {\n            return true;\n        }\n        return this._isCheckingNeeded;\n    }\n    getParseResults() {\n        if (!this.isParseRequired()) {\n            return this._parseResults;\n        }\n        return undefined;\n    }\n    // Adds a new circular dependency for this file but only if\n    // it hasn't already been added.\n    addCircularDependency(circDependency) {\n        let updatedDependencyList = false;\n        // Some topologies can result in a massive number of cycles. We'll cut it off.\n        if (this._circularDependencies.length < _maxImportCyclesPerFile) {\n            if (!this._circularDependencies.some((dep) => dep.isEqual(circDependency))) {\n                this._circularDependencies.push(circDependency);\n                updatedDependencyList = true;\n            }\n        }\n        if (updatedDependencyList) {\n            this._diagnosticVersion++;\n        }\n    }\n    setHitMaxImportDepth(maxImportDepth) {\n        this._hitMaxImportDepth = maxImportDepth;\n    }\n    // Parse the file and update the state. Callers should wait for completion\n    // (or at least cancel) prior to calling again. It returns true if a parse\n    // was required and false if the parse information was up to date already.\n    parse(configOptions, importResolver) {\n        return this._logTracker.log(`parsing: ${this._filePath}`, (ls) => {\n            // If the file is already parsed, we can skip.\n            if (!this.isParseRequired()) {\n                ls.add(`cache hit`);\n                return false;\n            }\n            const diagSink = new diagnosticSink_1.DiagnosticSink();\n            let fileContents = this._fileContents;\n            if (this._clientVersion === null) {\n                try {\n                    timing_1.timingStats.readFileTime.timeOperation(() => {\n                        // Read the file's contents.\n                        fileContents = this.fileSystem.readFileSync(this._filePath, 'utf8');\n                        // Remember the length and hash for comparison purposes.\n                        this._lastFileContentLength = fileContents.length;\n                        this._lastFileContentHash = StringUtils.hashString(fileContents);\n                    });\n                }\n                catch (error) {\n                    diagSink.addError(`Source file could not be read`, textRange_1.getEmptyRange());\n                    fileContents = '';\n                    if (!this.fileSystem.existsSync(this._filePath)) {\n                        this._isFileDeleted = true;\n                    }\n                }\n            }\n            // Use the configuration options to determine the environment in which\n            // this source file will be executed.\n            const execEnvironment = configOptions.findExecEnvironment(this._filePath);\n            const parseOptions = new parser_1.ParseOptions();\n            if (this._filePath.endsWith('pyi')) {\n                parseOptions.isStubFile = true;\n            }\n            parseOptions.pythonVersion = execEnvironment.pythonVersion;\n            try {\n                // Parse the token stream, building the abstract syntax tree.\n                const parser = new parser_1.Parser();\n                const parseResults = parser.parseSourceFile(fileContents, parseOptions, diagSink);\n                debug_1.assert(parseResults !== undefined && parseResults.tokenizerOutput !== undefined);\n                this._parseResults = parseResults;\n                // Resolve imports.\n                timing_1.timingStats.resolveImportsTime.timeOperation(() => {\n                    [\n                        this._imports,\n                        this._builtinsImport,\n                        this._typingModulePath,\n                        this._collectionsModulePath,\n                    ] = this._resolveImports(importResolver, parseResults.importedModules, execEnvironment);\n                    this._parseDiagnostics = diagSink.fetchAndClear();\n                });\n                // Is this file in a \"strict\" path?\n                const useStrict = configOptions.strict.find((strictFileSpec) => strictFileSpec.regExp.test(this._filePath)) !==\n                    undefined;\n                this._diagnosticRuleSet = CommentUtils.getFileLevelDirectives(this._parseResults.tokenizerOutput.tokens, configOptions.diagnosticRuleSet, useStrict);\n            }\n            catch (e) {\n                const message = (e.stack ? e.stack.toString() : undefined) ||\n                    (typeof e.message === 'string' ? e.message : undefined) ||\n                    JSON.stringify(e);\n                this._console.error(`An internal error occurred while parsing ${this.getFilePath()}: ` + message);\n                // Create dummy parse results.\n                this._parseResults = {\n                    text: '',\n                    parseTree: parseNodes_1.ModuleNode.create({ start: 0, length: 0 }),\n                    importedModules: [],\n                    futureImports: new Map(),\n                    tokenizerOutput: {\n                        tokens: new textRangeCollection_1.TextRangeCollection([]),\n                        lines: new textRangeCollection_1.TextRangeCollection([]),\n                        typeIgnoreAll: false,\n                        typeIgnoreLines: {},\n                        predominantEndOfLineSequence: '\\n',\n                        predominantTabSequence: '    ',\n                        predominantSingleQuoteCharacter: \"'\",\n                    },\n                    containsWildcardImport: false,\n                };\n                this._imports = undefined;\n                this._builtinsImport = undefined;\n                const diagSink = new diagnosticSink_1.DiagnosticSink();\n                diagSink.addError(`An internal error occurred while parsing file`, textRange_1.getEmptyRange());\n                this._parseDiagnostics = diagSink.fetchAndClear();\n                // Do not rethrow the exception, swallow it here. Callers are not\n                // prepared to handle an exception.\n            }\n            this._analyzedFileContentsVersion = this._fileContentsVersion;\n            this._isBindingNeeded = true;\n            this._isCheckingNeeded = true;\n            this._parseTreeNeedsCleaning = false;\n            this._hitMaxImportDepth = undefined;\n            this._diagnosticVersion++;\n            return true;\n        });\n    }\n    getDefinitionsForPosition(sourceMapper, position, evaluator, token) {\n        // If we have no completed analysis job, there's nothing to do.\n        if (!this._parseResults) {\n            return undefined;\n        }\n        return definitionProvider_1.DefinitionProvider.getDefinitionsForPosition(sourceMapper, this._parseResults, position, evaluator, token);\n    }\n    getDeclarationForPosition(sourceMapper, position, evaluator, token) {\n        // If we have no completed analysis job, there's nothing to do.\n        if (!this._parseResults) {\n            return undefined;\n        }\n        return referencesProvider_1.ReferencesProvider.getDeclarationForPosition(sourceMapper, this._parseResults, this._filePath, position, evaluator, token);\n    }\n    addReferences(referencesResult, includeDeclaration, evaluator, token) {\n        // If we have no completed analysis job, there's nothing to do.\n        if (!this._parseResults) {\n            return;\n        }\n        referencesProvider_1.ReferencesProvider.addReferences(this._parseResults, this._filePath, referencesResult, includeDeclaration, evaluator, token);\n    }\n    addHierarchicalSymbolsForDocument(symbolList, evaluator, token) {\n        // If we have no completed analysis job, there's nothing to do.\n        if (!this._parseResults) {\n            return;\n        }\n        documentSymbolProvider_1.DocumentSymbolProvider.addHierarchicalSymbolsForDocument(symbolList, this._parseResults, evaluator, token);\n    }\n    addSymbolsForDocument(symbolList, evaluator, query, token) {\n        // If we have no completed analysis job, there's nothing to do.\n        if (!this._parseResults) {\n            return;\n        }\n        documentSymbolProvider_1.DocumentSymbolProvider.addSymbolsForDocument(symbolList, query, this._filePath, this._parseResults, evaluator, token);\n    }\n    getHoverForPosition(sourceMapper, position, evaluator, token) {\n        // If this file hasn't been bound, no hover info is available.\n        if (this._isBindingNeeded || !this._parseResults) {\n            return undefined;\n        }\n        return hoverProvider_1.HoverProvider.getHoverForPosition(sourceMapper, this._parseResults, position, evaluator, token);\n    }\n    getDocumentHighlight(sourceMapper, position, evaluator, token) {\n        // If this file hasn't been bound, no hover info is available.\n        if (this._isBindingNeeded || !this._parseResults) {\n            return undefined;\n        }\n        return documentHighlightProvider_1.DocumentHighlightProvider.getDocumentHighlight(this._parseResults, position, evaluator, token);\n    }\n    getSignatureHelpForPosition(position, importLookup, evaluator, token) {\n        // If we have no completed analysis job, there's nothing to do.\n        if (!this._parseResults) {\n            return undefined;\n        }\n        return signatureHelpProvider_1.SignatureHelpProvider.getSignatureHelpForPosition(this._parseResults, position, evaluator, token);\n    }\n    getCompletionsForPosition(position, workspacePath, configOptions, importResolver, importLookup, evaluator, sourceMapper, moduleSymbolsCallback, token) {\n        // If we have no completed analysis job, there's nothing to do.\n        if (!this._parseResults) {\n            return undefined;\n        }\n        // This command should be called only for open files, in which\n        // case we should have the file contents already loaded.\n        if (this._fileContents === undefined) {\n            return undefined;\n        }\n        const completionProvider = new completionProvider_1.CompletionProvider(workspacePath, this._parseResults, this._fileContents, importResolver, position, this._filePath, configOptions, importLookup, evaluator, sourceMapper, moduleSymbolsCallback, token);\n        return completionProvider.getCompletionsForPosition();\n    }\n    resolveCompletionItem(configOptions, importResolver, importLookup, evaluator, sourceMapper, moduleSymbolsCallback, completionItem, token) {\n        if (!this._parseResults || this._fileContents === undefined) {\n            return;\n        }\n        const completionData = completionItem.data;\n        const completionProvider = new completionProvider_1.CompletionProvider(completionData.workspacePath, this._parseResults, this._fileContents, importResolver, completionData.position, this._filePath, configOptions, importLookup, evaluator, sourceMapper, moduleSymbolsCallback, token);\n        completionProvider.resolveCompletionItem(completionItem);\n    }\n    performQuickAction(command, args, token) {\n        // If we have no completed analysis job, there's nothing to do.\n        if (!this._parseResults) {\n            return undefined;\n        }\n        // This command should be called only for open files, in which\n        // case we should have the file contents already loaded.\n        if (this._fileContents === undefined) {\n            return undefined;\n        }\n        return quickActions_1.performQuickAction(command, args, this._parseResults, token);\n    }\n    bind(configOptions, importLookup, builtinsScope) {\n        debug_1.assert(!this.isParseRequired());\n        debug_1.assert(this.isBindingRequired());\n        debug_1.assert(!this._isBindingInProgress);\n        debug_1.assert(this._parseResults !== undefined);\n        return this._logTracker.log(`binding: ${this._filePath}`, () => {\n            try {\n                // Perform name binding.\n                timing_1.timingStats.bindTime.timeOperation(() => {\n                    this._cleanParseTreeIfRequired();\n                    const fileInfo = this._buildFileInfo(configOptions, this._parseResults.text, importLookup, builtinsScope);\n                    AnalyzerNodeInfo.setFileInfo(this._parseResults.parseTree, fileInfo);\n                    const binder = new binder_1.Binder(fileInfo);\n                    this._isBindingInProgress = true;\n                    this._binderResults = binder.bindModule(this._parseResults.parseTree);\n                    // If we're in \"test mode\" (used for unit testing), run an additional\n                    // \"test walker\" over the parse tree to validate its internal consistency.\n                    if (configOptions.internalTestMode) {\n                        const testWalker = new testWalker_1.TestWalker();\n                        testWalker.walk(this._parseResults.parseTree);\n                    }\n                    this._bindDiagnostics = fileInfo.diagnosticSink.fetchAndClear();\n                    const moduleScope = AnalyzerNodeInfo.getScope(this._parseResults.parseTree);\n                    debug_1.assert(moduleScope !== undefined);\n                    this._moduleSymbolTable = moduleScope.symbolTable;\n                });\n            }\n            catch (e) {\n                const message = (e.stack ? e.stack.toString() : undefined) ||\n                    (typeof e.message === 'string' ? e.message : undefined) ||\n                    JSON.stringify(e);\n                this._console.error(`An internal error occurred while performing name binding for ${this.getFilePath()}: ` + message);\n                const diagSink = new diagnosticSink_1.DiagnosticSink();\n                diagSink.addError(`An internal error occurred while performing name binding`, textRange_1.getEmptyRange());\n                this._bindDiagnostics = diagSink.fetchAndClear();\n                // Do not rethrow the exception, swallow it here. Callers are not\n                // prepared to handle an exception.\n            }\n            finally {\n                this._isBindingInProgress = false;\n            }\n            // Prepare for the next stage of the analysis.\n            this._diagnosticVersion++;\n            this._isCheckingNeeded = true;\n            this._isBindingNeeded = false;\n        });\n    }\n    check(evaluator) {\n        debug_1.assert(!this.isParseRequired());\n        debug_1.assert(!this.isBindingRequired());\n        debug_1.assert(!this._isBindingInProgress);\n        debug_1.assert(this.isCheckingRequired());\n        debug_1.assert(this._parseResults !== undefined);\n        return this._logTracker.log(`checking: ${this._filePath}`, () => {\n            try {\n                timing_1.timingStats.typeCheckerTime.timeOperation(() => {\n                    const checker = new checker_1.Checker(this._parseResults.parseTree, evaluator);\n                    checker.check();\n                    this._isCheckingNeeded = false;\n                    const fileInfo = AnalyzerNodeInfo.getFileInfo(this._parseResults.parseTree);\n                    this._checkerDiagnostics = fileInfo.diagnosticSink.fetchAndClear();\n                });\n            }\n            catch (e) {\n                const isCancellation = cancellationUtils_1.OperationCanceledException.is(e);\n                if (!isCancellation) {\n                    const message = (e.stack ? e.stack.toString() : undefined) ||\n                        (typeof e.message === 'string' ? e.message : undefined) ||\n                        JSON.stringify(e);\n                    this._console.error(`An internal error occurred while while performing type checking for ${this.getFilePath()}: ` +\n                        message);\n                    const diagSink = new diagnosticSink_1.DiagnosticSink();\n                    diagSink.addError(`An internal error occurred while performing type checking`, textRange_1.getEmptyRange());\n                    this._checkerDiagnostics = diagSink.fetchAndClear();\n                    // Mark the file as complete so we don't get into an infinite loop.\n                    this._isCheckingNeeded = false;\n                }\n                throw e;\n            }\n            finally {\n                // Clear any circular dependencies associated with this file.\n                // These will be detected by the program module and associated\n                // with the source file right before it is finalized.\n                this._circularDependencies = [];\n                this._diagnosticVersion++;\n            }\n        });\n    }\n    _buildFileInfo(configOptions, fileContents, importLookup, builtinsScope) {\n        debug_1.assert(this._parseResults !== undefined);\n        const analysisDiagnostics = new diagnosticSink_1.TextRangeDiagnosticSink(this._parseResults.tokenizerOutput.lines);\n        const fileInfo = {\n            importLookup,\n            futureImports: this._parseResults.futureImports,\n            builtinsScope,\n            typingModulePath: this._typingModulePath,\n            collectionsModulePath: this._collectionsModulePath,\n            diagnosticSink: analysisDiagnostics,\n            executionEnvironment: configOptions.findExecEnvironment(this._filePath),\n            diagnosticRuleSet: this._diagnosticRuleSet,\n            fileContents,\n            lines: this._parseResults.tokenizerOutput.lines,\n            filePath: this._filePath,\n            isStubFile: this._isStubFile,\n            isTypingStubFile: this._isTypingStubFile,\n            isTypingExtensionsStubFile: this._isTypingExtensionsStubFile,\n            isBuiltInStubFile: this._isBuiltInStubFile,\n            accessedSymbolMap: new Map(),\n        };\n        return fileInfo;\n    }\n    _cleanParseTreeIfRequired() {\n        if (this._parseResults) {\n            if (this._parseTreeNeedsCleaning) {\n                const cleanerWalker = new parseTreeCleaner_1.ParseTreeCleanerWalker(this._parseResults.parseTree);\n                cleanerWalker.clean();\n                this._parseTreeNeedsCleaning = false;\n            }\n        }\n    }\n    _resolveImports(importResolver, moduleImports, execEnv) {\n        const imports = [];\n        // Always include an implicit import of the builtins module.\n        let builtinsImportResult = importResolver.resolveImport(this._filePath, execEnv, {\n            leadingDots: 0,\n            nameParts: ['builtins'],\n            importedSymbols: undefined,\n        });\n        // Avoid importing builtins from the builtins.pyi file itself.\n        if (builtinsImportResult.resolvedPaths.length === 0 ||\n            builtinsImportResult.resolvedPaths[0] !== this.getFilePath()) {\n            imports.push(builtinsImportResult);\n        }\n        else {\n            builtinsImportResult = undefined;\n        }\n        // Always include an implicit import of the typing module.\n        const typingImportResult = importResolver.resolveImport(this._filePath, execEnv, {\n            leadingDots: 0,\n            nameParts: ['typing'],\n            importedSymbols: undefined,\n        });\n        // Avoid importing typing from the typing.pyi file itself.\n        let typingModulePath;\n        if (typingImportResult.resolvedPaths.length === 0 ||\n            typingImportResult.resolvedPaths[0] !== this.getFilePath()) {\n            imports.push(typingImportResult);\n            typingModulePath = typingImportResult.resolvedPaths[0];\n        }\n        let collectionsModulePath;\n        for (const moduleImport of moduleImports) {\n            const importResult = importResolver.resolveImport(this._filePath, execEnv, {\n                leadingDots: moduleImport.leadingDots,\n                nameParts: moduleImport.nameParts,\n                importedSymbols: moduleImport.importedSymbols,\n            });\n            // If the file imports the stdlib 'collections' module, stash\n            // away its file path. The type analyzer may need this to\n            // access types defined in the collections module.\n            if (importResult.isImportFound && importResult.isTypeshedFile) {\n                if (moduleImport.nameParts.length >= 1 && moduleImport.nameParts[0] === 'collections') {\n                    collectionsModulePath = importResult.resolvedPaths[importResult.resolvedPaths.length - 1];\n                }\n            }\n            imports.push(importResult);\n            // Associate the import results with the module import\n            // name node in the parse tree so we can access it later\n            // (for hover and definition support).\n            AnalyzerNodeInfo.setImportInfo(moduleImport.nameNode, importResult);\n        }\n        return [imports, builtinsImportResult, typingModulePath, collectionsModulePath];\n    }\n}\nexports.SourceFile = SourceFile;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/sourceFile.ts?");

/***/ }),

/***/ "./src/analyzer/sourceMapper.ts":
/*!**************************************!*\
  !*** ./src/analyzer/sourceMapper.ts ***!
  \**************************************/
/*! flagged exports */
/*! export SourceMapper [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isStubFile [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * sourceMapper.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Logic that maps a (.pyi) stub to its (.py) implementation source file.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isStubFile = exports.SourceMapper = void 0;\nconst AnalyzerNodeInfo = __webpack_require__(/*! ../analyzer/analyzerNodeInfo */ \"./src/analyzer/analyzerNodeInfo.ts\");\nconst ParseTreeUtils = __webpack_require__(/*! ../analyzer/parseTreeUtils */ \"./src/analyzer/parseTreeUtils.ts\");\nconst pathUtils_1 = __webpack_require__(/*! ../common/pathUtils */ \"./src/common/pathUtils.ts\");\nclass SourceMapper {\n    constructor(_importResolver, _execEnv, _evaluator, _fileBinder) {\n        this._importResolver = _importResolver;\n        this._execEnv = _execEnv;\n        this._evaluator = _evaluator;\n        this._fileBinder = _fileBinder;\n    }\n    findModules(stubFilePath) {\n        const sourceFiles = this._getBoundSourceFiles(stubFilePath);\n        return sourceFiles.map((sf) => { var _a; return (_a = sf.getParseResults()) === null || _a === void 0 ? void 0 : _a.parseTree; }).filter(_isDefined);\n    }\n    findDeclarations(stubDecl) {\n        if (stubDecl.type === 4 /* Class */) {\n            return this.findClassDeclarations(stubDecl);\n        }\n        else if (stubDecl.type === 3 /* Function */) {\n            return this.findFunctionDeclarations(stubDecl);\n        }\n        return [];\n    }\n    findClassDeclarations(stubDecl) {\n        const className = this._getFullClassName(stubDecl.node);\n        const sourceFiles = this._getBoundSourceFiles(stubDecl.path);\n        return sourceFiles.flatMap((sourceFile) => this._findClassDeclarations(sourceFile, className));\n    }\n    findFunctionDeclarations(stubDecl) {\n        const functionName = stubDecl.node.name.value;\n        const sourceFiles = this._getBoundSourceFiles(stubDecl.path);\n        if (stubDecl.isMethod) {\n            const classNode = ParseTreeUtils.getEnclosingClass(stubDecl.node);\n            if (classNode === undefined) {\n                return [];\n            }\n            const className = this._getFullClassName(classNode);\n            return sourceFiles.flatMap((sourceFile) => this._findMethodDeclarations(sourceFile, className, functionName));\n        }\n        else {\n            return sourceFiles.flatMap((sourceFile) => this._findFunctionDeclarations(sourceFile, functionName));\n        }\n    }\n    _findMethodDeclarations(sourceFile, className, functionName) {\n        const result = [];\n        const classDecls = this._findClassDeclarations(sourceFile, className);\n        for (const classDecl of classDecls) {\n            const methodDecls = this._lookUpSymbolDeclarations(classDecl.node, functionName);\n            for (const methodDecl of methodDecls) {\n                if (methodDecl.type === 3 /* Function */ && methodDecl.isMethod) {\n                    result.push(methodDecl);\n                }\n            }\n        }\n        return result;\n    }\n    _findFunctionDeclarations(sourceFile, functionName) {\n        var _a;\n        const result = [];\n        const functionDecls = this._lookUpSymbolDeclarations((_a = sourceFile.getParseResults()) === null || _a === void 0 ? void 0 : _a.parseTree, functionName);\n        for (const functionDecl of functionDecls) {\n            if (functionDecl.type === 3 /* Function */) {\n                result.push(functionDecl);\n            }\n            else if (functionDecl.type === 6 /* Alias */) {\n                const resolvedDecl = this._evaluator.resolveAliasDeclaration(functionDecl, \n                /* resolveLocalNames */ true);\n                if (resolvedDecl) {\n                    if (resolvedDecl.type === 3 /* Function */) {\n                        if (isStubFile(resolvedDecl.path)) {\n                            result.push(...this.findFunctionDeclarations(resolvedDecl));\n                        }\n                        else {\n                            result.push(resolvedDecl);\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    _findClassDeclarations(sourceFile, fullClassName) {\n        var _a;\n        let result = [];\n        // fullClassName is period delimited, for example: 'OuterClass.InnerClass'\n        const parentNode = (_a = sourceFile.getParseResults()) === null || _a === void 0 ? void 0 : _a.parseTree;\n        if (parentNode) {\n            let classNameParts = fullClassName.split('.');\n            if (classNameParts.length > 0) {\n                result = this._findClassDeclarationsUnderNode(sourceFile, classNameParts[0], parentNode);\n                classNameParts = classNameParts.slice(1);\n            }\n            for (const classNamePart of classNameParts) {\n                result = this._findClassDeclarationsUnderClass(sourceFile, classNamePart, result);\n            }\n        }\n        return result;\n    }\n    _findClassDeclarationsUnderClass(sourceFile, className, parentClassDecls) {\n        return parentClassDecls.flatMap((parentDecl) => this._findClassDeclarationsUnderNode(sourceFile, className, parentDecl.node));\n    }\n    _findClassDeclarationsUnderNode(sourceFile, className, parentNode) {\n        const result = [];\n        for (const decl of this._lookUpSymbolDeclarations(parentNode, className)) {\n            if (decl.type === 4 /* Class */) {\n                result.push(decl);\n            }\n        }\n        return result;\n    }\n    _lookUpSymbolDeclarations(node, symbolName) {\n        if (node === undefined) {\n            return [];\n        }\n        const moduleScope = AnalyzerNodeInfo.getScope(node);\n        const symbol = moduleScope === null || moduleScope === void 0 ? void 0 : moduleScope.lookUpSymbol(symbolName);\n        const decls = symbol === null || symbol === void 0 ? void 0 : symbol.getDeclarations();\n        return decls !== null && decls !== void 0 ? decls : [];\n    }\n    _getFullClassName(node) {\n        const fullName = [];\n        let current = node;\n        while (current !== undefined) {\n            fullName.push(current.name.value);\n            current = ParseTreeUtils.getEnclosingClass(current);\n        }\n        return fullName.reverse().join('.');\n    }\n    _getBoundSourceFiles(stubFilePath) {\n        const paths = this._importResolver.getSourceFilesFromStub(stubFilePath, this._execEnv);\n        return paths.map((fp) => this._fileBinder(stubFilePath, fp)).filter(_isDefined);\n    }\n}\nexports.SourceMapper = SourceMapper;\nfunction isStubFile(filePath) {\n    return pathUtils_1.getAnyExtensionFromPath(filePath, ['.pyi'], /* ignoreCase */ false) === '.pyi';\n}\nexports.isStubFile = isStubFile;\nfunction _isDefined(element) {\n    return element !== undefined;\n}\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/sourceMapper.ts?");

/***/ }),

/***/ "./src/analyzer/staticExpressions.ts":
/*!*******************************************!*\
  !*** ./src/analyzer/staticExpressions.ts ***!
  \*******************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export evaluateStaticBoolExpression [provided] [no usage info] [missing usage info prevents renaming] */
/*! export evaluateStaticBoolLikeExpression [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * staticExpressions.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Collection of static methods that operate on expressions\n * (parse node trees).\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.evaluateStaticBoolLikeExpression = exports.evaluateStaticBoolExpression = void 0;\n// Returns undefined if the expression cannot be evaluated\n// statically as a bool value or true/false if it can.\nfunction evaluateStaticBoolExpression(node, execEnv) {\n    if (node.nodeType === 56 /* UnaryOperation */) {\n        if (node.operator === 37 /* Or */ || node.operator === 36 /* And */) {\n            const value = evaluateStaticBoolLikeExpression(node.expression, execEnv);\n            if (value !== undefined) {\n                return !value;\n            }\n        }\n    }\n    else if (node.nodeType === 7 /* BinaryOperation */) {\n        // Is it an OR or AND expression?\n        if (node.operator === 37 /* Or */ || node.operator === 36 /* And */) {\n            const leftValue = evaluateStaticBoolExpression(node.leftExpression, execEnv);\n            const rightValue = evaluateStaticBoolExpression(node.rightExpression, execEnv);\n            if (leftValue === undefined || rightValue === undefined) {\n                return undefined;\n            }\n            if (node.operator === 37 /* Or */) {\n                return leftValue || rightValue;\n            }\n            else {\n                return leftValue && rightValue;\n            }\n        }\n        if (_isSysVersionInfoExpression(node.leftExpression) && node.rightExpression.nodeType === 53 /* Tuple */) {\n            // Handle the special case of \"sys.version_info >= (3, x)\"\n            const comparisonVersion = _convertTupleToVersion(node.rightExpression);\n            return _evaluateNumericBinaryOperation(node.operator, execEnv.pythonVersion, comparisonVersion);\n        }\n        else if (node.leftExpression.nodeType === 24 /* Index */ &&\n            _isSysVersionInfoExpression(node.leftExpression.baseExpression) &&\n            node.leftExpression.items.items.length === 1 &&\n            node.leftExpression.items.items[0].nodeType === 41 /* Number */ &&\n            !node.leftExpression.items.items[0].isImaginary &&\n            node.leftExpression.items.items[0].value === 0 &&\n            node.rightExpression.nodeType === 41 /* Number */) {\n            // Handle the special case of \"sys.version_info[0] >= X\"\n            return _evaluateNumericBinaryOperation(node.operator, Math.floor(execEnv.pythonVersion / 256), node.rightExpression.value);\n        }\n        else if (_isSysPlatformInfoExpression(node.leftExpression) &&\n            node.rightExpression.nodeType === 49 /* StringList */) {\n            // Handle the special case of \"sys.platform != 'X'\"\n            const comparisonPlatform = node.rightExpression.strings.map((s) => s.value).join('');\n            const expectedPlatformName = _getExpectedPlatformNameFromPlatform(execEnv);\n            return _evaluateStringBinaryOperation(node.operator, expectedPlatformName || '', comparisonPlatform);\n        }\n        else if (_isOsNameInfoExpression(node.leftExpression) &&\n            node.rightExpression.nodeType === 49 /* StringList */) {\n            // Handle the special case of \"os.name == 'X'\"\n            const comparisonOsName = node.rightExpression.strings.map((s) => s.value).join('');\n            const expectedOsName = _getExpectedOsNameFromPlatform(execEnv);\n            if (expectedOsName !== undefined) {\n                return _evaluateStringBinaryOperation(node.operator, expectedOsName, comparisonOsName);\n            }\n        }\n    }\n    else if (node.nodeType === 11 /* Constant */) {\n        if (node.constType === 31 /* True */) {\n            return true;\n        }\n        else if (node.constType === 14 /* False */) {\n            return false;\n        }\n    }\n    else if (node.nodeType === 39 /* Name */) {\n        if (node.value === 'TYPE_CHECKING') {\n            return true;\n        }\n    }\n    else if (node.nodeType === 36 /* MemberAccess */ &&\n        node.memberName.value === 'TYPE_CHECKING' &&\n        node.leftExpression.nodeType === 39 /* Name */ &&\n        node.leftExpression.value === 'typing') {\n        return true;\n    }\n    return undefined;\n}\nexports.evaluateStaticBoolExpression = evaluateStaticBoolExpression;\n// Similar to evaluateStaticBoolExpression except that it handles\n// other non-bool values that are statically falsy or truthy\n// (like \"None\").\nfunction evaluateStaticBoolLikeExpression(node, execEnv) {\n    if (node.nodeType === 11 /* Constant */) {\n        if (node.constType === 24 /* None */) {\n            return false;\n        }\n    }\n    return evaluateStaticBoolExpression(node, execEnv);\n}\nexports.evaluateStaticBoolLikeExpression = evaluateStaticBoolLikeExpression;\nfunction _convertTupleToVersion(node) {\n    let comparisonVersion;\n    // Ignore patch versions.\n    if (node.expressions.length >= 2) {\n        if (node.expressions[0].nodeType === 41 /* Number */ &&\n            !node.expressions[0].isImaginary &&\n            node.expressions[1].nodeType === 41 /* Number */ &&\n            !node.expressions[1].isImaginary) {\n            const majorVersion = node.expressions[0];\n            const minorVersion = node.expressions[1];\n            comparisonVersion = majorVersion.value * 256 + minorVersion.value;\n        }\n    }\n    else if (node.expressions.length === 1) {\n        const majorVersion = node.expressions[0];\n        comparisonVersion = majorVersion.value * 256;\n    }\n    return comparisonVersion;\n}\nfunction _evaluateNumericBinaryOperation(operatorType, leftValue, rightValue) {\n    if (leftValue !== undefined && rightValue !== undefined) {\n        if (operatorType === 20 /* LessThan */) {\n            return leftValue < rightValue;\n        }\n        else if (operatorType === 21 /* LessThanOrEqual */) {\n            return leftValue <= rightValue;\n        }\n        else if (operatorType === 15 /* GreaterThan */) {\n            return leftValue > rightValue;\n        }\n        else if (operatorType === 16 /* GreaterThanOrEqual */) {\n            return leftValue >= rightValue;\n        }\n        else if (operatorType === 12 /* Equals */) {\n            return leftValue === rightValue;\n        }\n        else if (operatorType === 28 /* NotEquals */) {\n            return leftValue !== rightValue;\n        }\n    }\n    return undefined;\n}\nfunction _evaluateStringBinaryOperation(operatorType, leftValue, rightValue) {\n    if (leftValue !== undefined && rightValue !== undefined) {\n        if (operatorType === 12 /* Equals */) {\n            return leftValue === rightValue;\n        }\n        else if (operatorType === 28 /* NotEquals */) {\n            return leftValue !== rightValue;\n        }\n    }\n    return undefined;\n}\nfunction _isSysVersionInfoExpression(node) {\n    if (node.nodeType === 36 /* MemberAccess */) {\n        if (node.leftExpression.nodeType === 39 /* Name */ &&\n            node.leftExpression.value === 'sys' &&\n            node.memberName.value === 'version_info') {\n            return true;\n        }\n    }\n    return false;\n}\nfunction _isSysPlatformInfoExpression(node) {\n    if (node.nodeType === 36 /* MemberAccess */) {\n        if (node.leftExpression.nodeType === 39 /* Name */ &&\n            node.leftExpression.value === 'sys' &&\n            node.memberName.value === 'platform') {\n            return true;\n        }\n    }\n    return false;\n}\nfunction _isOsNameInfoExpression(node) {\n    if (node.nodeType === 36 /* MemberAccess */) {\n        if (node.leftExpression.nodeType === 39 /* Name */ &&\n            node.leftExpression.value === 'os' &&\n            node.memberName.value === 'name') {\n            return true;\n        }\n    }\n    return false;\n}\nfunction _getExpectedPlatformNameFromPlatform(execEnv) {\n    if (execEnv.pythonPlatform === 'Darwin') {\n        return 'darwin';\n    }\n    else if (execEnv.pythonPlatform === 'Windows') {\n        return 'win32';\n    }\n    else if (execEnv.pythonPlatform === 'Linux') {\n        return 'linux';\n    }\n    return undefined;\n}\nfunction _getExpectedOsNameFromPlatform(execEnv) {\n    if (execEnv.pythonPlatform === 'Darwin') {\n        return 'posix';\n    }\n    else if (execEnv.pythonPlatform === 'Windows') {\n        return 'nt';\n    }\n    else if (execEnv.pythonPlatform === 'Linux') {\n        return 'posix';\n    }\n    return undefined;\n}\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/staticExpressions.ts?");

/***/ }),

/***/ "./src/analyzer/symbol.ts":
/*!********************************!*\
  !*** ./src/analyzer/symbol.ts ***!
  \********************************/
/*! flagged exports */
/*! export Symbol [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export indeterminateSymbolId [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * symbol.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Represents an association between a name and the type\n * (or multiple types) that the symbol is associated with\n * in the program.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Symbol = exports.indeterminateSymbolId = void 0;\nconst declarationUtils_1 = __webpack_require__(/*! ./declarationUtils */ \"./src/analyzer/declarationUtils.ts\");\nlet nextSymbolId = 1;\nfunction getUniqueSymbolId() {\n    return nextSymbolId++;\n}\n// Symbol ID that indicates that there is no specific symbol.\nexports.indeterminateSymbolId = 0;\nclass Symbol {\n    constructor(flags = 4 /* ClassMember */) {\n        this.id = getUniqueSymbolId();\n        this._flags = flags;\n    }\n    static createWithType(flags, type) {\n        const newSymbol = new Symbol(flags);\n        newSymbol._synthesizedType = type;\n        return newSymbol;\n    }\n    isInitiallyUnbound() {\n        return !!(this._flags & 1 /* InitiallyUnbound */);\n    }\n    setIsExternallyHidden() {\n        this._flags |= 2 /* ExternallyHidden */;\n    }\n    isExternallyHidden() {\n        return !!(this._flags & 2 /* ExternallyHidden */);\n    }\n    setIsIgnoredForProtocolMatch() {\n        this._flags |= 64 /* IgnoredForProtocolMatch */;\n    }\n    isIgnoredForProtocolMatch() {\n        return !!(this._flags & 64 /* IgnoredForProtocolMatch */);\n    }\n    setIsClassMember() {\n        this._flags |= 4 /* ClassMember */;\n    }\n    isClassMember() {\n        return !!(this._flags & 4 /* ClassMember */);\n    }\n    isInaccessibleToInstance() {\n        return !!(this._flags & 16 /* InaccessibleToInstance */);\n    }\n    setIsInstanceMember() {\n        this._flags |= 8 /* InstanceMember */;\n    }\n    isInstanceMember() {\n        return !!(this._flags & 8 /* InstanceMember */);\n    }\n    setIsClassVar() {\n        this._flags |= 128 /* ClassVar */;\n    }\n    isClassVar() {\n        return !!(this._flags & 128 /* ClassVar */);\n    }\n    setIsPrivateMember() {\n        this._flags |= 32 /* PrivateMember */;\n    }\n    isPrivateMember() {\n        return !!(this._flags & 32 /* PrivateMember */);\n    }\n    addDeclaration(declaration) {\n        if (this._declarations) {\n            // See if this node was already identified as a declaration. If so,\n            // replace it. Otherwise, add it as a new declaration to the end of\n            // the list.\n            const declIndex = this._declarations.findIndex((decl) => declarationUtils_1.areDeclarationsSame(decl, declaration));\n            if (declIndex < 0) {\n                this._declarations.push(declaration);\n            }\n            else {\n                // If the new declaration has a defined type, it should replace\n                // the existing one.\n                const curDecl = this._declarations[declIndex];\n                if (declarationUtils_1.hasTypeForDeclaration(declaration)) {\n                    this._declarations[declIndex] = declaration;\n                    if (curDecl.type === 1 /* Variable */ && declaration.type === 1 /* Variable */) {\n                        if (!declaration.inferredTypeSource && curDecl.inferredTypeSource) {\n                            declaration.inferredTypeSource = curDecl.inferredTypeSource;\n                        }\n                    }\n                }\n                else if (declaration.type === 1 /* Variable */) {\n                    // If it's marked \"final\" or \"type alias\", this should be reflected\n                    // in the existing declaration. Likewise, if the existing declaration\n                    // doesn't have a type source, add it.\n                    if (curDecl.type === 1 /* Variable */) {\n                        if (declaration.isFinal) {\n                            curDecl.isFinal = true;\n                        }\n                        if (declaration.isTypeAlias) {\n                            curDecl.isTypeAlias = true;\n                        }\n                        if (!curDecl.inferredTypeSource && declaration.inferredTypeSource) {\n                            curDecl.inferredTypeSource = declaration.inferredTypeSource;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            this._declarations = [declaration];\n        }\n    }\n    hasDeclarations() {\n        return this._declarations ? this._declarations.length > 0 : false;\n    }\n    getDeclarations() {\n        return this._declarations ? this._declarations : [];\n    }\n    hasTypedDeclarations() {\n        // We'll treat an synthesized type as an implicit declaration.\n        if (this._synthesizedType) {\n            return true;\n        }\n        return this.getDeclarations().some((decl) => declarationUtils_1.hasTypeForDeclaration(decl));\n    }\n    getTypedDeclarations() {\n        return this.getDeclarations().filter((decl) => declarationUtils_1.hasTypeForDeclaration(decl));\n    }\n    getSynthesizedType() {\n        return this._synthesizedType;\n    }\n}\nexports.Symbol = Symbol;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/symbol.ts?");

/***/ }),

/***/ "./src/analyzer/symbolNameUtils.ts":
/*!*****************************************!*\
  !*** ./src/analyzer/symbolNameUtils.ts ***!
  \*****************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isConstantName [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isDunderName [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isPrivateName [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isPrivateOrProtectedName [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isProtectedName [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * symbolNameUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Static methods that apply to symbols or symbol names.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isConstantName = exports.isDunderName = exports.isPrivateOrProtectedName = exports.isProtectedName = exports.isPrivateName = void 0;\nconst _constantRegEx = /^[A-Z0-9_]+$/;\nconst _underscoreOnlyRegEx = /^[_]+$/;\n// Private symbol names start with a double underscore.\nfunction isPrivateName(name) {\n    return name.length > 2 && name.startsWith('__') && !name.endsWith('__');\n}\nexports.isPrivateName = isPrivateName;\n// Protected symbol names start with a single underscore.\nfunction isProtectedName(name) {\n    return name.length > 1 && name.startsWith('_') && !name.startsWith('__');\n}\nexports.isProtectedName = isProtectedName;\nfunction isPrivateOrProtectedName(name) {\n    return isPrivateName(name) || isProtectedName(name);\n}\nexports.isPrivateOrProtectedName = isPrivateOrProtectedName;\n// \"Dunder\" names start and end with two underscores.\nfunction isDunderName(name) {\n    return name.length > 4 && name.startsWith('__') && name.endsWith('__');\n}\nexports.isDunderName = isDunderName;\n// Constants are all-caps with possible numbers and underscores.\nfunction isConstantName(name) {\n    return !!name.match(_constantRegEx) && !name.match(_underscoreOnlyRegEx);\n}\nexports.isConstantName = isConstantName;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/symbolNameUtils.ts?");

/***/ }),

/***/ "./src/analyzer/symbolUtils.ts":
/*!*************************************!*\
  !*** ./src/analyzer/symbolUtils.ts ***!
  \*************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getLastTypedDeclaredForSymbol [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isFinalVariable [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isTypedDictMemberAccessedThroughIndex [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * symbolUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Collection of functions that operate on Symbol objects.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isFinalVariable = exports.isTypedDictMemberAccessedThroughIndex = exports.getLastTypedDeclaredForSymbol = void 0;\nconst declarationUtils_1 = __webpack_require__(/*! ./declarationUtils */ \"./src/analyzer/declarationUtils.ts\");\nfunction getLastTypedDeclaredForSymbol(symbol) {\n    const typedDecls = symbol.getTypedDeclarations();\n    if (typedDecls.length > 0) {\n        return typedDecls[typedDecls.length - 1];\n    }\n    return undefined;\n}\nexports.getLastTypedDeclaredForSymbol = getLastTypedDeclaredForSymbol;\n// Within TypedDict classes, member variables are not accessible as\n// normal attributes. Instead, they are accessed through index operations.\nfunction isTypedDictMemberAccessedThroughIndex(symbol) {\n    const typedDecls = symbol.getTypedDeclarations();\n    if (typedDecls.length > 0) {\n        const lastDecl = typedDecls[typedDecls.length - 1];\n        if (lastDecl.type === 1 /* Variable */) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.isTypedDictMemberAccessedThroughIndex = isTypedDictMemberAccessedThroughIndex;\nfunction isFinalVariable(symbol) {\n    return symbol.getDeclarations().some((decl) => declarationUtils_1.isFinalVariableDeclaration(decl));\n}\nexports.isFinalVariable = isFinalVariable;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/symbolUtils.ts?");

/***/ }),

/***/ "./src/analyzer/testWalker.ts":
/*!************************************!*\
  !*** ./src/analyzer/testWalker.ts ***!
  \************************************/
/*! flagged exports */
/*! export TestWalker [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * testWalker.ts\n *\n * Walks a parse tree to validate internal consistency and completeness.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TestWalker = void 0;\nconst parseTreeWalker_1 = __webpack_require__(/*! ../analyzer/parseTreeWalker */ \"./src/analyzer/parseTreeWalker.ts\");\nconst debug_1 = __webpack_require__(/*! ../common/debug */ \"./src/common/debug.ts\");\nconst textRange_1 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\nclass TestWalker extends parseTreeWalker_1.ParseTreeWalker {\n    constructor() {\n        super();\n    }\n    visitNode(node) {\n        const children = super.visitNode(node);\n        this._verifyParentChildLinks(node, children);\n        this._verifyChildRanges(node, children);\n        return children;\n    }\n    // Make sure that all of the children point to their parent.\n    _verifyParentChildLinks(node, children) {\n        children.forEach((child) => {\n            if (child) {\n                if (child.parent !== node) {\n                    debug_1.fail(`Child node ${child.nodeType} does not ` + `contain a reference to its parent ${node.nodeType}`);\n                }\n            }\n        });\n    }\n    // Verify that:\n    //      Children are all contained within the parent\n    //      Children have non-overlapping ranges\n    //      Children are listed in increasing order\n    _verifyChildRanges(node, children) {\n        let prevNode;\n        children.forEach((child) => {\n            if (child) {\n                let skipCheck = false;\n                // There are a few exceptions we need to deal with here. Comment\n                // annotations can occur outside of an assignment node's range.\n                if (node.nodeType === 3 /* Assignment */) {\n                    if (child === node.typeAnnotationComment) {\n                        skipCheck = true;\n                    }\n                }\n                if (node.nodeType === 49 /* StringList */) {\n                    if (child === node.typeAnnotation) {\n                        skipCheck = true;\n                    }\n                }\n                if (!skipCheck) {\n                    // Make sure the child is contained within the parent.\n                    if (child.start < node.start || textRange_1.TextRange.getEnd(child) > textRange_1.TextRange.getEnd(node)) {\n                        debug_1.fail(`Child node ${child.nodeType} is not ` + `contained within its parent ${node.nodeType}`);\n                    }\n                    if (prevNode) {\n                        // Make sure the child is after the previous child.\n                        if (child.start < textRange_1.TextRange.getEnd(prevNode)) {\n                            debug_1.fail(`Child node is not after previous child node`);\n                        }\n                    }\n                    prevNode = child;\n                }\n            }\n        });\n    }\n}\nexports.TestWalker = TestWalker;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/testWalker.ts?");

/***/ }),

/***/ "./src/analyzer/typeCache.ts":
/*!***********************************!*\
  !*** ./src/analyzer/typeCache.ts ***!
  \***********************************/
/*! flagged exports */
/*! export IncompleteTypeTracker [provided] [no usage info] [missing usage info prevents renaming] */
/*! export SpeculativeTypeTracker [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isIncompleteType [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * typeCache.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Module used by the type evaluator that caches computed types\n * and stores them by node ID.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IncompleteTypeTracker = exports.SpeculativeTypeTracker = exports.isIncompleteType = void 0;\nconst debug_1 = __webpack_require__(/*! ../common/debug */ \"./src/common/debug.ts\");\n// Define a user type guard function for IncompleteType.\nfunction isIncompleteType(cachedType) {\n    return !!cachedType.isIncompleteType;\n}\nexports.isIncompleteType = isIncompleteType;\n// This class maintains a stack of \"speculative type contexts\". When\n// a context is popped off the stack, all of the speculative type cache\n// entries that were created within that context are removed from the\n// corresponding type caches because they are no longer valid.\nclass SpeculativeTypeTracker {\n    constructor() {\n        this._speculativeContextStack = [];\n    }\n    enterSpeculativeContext(speculativeRootNode) {\n        this._speculativeContextStack.push({ speculativeRootNode, entriesToUndo: [] });\n    }\n    leaveSpeculativeContext() {\n        debug_1.assert(this._speculativeContextStack.length > 0);\n        const context = this._speculativeContextStack.pop();\n        // Delete all of the speculative type cache entries\n        // that were tracked in this context.\n        context.entriesToUndo.forEach((entry) => {\n            entry.cache.delete(entry.id);\n        });\n    }\n    isSpeculative() {\n        return this._speculativeContextStack.length > 0;\n    }\n    getSpeculativeRootNode() {\n        const stackDepth = this._speculativeContextStack.length;\n        if (stackDepth > 0) {\n            // Return the speculative node associated with the most\n            // recent context pushed onto the stack.\n            return this._speculativeContextStack[stackDepth - 1].speculativeRootNode;\n        }\n        return undefined;\n    }\n    trackEntry(cache, id) {\n        const stackSize = this._speculativeContextStack.length;\n        if (stackSize > 0) {\n            this._speculativeContextStack[stackSize - 1].entriesToUndo.push({\n                cache,\n                id,\n            });\n        }\n    }\n    // Temporarily disables speculative mode, clearing the stack\n    // of speculative contexts. It returns the stack so the caller\n    // can later restore it by calling enableSpeculativeMode.\n    disableSpeculativeMode() {\n        const stack = this._speculativeContextStack;\n        this._speculativeContextStack = [];\n        return stack;\n    }\n    enableSpeculativeMode(stack) {\n        debug_1.assert(this._speculativeContextStack.length === 0);\n        this._speculativeContextStack = stack;\n    }\n}\nexports.SpeculativeTypeTracker = SpeculativeTypeTracker;\n// This class tracks a list of cache entries that need to be\n// undone because they were based on an \"incomplete type\" -\n// a type that is calculated during code flow analysis and\n// is incomplete because not all paths have been exhaustively\n// explored.\nclass IncompleteTypeTracker {\n    constructor() {\n        this._entriesToUndo = [];\n        this._requiresUndo = false;\n    }\n    trackEntry(cache, id) {\n        if (this._requiresUndo) {\n            this._entriesToUndo.push({\n                cache,\n                id,\n            });\n        }\n    }\n    leaveIncompleteTypeMode() {\n        this._entriesToUndo.forEach((entry) => {\n            entry.cache.delete(entry.id);\n        });\n        this._requiresUndo = false;\n        this._entriesToUndo = [];\n    }\n    enterIncompleteTypeMode() {\n        // Note that subsequent types are based on incomplete\n        // type information and should be tracked and ultimately\n        // removed from the cache.\n        this._requiresUndo = true;\n    }\n    isIncompleteTypeMode() {\n        return this._requiresUndo;\n    }\n}\nexports.IncompleteTypeTracker = IncompleteTypeTracker;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/typeCache.ts?");

/***/ }),

/***/ "./src/analyzer/typeDocStringUtils.ts":
/*!********************************************!*\
  !*** ./src/analyzer/typeDocStringUtils.ts ***!
  \********************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getClassDocString [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getFunctionDocStringFromDeclaration [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getFunctionDocStringFromType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getModuleDocString [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getOverloadedFunctionDocStrings [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * typeDocStringUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Logic that obtains the doc string for types by looking\n * at the declaration in the type stub, and if needed, in\n * the source file.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getFunctionDocStringFromDeclaration = exports.getFunctionDocStringFromType = exports.getClassDocString = exports.getModuleDocString = exports.getOverloadedFunctionDocStrings = void 0;\nconst ParseTreeUtils = __webpack_require__(/*! ../analyzer/parseTreeUtils */ \"./src/analyzer/parseTreeUtils.ts\");\nconst sourceMapper_1 = __webpack_require__(/*! ../analyzer/sourceMapper */ \"./src/analyzer/sourceMapper.ts\");\nfunction getOverloadedFunctionDocStrings(type, resolvedDecl, sourceMapper) {\n    const docStrings = [];\n    if (type.overloads.some((o) => o.details.docString)) {\n        type.overloads.forEach((overload) => {\n            if (overload.details.docString) {\n                docStrings.push(overload.details.docString);\n            }\n        });\n    }\n    else if (resolvedDecl && sourceMapper_1.isStubFile(resolvedDecl.path) && resolvedDecl.type === 3 /* Function */) {\n        const implDecls = sourceMapper.findFunctionDeclarations(resolvedDecl);\n        const docString = _getFunctionOrClassDeclDocString(implDecls);\n        if (docString) {\n            docStrings.push(docString);\n        }\n    }\n    return docStrings;\n}\nexports.getOverloadedFunctionDocStrings = getOverloadedFunctionDocStrings;\nfunction getModuleDocString(type, resolvedDecl, sourceMapper) {\n    let docString = type.docString;\n    if (!docString) {\n        if (resolvedDecl && sourceMapper_1.isStubFile(resolvedDecl.path)) {\n            const modules = sourceMapper.findModules(resolvedDecl.path);\n            docString = _getModuleNodeDocString(modules);\n        }\n    }\n    return docString;\n}\nexports.getModuleDocString = getModuleDocString;\nfunction getClassDocString(type, resolvedDecl, sourceMapper) {\n    let docString = type.details.docString;\n    if (!docString) {\n        if (resolvedDecl && sourceMapper_1.isStubFile(resolvedDecl.path) && resolvedDecl.type === 4 /* Class */) {\n            const implDecls = sourceMapper.findClassDeclarations(resolvedDecl);\n            docString = _getFunctionOrClassDeclDocString(implDecls);\n        }\n    }\n    return docString;\n}\nexports.getClassDocString = getClassDocString;\nfunction getFunctionDocStringFromType(type, sourceMapper) {\n    let docString = type.details.docString;\n    if (!docString && type.details.declaration) {\n        docString = getFunctionDocStringFromDeclaration(type.details.declaration, sourceMapper);\n    }\n    return docString;\n}\nexports.getFunctionDocStringFromType = getFunctionDocStringFromType;\nfunction getFunctionDocStringFromDeclaration(resolvedDecl, sourceMapper) {\n    let docString = _getFunctionOrClassDeclDocString([resolvedDecl]);\n    if (!docString && sourceMapper_1.isStubFile(resolvedDecl.path)) {\n        const implDecls = sourceMapper.findFunctionDeclarations(resolvedDecl);\n        docString = _getFunctionOrClassDeclDocString(implDecls);\n    }\n    return docString;\n}\nexports.getFunctionDocStringFromDeclaration = getFunctionDocStringFromDeclaration;\nfunction _getFunctionOrClassDeclDocString(decls) {\n    var _a, _b;\n    for (const decl of decls) {\n        const docString = ParseTreeUtils.getDocString((_b = (_a = decl.node) === null || _a === void 0 ? void 0 : _a.suite) === null || _b === void 0 ? void 0 : _b.statements);\n        if (docString) {\n            return docString;\n        }\n    }\n    return undefined;\n}\nfunction _getModuleNodeDocString(modules) {\n    for (const module of modules) {\n        if (module.statements) {\n            const docString = ParseTreeUtils.getDocString(module.statements);\n            if (docString) {\n                return docString;\n            }\n        }\n    }\n    return undefined;\n}\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/typeDocStringUtils.ts?");

/***/ }),

/***/ "./src/analyzer/typeEvaluator.ts":
/*!***************************************!*\
  !*** ./src/analyzer/typeEvaluator.ts ***!
  \***************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export createTypeEvaluator [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * typeEvaluator.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Module that evaluates types of parse tree nodes within\n * a program.\n *\n * Note: This is a gargantuan module - much larger than I would\n * normally create. It is written this way primarily for performance,\n * with the internal methods having access to the full closure of\n * the createTypeEvaluator function. This is the same approach\n * taken by the TypeScript compiler.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createTypeEvaluator = void 0;\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst debug_1 = __webpack_require__(/*! ../common/debug */ \"./src/common/debug.ts\");\nconst diagnostic_1 = __webpack_require__(/*! ../common/diagnostic */ \"./src/common/diagnostic.ts\");\nconst positionUtils_1 = __webpack_require__(/*! ../common/positionUtils */ \"./src/common/positionUtils.ts\");\nconst pythonVersion_1 = __webpack_require__(/*! ../common/pythonVersion */ \"./src/common/pythonVersion.ts\");\nconst textRange_1 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\nconst localize_1 = __webpack_require__(/*! ../localization/localize */ \"./src/localization/localize.ts\");\nconst parseNodes_1 = __webpack_require__(/*! ../parser/parseNodes */ \"./src/parser/parseNodes.ts\");\nconst parser_1 = __webpack_require__(/*! ../parser/parser */ \"./src/parser/parser.ts\");\nconst AnalyzerNodeInfo = __webpack_require__(/*! ./analyzerNodeInfo */ \"./src/analyzer/analyzerNodeInfo.ts\");\nconst codeFlow_1 = __webpack_require__(/*! ./codeFlow */ \"./src/analyzer/codeFlow.ts\");\nconst declarationUtils_1 = __webpack_require__(/*! ./declarationUtils */ \"./src/analyzer/declarationUtils.ts\");\nconst ParseTreeUtils = __webpack_require__(/*! ./parseTreeUtils */ \"./src/analyzer/parseTreeUtils.ts\");\nconst ScopeUtils = __webpack_require__(/*! ./scopeUtils */ \"./src/analyzer/scopeUtils.ts\");\nconst staticExpressions_1 = __webpack_require__(/*! ./staticExpressions */ \"./src/analyzer/staticExpressions.ts\");\nconst symbol_1 = __webpack_require__(/*! ./symbol */ \"./src/analyzer/symbol.ts\");\nconst symbolNameUtils_1 = __webpack_require__(/*! ./symbolNameUtils */ \"./src/analyzer/symbolNameUtils.ts\");\nconst symbolUtils_1 = __webpack_require__(/*! ./symbolUtils */ \"./src/analyzer/symbolUtils.ts\");\nconst typeCache_1 = __webpack_require__(/*! ./typeCache */ \"./src/analyzer/typeCache.ts\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/analyzer/types.ts\");\nconst typeUtils_1 = __webpack_require__(/*! ./typeUtils */ \"./src/analyzer/typeUtils.ts\");\nconst typeVarMap_1 = __webpack_require__(/*! ./typeVarMap */ \"./src/analyzer/typeVarMap.ts\");\nconst arithmeticOperatorMap = {\n    [0 /* Add */]: ['__add__', '__radd__'],\n    [33 /* Subtract */]: ['__sub__', '__rsub__'],\n    [26 /* Multiply */]: ['__mul__', '__rmul__'],\n    [13 /* FloorDivide */]: ['__floordiv__', '__rfloordiv__'],\n    [10 /* Divide */]: ['__truediv__', '__rtruediv__'],\n    [24 /* Mod */]: ['__mod__', '__rmod__'],\n    [29 /* Power */]: ['__pow__', '__rpow__'],\n    [22 /* MatrixMultiply */]: ['__matmul__', '__rmatmul__'],\n};\nconst bitwiseOperatorMap = {\n    [3 /* BitwiseAnd */]: ['__and__', '__rand__'],\n    [6 /* BitwiseOr */]: ['__or__', '__ror__'],\n    [8 /* BitwiseXor */]: ['__xor__', '__rxor__'],\n    [17 /* LeftShift */]: ['__lshift__', '__rlshift__'],\n    [31 /* RightShift */]: ['__rshift__', '__rrshift__'],\n};\nconst comparisonOperatorMap = {\n    [12 /* Equals */]: ['__eq__', '__ne__'],\n    [28 /* NotEquals */]: ['__ne__', '__eq__'],\n    [20 /* LessThan */]: ['__lt__', '__gt__'],\n    [21 /* LessThanOrEqual */]: ['__le__', '__ge__'],\n    [15 /* GreaterThan */]: ['__gt__', '__lt__'],\n    [16 /* GreaterThanOrEqual */]: ['__ge__', '__le__'],\n};\nconst booleanOperatorMap = {\n    [36 /* And */]: true,\n    [37 /* Or */]: true,\n    [39 /* Is */]: true,\n    [40 /* IsNot */]: true,\n    [41 /* In */]: true,\n    [42 /* NotIn */]: true,\n};\n// How many levels deep should we attempt to infer return\n// types based on call-site argument types? The deeper we go,\n// the more types we may be able to infer, but the worse the\n// performance.\nconst maxReturnTypeInferenceStackSize = 3;\nfunction createTypeEvaluator(importLookup, printTypeFlags) {\n    const symbolResolutionStack = [];\n    const isReachableRecursionMap = new Map();\n    const functionRecursionMap = new Map();\n    const callIsNoReturnCache = new Map();\n    const codeFlowAnalyzerCache = new Map();\n    const typeCache = new Map();\n    const speculativeTypeTracker = new typeCache_1.SpeculativeTypeTracker();\n    const incompleteTypeTracker = new typeCache_1.IncompleteTypeTracker();\n    let cancellationToken;\n    let isDiagnosticSuppressed = false;\n    let flowIncompleteGeneration = 1;\n    const returnTypeInferenceContextStack = [];\n    let returnTypeInferenceTypeCache;\n    function runWithCancellationToken(token, callback) {\n        try {\n            cancellationToken = token;\n            return callback();\n        }\n        finally {\n            cancellationToken = undefined;\n        }\n    }\n    function checkForCancellation() {\n        if (cancellationToken) {\n            cancellationUtils_1.throwIfCancellationRequested(cancellationToken);\n        }\n    }\n    function getTypeCacheSize() {\n        return typeCache.size;\n    }\n    function readTypeCache(node) {\n        let cachedType;\n        // Should we use a temporary cache associated with a contextual\n        // analysis of a function, contextualized based on call-site argument types?\n        if (returnTypeInferenceTypeCache && isNodeInReturnTypeInferenceContext(node)) {\n            cachedType = returnTypeInferenceTypeCache.get(node.id);\n        }\n        else {\n            cachedType = typeCache.get(node.id);\n        }\n        if (cachedType === undefined) {\n            return undefined;\n        }\n        debug_1.assert(!typeCache_1.isIncompleteType(cachedType));\n        return cachedType;\n    }\n    function writeTypeCache(node, type) {\n        // Should we use a temporary cache associated with a contextual\n        // analysis of a function, contextualized based on call-site argument types?\n        const typeCacheToUse = returnTypeInferenceTypeCache && isNodeInReturnTypeInferenceContext(node)\n            ? returnTypeInferenceTypeCache\n            : typeCache;\n        typeCacheToUse.set(node.id, type);\n        // If the entry is located within a part of the parse tree that is currently being\n        // \"speculatively\" evaluated, track it so we delete the cached entry when we leave\n        // this speculative context.\n        const speculativeNode = speculativeTypeTracker.getSpeculativeRootNode();\n        if (speculativeNode && ParseTreeUtils.isNodeContainedWithin(node, speculativeNode)) {\n            speculativeTypeTracker.trackEntry(typeCacheToUse, node.id);\n        }\n        incompleteTypeTracker.trackEntry(typeCacheToUse, node.id);\n    }\n    // Determines whether the specified node is contained within\n    // the function node corresponding to the function that we\n    // are currently analyzing in the context of parameter types\n    // defined by a call site.\n    function isNodeInReturnTypeInferenceContext(node) {\n        const stackSize = returnTypeInferenceContextStack.length;\n        if (stackSize === 0) {\n            return false;\n        }\n        const contextNode = returnTypeInferenceContextStack[stackSize - 1];\n        let curNode = node;\n        while (curNode) {\n            if (curNode === contextNode.functionNode) {\n                return true;\n            }\n            curNode = curNode.parent;\n        }\n        return false;\n    }\n    function getCodeFlowAnalyzerForReturnTypeInferenceContext() {\n        const stackSize = returnTypeInferenceContextStack.length;\n        debug_1.assert(stackSize > 0);\n        const contextNode = returnTypeInferenceContextStack[stackSize - 1];\n        return contextNode.codeFlowAnalyzer;\n    }\n    function getIndexOfSymbolResolution(symbol, declaration) {\n        return symbolResolutionStack.findIndex((entry) => entry.symbolId === symbol.id && entry.declaration === declaration);\n    }\n    function pushSymbolResolution(symbol, declaration) {\n        const index = getIndexOfSymbolResolution(symbol, declaration);\n        if (index >= 0) {\n            // Mark all of the entries between these two as invalid.\n            for (let i = index + 1; i < symbolResolutionStack.length; i++) {\n                symbolResolutionStack[i].isResultValid = false;\n            }\n            return false;\n        }\n        symbolResolutionStack.push({\n            symbolId: symbol.id,\n            declaration,\n            isResultValid: true,\n        });\n        return true;\n    }\n    function popSymbolResolution(symbol) {\n        const poppedEntry = symbolResolutionStack.pop();\n        debug_1.assert(poppedEntry.symbolId === symbol.id);\n        return poppedEntry.isResultValid;\n    }\n    function setSymbolResolutionPartialType(symbol, declaration, type) {\n        const index = getIndexOfSymbolResolution(symbol, declaration);\n        if (index >= 0) {\n            symbolResolutionStack[index].partialType = type;\n        }\n    }\n    function getSymbolResolutionPartialType(symbol, declaration) {\n        const index = getIndexOfSymbolResolution(symbol, declaration);\n        if (index >= 0) {\n            return symbolResolutionStack[index].partialType;\n        }\n        return undefined;\n    }\n    // Determines the type of the specified node by evaluating it in\n    // context, logging any errors in the process. This may require the\n    // type of surrounding statements to be evaluated.\n    function getType(node) {\n        if (AnalyzerNodeInfo.isCodeUnreachable(node)) {\n            return undefined;\n        }\n        evaluateTypesForExpressionInContext(node);\n        // We assume here that the type for the node in question\n        // will be populated in the cache. Some nodes don't have\n        // defined types (e.g. a raw list comprehension outside\n        // of its containing list), so we'll return undefined in those\n        // cases.\n        return readTypeCache(node);\n    }\n    function getTypeOfExpression(node, expectedType, flags = 0 /* None */) {\n        var _a;\n        // Is this type already cached?\n        const cachedType = readTypeCache(node);\n        if (cachedType) {\n            return { type: cachedType, node };\n        }\n        // This is a frequently-called routine, so it's a good place to call\n        // the cancellation check. If the operation is canceled, an exception\n        // will be thrown at this point.\n        checkForCancellation();\n        let typeResult;\n        let reportExpectingTypeErrors = (flags & 256 /* ExpectingType */) !== 0;\n        switch (node.nodeType) {\n            case 39 /* Name */: {\n                typeResult = getTypeFromName(node, flags);\n                break;\n            }\n            case 36 /* MemberAccess */: {\n                typeResult = getTypeFromMemberAccess(node, flags);\n                break;\n            }\n            case 24 /* Index */: {\n                typeResult = getTypeFromIndex(node, flags);\n                break;\n            }\n            case 9 /* Call */: {\n                typeResult = getTypeFromCall(node, expectedType, flags);\n                break;\n            }\n            case 53 /* Tuple */: {\n                typeResult = getTypeFromTuple(node, expectedType);\n                break;\n            }\n            case 11 /* Constant */: {\n                typeResult = getTypeFromConstant(node, flags);\n                break;\n            }\n            case 49 /* StringList */: {\n                const expectingType = (flags & 32 /* EvaluateStringLiteralAsType */) !== 0 && !isAnnotationLiteralValue(node);\n                if (expectingType) {\n                    if (node.typeAnnotation) {\n                        typeResult = getTypeOfExpression(node.typeAnnotation, undefined, flags | 4 /* AllowForwardReferences */ | 256 /* ExpectingType */);\n                    }\n                    else if (!node.typeAnnotation && node.strings.length === 1) {\n                        // We didn't know at parse time that this string node was going\n                        // to be evaluated as a forward-referenced type. We need\n                        // to re-invoke the parser at this stage.\n                        const expr = parseStringAsTypeAnnotation(node);\n                        if (expr) {\n                            typeResult = getTypeOfExpression(expr, undefined, flags | 4 /* AllowForwardReferences */ | 256 /* ExpectingType */);\n                        }\n                    }\n                    if (!typeResult) {\n                        const fileInfo = getFileInfo(node);\n                        addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.expectedTypeNotString(), node);\n                        typeResult = { node, type: types_1.UnknownType.create() };\n                    }\n                    // Don't report expecting type errors again. We will have already\n                    // reported them when analyzing the contents of the string.\n                    reportExpectingTypeErrors = false;\n                }\n                else {\n                    // Evaluate the format string expressions in this context.\n                    node.strings.forEach((str) => {\n                        if (str.nodeType === 28 /* FormatString */) {\n                            str.expressions.forEach((expr) => {\n                                getTypeOfExpression(expr);\n                            });\n                        }\n                    });\n                    const isBytes = (node.strings[0].token.flags & 32 /* Bytes */) !== 0;\n                    // Don't create a literal type if it's an f-string.\n                    if (node.strings.some((str) => str.nodeType === 28 /* FormatString */)) {\n                        typeResult = {\n                            node,\n                            type: getBuiltInObject(node, isBytes ? 'bytes' : 'str'),\n                        };\n                    }\n                    else {\n                        typeResult = {\n                            node,\n                            type: cloneBuiltinObjectWithLiteral(node, isBytes ? 'bytes' : 'str', node.strings.map((s) => s.value).join('')),\n                        };\n                    }\n                }\n                break;\n            }\n            case 41 /* Number */: {\n                let builtInType = 'float';\n                if (node.isImaginary) {\n                    builtInType = 'complex';\n                }\n                else if (node.isInteger) {\n                    builtInType = 'int';\n                }\n                typeResult = { node, type: cloneBuiltinObjectWithLiteral(node, builtInType, node.value) };\n                break;\n            }\n            case 18 /* Ellipsis */: {\n                if ((flags & 1 /* ConvertEllipsisToAny */) !== 0) {\n                    typeResult = { type: types_1.AnyType.create(true), node };\n                }\n                else if ((flags & 1024 /* ConvertEllipsisToUnknown */) !== 0) {\n                    typeResult = { type: types_1.UnknownType.create(), node };\n                }\n                else {\n                    const ellipsisType = getBuiltInObject(node, 'ellipsis') || types_1.AnyType.create();\n                    typeResult = { type: ellipsisType, node };\n                }\n                break;\n            }\n            case 56 /* UnaryOperation */: {\n                typeResult = getTypeFromUnaryOperation(node, expectedType);\n                break;\n            }\n            case 7 /* BinaryOperation */: {\n                typeResult = getTypeFromBinaryOperation(node, expectedType, flags);\n                break;\n            }\n            case 5 /* AugmentedAssignment */: {\n                const type = getTypeFromAugmentedAssignment(node, expectedType);\n                assignTypeToExpression(node.destExpression, type, node.rightExpression);\n                typeResult = { type, node };\n                break;\n            }\n            case 32 /* List */: {\n                typeResult = getTypeFromList(node, expectedType);\n                break;\n            }\n            case 47 /* Slice */: {\n                typeResult = getTypeFromSlice(node);\n                break;\n            }\n            case 6 /* Await */: {\n                typeResult = getTypeOfExpression(node.expression, undefined, flags);\n                typeResult = {\n                    type: getTypeFromAwaitable(typeResult.type, node.expression),\n                    node,\n                };\n                break;\n            }\n            case 52 /* Ternary */: {\n                typeResult = getTypeFromTernary(node, flags);\n                break;\n            }\n            case 33 /* ListComprehension */: {\n                typeResult = getTypeFromListComprehension(node);\n                break;\n            }\n            case 15 /* Dictionary */: {\n                typeResult = getTypeFromDictionary(node, expectedType);\n                break;\n            }\n            case 31 /* Lambda */: {\n                typeResult = getTypeFromLambda(node, expectedType);\n                break;\n            }\n            case 46 /* Set */: {\n                typeResult = getTypeFromSet(node, expectedType);\n                break;\n            }\n            case 3 /* Assignment */: {\n                typeResult = getTypeOfExpression(node.rightExpression);\n                assignTypeToExpression(node.leftExpression, typeResult.type, node.rightExpression);\n                break;\n            }\n            case 4 /* AssignmentExpression */: {\n                typeResult = getTypeOfExpression(node.rightExpression);\n                assignTypeToExpression(node.name, typeResult.type, node.rightExpression);\n                break;\n            }\n            case 61 /* Yield */: {\n                typeResult = getTypeFromYield(node);\n                break;\n            }\n            case 62 /* YieldFrom */: {\n                typeResult = getTypeFromYieldFrom(node);\n                break;\n            }\n            case 57 /* Unpack */: {\n                const iterType = getTypeOfExpression(node.expression, expectedType).type;\n                const type = getTypeFromIterable(iterType, /* isAsync */ false, node, /* supportGetItem */ false);\n                typeResult = { type, unpackedType: iterType, node };\n                break;\n            }\n            case 55 /* TypeAnnotation */: {\n                typeResult = getTypeOfExpression(node.typeAnnotation, undefined, 32 /* EvaluateStringLiteralAsType */ |\n                    128 /* ParamSpecDisallowed */ |\n                    256 /* ExpectingType */);\n                break;\n            }\n            case 0 /* Error */: {\n                // Evaluate the child expression as best we can so the\n                // type information is cached for the completion handler.\n                suppressDiagnostics(() => {\n                    if (node.child) {\n                        getTypeOfExpression(node.child);\n                    }\n                });\n                typeResult = { type: types_1.UnknownType.create(), node };\n                break;\n            }\n        }\n        if (!typeResult) {\n            // We shouldn't get here. If we do, report an error.\n            debug_1.fail(`Unhandled expression type '${ParseTreeUtils.printExpression(node)}'`);\n        }\n        if (reportExpectingTypeErrors) {\n            const resultType = typeUtils_1.transformTypeObjectToClass(typeResult.type);\n            if (!types_1.TypeBase.isInstantiable(resultType)) {\n                const isEmptyTuple = types_1.isObject(resultType) &&\n                    types_1.ClassType.isBuiltIn(resultType.classType, 'Tuple') &&\n                    ((_a = resultType.classType.typeArguments) === null || _a === void 0 ? void 0 : _a.length) === 0;\n                if ((flags & 512 /* AllowEmptyTupleAsType */) === 0 || !isEmptyTuple) {\n                    addExpectedClassDiagnostic(typeResult.type, node);\n                }\n            }\n        }\n        // Don't update the type cache with an unbound type that results from\n        // a resolution cycle. The cache will be updated when the stack unwinds\n        // and the type is fully evaluated.\n        if (!typeResult.isResolutionCyclical) {\n            writeTypeCache(node, typeResult.type);\n        }\n        return typeResult;\n    }\n    function isAnnotationEvaluationPostponed(fileInfo) {\n        return fileInfo.futureImports.get('annotations') !== undefined || fileInfo.isStubFile;\n    }\n    function getTypeOfAnnotation(node, allowFinal = false) {\n        var _a;\n        const fileInfo = getFileInfo(node);\n        // Special-case the typing.pyi file, which contains some special\n        // types that the type analyzer needs to interpret differently.\n        if (fileInfo.isTypingStubFile || fileInfo.isTypingExtensionsStubFile) {\n            const specialType = handleTypingStubTypeAnnotation(node);\n            if (specialType) {\n                writeTypeCache(node, specialType);\n                return specialType;\n            }\n        }\n        let evaluatorFlags = 256 /* ExpectingType */ |\n            1 /* ConvertEllipsisToAny */ |\n            32 /* EvaluateStringLiteralAsType */ |\n            128 /* ParamSpecDisallowed */;\n        if (isAnnotationEvaluationPostponed(fileInfo)) {\n            evaluatorFlags |= 4 /* AllowForwardReferences */;\n        }\n        // If the annotation is part of a comment, allow forward references\n        // even if it's not enclosed in quotes.\n        if (((_a = node === null || node === void 0 ? void 0 : node.parent) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* Assignment */ && node.parent.typeAnnotationComment === node) {\n            evaluatorFlags |= 4 /* AllowForwardReferences */;\n        }\n        if (!allowFinal) {\n            evaluatorFlags |= 64 /* FinalDisallowed */;\n        }\n        const classType = getTypeOfExpression(node, undefined, evaluatorFlags).type;\n        return typeUtils_1.convertToInstance(classType);\n    }\n    function getTypeFromDecorator(node, functionOrClassType) {\n        const baseTypeResult = getTypeOfExpression(node.leftExpression, undefined, 2 /* DoNotSpecialize */);\n        let decoratorCall = baseTypeResult;\n        // If the decorator has arguments, evaluate that call first.\n        if (node.arguments) {\n            const argList = node.arguments.map((arg) => {\n                const functionArg = {\n                    valueExpression: arg.valueExpression,\n                    argumentCategory: arg.argumentCategory,\n                    name: arg.name,\n                };\n                return functionArg;\n            });\n            // Evaluate the decorator. Don't check for unknown arguments\n            // because these errors will already be reported as unknown\n            // parameters.\n            decoratorCall = getTypeFromCallWithBaseType(node, argList, decoratorCall, undefined, 16 /* DoNotCheckForUnknownArgs */);\n        }\n        const argList = [\n            {\n                argumentCategory: 0 /* Simple */,\n                type: functionOrClassType,\n            },\n        ];\n        return getTypeFromCallWithBaseType(node, argList, decoratorCall, undefined, 16 /* DoNotCheckForUnknownArgs */).type;\n    }\n    // Gets a member type from an object and if it's a function binds\n    // it to the object. If bindToClass is undefined, the binding is done\n    // using the objectType parameter. Callers can specify these separately\n    // to handle the case where we're fetching the object member from a\n    // metaclass but binding to the class.\n    function getTypeFromObjectMember(errorNode, objectType, memberName, usage, diag, memberAccessFlags = 0 /* None */, bindToClass) {\n        const memberInfo = getTypeFromClassMemberName(errorNode, objectType.classType, memberName, usage, diag, memberAccessFlags |\n            16 /* DisallowClassVarWrites */ |\n            32 /* SkipIfInaccessibleToInstance */);\n        let resultType = memberInfo ? memberInfo.type : undefined;\n        if (resultType) {\n            if (resultType.category === 5 /* Function */ ||\n                resultType.category === 6 /* OverloadedFunction */) {\n                if (memberInfo.isClassMember) {\n                    resultType = bindFunctionToClassOrObject(bindToClass || objectType, resultType, !!bindToClass);\n                }\n            }\n        }\n        return resultType;\n    }\n    // Gets a member type from a class and if it's a function binds\n    // it to the object.\n    function getTypeFromClassMember(errorNode, classType, memberName, usage, diag, memberAccessFlags = 0 /* None */) {\n        let memberInfo = getTypeFromClassMemberName(errorNode, classType, memberName, usage, diag, memberAccessFlags | 1 /* SkipInstanceMembers */);\n        // If it wasn't found on the class, see if it's part of the metaclass.\n        if (!memberInfo) {\n            const metaclass = typeUtils_1.getMetaclass(classType);\n            if (metaclass && types_1.isClass(metaclass)) {\n                memberInfo = getTypeFromClassMemberName(errorNode, metaclass, memberName, usage, new diagnostic_1.DiagnosticAddendum(), memberAccessFlags | 1 /* SkipInstanceMembers */, classType);\n            }\n        }\n        let resultType = memberInfo ? memberInfo.type : undefined;\n        if (resultType) {\n            if (resultType.category === 5 /* Function */ ||\n                resultType.category === 6 /* OverloadedFunction */) {\n                if (memberInfo.isClassMember) {\n                    resultType = bindFunctionToClassOrObject(classType, resultType);\n                }\n            }\n        }\n        return resultType;\n    }\n    function getBoundMethod(classType, memberName, treatAsClassMember) {\n        const aliasClass = classType.details.aliasClass;\n        if (aliasClass) {\n            classType = aliasClass;\n        }\n        const memberInfo = typeUtils_1.lookUpClassMember(classType, memberName, 8 /* SkipInstanceVariables */ | 4 /* SkipObjectBaseClass */);\n        if (memberInfo) {\n            const unboundMethodType = getTypeOfMember(memberInfo);\n            if (unboundMethodType.category === 5 /* Function */ ||\n                unboundMethodType.category === 6 /* OverloadedFunction */) {\n                const boundMethod = bindFunctionToClassOrObject(types_1.ObjectType.create(classType), unboundMethodType, treatAsClassMember);\n                if (boundMethod.category === 5 /* Function */ ||\n                    boundMethod.category === 6 /* OverloadedFunction */) {\n                    return boundMethod;\n                }\n            }\n        }\n        return undefined;\n    }\n    // Returns the signature(s) associated with a call node that contains\n    // the specified node. It also returns the index of the argument\n    // that contains the node.\n    function getCallSignatureInfo(node, insertionOffset, tokens) {\n        // Find the call node that contains the specified node.\n        let curNode = node;\n        let callNode;\n        while (curNode !== undefined) {\n            if (curNode.nodeType === 9 /* Call */ || curNode.nodeType === 13 /* Decorator */) {\n                callNode = curNode;\n                break;\n            }\n            curNode = curNode.parent;\n        }\n        if (!callNode || !callNode.arguments) {\n            return undefined;\n        }\n        if (insertionOffset >= textRange_1.TextRange.getEnd(callNode)) {\n            return undefined;\n        }\n        const exprNode = callNode.leftExpression;\n        const callType = getType(exprNode);\n        if (callType === undefined) {\n            return undefined;\n        }\n        const argList = [];\n        let addedActive = false;\n        let previousCategory = 0 /* Simple */;\n        // Empty arguments do not enter the AST as nodes, but instead are left blank.\n        // Instead, we detect when we appear to be between two known arguments or at the\n        // end of the argument list and insert a fake argument of an unknown type to have\n        // something to match later.\n        function addFakeArg() {\n            argList.push({\n                argumentCategory: previousCategory,\n                type: types_1.UnknownType.create(),\n                active: true,\n            });\n        }\n        callNode.arguments.forEach((arg) => {\n            let active = false;\n            if (!addedActive) {\n                // Calculate the argument's bounds including whitespace and colons.\n                let start = arg.start;\n                const startTokenIndex = tokens.getItemAtPosition(start);\n                if (startTokenIndex >= 0) {\n                    start = textRange_1.TextRange.getEnd(tokens.getItemAt(startTokenIndex - 1));\n                }\n                let end = textRange_1.TextRange.getEnd(arg);\n                const endTokenIndex = tokens.getItemAtPosition(end);\n                if (endTokenIndex >= 0) {\n                    // Find the true end of the argument by searching for the\n                    // terminating comma or parenthesis.\n                    for (let i = endTokenIndex; i < tokens.count; i++) {\n                        const tok = tokens.getItemAt(i);\n                        switch (tok.type) {\n                            case 12 /* Comma */:\n                            case 14 /* CloseParenthesis */:\n                                break;\n                            default:\n                                continue;\n                        }\n                        end = textRange_1.TextRange.getEnd(tok);\n                        break;\n                    }\n                }\n                if (insertionOffset < end) {\n                    if (insertionOffset >= start) {\n                        active = true;\n                    }\n                    else {\n                        addFakeArg();\n                    }\n                    addedActive = true;\n                }\n            }\n            previousCategory = arg.argumentCategory;\n            argList.push({\n                valueExpression: arg.valueExpression,\n                argumentCategory: arg.argumentCategory,\n                name: arg.name,\n                active: active,\n            });\n        });\n        if (!addedActive) {\n            addFakeArg();\n        }\n        const signatures = [];\n        function addOneFunctionToSignature(type) {\n            let callResult;\n            useSpeculativeMode(callNode, () => {\n                callResult = validateFunctionArguments(exprNode, argList, type, new typeVarMap_1.TypeVarMap(), \n                /* skipUnknownArgCheck */ true, \n                /* inferReturnTypeIfNeeded */ true, undefined);\n            });\n            signatures.push({\n                type,\n                activeParam: callResult === null || callResult === void 0 ? void 0 : callResult.activeParam,\n            });\n        }\n        function addFunctionToSignature(type) {\n            if (type.category === 5 /* Function */) {\n                addOneFunctionToSignature(type);\n            }\n            else {\n                type.overloads.forEach(addOneFunctionToSignature);\n            }\n        }\n        typeUtils_1.doForSubtypes(callType, (subtype) => {\n            switch (subtype.category) {\n                case 5 /* Function */:\n                case 6 /* OverloadedFunction */: {\n                    addFunctionToSignature(subtype);\n                    break;\n                }\n                case 7 /* Class */: {\n                    let methodType;\n                    // Try to get the __init__ method first because it typically has\n                    // more type information than __new__.\n                    methodType = getBoundMethod(subtype, '__init__', false);\n                    if (!methodType) {\n                        // If there was no __init__ method, use the __new__ method\n                        // instead.\n                        methodType = getBoundMethod(subtype, '__new__', true);\n                    }\n                    if (methodType) {\n                        addFunctionToSignature(methodType);\n                    }\n                    break;\n                }\n                case 8 /* Object */: {\n                    const methodType = getBoundMethod(subtype.classType, '__call__', false);\n                    if (methodType) {\n                        addFunctionToSignature(methodType);\n                    }\n                    break;\n                }\n            }\n            return undefined;\n        });\n        if (signatures.length === 0) {\n            return undefined;\n        }\n        return {\n            callNode,\n            signatures,\n        };\n    }\n    // Determines whether the specified expression is an explicit TypeAlias declaration.\n    function isDeclaredTypeAlias(expression) {\n        if (expression.nodeType === 55 /* TypeAnnotation */) {\n            if (expression.valueExpression.nodeType === 39 /* Name */) {\n                const symbolWithScope = lookUpSymbolRecursive(expression, expression.valueExpression.value, \n                /* honorCodeFlow */ false);\n                if (symbolWithScope) {\n                    const symbol = symbolWithScope.symbol;\n                    return symbol.getDeclarations().find((decl) => declarationUtils_1.isTypeAliasDeclaration(decl)) !== undefined;\n                }\n            }\n        }\n        return false;\n    }\n    // Determines whether the specified expression is a symbol with a declared type\n    // (either a simple name or a member variable). If so, the type is returned.\n    function getDeclaredTypeForExpression(expression) {\n        let symbol;\n        let classOrObjectBase;\n        switch (expression.nodeType) {\n            case 39 /* Name */: {\n                const symbolWithScope = lookUpSymbolRecursive(expression, expression.value, /* honorCodeFlow */ true);\n                if (symbolWithScope) {\n                    symbol = symbolWithScope.symbol;\n                }\n                break;\n            }\n            case 55 /* TypeAnnotation */: {\n                return getDeclaredTypeForExpression(expression.valueExpression);\n            }\n            case 36 /* MemberAccess */: {\n                const baseType = typeUtils_1.makeTypeVarsConcrete(getTypeOfExpression(expression.leftExpression).type);\n                let classMemberInfo;\n                if (types_1.isObject(baseType)) {\n                    classMemberInfo = typeUtils_1.lookUpObjectMember(baseType, expression.memberName.value, 32 /* DeclaredTypesOnly */);\n                    classOrObjectBase = baseType;\n                }\n                else if (types_1.isClass(baseType)) {\n                    classMemberInfo = typeUtils_1.lookUpClassMember(baseType, expression.memberName.value, 8 /* SkipInstanceVariables */ | 32 /* DeclaredTypesOnly */);\n                    classOrObjectBase = baseType;\n                }\n                if (classMemberInfo) {\n                    symbol = classMemberInfo.symbol;\n                }\n                break;\n            }\n            case 24 /* Index */: {\n                const baseType = getDeclaredTypeForExpression(expression.baseExpression);\n                if (baseType && types_1.isObject(baseType)) {\n                    const setItemMember = typeUtils_1.lookUpClassMember(baseType.classType, '__setitem__');\n                    if (setItemMember) {\n                        const setItemType = getTypeOfMember(setItemMember);\n                        if (setItemType.category === 5 /* Function */) {\n                            const boundFunction = bindFunctionToClassOrObject(baseType, setItemType);\n                            if (boundFunction.category === 5 /* Function */) {\n                                if (boundFunction.details.parameters.length === 2) {\n                                    const paramType = types_1.FunctionType.getEffectiveParameterType(boundFunction, 1);\n                                    if (!types_1.isAnyOrUnknown(paramType)) {\n                                        return paramType;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n        }\n        if (symbol) {\n            let declaredType = getDeclaredTypeOfSymbol(symbol);\n            if (declaredType) {\n                // If it's a property, we need to get the fset type.\n                if (typeUtils_1.isProperty(declaredType)) {\n                    const setterInfo = typeUtils_1.lookUpClassMember(declaredType.classType, 'fset');\n                    const setter = setterInfo ? getTypeOfMember(setterInfo) : undefined;\n                    if (!setter || setter.category !== 5 /* Function */ || setter.details.parameters.length < 2) {\n                        return undefined;\n                    }\n                    declaredType = setter.details.parameters[1].type;\n                }\n                if (classOrObjectBase) {\n                    declaredType = bindFunctionToClassOrObject(classOrObjectBase, declaredType);\n                }\n                return declaredType;\n            }\n        }\n        return undefined;\n    }\n    // Applies an \"await\" operation to the specified type and returns\n    // the result. According to PEP 492, await operates on:\n    // 1) a generator object\n    // 2) an Awaitable (object that provides an __await__ that\n    //    returns a generator object)\n    // If errorNode is undefined, no errors are reported.\n    function getTypeFromAwaitable(type, errorNode) {\n        return typeUtils_1.doForSubtypes(type, (subtype) => {\n            if (types_1.isAnyOrUnknown(subtype)) {\n                return subtype;\n            }\n            const generatorReturnType = getReturnTypeFromGenerator(subtype);\n            if (generatorReturnType) {\n                return generatorReturnType;\n            }\n            if (types_1.isObject(subtype)) {\n                const awaitReturnType = getSpecializedReturnType(subtype, '__await__');\n                if (awaitReturnType) {\n                    if (types_1.isAnyOrUnknown(awaitReturnType)) {\n                        return awaitReturnType;\n                    }\n                    if (types_1.isObject(awaitReturnType)) {\n                        const iterReturnType = getSpecializedReturnType(awaitReturnType, '__iter__');\n                        if (iterReturnType) {\n                            const generatorReturnType = getReturnTypeFromGenerator(awaitReturnType);\n                            if (generatorReturnType) {\n                                return generatorReturnType;\n                            }\n                        }\n                    }\n                }\n            }\n            if (errorNode) {\n                const fileInfo = getFileInfo(errorNode);\n                addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.typeNotAwaitable().format({ type: printType(subtype) }), errorNode);\n            }\n            return types_1.UnknownType.create();\n        });\n    }\n    // Validates that the type is iterable and returns the iterated type.\n    // If errorNode is undefined, no errors are reported.\n    function getTypeFromIterable(type, isAsync, errorNode, supportGetItem) {\n        const iterMethodName = isAsync ? '__aiter__' : '__iter__';\n        const nextMethodName = isAsync ? '__anext__' : '__next__';\n        const getItemMethodName = supportGetItem ? '__getitem__' : '';\n        type = typeUtils_1.makeTypeVarsConcrete(type);\n        if (type.category === 10 /* Union */ && type.subtypes.some((t) => types_1.isNone(t))) {\n            if (errorNode) {\n                addDiagnostic(getFileInfo(errorNode).diagnosticRuleSet.reportOptionalIterable, \"reportOptionalIterable\" /* reportOptionalIterable */, localize_1.Localizer.Diagnostic.noneNotIterable(), errorNode);\n            }\n            type = types_1.removeNoneFromUnion(type);\n        }\n        const getIteratorReturnType = (objType, metaclass, diag) => {\n            const iterReturnType = metaclass\n                ? getSpecializedReturnTypeForMetaclassMethod(metaclass, objType.classType, iterMethodName)\n                : getSpecializedReturnType(objType, iterMethodName);\n            if (!iterReturnType) {\n                // There was no __iter__. See if we can fall back to\n                // the __getitem__ method instead.\n                if (getItemMethodName) {\n                    const getItemReturnType = getSpecializedReturnType(objType, getItemMethodName);\n                    if (getItemReturnType) {\n                        return getItemReturnType;\n                    }\n                }\n                diag.addMessage(localize_1.Localizer.Diagnostic.methodNotDefined().format({ name: iterMethodName }));\n            }\n            else {\n                if (types_1.isAnyOrUnknown(iterReturnType)) {\n                    return iterReturnType;\n                }\n                if (types_1.isObject(iterReturnType)) {\n                    const nextReturnType = getSpecializedReturnType(iterReturnType, nextMethodName);\n                    if (!nextReturnType) {\n                        diag.addMessage(localize_1.Localizer.Diagnostic.methodNotDefinedOnType().format({\n                            name: nextMethodName,\n                            type: printType(iterReturnType),\n                        }));\n                    }\n                    else {\n                        if (!isAsync) {\n                            return nextReturnType;\n                        }\n                        // If it's an async iteration, there's an implicit\n                        // 'await' operator applied.\n                        return getTypeFromAwaitable(nextReturnType, errorNode);\n                    }\n                }\n                else {\n                    diag.addMessage(localize_1.Localizer.Diagnostic.methodReturnsNonObject().format({ name: iterMethodName }));\n                }\n            }\n            return undefined;\n        };\n        return typeUtils_1.doForSubtypes(type, (subtype) => {\n            if (types_1.isAnyOrUnknown(subtype)) {\n                return subtype;\n            }\n            const diag = new diagnostic_1.DiagnosticAddendum();\n            if (types_1.isAnyOrUnknown(subtype)) {\n                return subtype;\n            }\n            else if (types_1.isObject(subtype)) {\n                const returnType = getIteratorReturnType(subtype, undefined, diag);\n                if (returnType) {\n                    return returnType;\n                }\n            }\n            else if (types_1.isClass(subtype)) {\n                // Handle the case where the class itself is iterable.\n                // This is true for classes that derive from Enum, for example.\n                const metaclassType = typeUtils_1.getMetaclass(subtype);\n                if (metaclassType) {\n                    if (types_1.isClass(metaclassType)) {\n                        const returnType = getIteratorReturnType(types_1.ObjectType.create(subtype), metaclassType, diag);\n                        if (returnType) {\n                            return returnType;\n                        }\n                    }\n                }\n            }\n            if (errorNode) {\n                addDiagnostic(getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.typeNotIterable().format({ type: printType(subtype) }) + diag.getString(), errorNode);\n            }\n            return types_1.UnknownType.create();\n        });\n    }\n    // Validates fields for compatibility with a dataclass and synthesizes\n    // an appropriate __new__ and __init__ methods plus a __dataclass_fields__\n    // class variable.\n    function synthesizeDataClassMethods(node, classType, skipSynthesizeInit) {\n        debug_1.assert(types_1.ClassType.isDataClass(classType));\n        const newType = types_1.FunctionType.createInstance('__new__', 1 /* ConstructorMethod */ | 64 /* SynthesizedMethod */);\n        const initType = types_1.FunctionType.createInstance('__init__', 64 /* SynthesizedMethod */);\n        types_1.FunctionType.addParameter(newType, {\n            category: 0 /* Simple */,\n            name: 'cls',\n            type: classType,\n        });\n        types_1.FunctionType.addDefaultParameters(newType);\n        newType.details.declaredReturnType = types_1.ObjectType.create(classType);\n        types_1.FunctionType.addParameter(initType, {\n            category: 0 /* Simple */,\n            name: 'self',\n            type: types_1.ObjectType.create(classType),\n        });\n        initType.details.declaredReturnType = types_1.NoneType.createInstance();\n        // Maintain a list of all dataclass entries (including\n        // those from inherited classes) plus a list of only those\n        // entries added by this class.\n        const localDataClassEntries = [];\n        const fullDataClassEntries = [];\n        addInheritedDataClassEntries(classType, fullDataClassEntries);\n        const localEntryTypeEvaluator = [];\n        node.suite.statements.forEach((statementList) => {\n            if (statementList.nodeType === 48 /* StatementList */) {\n                statementList.statements.forEach((statement) => {\n                    let variableNameNode;\n                    let variableTypeEvaluator;\n                    let hasDefaultValue = false;\n                    let includeInInit = true;\n                    if (statement.nodeType === 3 /* Assignment */) {\n                        if (statement.leftExpression.nodeType === 55 /* TypeAnnotation */ &&\n                            statement.leftExpression.valueExpression.nodeType === 39 /* Name */) {\n                            variableNameNode = statement.leftExpression.valueExpression;\n                            variableTypeEvaluator = () => getTypeOfAnnotation(statement.leftExpression.typeAnnotation, \n                            /* allowFinal */ true);\n                        }\n                        hasDefaultValue = true;\n                        // If the RHS of the assignment is assigning a field instance where the\n                        // \"init\" parameter is set to false, do not include it in the init method.\n                        if (statement.rightExpression.nodeType === 9 /* Call */) {\n                            const callType = getTypeOfExpression(statement.rightExpression.leftExpression).type;\n                            if (callType.category === 6 /* OverloadedFunction */ &&\n                                callType.overloads[0].details.builtInName === 'field') {\n                                const initArg = statement.rightExpression.arguments.find((arg) => { var _a; return ((_a = arg.name) === null || _a === void 0 ? void 0 : _a.value) === 'init'; });\n                                if (initArg && initArg.valueExpression) {\n                                    const value = staticExpressions_1.evaluateStaticBoolExpression(initArg.valueExpression, getFileInfo(initArg).executionEnvironment);\n                                    if (value === false) {\n                                        includeInInit = false;\n                                    }\n                                }\n                                hasDefaultValue = statement.rightExpression.arguments.some((arg) => { var _a, _b; return ((_a = arg.name) === null || _a === void 0 ? void 0 : _a.value) === 'default' || ((_b = arg.name) === null || _b === void 0 ? void 0 : _b.value) === 'default_factory'; });\n                            }\n                        }\n                    }\n                    else if (statement.nodeType === 55 /* TypeAnnotation */) {\n                        if (statement.valueExpression.nodeType === 39 /* Name */) {\n                            variableNameNode = statement.valueExpression;\n                            variableTypeEvaluator = () => getTypeOfAnnotation(statement.typeAnnotation, /* allowFinal */ true);\n                        }\n                    }\n                    if (variableNameNode && variableTypeEvaluator) {\n                        const variableName = variableNameNode.value;\n                        // Don't include class vars. PEP 557 indicates that they shouldn't\n                        // be considered data class entries.\n                        const variableSymbol = classType.details.fields.get(variableName);\n                        if (!(variableSymbol === null || variableSymbol === void 0 ? void 0 : variableSymbol.isClassVar())) {\n                            // Create a new data class entry, but defer evaluation of the type until\n                            // we've compiled the full list of data class entries for this class. This\n                            // allows us to handle circular references in types.\n                            const dataClassEntry = {\n                                name: variableName,\n                                hasDefault: hasDefaultValue,\n                                includeInInit,\n                                type: types_1.UnknownType.create(),\n                            };\n                            localEntryTypeEvaluator.push({ entry: dataClassEntry, evaluator: variableTypeEvaluator });\n                            // Add the new entry to the local entry list.\n                            let insertIndex = localDataClassEntries.findIndex((e) => e.name === variableName);\n                            if (insertIndex >= 0) {\n                                localDataClassEntries[insertIndex] = dataClassEntry;\n                            }\n                            else {\n                                localDataClassEntries.push(dataClassEntry);\n                            }\n                            // Add the new entry to the full entry list.\n                            insertIndex = fullDataClassEntries.findIndex((p) => p.name === variableName);\n                            if (insertIndex >= 0) {\n                                fullDataClassEntries[insertIndex] = dataClassEntry;\n                            }\n                            else {\n                                fullDataClassEntries.push(dataClassEntry);\n                                insertIndex = fullDataClassEntries.length - 1;\n                            }\n                            // If we've already seen a entry with a default value defined,\n                            // all subsequent entries must also have default values.\n                            const firstDefaultValueIndex = fullDataClassEntries.findIndex((p) => p.hasDefault && p.includeInInit);\n                            if (includeInInit &&\n                                !hasDefaultValue &&\n                                firstDefaultValueIndex >= 0 &&\n                                firstDefaultValueIndex < insertIndex) {\n                                addError(localize_1.Localizer.Diagnostic.dataClassFieldWithDefault(), variableNameNode);\n                            }\n                        }\n                    }\n                });\n            }\n        });\n        classType.details.dataClassEntries = localDataClassEntries;\n        // Now that the dataClassEntries field has been set with a complete list\n        // of local data class entries for this class, perform deferred type\n        // evaluations. This could involve circular type dependencies, so it's\n        // required that the list be complete (even if types are not yet accurate)\n        // before we perform the type evaluations.\n        localEntryTypeEvaluator.forEach((entryEvaluator) => {\n            entryEvaluator.entry.type = entryEvaluator.evaluator();\n        });\n        const symbolTable = classType.details.fields;\n        if (!skipSynthesizeInit) {\n            fullDataClassEntries.forEach((entry) => {\n                if (entry.includeInInit) {\n                    const functionParam = {\n                        category: 0 /* Simple */,\n                        name: entry.name,\n                        hasDefault: entry.hasDefault,\n                        hasDeclaredType: true,\n                        type: entry.type,\n                    };\n                    types_1.FunctionType.addParameter(initType, functionParam);\n                }\n            });\n            symbolTable.set('__init__', symbol_1.Symbol.createWithType(4 /* ClassMember */, initType));\n            symbolTable.set('__new__', symbol_1.Symbol.createWithType(4 /* ClassMember */, newType));\n        }\n        let dictType = getBuiltInType(node, 'Dict');\n        if (types_1.isClass(dictType)) {\n            dictType = types_1.ObjectType.create(types_1.ClassType.cloneForSpecialization(dictType, [getBuiltInObject(node, 'str'), types_1.AnyType.create()], \n            /* isTypeArgumentExplicit */ false));\n        }\n        symbolTable.set('__dataclass_fields__', symbol_1.Symbol.createWithType(4 /* ClassMember */, dictType));\n    }\n    function synthesizeTypedDictClassMethods(node, classType) {\n        debug_1.assert(types_1.ClassType.isTypedDictClass(classType));\n        // Synthesize a __new__ method.\n        const newType = types_1.FunctionType.createInstance('__new__', 1 /* ConstructorMethod */ | 64 /* SynthesizedMethod */);\n        types_1.FunctionType.addParameter(newType, {\n            category: 0 /* Simple */,\n            name: 'cls',\n            type: classType,\n        });\n        types_1.FunctionType.addDefaultParameters(newType);\n        newType.details.declaredReturnType = types_1.ObjectType.create(classType);\n        // Synthesize an __init__ method.\n        const initType = types_1.FunctionType.createInstance('__init__', 64 /* SynthesizedMethod */);\n        types_1.FunctionType.addParameter(initType, {\n            category: 0 /* Simple */,\n            name: 'self',\n            type: types_1.ObjectType.create(classType),\n        });\n        initType.details.declaredReturnType = types_1.NoneType.createInstance();\n        // All parameters must be named, so insert an empty \"*\".\n        types_1.FunctionType.addParameter(initType, {\n            category: 1 /* VarArgList */,\n            type: types_1.AnyType.create(),\n        });\n        const entries = getTypedDictMembersForClass(classType);\n        entries.forEach((entry, name) => {\n            types_1.FunctionType.addParameter(initType, {\n                category: 0 /* Simple */,\n                name,\n                hasDefault: !entry.isRequired,\n                type: entry.valueType,\n            });\n        });\n        const symbolTable = classType.details.fields;\n        symbolTable.set('__init__', symbol_1.Symbol.createWithType(4 /* ClassMember */, initType));\n        symbolTable.set('__new__', symbol_1.Symbol.createWithType(4 /* ClassMember */, newType));\n        const strClass = getBuiltInType(node, 'str');\n        // Synthesize a \"get\" method for each named entry.\n        if (types_1.isClass(strClass)) {\n            const createGetFunction = (keyType, valueType) => {\n                const getOverload = types_1.FunctionType.createInstance('get', 64 /* SynthesizedMethod */ | 256 /* Overloaded */);\n                types_1.FunctionType.addParameter(getOverload, {\n                    category: 0 /* Simple */,\n                    name: 'self',\n                    type: types_1.ObjectType.create(classType),\n                });\n                types_1.FunctionType.addParameter(getOverload, {\n                    category: 0 /* Simple */,\n                    name: 'k',\n                    hasDeclaredType: true,\n                    type: keyType,\n                });\n                types_1.FunctionType.addParameter(getOverload, {\n                    category: 0 /* Simple */,\n                    name: 'default',\n                    hasDeclaredType: true,\n                    type: valueType,\n                    hasDefault: true,\n                });\n                getOverload.details.declaredReturnType = valueType;\n                return getOverload;\n            };\n            const getOverloads = [];\n            entries.forEach((entry, name) => {\n                const getOverload = createGetFunction(types_1.ObjectType.create(types_1.ClassType.cloneWithLiteral(strClass, name)), entry.valueType);\n                getOverloads.push(getOverload);\n            });\n            // Provide a final overload for 'get' that handles the general case\n            // where the key is a str but the literal value isn't known.\n            const getOverload = createGetFunction(types_1.ObjectType.create(strClass), types_1.UnknownType.create());\n            getOverloads.push(getOverload);\n            const getMethod = types_1.OverloadedFunctionType.create(getOverloads);\n            symbolTable.set('get', symbol_1.Symbol.createWithType(4 /* ClassMember */, getMethod));\n        }\n    }\n    function getTypingType(node, symbolName) {\n        const fileInfo = getFileInfo(node);\n        const typingImportPath = fileInfo.typingModulePath;\n        if (!typingImportPath) {\n            return undefined;\n        }\n        const lookupResult = importLookup(typingImportPath);\n        if (!lookupResult) {\n            return undefined;\n        }\n        const symbol = lookupResult.symbolTable.get(symbolName);\n        if (!symbol) {\n            return undefined;\n        }\n        return getEffectiveTypeOfSymbol(symbol);\n    }\n    function isNodeReachable(node) {\n        const flowNode = AnalyzerNodeInfo.getFlowNode(node);\n        if (!flowNode) {\n            return true;\n        }\n        return isFlowNodeReachable(flowNode);\n    }\n    function isAfterNodeReachable(node) {\n        const returnFlowNode = AnalyzerNodeInfo.getAfterFlowNode(node);\n        if (!returnFlowNode) {\n            return false;\n        }\n        return isFlowNodeReachable(returnFlowNode);\n    }\n    // Determines whether there is a code flow path from sourceNode to sinkNode.\n    function isFlowPathBetweenNodes(sourceNode, sinkNode) {\n        const sourceFlowNode = AnalyzerNodeInfo.getFlowNode(sourceNode);\n        const sinkFlowNode = AnalyzerNodeInfo.getFlowNode(sinkNode);\n        if (!sourceFlowNode || !sinkFlowNode) {\n            return false;\n        }\n        if (sourceFlowNode === sinkFlowNode) {\n            return true;\n        }\n        return isFlowNodeReachable(sinkFlowNode, sourceFlowNode);\n    }\n    // Determines whether the specified string literal is part\n    // of a Literal['xxx'] statement. If so, we will not treat\n    // the string as a normal forward-declared type annotation.\n    function isAnnotationLiteralValue(node) {\n        if (node.parent && node.parent.nodeType === 25 /* IndexItems */) {\n            const indexItemsNode = node.parent;\n            if (indexItemsNode.parent && indexItemsNode.parent.nodeType === 24 /* Index */) {\n                const indexNode = indexItemsNode.parent;\n                const baseType = getTypeOfExpression(indexNode.baseExpression).type;\n                if (baseType && types_1.isClass(baseType)) {\n                    if (types_1.ClassType.isSpecialBuiltIn(baseType, 'Literal')) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    function addInformation(message, node, range) {\n        return addDiagnosticWithSuppressionCheck('information', message, node, range);\n    }\n    function addWarning(message, node, range) {\n        return addDiagnosticWithSuppressionCheck('warning', message, node, range);\n    }\n    function addError(message, node, range) {\n        return addDiagnosticWithSuppressionCheck('error', message, node, range);\n    }\n    function addUnusedCode(node, textRange) {\n        if (!isDiagnosticSuppressed && !isSpeculativeMode(node) && !incompleteTypeTracker.isIncompleteTypeMode()) {\n            const fileInfo = getFileInfo(node);\n            fileInfo.diagnosticSink.addUnusedCodeWithTextRange(localize_1.Localizer.Diagnostic.unreachableCode(), textRange);\n        }\n    }\n    function addDiagnosticWithSuppressionCheck(diagLevel, message, node, range) {\n        if (!isDiagnosticSuppressed && !isSpeculativeMode(node) && !incompleteTypeTracker.isIncompleteTypeMode()) {\n            const fileInfo = getFileInfo(node);\n            return fileInfo.diagnosticSink.addDiagnosticWithTextRange(diagLevel, message, range || node);\n        }\n        return undefined;\n    }\n    function addDiagnostic(diagLevel, rule, message, node) {\n        if (diagLevel === 'none') {\n            return undefined;\n        }\n        const diagnostic = addDiagnosticWithSuppressionCheck(diagLevel, message, node);\n        if (diagnostic) {\n            diagnostic.setRule(rule);\n        }\n        return diagnostic;\n    }\n    function addDiagnosticForTextRange(fileInfo, diagLevel, rule, message, range) {\n        if (diagLevel === 'none') {\n            return undefined;\n        }\n        const diagnostic = fileInfo.diagnosticSink.addDiagnosticWithTextRange(diagLevel, message, range);\n        diagnostic.setRule(rule);\n        return diagnostic;\n    }\n    function addExpectedClassDiagnostic(type, node) {\n        const fileInfo = getFileInfo(node);\n        const diag = new diagnostic_1.DiagnosticAddendum();\n        if (type.category === 10 /* Union */) {\n            type.subtypes.forEach((subtype) => {\n                if (!types_1.TypeBase.isInstantiable(subtype)) {\n                    diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeNotClass().format({ type: printType(subtype) }));\n                }\n            });\n        }\n        addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.typeExpectedClass().format({ type: printType(type) }) + diag.getString(), node);\n    }\n    function assignTypeToNameNode(nameNode, type, srcExpression, expectedTypeDiagAddendum) {\n        const nameValue = nameNode.value;\n        const symbolWithScope = lookUpSymbolRecursive(nameNode, nameValue, /* honorCodeFlow */ false);\n        if (!symbolWithScope) {\n            // This can happen when we are evaluating a piece of code that was\n            // determined to be unreachable by the binder.\n            return;\n        }\n        const declarations = symbolWithScope.symbol.getDeclarations();\n        const declaredType = getDeclaredTypeOfSymbol(symbolWithScope.symbol);\n        const fileInfo = getFileInfo(nameNode);\n        // We found an existing declared type. Make sure the type is assignable.\n        let destType = type;\n        if (declaredType && srcExpression) {\n            let diagAddendum = new diagnostic_1.DiagnosticAddendum();\n            if (!canAssignType(declaredType, type, diagAddendum)) {\n                // If there was an expected type mismatch, use that diagnostic\n                // addendum because it will be more informative.\n                if (expectedTypeDiagAddendum) {\n                    diagAddendum = expectedTypeDiagAddendum;\n                }\n                addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.typeAssignmentMismatch().format({\n                    sourceType: printType(type),\n                    destType: printType(declaredType),\n                }) + diagAddendum.getString(), srcExpression || nameNode);\n                // If the user has requested that no general type issues be\n                // reported, don't replace the destType with the declaredType\n                // because they won't understand why subsequent errors are\n                // generated.\n                if (fileInfo.diagnosticRuleSet.reportGeneralTypeIssues !== 'none') {\n                    destType = declaredType;\n                }\n            }\n            else {\n                // Constrain the resulting type to match the declared type.\n                destType = narrowDeclaredTypeBasedOnAssignedType(declaredType, type);\n            }\n        }\n        else {\n            // If this is a member name (within a class scope) and the member name\n            // appears to be a constant, use the strict source type. If it's a member\n            // variable that can be overridden by a child class, use the more general\n            // version by stripping off the literal.\n            const scope = ScopeUtils.getScopeForNode(nameNode);\n            if ((scope === null || scope === void 0 ? void 0 : scope.type) === 2 /* Class */) {\n                const isConstant = symbolNameUtils_1.isConstantName(nameValue);\n                const isPrivate = symbolNameUtils_1.isPrivateOrProtectedName(nameValue);\n                if (!isConstant &&\n                    (!isPrivate || getFileInfo(nameNode).diagnosticRuleSet.reportPrivateUsage === 'none')) {\n                    destType = typeUtils_1.stripLiteralValue(destType);\n                }\n            }\n        }\n        const varDecl = declarations.find((decl) => decl.type === 1 /* Variable */);\n        if (varDecl && varDecl.type === 1 /* Variable */ && srcExpression) {\n            if (varDecl.isConstant) {\n                // A constant variable can be assigned only once. If this\n                // isn't the first assignment, generate an error.\n                if (nameNode !== declarations[0].node) {\n                    addDiagnostic(fileInfo.diagnosticRuleSet.reportConstantRedefinition, \"reportConstantRedefinition\" /* reportConstantRedefinition */, localize_1.Localizer.Diagnostic.constantRedefinition().format({ name: nameValue }), nameNode);\n                }\n            }\n        }\n        writeTypeCache(nameNode, destType);\n    }\n    function assignTypeToMemberAccessNode(target, type, srcExpr, expectedTypeDiagAddendum) {\n        const baseTypeResult = getTypeOfExpression(target.leftExpression);\n        const baseType = typeUtils_1.makeTypeVarsConcrete(baseTypeResult.type);\n        // Handle member accesses (e.g. self.x or cls.y).\n        if (target.leftExpression.nodeType === 39 /* Name */) {\n            // Determine whether we're writing to a class or instance member.\n            const enclosingClassNode = ParseTreeUtils.getEnclosingClass(target);\n            if (enclosingClassNode) {\n                const classTypeResults = getTypeOfClass(enclosingClassNode);\n                if (classTypeResults && types_1.isClass(classTypeResults.classType)) {\n                    if (types_1.isObject(baseType)) {\n                        if (types_1.ClassType.isSameGenericClass(baseType.classType, classTypeResults.classType)) {\n                            assignTypeToMemberVariable(target, type, true, srcExpr);\n                        }\n                    }\n                    else if (types_1.isClass(baseType)) {\n                        if (types_1.ClassType.isSameGenericClass(baseType, classTypeResults.classType)) {\n                            assignTypeToMemberVariable(target, type, false, srcExpr);\n                        }\n                    }\n                    // Assignments to instance or class variables through \"self\" or \"cls\" is not\n                    // allowed for protocol classes.\n                    if (types_1.ClassType.isProtocolClass(classTypeResults.classType)) {\n                        addError(localize_1.Localizer.Diagnostic.assignmentInProtocol(), target.memberName);\n                    }\n                }\n            }\n        }\n        getTypeFromMemberAccessWithBaseType(target, baseTypeResult, { method: 'set', setType: type, setErrorNode: srcExpr, setExpectedTypeDiag: expectedTypeDiagAddendum }, 0 /* None */);\n        writeTypeCache(target.memberName, type);\n        writeTypeCache(target, type);\n    }\n    function assignTypeToMemberVariable(node, srcType, isInstanceMember, srcExprNode) {\n        const memberName = node.memberName.value;\n        const fileInfo = getFileInfo(node);\n        const classDef = ParseTreeUtils.getEnclosingClass(node);\n        if (!classDef) {\n            return;\n        }\n        const classTypeInfo = getTypeOfClass(classDef);\n        if (classTypeInfo && types_1.isClass(classTypeInfo.classType)) {\n            let memberInfo = typeUtils_1.lookUpClassMember(classTypeInfo.classType, memberName, isInstanceMember ? 0 /* Default */ : 8 /* SkipInstanceVariables */);\n            const memberFields = classTypeInfo.classType.details.fields;\n            if (memberInfo) {\n                // Are we accessing an existing member on this class, or is\n                // it a member on a parent class?\n                const isThisClass = types_1.isClass(memberInfo.classType) &&\n                    types_1.ClassType.isSameGenericClass(classTypeInfo.classType, memberInfo.classType);\n                if (isThisClass && memberInfo.isInstanceMember === isInstanceMember) {\n                    const symbol = memberFields.get(memberName);\n                    debug_1.assert(symbol !== undefined);\n                    const typedDecls = symbol.getDeclarations();\n                    let isFinalVar = symbolUtils_1.isFinalVariable(symbol);\n                    // Check for an attempt to overwrite a constant or final member variable.\n                    if (typedDecls.length > 0 &&\n                        typedDecls[0].type === 1 /* Variable */ &&\n                        srcExprNode &&\n                        node.memberName !== typedDecls[0].node) {\n                        if (typedDecls[0].isConstant) {\n                            addDiagnostic(fileInfo.diagnosticRuleSet.reportConstantRedefinition, \"reportConstantRedefinition\" /* reportConstantRedefinition */, localize_1.Localizer.Diagnostic.constantRedefinition().format({ name: node.memberName.value }), node.memberName);\n                        }\n                        // If a Final instance variable is declared in the class body but is\n                        // being assigned within an __init__ method, it's allowed.\n                        const enclosingFunctionNode = ParseTreeUtils.getEnclosingFunction(node);\n                        if (enclosingFunctionNode && enclosingFunctionNode.name.value === '__init__') {\n                            isFinalVar = false;\n                        }\n                        if (isFinalVar) {\n                            addError(localize_1.Localizer.Diagnostic.finalReassigned().format({ name: node.memberName.value }), node.memberName);\n                        }\n                    }\n                }\n                else {\n                    // Is the target a property?\n                    const declaredType = getDeclaredTypeOfSymbol(memberInfo.symbol);\n                    if (declaredType && !typeUtils_1.isProperty(declaredType)) {\n                        // Handle the case where there is a class variable defined with the same\n                        // name, but there's also now an instance variable introduced. Combine the\n                        // type of the class variable with that of the new instance variable.\n                        if (!memberInfo.isInstanceMember && isInstanceMember) {\n                            // The class variable is accessed in this case.\n                            setSymbolAccessed(fileInfo, memberInfo.symbol, node.memberName);\n                            const memberType = getTypeOfMember(memberInfo);\n                            srcType = types_1.combineTypes([srcType, memberType]);\n                        }\n                    }\n                }\n            }\n            // Look up the member info again, now that we've potentially updated it.\n            memberInfo = typeUtils_1.lookUpClassMember(classTypeInfo.classType, memberName, 32 /* DeclaredTypesOnly */);\n            if (!memberInfo && srcExprNode) {\n                reportPossibleUnknownAssignment(fileInfo.diagnosticRuleSet.reportUnknownMemberType, \"reportUnknownMemberType\" /* reportUnknownMemberType */, node.memberName, srcType, node);\n            }\n        }\n    }\n    function assignTypeToTupleNode(target, type, srcExpr) {\n        // Initialize the array of target types, one for each target.\n        const targetTypes = new Array(target.expressions.length);\n        for (let i = 0; i < target.expressions.length; i++) {\n            targetTypes[i] = [];\n        }\n        // Do any of the targets use an unpack operator? If so, it will consume all of the\n        // entries at that location.\n        const unpackIndex = target.expressions.findIndex((expr) => expr.nodeType === 57 /* Unpack */);\n        typeUtils_1.doForSubtypes(type, (subtype) => {\n            // Is this subtype a tuple?\n            const tupleType = typeUtils_1.getSpecializedTupleType(subtype);\n            if (tupleType && tupleType.typeArguments) {\n                const sourceEntryTypes = tupleType.typeArguments;\n                const sourceEntryCount = sourceEntryTypes.length;\n                // Is this a homogenous tuple of indeterminate length?\n                if (sourceEntryCount === 2 && typeUtils_1.isEllipsisType(sourceEntryTypes[1])) {\n                    for (let index = 0; index < target.expressions.length; index++) {\n                        targetTypes[index].push(sourceEntryTypes[0]);\n                    }\n                }\n                else {\n                    let sourceIndex = 0;\n                    let targetIndex = 0;\n                    for (targetIndex = 0; targetIndex < target.expressions.length; targetIndex++) {\n                        if (targetIndex === unpackIndex) {\n                            // Consume as many source entries as necessary to\n                            // make the remaining tuple entry counts match.\n                            const remainingTargetEntries = target.expressions.length - targetIndex - 1;\n                            const remainingSourceEntries = sourceEntryCount - sourceIndex;\n                            let entriesToPack = Math.max(remainingSourceEntries - remainingTargetEntries, 0);\n                            while (entriesToPack > 0) {\n                                targetTypes[targetIndex].push(sourceEntryTypes[sourceIndex]);\n                                sourceIndex++;\n                                entriesToPack--;\n                            }\n                        }\n                        else {\n                            if (sourceIndex >= sourceEntryCount) {\n                                // No more source entries to assign.\n                                break;\n                            }\n                            targetTypes[targetIndex].push(sourceEntryTypes[sourceIndex]);\n                            sourceIndex++;\n                        }\n                    }\n                    // Have we accounted for all of the targets and sources? If not, we have a size mismatch.\n                    if (targetIndex < target.expressions.length || sourceIndex < sourceEntryCount) {\n                        const fileInfo = getFileInfo(target);\n                        const expectedEntryCount = unpackIndex >= 0 ? target.expressions.length - 1 : target.expressions.length;\n                        addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.tupleSizeMismatch().format({\n                            expected: expectedEntryCount,\n                            received: sourceEntryCount,\n                        }), target);\n                    }\n                }\n            }\n            else {\n                // The assigned expression isn't a tuple, so it had better\n                // be some iterable type.\n                const iterableType = getTypeFromIterable(subtype, \n                /* isAsync */ false, srcExpr, \n                /* supportGetItem */ false);\n                for (let index = 0; index < target.expressions.length; index++) {\n                    targetTypes[index].push(iterableType);\n                }\n            }\n            // We need to return something to satisfy doForSubtypes.\n            return undefined;\n        });\n        // Assign the resulting types to the individual names in the tuple target expression.\n        target.expressions.forEach((expr, index) => {\n            const typeList = targetTypes[index];\n            let targetType = typeList.length === 0 ? types_1.UnknownType.create() : types_1.combineTypes(typeList);\n            // If the target uses an unpack operator, wrap the target type in a list.\n            if (index === unpackIndex) {\n                const listType = getBuiltInType(expr, 'List');\n                if (types_1.isClass(listType)) {\n                    targetType = types_1.ObjectType.create(types_1.ClassType.cloneForSpecialization(listType, [targetType], /* isTypeArgumentExplicit */ false));\n                }\n            }\n            assignTypeToExpression(expr, targetType, srcExpr);\n        });\n        writeTypeCache(target, type);\n    }\n    function assignTypeToExpression(target, type, srcExpr, expectedTypeDiagAddendum) {\n        // Is the source expression a TypeVar() call?\n        if (types_1.isTypeVar(type)) {\n            if (srcExpr && srcExpr.nodeType === 9 /* Call */) {\n                const callType = getTypeOfExpression(srcExpr.leftExpression).type;\n                if (types_1.isClass(callType) &&\n                    (types_1.ClassType.isBuiltIn(callType, 'TypeVar') || types_1.ClassType.isBuiltIn(callType, 'ParamSpec'))) {\n                    if (target.nodeType !== 39 /* Name */ || target.value !== type.name) {\n                        addError(type.isParamSpec\n                            ? localize_1.Localizer.Diagnostic.paramSpecAssignedName().format({ name: type.name })\n                            : localize_1.Localizer.Diagnostic.typeVarAssignedName().format({ name: type.name }), target);\n                    }\n                }\n            }\n        }\n        // If the type was partially unbound, an error will have already been logged.\n        // Remove the unbound before assigning to the target expression so the unbound\n        // error doesn't propagate.\n        type = types_1.removeUnboundFromUnion(type);\n        switch (target.nodeType) {\n            case 39 /* Name */: {\n                const name = target;\n                // Handle '__all__' as a special case in the module scope.\n                if (name.value === '__all__' && srcExpr) {\n                    const scope = ScopeUtils.getScopeForNode(target);\n                    if ((scope === null || scope === void 0 ? void 0 : scope.type) === 3 /* Module */) {\n                        // It's common for modules to include the expression\n                        // __all__ = ['a', 'b', 'c']\n                        // We will mark the symbols referenced by these strings as accessed.\n                        if (srcExpr.nodeType === 32 /* List */) {\n                            const fileInfo = getFileInfo(target);\n                            srcExpr.entries.forEach((entryExpr) => {\n                                if (entryExpr.nodeType === 49 /* StringList */ ||\n                                    entryExpr.nodeType === 50 /* String */) {\n                                    const symbolName = entryExpr.nodeType === 50 /* String */\n                                        ? entryExpr.value\n                                        : entryExpr.strings.map((s) => s.value).join('');\n                                    const symbolInScope = scope.lookUpSymbolRecursive(symbolName);\n                                    if (symbolInScope) {\n                                        setSymbolAccessed(fileInfo, symbolInScope.symbol, target);\n                                    }\n                                }\n                            });\n                        }\n                    }\n                }\n                reportPossibleUnknownAssignment(getFileInfo(target).diagnosticRuleSet.reportUnknownVariableType, \"reportUnknownVariableType\" /* reportUnknownVariableType */, target, type, target);\n                assignTypeToNameNode(target, type, srcExpr, expectedTypeDiagAddendum);\n                break;\n            }\n            case 36 /* MemberAccess */: {\n                assignTypeToMemberAccessNode(target, type, srcExpr, expectedTypeDiagAddendum);\n                break;\n            }\n            case 24 /* Index */: {\n                const baseTypeResult = getTypeOfExpression(target.baseExpression, undefined, 2 /* DoNotSpecialize */);\n                const indexTypeResult = getTypeFromIndexWithBaseType(target, baseTypeResult.type, {\n                    method: 'set',\n                    setType: type,\n                    setErrorNode: srcExpr,\n                    setExpectedTypeDiag: expectedTypeDiagAddendum,\n                }, 0 /* None */);\n                writeTypeCache(target, indexTypeResult.type);\n                break;\n            }\n            case 53 /* Tuple */: {\n                assignTypeToTupleNode(target, type, srcExpr);\n                break;\n            }\n            case 55 /* TypeAnnotation */: {\n                const typeHintType = getTypeOfAnnotation(target.typeAnnotation, ParseTreeUtils.isFinalAllowedForAssignmentTarget(target.valueExpression));\n                const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n                if (canAssignType(typeHintType, type, diagAddendum)) {\n                    type = narrowDeclaredTypeBasedOnAssignedType(typeHintType, type);\n                }\n                assignTypeToExpression(target.valueExpression, type, srcExpr, expectedTypeDiagAddendum);\n                break;\n            }\n            case 57 /* Unpack */: {\n                if (target.expression.nodeType === 39 /* Name */) {\n                    assignTypeToNameNode(target.expression, type, srcExpr);\n                }\n                break;\n            }\n            case 32 /* List */: {\n                // The assigned expression had better be some iterable type.\n                const iteratedType = getTypeFromIterable(type, \n                /* isAsync */ false, srcExpr, \n                /* supportGetItem */ false);\n                target.entries.forEach((entry) => {\n                    assignTypeToExpression(entry, iteratedType, srcExpr);\n                });\n                break;\n            }\n            case 0 /* Error */: {\n                // Evaluate the child expression as best we can so the\n                // type information is cached for the completion handler.\n                suppressDiagnostics(() => {\n                    if (target.child) {\n                        getTypeOfExpression(target.child);\n                    }\n                });\n                break;\n            }\n            default: {\n                const fileInfo = getFileInfo(target);\n                addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.assignmentTargetExpr(), target);\n                break;\n            }\n        }\n    }\n    function verifyDeleteExpression(node) {\n        switch (node.nodeType) {\n            case 39 /* Name */: {\n                // Get the type to evaluate whether it's bound\n                // and to mark it accessed.\n                getTypeOfExpression(node);\n                break;\n            }\n            case 36 /* MemberAccess */: {\n                const baseTypeResult = getTypeOfExpression(node.leftExpression);\n                const memberType = getTypeFromMemberAccessWithBaseType(node, baseTypeResult, { method: 'del' }, 0 /* None */);\n                writeTypeCache(node.memberName, memberType.type);\n                break;\n            }\n            case 24 /* Index */: {\n                const baseTypeResult = getTypeOfExpression(node.baseExpression, undefined, 2 /* DoNotSpecialize */);\n                getTypeFromIndexWithBaseType(node, baseTypeResult.type, { method: 'del' }, 0 /* None */);\n                writeTypeCache(node, types_1.UnboundType.create());\n                break;\n            }\n            case 0 /* Error */: {\n                // Evaluate the child expression as best we can so the\n                // type information is cached for the completion handler.\n                suppressDiagnostics(() => {\n                    if (node.child) {\n                        getTypeOfExpression(node.child);\n                    }\n                });\n                break;\n            }\n            default: {\n                const fileInfo = getFileInfo(node);\n                addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.delTargetExpr(), node);\n                break;\n            }\n        }\n    }\n    function setSymbolAccessed(fileInfo, symbol, node) {\n        if (!isSpeculativeMode(node) && !incompleteTypeTracker.isIncompleteTypeMode()) {\n            fileInfo.accessedSymbolMap.set(symbol.id, true);\n        }\n    }\n    // Builds a sorted list of dataclass entries that are inherited by\n    // the specified class. These entries must be unique and in reverse-MRO\n    // order.\n    function addInheritedDataClassEntries(classType, entries) {\n        for (let i = classType.details.mro.length - 1; i >= 0; i--) {\n            const mroClass = classType.details.mro[i];\n            if (types_1.isClass(mroClass)) {\n                const dataClassEntries = types_1.ClassType.getDataClassEntries(mroClass);\n                // Add the entries to the end of the list, replacing same-named\n                // entries if found.\n                dataClassEntries.forEach((entry) => {\n                    const existingIndex = entries.findIndex((e) => e.name === entry.name);\n                    if (existingIndex >= 0) {\n                        entries[existingIndex] = entry;\n                    }\n                    else {\n                        entries.push(entry);\n                    }\n                });\n            }\n        }\n    }\n    function getReturnTypeFromGenerator(type) {\n        if (types_1.isAnyOrUnknown(type)) {\n            return type;\n        }\n        if (types_1.isObject(type)) {\n            // Is this a Generator? If so, return the third\n            // type argument, which is the await response type.\n            const classType = type.classType;\n            if (types_1.ClassType.isBuiltIn(classType, 'Generator')) {\n                const typeArgs = classType.typeArguments;\n                if (typeArgs && typeArgs.length >= 3) {\n                    return typeArgs[2];\n                }\n            }\n        }\n        return undefined;\n    }\n    function getSpecializedReturnType(objType, memberName) {\n        const classMember = typeUtils_1.lookUpObjectMember(objType, memberName, 8 /* SkipInstanceVariables */);\n        if (!classMember) {\n            return undefined;\n        }\n        const memberType = getTypeOfMember(classMember);\n        if (types_1.isAnyOrUnknown(memberType)) {\n            return memberType;\n        }\n        if (memberType.category === 5 /* Function */) {\n            const methodType = bindFunctionToClassOrObject(objType, memberType);\n            return getFunctionEffectiveReturnType(methodType);\n        }\n        return undefined;\n    }\n    // This is similar to _getSpecializedReturnType except that\n    // the method lookup occurs on a metaclass rather than\n    // the object that derives from it.\n    function getSpecializedReturnTypeForMetaclassMethod(metaclass, classType, memberName) {\n        const classMember = typeUtils_1.lookUpObjectMember(types_1.ObjectType.create(metaclass), memberName, 8 /* SkipInstanceVariables */);\n        if (!classMember) {\n            return undefined;\n        }\n        const memberType = getTypeOfMember(classMember);\n        if (types_1.isAnyOrUnknown(memberType)) {\n            return memberType;\n        }\n        if (memberType.category === 5 /* Function */) {\n            const methodType = bindFunctionToClassOrObject(classType, memberType, \n            /* treatAsClassMember */ true);\n            return getFunctionEffectiveReturnType(methodType);\n        }\n        return undefined;\n    }\n    function getTypeFromName(node, flags) {\n        const fileInfo = getFileInfo(node);\n        const name = node.value;\n        let type;\n        let isResolutionCyclical = false;\n        const allowForwardReferences = (flags & 4 /* AllowForwardReferences */) !== 0;\n        // Look for the scope that contains the value definition and\n        // see if it has a declared type.\n        const symbolWithScope = lookUpSymbolRecursive(node, name, !allowForwardReferences);\n        if (symbolWithScope) {\n            let useCodeFlowAnalysis = !allowForwardReferences;\n            // If the symbol is implicitly imported from the builtin\n            // scope, there's no need to use code flow analysis.\n            if (symbolWithScope.scope.type === 4 /* Builtin */) {\n                useCodeFlowAnalysis = false;\n            }\n            if (fileInfo.isStubFile) {\n                // Type stubs allow forward references of classes, so\n                // don't use code flow analysis in this case.\n                const decl = symbolUtils_1.getLastTypedDeclaredForSymbol(symbolWithScope.symbol);\n                if (decl && decl.type === 4 /* Class */) {\n                    useCodeFlowAnalysis = false;\n                }\n            }\n            const symbol = symbolWithScope.symbol;\n            // Get the effective type (either the declared type or the inferred type).\n            // If we're using code flow analysis, pass the usage node so we consider\n            // only the assignment nodes that are reachable from this usage.\n            const effectiveTypeInfo = getEffectiveTypeOfSymbolForUsage(symbol, useCodeFlowAnalysis ? node : undefined);\n            const effectiveType = effectiveTypeInfo.type;\n            if (effectiveTypeInfo.isResolutionCyclical) {\n                isResolutionCyclical = true;\n            }\n            const isSpecialBuiltIn = !!effectiveType && types_1.isClass(effectiveType) && types_1.ClassType.isSpecialBuiltIn(effectiveType);\n            type = effectiveType;\n            if (useCodeFlowAnalysis && !isSpecialBuiltIn) {\n                // See if code flow analysis can tell us anything more about the type.\n                // If the symbol is declared outside of our execution scope, use its effective\n                // type. If it's declared inside our execution scope, it generally starts\n                // as unbound at the start of the code flow.\n                const typeAtStart = symbolWithScope.isBeyondExecutionScope || !symbol.isInitiallyUnbound()\n                    ? effectiveType\n                    : types_1.UnboundType.create();\n                const codeFlowType = getFlowTypeOfReference(node, symbol.id, typeAtStart);\n                if (codeFlowType) {\n                    type = codeFlowType;\n                }\n            }\n            if (!(flags & 2 /* DoNotSpecialize */)) {\n                if (types_1.isClass(type)) {\n                    if (!type.typeArguments) {\n                        type = createSpecializedClassType(type, undefined, flags, node);\n                    }\n                }\n                else if (types_1.isObject(type)) {\n                    // If this is an object that contains a Type[X], transform it\n                    // into class X.\n                    const typeType = getClassFromPotentialTypeObject(type);\n                    if (typeType) {\n                        type = typeType;\n                    }\n                }\n            }\n            // If there is a resolution cycle, don't report it as an unbound symbol\n            // at this time. It will be re-evaluated as the call stack unwinds, and\n            // its actual type will be known then.\n            if (!isResolutionCyclical) {\n                if (types_1.isUnbound(type)) {\n                    addDiagnostic(fileInfo.diagnosticRuleSet.reportUnboundVariable, \"reportUnboundVariable\" /* reportUnboundVariable */, localize_1.Localizer.Diagnostic.symbolIsUnbound().format({ name }), node);\n                }\n                else if (types_1.isPossiblyUnbound(type)) {\n                    addDiagnostic(fileInfo.diagnosticRuleSet.reportUnboundVariable, \"reportUnboundVariable\" /* reportUnboundVariable */, localize_1.Localizer.Diagnostic.symbolIsPossiblyUnbound().format({ name }), node);\n                }\n            }\n            setSymbolAccessed(fileInfo, symbol, node);\n        }\n        else {\n            // Handle the special case of \"reveal_type\".\n            if (name !== 'reveal_type') {\n                addDiagnostic(fileInfo.diagnosticRuleSet.reportUndefinedVariable, \"reportUndefinedVariable\" /* reportUndefinedVariable */, localize_1.Localizer.Diagnostic.symbolIsUndefined().format({ name }), node);\n            }\n            type = types_1.UnknownType.create();\n        }\n        if (types_1.isTypeVar(type) && type.isParamSpec) {\n            if (flags & 128 /* ParamSpecDisallowed */) {\n                addError(localize_1.Localizer.Diagnostic.paramSpecContext(), node);\n            }\n        }\n        if ((flags & 256 /* ExpectingType */) !== 0) {\n            if ((flags & 2048 /* GenericClassTypeAllowed */) === 0) {\n                if (types_1.isClass(type) && types_1.ClassType.isBuiltIn(type, 'Generic')) {\n                    addDiagnostic(getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.genericNotAllowed(), node);\n                }\n            }\n        }\n        return { type, node, isResolutionCyclical };\n    }\n    function getTypeFromMemberAccess(node, flags) {\n        const baseTypeFlags = 2 /* DoNotSpecialize */ |\n            (flags & (256 /* ExpectingType */ | 4 /* AllowForwardReferences */));\n        const baseTypeResult = getTypeOfExpression(node.leftExpression, undefined, baseTypeFlags);\n        const memberTypeResult = getTypeFromMemberAccessWithBaseType(node, baseTypeResult, { method: 'get' }, flags);\n        if (codeFlow_1.isCodeFlowSupportedForReference(node)) {\n            // Before performing code flow analysis, update the cache to prevent recursion.\n            writeTypeCache(node, memberTypeResult.type);\n            writeTypeCache(node.memberName, memberTypeResult.type);\n            // If the type is initially unbound, see if there's a parent class that\n            // potentially initialized the value.\n            let initialType = memberTypeResult.type;\n            if (types_1.isUnbound(initialType)) {\n                const baseType = typeUtils_1.makeTypeVarsConcrete(baseTypeResult.type);\n                let classMemberInfo;\n                if (types_1.isClass(baseType)) {\n                    classMemberInfo = typeUtils_1.lookUpClassMember(baseType, node.memberName.value, 1 /* SkipOriginalClass */);\n                }\n                else if (types_1.isObject(baseType)) {\n                    classMemberInfo = typeUtils_1.lookUpObjectMember(baseType, node.memberName.value, 1 /* SkipOriginalClass */);\n                }\n                if (classMemberInfo) {\n                    initialType = getTypeOfMember(classMemberInfo);\n                }\n            }\n            // See if we can refine the type based on code flow analysis.\n            const codeFlowType = getFlowTypeOfReference(node, symbol_1.indeterminateSymbolId, initialType);\n            if (codeFlowType) {\n                memberTypeResult.type = codeFlowType;\n            }\n        }\n        // Cache the type information in the member name node as well.\n        writeTypeCache(node.memberName, memberTypeResult.type);\n        return memberTypeResult;\n    }\n    function getTypeFromMemberAccessWithBaseType(node, baseTypeResult, usage, flags) {\n        const baseType = baseTypeResult.type;\n        const memberName = node.memberName.value;\n        let diag = new diagnostic_1.DiagnosticAddendum();\n        const fileInfo = getFileInfo(node);\n        let type;\n        switch (baseType.category) {\n            case 2 /* Any */:\n            case 1 /* Unknown */: {\n                type = baseType;\n                break;\n            }\n            case 7 /* Class */: {\n                type = getTypeFromClassMember(node.memberName, baseType, memberName, usage, diag);\n                break;\n            }\n            case 11 /* TypeVar */: {\n                if (baseType.isParamSpec) {\n                    if (memberName === 'args' || memberName === 'kwargs') {\n                        return { type: types_1.AnyType.create(), node };\n                    }\n                    addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.paramSpecUnknownMember().format({ name: memberName }), node.memberName);\n                    return { type: types_1.UnknownType.create(), node };\n                }\n                return getTypeFromMemberAccessWithBaseType(node, {\n                    type: typeUtils_1.specializeType(baseType, /* typeVarMap */ undefined, /* makeConcrete */ true),\n                    node,\n                }, usage, 0 /* None */);\n            }\n            case 8 /* Object */: {\n                const classFromTypeObject = getClassFromPotentialTypeObject(baseType);\n                if (classFromTypeObject) {\n                    // Handle the case where the object is a 'Type' object, which\n                    // represents a class.\n                    return getTypeFromMemberAccessWithBaseType(node, { type: classFromTypeObject, node: baseTypeResult.node }, usage, flags);\n                }\n                type = getTypeFromObjectMember(node.memberName, baseType, memberName, usage, diag);\n                break;\n            }\n            case 9 /* Module */: {\n                const symbol = types_1.ModuleType.getField(baseType, memberName);\n                if (symbol) {\n                    if (usage.method === 'get') {\n                        setSymbolAccessed(getFileInfo(node), symbol, node.memberName);\n                    }\n                    type = getEffectiveTypeOfSymbol(symbol);\n                    // If the type resolved to \"unbound\", treat it as \"unknown\" in\n                    // the case of a module reference because if it's truly unbound,\n                    // that error will be reported within the module and should not\n                    // leak into other modules that import it.\n                    if (types_1.isUnbound(type)) {\n                        type = types_1.UnknownType.create();\n                    }\n                }\n                else {\n                    // Does the stub file export a top-level __getattr__ function?\n                    if (usage.method === 'get') {\n                        const getAttrSymbol = types_1.ModuleType.getField(baseType, '__getattr__');\n                        if (getAttrSymbol) {\n                            const decls = getAttrSymbol.getDeclarations();\n                            // Only honor the __getattr__ if it's in a stub file.\n                            if (decls.some((decl) => decl.path.toLowerCase().endsWith('.pyi'))) {\n                                const getAttrType = getEffectiveTypeOfSymbol(getAttrSymbol);\n                                if (getAttrType.category === 5 /* Function */) {\n                                    type = getFunctionEffectiveReturnType(getAttrType);\n                                }\n                            }\n                        }\n                    }\n                    if (!type) {\n                        addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.moduleUnknownMember().format({ name: memberName }), node.memberName);\n                        type = types_1.UnknownType.create();\n                    }\n                }\n                break;\n            }\n            case 10 /* Union */: {\n                type = typeUtils_1.doForSubtypes(baseType, (subtype) => {\n                    if (types_1.isNone(subtype)) {\n                        addDiagnostic(getFileInfo(node).diagnosticRuleSet.reportOptionalMemberAccess, \"reportOptionalMemberAccess\" /* reportOptionalMemberAccess */, localize_1.Localizer.Diagnostic.noneUnknownMember().format({ name: memberName }), node.memberName);\n                        return undefined;\n                    }\n                    else if (types_1.isUnbound(subtype)) {\n                        // Don't do anything if it's unbound. The error will already\n                        // be reported elsewhere.\n                        return undefined;\n                    }\n                    else {\n                        const typeResult = getTypeFromMemberAccessWithBaseType(node, {\n                            type: subtype,\n                            node,\n                        }, usage, 0 /* None */);\n                        return typeResult.type;\n                    }\n                });\n                break;\n            }\n            case 5 /* Function */:\n            case 6 /* OverloadedFunction */: {\n                // TODO - not yet sure what to do about members of functions,\n                // which have associated dictionaries.\n                type = types_1.AnyType.create();\n                break;\n            }\n            default:\n                diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeUnsupported().format({ type: printType(baseType) }));\n                break;\n        }\n        if (!type) {\n            let diagMessage = localize_1.Localizer.Diagnostic.memberAccess();\n            if (usage.method === 'set') {\n                diagMessage = localize_1.Localizer.Diagnostic.memberSet();\n            }\n            else if (usage.method === 'del') {\n                diagMessage = localize_1.Localizer.Diagnostic.memberDelete();\n            }\n            // If there is an expected type diagnostic addendum (used for assignments),\n            // use that rather than the local diagnostic addendum because it will be\n            // more informative.\n            if (usage.setExpectedTypeDiag) {\n                diag = usage.setExpectedTypeDiag;\n            }\n            addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, diagMessage.format({ name: memberName, type: printType(baseType) }) + diag.getString(), node.memberName);\n            type = types_1.UnknownType.create();\n        }\n        // Should we specialize the class?\n        if ((flags & 2 /* DoNotSpecialize */) === 0) {\n            if (types_1.isClass(type) && !type.typeArguments) {\n                type = createSpecializedClassType(type, undefined, flags, node);\n            }\n        }\n        if (usage.method === 'get') {\n            reportPossibleUnknownAssignment(fileInfo.diagnosticRuleSet.reportUnknownMemberType, \"reportUnknownMemberType\" /* reportUnknownMemberType */, node.memberName, type, node);\n        }\n        return { type, node };\n    }\n    // If the object type is a 'Type' object, converts it to the corresponding\n    // class that it represents and returns that class. Otherwise returns undefined.\n    function getClassFromPotentialTypeObject(potentialTypeObject) {\n        const objectClass = potentialTypeObject.classType;\n        if (types_1.ClassType.isBuiltIn(objectClass, 'Type')) {\n            const typeArgs = objectClass.typeArguments;\n            if (typeArgs && typeArgs.length > 0) {\n                let firstTypeArg = typeArgs[0];\n                // If the type arg is a type var itself, specialize it in case it's bound.\n                if (types_1.isTypeVar(firstTypeArg)) {\n                    firstTypeArg = typeUtils_1.getConcreteTypeFromTypeVar(firstTypeArg);\n                }\n                if (types_1.isObject(firstTypeArg)) {\n                    return firstTypeArg.classType;\n                }\n            }\n            return types_1.AnyType.create();\n        }\n        return undefined;\n    }\n    function getTypeFromClassMemberName(errorNode, classType, memberName, usage, diag, flags, bindToClass) {\n        // If this is a special type (like \"List\") that has an alias\n        // class (like \"list\"), switch to the alias, which defines\n        // the members.\n        if (classType.details.aliasClass) {\n            classType = classType.details.aliasClass;\n        }\n        let classLookupFlags = 0 /* Default */;\n        if (flags & 1 /* SkipInstanceMembers */) {\n            classLookupFlags |= 8 /* SkipInstanceVariables */;\n        }\n        if (flags & 2 /* SkipBaseClasses */) {\n            classLookupFlags |= 2 /* SkipBaseClasses */;\n        }\n        if (flags & 4 /* SkipObjectBaseClass */) {\n            classLookupFlags |= 4 /* SkipObjectBaseClass */;\n        }\n        if (flags & 32 /* SkipIfInaccessibleToInstance */) {\n            classLookupFlags |= 16 /* SkipIfInaccessibleToInstance */;\n        }\n        // Always look for a member with a declared type first.\n        let memberInfo = typeUtils_1.lookUpClassMember(classType, memberName, classLookupFlags | 32 /* DeclaredTypesOnly */);\n        // If we couldn't find a symbol with a declared type, use\n        // a symbol with an inferred type.\n        if (!memberInfo) {\n            memberInfo = typeUtils_1.lookUpClassMember(classType, memberName, classLookupFlags);\n        }\n        if (memberInfo) {\n            let type;\n            if (usage.method === 'get') {\n                type = getTypeOfMember(memberInfo);\n            }\n            else {\n                // If the usage indicates a 'set' or 'delete', use\n                // only the declared type to avoid circular\n                // type evaluation.\n                type = getDeclaredTypeOfSymbol(memberInfo.symbol) || types_1.UnknownType.create();\n            }\n            if (usage.method === 'set' && memberInfo.symbol.isClassVar()) {\n                if (flags & 16 /* DisallowClassVarWrites */) {\n                    diag.addMessage(localize_1.Localizer.DiagnosticAddendum.memberSetClassVar().format({ name: memberName }));\n                    return undefined;\n                }\n            }\n            // Don't include variables within typed dict classes.\n            if (types_1.ClassType.isTypedDictClass(classType)) {\n                const typedDecls = memberInfo.symbol.getTypedDeclarations();\n                if (typedDecls.length > 0 && typedDecls[0].type === 1 /* Variable */) {\n                    diag.addMessage(localize_1.Localizer.DiagnosticAddendum.memberUnknown().format({ name: memberName }));\n                    return undefined;\n                }\n            }\n            if (usage.method === 'get') {\n                // Mark the member accessed if it's not coming from a parent class.\n                if (types_1.isClass(memberInfo.classType) && types_1.ClassType.isSameGenericClass(memberInfo.classType, classType)) {\n                    setSymbolAccessed(getFileInfo(errorNode), memberInfo.symbol, errorNode);\n                }\n            }\n            if (types_1.isObject(type)) {\n                // See if there's a magic \"__get__\", \"__set__\", or \"__delete__\"\n                // method on the object.\n                let accessMethodName;\n                if (usage.method === 'get') {\n                    accessMethodName = '__get__';\n                }\n                else if (usage.method === 'set') {\n                    accessMethodName = '__set__';\n                }\n                else {\n                    accessMethodName = '__delete__';\n                }\n                const memberClassType = type.classType;\n                const accessMethod = typeUtils_1.lookUpClassMember(memberClassType, accessMethodName, 8 /* SkipInstanceVariables */);\n                // Handle properties specially.\n                if (types_1.ClassType.isPropertyClass(type.classType)) {\n                    if (usage.method === 'set') {\n                        if (!accessMethod) {\n                            diag.addMessage(localize_1.Localizer.DiagnosticAddendum.propertyMissingSetter().format({ name: memberName }));\n                            return undefined;\n                        }\n                    }\n                    else if (usage.method === 'del') {\n                        if (!accessMethod) {\n                            diag.addMessage(localize_1.Localizer.DiagnosticAddendum.propertyMissingDeleter().format({ name: memberName }));\n                            return undefined;\n                        }\n                    }\n                }\n                if (accessMethod) {\n                    let accessMethodType = getTypeOfMember(accessMethod);\n                    // If it's an overloaded function, determine which overload to use.\n                    if (accessMethodType.category === 6 /* OverloadedFunction */) {\n                        const argList = [\n                            {\n                                argumentCategory: 0 /* Simple */,\n                                type: types_1.ObjectType.create(memberClassType),\n                            },\n                            {\n                                argumentCategory: 0 /* Simple */,\n                                type: flags & 1 /* SkipInstanceMembers */\n                                    ? types_1.NoneType.createInstance()\n                                    : types_1.ObjectType.create(classType),\n                            },\n                            {\n                                argumentCategory: 0 /* Simple */,\n                                type: types_1.AnyType.create(),\n                            },\n                        ];\n                        const overload = findOverloadedFunctionType(errorNode, argList, accessMethodType, \n                        /* expectedType */ undefined);\n                        if (overload) {\n                            accessMethodType = overload;\n                        }\n                    }\n                    if (accessMethodType.category === 5 /* Function */) {\n                        // Bind the accessor to the base object type.\n                        accessMethodType = bindFunctionToClassOrObject(bindToClass || types_1.ObjectType.create(classType), accessMethodType, bindToClass !== undefined);\n                        if (usage.method === 'get') {\n                            type = getFunctionEffectiveReturnType(accessMethodType);\n                            if (types_1.isClass(memberInfo.classType)) {\n                                type = typeUtils_1.partiallySpecializeType(type, memberInfo.classType);\n                            }\n                        }\n                        else {\n                            if (usage.method === 'set') {\n                                // Verify that the setter's parameter type matches\n                                // the type of the value being assigned.\n                                if (accessMethodType.details.parameters.length >= 2) {\n                                    const setValueType = accessMethodType.details.parameters[1].type;\n                                    if (!canAssignType(setValueType, usage.setType, diag)) {\n                                        return undefined;\n                                    }\n                                }\n                            }\n                            // The type isn't important for set or delete usage.\n                            // We just need to return some defined type.\n                            type = types_1.AnyType.create();\n                        }\n                    }\n                    return {\n                        type,\n                        isClassMember: !memberInfo.isInstanceMember,\n                    };\n                }\n            }\n            if (usage.method === 'set') {\n                let enforceTargetType = false;\n                if (memberInfo.symbol.hasTypedDeclarations()) {\n                    // If the member has a declared type, we will enforce it.\n                    enforceTargetType = true;\n                }\n                else {\n                    // If the member has no declared type, we will enforce it\n                    // if this assignment isn't within the enclosing class. If\n                    // it is within the enclosing class, the assignment is used\n                    // to infer the type of the member.\n                    if (!memberInfo.symbol.getDeclarations().some((decl) => decl.node === errorNode)) {\n                        enforceTargetType = true;\n                    }\n                }\n                if (enforceTargetType) {\n                    let effectiveType = type;\n                    // If the code is patching a method (defined on the class)\n                    // with an object-level function, strip the \"self\" parameter\n                    // off the original type. This is sometimes done for test\n                    // purposes to override standard behaviors of specific methods.\n                    if ((flags & 1 /* SkipInstanceMembers */) === 0) {\n                        if (!memberInfo.isInstanceMember && type.category === 5 /* Function */) {\n                            if (types_1.FunctionType.isClassMethod(type) || types_1.FunctionType.isInstanceMethod(type)) {\n                                effectiveType = typeUtils_1.stripFirstParameter(type);\n                            }\n                        }\n                    }\n                    // Verify that the assigned type is compatible.\n                    if (!canAssignType(effectiveType, usage.setType, diag.createAddendum())) {\n                        diag.addMessage(localize_1.Localizer.DiagnosticAddendum.memberAssignment().format({\n                            type: printType(usage.setType),\n                            name: memberName,\n                            classType: printObjectTypeForClass(classType),\n                        }));\n                        return undefined;\n                    }\n                }\n            }\n            return {\n                type,\n                isClassMember: !memberInfo.isInstanceMember,\n            };\n        }\n        if (!(flags & 8 /* SkipGetAttributeCheck */)) {\n            if (usage.method === 'get') {\n                // See if the class has a \"__getattribute__\" or \"__getattr__\" method.\n                // If so, arbitrary members are supported.\n                const getAttribType = getTypeFromClassMember(errorNode, classType, '__getattribute__', { method: 'get' }, new diagnostic_1.DiagnosticAddendum(), 9 /* SkipForMethodLookup */ | 4 /* SkipObjectBaseClass */);\n                if (getAttribType && getAttribType.category === 5 /* Function */) {\n                    return {\n                        type: getFunctionEffectiveReturnType(getAttribType),\n                        isClassMember: false,\n                    };\n                }\n                const getAttrType = getTypeFromClassMember(errorNode, classType, '__getattr__', { method: 'get' }, new diagnostic_1.DiagnosticAddendum(), 9 /* SkipForMethodLookup */);\n                if (getAttrType && getAttrType.category === 5 /* Function */) {\n                    return {\n                        type: getFunctionEffectiveReturnType(getAttrType),\n                        isClassMember: false,\n                    };\n                }\n            }\n            else if (usage.method === 'set') {\n                const setAttrType = getTypeFromClassMember(errorNode, classType, '__setattr__', { method: 'get' }, new diagnostic_1.DiagnosticAddendum(), 9 /* SkipForMethodLookup */ | 4 /* SkipObjectBaseClass */);\n                if (setAttrType) {\n                    // The type doesn't matter for a set usage. We just need\n                    // to return a defined type.\n                    return {\n                        type: types_1.AnyType.create(),\n                        isClassMember: false,\n                    };\n                }\n            }\n            else {\n                debug_1.assert(usage.method === 'del');\n                const delAttrType = getTypeFromClassMember(errorNode, classType, '__detattr__', { method: 'get' }, new diagnostic_1.DiagnosticAddendum(), 9 /* SkipForMethodLookup */ | 4 /* SkipObjectBaseClass */);\n                if (delAttrType) {\n                    // The type doesn't matter for a delete usage. We just need\n                    // to return a defined type.\n                    return {\n                        type: types_1.AnyType.create(),\n                        isClassMember: false,\n                    };\n                }\n            }\n        }\n        diag.addMessage(localize_1.Localizer.DiagnosticAddendum.memberUnknown().format({ name: memberName }));\n        return undefined;\n    }\n    function getTypeFromIndex(node, flags = 0 /* None */) {\n        const baseTypeResult = getTypeOfExpression(node.baseExpression, undefined, flags | 2 /* DoNotSpecialize */);\n        return getTypeFromIndexWithBaseType(node, baseTypeResult.type, { method: 'get' }, flags);\n    }\n    function getTypeFromIndexWithBaseType(node, baseType, usage, flags) {\n        var _a;\n        // Handle the case where we're specializing a generic union\n        // of classes, a callable, or a specialized class.\n        if (baseType.category === 10 /* Union */ ||\n            baseType.category === 5 /* Function */ ||\n            (types_1.isClass(baseType) && baseType.typeArguments)) {\n            const isUnionOfClasses = types_1.isUnionableType([baseType]);\n            if (isUnionOfClasses) {\n                const typeParameters = [];\n                typeUtils_1.doForSubtypes(baseType, (subtype) => {\n                    typeUtils_1.addTypeVarsToListIfUnique(typeParameters, typeUtils_1.getTypeVarArgumentsRecursive(subtype));\n                    return undefined;\n                });\n                if (typeParameters.length > 0) {\n                    const typeArgs = getTypeArgs(node.items, flags);\n                    if (typeArgs.length > typeParameters.length) {\n                        addError(localize_1.Localizer.Diagnostic.typeArgsTooMany().format({\n                            expected: typeParameters.length,\n                            received: typeArgs.length,\n                        }), typeArgs[typeParameters.length].node);\n                    }\n                    const typeVarMap = new typeVarMap_1.TypeVarMap();\n                    const diag = new diagnostic_1.DiagnosticAddendum();\n                    typeParameters.forEach((param, index) => {\n                        assignTypeToTypeVar(param, index < typeArgs.length ? typeUtils_1.convertToInstance(typeArgs[index].type) : types_1.UnknownType.create(), \n                        /* canNarrowType */ false, diag, typeVarMap);\n                    });\n                    if (!diag.isEmpty()) {\n                        addError(localize_1.Localizer.Diagnostic.typeNotSpecializable().format({ type: printType(baseType) }) +\n                            diag.getString(), node.items);\n                    }\n                    let type = typeUtils_1.specializeType(baseType, typeVarMap);\n                    if (baseType.typeAliasInfo && type !== baseType) {\n                        const typeArgs = [];\n                        (_a = baseType.typeAliasInfo.typeParameters) === null || _a === void 0 ? void 0 : _a.forEach((typeParam) => {\n                            typeArgs.push(typeVarMap.getTypeVar(typeParam.name) || types_1.UnknownType.create());\n                        });\n                        type = types_1.TypeBase.cloneForTypeAlias(type, baseType.typeAliasInfo.aliasName, baseType.typeAliasInfo.typeParameters, typeArgs);\n                    }\n                    return { type, node };\n                }\n            }\n        }\n        const type = typeUtils_1.doForSubtypes(baseType, (subtype) => {\n            subtype = typeUtils_1.makeTypeVarsConcrete(subtype);\n            if (types_1.isAnyOrUnknown(subtype)) {\n                return subtype;\n            }\n            if (types_1.isClass(subtype)) {\n                // Setting the value of an indexed class will always result\n                // in an exception.\n                if (usage.method === 'set') {\n                    addError(localize_1.Localizer.Diagnostic.genericClassAssigned(), node.baseExpression);\n                }\n                else if (usage.method === 'del') {\n                    addError(localize_1.Localizer.Diagnostic.genericClassDeleted(), node.baseExpression);\n                }\n                if (types_1.ClassType.isSpecialBuiltIn(subtype, 'Literal')) {\n                    // Special-case Literal types.\n                    return createLiteralType(node);\n                }\n                if (types_1.ClassType.isBuiltIn(subtype, 'InitVar')) {\n                    // Special-case InitVar, used in data classes.\n                    const typeArgs = getTypeArgs(node.items, flags);\n                    if (typeArgs.length === 1) {\n                        return typeArgs[0].type;\n                    }\n                    else {\n                        addError(localize_1.Localizer.Diagnostic.typeArgsMismatchOne().format({ received: typeArgs.length }), node.baseExpression);\n                        return types_1.UnknownType.create();\n                    }\n                }\n                if (types_1.ClassType.isEnumClass(subtype)) {\n                    // Special-case Enum types.\n                    // TODO - validate that there's only one index entry\n                    // that is a str type.\n                    // TODO - validate that literal strings are referencing\n                    // a known enum member.\n                    return types_1.ObjectType.create(subtype);\n                }\n                // Handle the case where the base type is \"Tuple\". We need to\n                // perform special processing of the type args in this case to permit\n                // empty tuples.\n                let adjustedFlags = flags;\n                if (types_1.isClass(subtype) && types_1.ClassType.isBuiltIn(subtype, 'Tuple')) {\n                    adjustedFlags |= 512 /* AllowEmptyTupleAsType */;\n                }\n                const isAnnotatedClass = types_1.isClass(subtype) && types_1.ClassType.isBuiltIn(subtype, 'Annotated');\n                const typeArgs = getTypeArgs(node.items, adjustedFlags, isAnnotatedClass);\n                return createSpecializedClassType(subtype, typeArgs, flags, node);\n            }\n            if (types_1.isObject(subtype)) {\n                return getTypeFromIndexedObject(node, subtype, usage);\n            }\n            if (types_1.isNever(subtype)) {\n                return types_1.UnknownType.create();\n            }\n            if (types_1.isNone(subtype)) {\n                addDiagnostic(getFileInfo(node).diagnosticRuleSet.reportOptionalSubscript, \"reportOptionalSubscript\" /* reportOptionalSubscript */, localize_1.Localizer.Diagnostic.noneNotSubscriptable(), node.baseExpression);\n                return types_1.UnknownType.create();\n            }\n            if (!types_1.isUnbound(subtype)) {\n                const fileInfo = getFileInfo(node);\n                addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.typeNotSubscriptable().format({ type: printType(subtype) }), node.baseExpression);\n            }\n            return types_1.UnknownType.create();\n        });\n        // In case we didn't walk the list items above, do so now.\n        // If we have, this information will be cached.\n        node.items.items.forEach((item) => {\n            getTypeOfExpression(item, /* expectedType */ undefined, flags & 4 /* AllowForwardReferences */);\n        });\n        return { type, node };\n    }\n    function getTypeFromIndexedObject(node, baseType, usage) {\n        // Handle index operations for TypedDict classes specially.\n        if (types_1.ClassType.isTypedDictClass(baseType.classType)) {\n            if (node.items.items.length !== 1) {\n                addError(localize_1.Localizer.Diagnostic.typeArgsMismatchOne().format({ received: node.items.items.length }), node);\n                return types_1.UnknownType.create();\n            }\n            const entries = getTypedDictMembersForClass(baseType.classType);\n            const indexType = getTypeOfExpression(node.items.items[0]).type;\n            let diag = new diagnostic_1.DiagnosticAddendum();\n            const resultingType = typeUtils_1.doForSubtypes(indexType, (subtype) => {\n                if (types_1.isAnyOrUnknown(subtype)) {\n                    return subtype;\n                }\n                if (types_1.isObject(subtype) && types_1.ClassType.isBuiltIn(subtype.classType, 'str')) {\n                    if (subtype.classType.literalValue === undefined) {\n                        // If it's a plain str with no literal value, we can't\n                        // make any determination about the resulting type.\n                        return types_1.UnknownType.create();\n                    }\n                    // Look up the entry in the typed dict to get its type.\n                    const entryName = subtype.classType.literalValue;\n                    const entry = entries.get(entryName);\n                    if (!entry) {\n                        diag.addMessage(localize_1.Localizer.DiagnosticAddendum.keyUndefined().format({\n                            name: entryName,\n                            type: printType(baseType),\n                        }));\n                        return types_1.UnknownType.create();\n                    }\n                    if (usage.method === 'set') {\n                        canAssignType(entry.valueType, usage.setType, diag);\n                    }\n                    else if (usage.method === 'del' && entry.isRequired) {\n                        const fileInfo = getFileInfo(node);\n                        addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.keyRequiredDeleted().format({ name: entryName }), node);\n                    }\n                    return entry.valueType;\n                }\n                diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeNotStringLiteral().format({ type: printType(subtype) }));\n                return types_1.UnknownType.create();\n            });\n            // If we have an \"expected type\" diagnostic addendum (used for assignments),\n            // use that rather than the local diagnostic information because it will\n            // be more informative.\n            if (usage.setExpectedTypeDiag) {\n                diag = usage.setExpectedTypeDiag;\n            }\n            if (!diag.isEmpty()) {\n                let typedDictDiag;\n                if (usage.method === 'set') {\n                    typedDictDiag = localize_1.Localizer.Diagnostic.typedDictSet();\n                }\n                else if (usage.method === 'del') {\n                    typedDictDiag = localize_1.Localizer.Diagnostic.typedDictDelete();\n                }\n                else {\n                    typedDictDiag = localize_1.Localizer.Diagnostic.typedDictAccess();\n                }\n                const fileInfo = getFileInfo(node);\n                addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, typedDictDiag + diag.getString(), node);\n            }\n            return resultingType;\n        }\n        let magicMethodName;\n        if (usage.method === 'get') {\n            magicMethodName = '__getitem__';\n        }\n        else if (usage.method === 'set') {\n            magicMethodName = '__setitem__';\n        }\n        else {\n            debug_1.assert(usage.method === 'del');\n            magicMethodName = '__delitem__';\n        }\n        const itemMethodType = getTypeFromObjectMember(node, baseType, magicMethodName, { method: 'get' }, new diagnostic_1.DiagnosticAddendum(), 9 /* SkipForMethodLookup */);\n        if (!itemMethodType) {\n            const fileInfo = getFileInfo(node);\n            addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.methodNotDefinedOnType().format({\n                name: magicMethodName,\n                type: printType(baseType),\n            }), node.baseExpression);\n            return types_1.UnknownType.create();\n        }\n        const indexTypeList = node.items.items.map((item) => getTypeOfExpression(item).type);\n        let indexType;\n        if (indexTypeList.length === 1) {\n            indexType = indexTypeList[0];\n            // Handle the special case where the object is a Tuple and\n            // the index is a constant number. In such case, we can determine\n            // the exact type by indexing into the tuple type array.\n            const baseTypeClass = baseType.classType;\n            if (types_1.isClass(baseTypeClass) &&\n                types_1.ClassType.isBuiltIn(baseTypeClass, 'Tuple') &&\n                baseTypeClass.typeArguments &&\n                baseTypeClass.typeArguments.length > 0) {\n                if (node.items.items[0].nodeType === 41 /* Number */ &&\n                    node.items.items[0].isInteger &&\n                    !node.items.items[0].isImaginary) {\n                    const numberNode = node.items.items[0];\n                    if (numberNode.isInteger && numberNode.value >= 0) {\n                        if (baseTypeClass.typeArguments.length === 2 &&\n                            typeUtils_1.isEllipsisType(baseTypeClass.typeArguments[1])) {\n                            return baseTypeClass.typeArguments[0];\n                        }\n                        else if (numberNode.value < baseTypeClass.typeArguments.length) {\n                            return baseTypeClass.typeArguments[numberNode.value];\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            // Handle the case where the index expression is a tuple. This\n            // isn't used in most cases, but it is supported by the language.\n            const builtInTupleType = getBuiltInType(node, 'Tuple');\n            if (types_1.isClass(builtInTupleType)) {\n                indexType = typeUtils_1.convertToInstance(types_1.ClassType.cloneForSpecialization(builtInTupleType, indexTypeList, \n                /* isTypeArgumentExplicit */ false));\n            }\n            else {\n                indexType = types_1.UnknownType.create();\n            }\n        }\n        const argList = [\n            {\n                argumentCategory: 0 /* Simple */,\n                type: indexType,\n            },\n        ];\n        if (usage.method === 'set') {\n            argList.push({\n                argumentCategory: 0 /* Simple */,\n                type: usage.setType || types_1.AnyType.create(),\n            });\n        }\n        const callResult = validateCallArguments(node, argList, itemMethodType, new typeVarMap_1.TypeVarMap(), \n        /* skipUnknownArgCheck */ false, \n        /* inferReturnTypeIfNeeded */ true, \n        /* expectedType */ undefined);\n        return callResult.returnType || types_1.UnknownType.create();\n    }\n    function getTypeArgs(node, flags, isAnnotatedClass = false) {\n        const typeArgs = [];\n        const adjFlags = flags & ~128 /* ParamSpecDisallowed */;\n        node.items.forEach((expr, index) => {\n            // If it's an Annotated[a, b, c], only the first index should be treated\n            // as a type. The others can be regular (non-type) objects.\n            if (isAnnotatedClass && index > 0) {\n                typeArgs.push(getTypeOfExpression(expr, \n                /* expectedType */ undefined, 128 /* ParamSpecDisallowed */ | 2 /* DoNotSpecialize */));\n            }\n            else {\n                typeArgs.push(getTypeArg(expr, adjFlags));\n            }\n        });\n        return typeArgs;\n    }\n    function getTypeArg(node, flags) {\n        let typeResult;\n        let adjustedFlags = flags |\n            256 /* ExpectingType */ |\n            1 /* ConvertEllipsisToAny */ |\n            32 /* EvaluateStringLiteralAsType */ |\n            64 /* FinalDisallowed */;\n        const fileInfo = getFileInfo(node);\n        if (isAnnotationEvaluationPostponed(fileInfo)) {\n            adjustedFlags |= 4 /* AllowForwardReferences */;\n        }\n        if (node.nodeType === 32 /* List */) {\n            typeResult = {\n                type: types_1.UnknownType.create(),\n                typeList: node.entries.map((entry) => getTypeOfExpression(entry, undefined, adjustedFlags)),\n                node,\n            };\n        }\n        else {\n            typeResult = getTypeOfExpression(node, /* expectedType */ undefined, adjustedFlags);\n        }\n        return typeResult;\n    }\n    function getTypeFromTuple(node, expectedType) {\n        // Build an array of expected types.\n        const expectedTypes = [];\n        if (expectedType && types_1.isObject(expectedType)) {\n            const tupleClass = expectedType.classType;\n            if (types_1.ClassType.isBuiltIn(tupleClass, 'Tuple') && tupleClass.typeArguments) {\n                // Is this a homogeneous tuple of indeterminate length? If so,\n                // match the number of expected types to the number of entries\n                // in the tuple expression.\n                if (tupleClass.typeArguments.length === 2 && typeUtils_1.isEllipsisType(tupleClass.typeArguments[1])) {\n                    for (let i = 0; i < node.expressions.length; i++) {\n                        expectedTypes.push(tupleClass.typeArguments[0]);\n                    }\n                }\n                else {\n                    tupleClass.typeArguments.forEach((typeArg) => {\n                        expectedTypes.push(typeArg);\n                    });\n                }\n            }\n        }\n        const entryTypeResults = node.expressions.map((expr, index) => getTypeOfExpression(expr, index < expectedTypes.length ? expectedTypes[index] : undefined));\n        let type = types_1.UnknownType.create();\n        const builtInTupleType = getBuiltInType(node, 'Tuple');\n        if (types_1.isClass(builtInTupleType)) {\n            let tupleTypes = [];\n            for (const typeResult of entryTypeResults) {\n                if (typeResult.unpackedType) {\n                    // Is this an unpacked tuple? If so, we can append the individual\n                    // unpacked entries onto the new tuple. If it's not an upacked tuple\n                    // but some other iterator (e.g. a List), we won't know the number of\n                    // items, so we'll need to leave the Tuple open-ended.\n                    if (types_1.isObject(typeResult.unpackedType) &&\n                        types_1.ClassType.isBuiltIn(typeResult.unpackedType.classType, 'Tuple')) {\n                        const typeArgs = typeResult.unpackedType.classType.typeArguments;\n                        // If the Tuple wasn't specialized or has a \"...\" type parameter, we can't\n                        // make any determination about its contents.\n                        if (!typeArgs || typeArgs.some((t) => typeUtils_1.isEllipsisType(t))) {\n                            tupleTypes = [types_1.AnyType.create(false), types_1.AnyType.create(true)];\n                            break;\n                        }\n                        for (const typeArg of typeArgs) {\n                            tupleTypes.push(typeArg);\n                        }\n                    }\n                    else {\n                        tupleTypes = [types_1.AnyType.create(false), types_1.AnyType.create(true)];\n                        break;\n                    }\n                }\n                else {\n                    tupleTypes.push(typeResult.type);\n                }\n            }\n            type = typeUtils_1.convertToInstance(types_1.ClassType.cloneForSpecialization(builtInTupleType, tupleTypes, /* isTypeArgumentExplicit */ false));\n        }\n        return { type, node };\n    }\n    function getTypeFromCall(node, expectedType, flags) {\n        const baseTypeResult = getTypeOfExpression(node.leftExpression, undefined, 2 /* DoNotSpecialize */);\n        // Handle the built-in \"super\" call specially.\n        if (node.leftExpression.nodeType === 39 /* Name */ && node.leftExpression.value === 'super') {\n            return {\n                type: getTypeFromSuperCall(node),\n                node,\n            };\n        }\n        // Handle the special-case \"reveal_type\" call.\n        if (types_1.isAnyOrUnknown(baseTypeResult.type) &&\n            node.leftExpression.nodeType === 39 /* Name */ &&\n            node.leftExpression.value === 'reveal_type' &&\n            node.arguments.length === 1 &&\n            node.arguments[0].argumentCategory === 0 /* Simple */ &&\n            node.arguments[0].name === undefined) {\n            const type = getTypeOfExpression(node.arguments[0].valueExpression).type;\n            const exprString = ParseTreeUtils.printExpression(node.arguments[0].valueExpression);\n            addWarning(`Type of \"${exprString}\" is \"${printType(type)}\"`, node.arguments[0]);\n            return { type: types_1.AnyType.create(), node };\n        }\n        const argList = node.arguments.map((arg) => {\n            const functionArg = {\n                valueExpression: arg.valueExpression,\n                argumentCategory: arg.argumentCategory,\n                name: arg.name,\n            };\n            return functionArg;\n        });\n        return getTypeFromCallWithBaseType(node, argList, baseTypeResult, expectedType, flags & ~2 /* DoNotSpecialize */);\n    }\n    function getTypeFromSuperCall(node) {\n        if (node.arguments.length > 2) {\n            addError(localize_1.Localizer.Diagnostic.superCallArgCount(), node.arguments[2]);\n        }\n        // Determine which class the \"super\" call is applied to. If\n        // there is no first argument, then the class is implicit.\n        let targetClassType;\n        if (node.arguments.length > 0) {\n            targetClassType = getTypeOfExpression(node.arguments[0].valueExpression).type;\n            if (!types_1.isAnyOrUnknown(targetClassType) && !types_1.isClass(targetClassType)) {\n                addError(localize_1.Localizer.Diagnostic.superCallFirstArg().format({ type: printType(targetClassType) }), node.arguments[0].valueExpression);\n            }\n        }\n        else {\n            const enclosingClass = ParseTreeUtils.getEnclosingClass(node);\n            if (enclosingClass) {\n                const classTypeInfo = getTypeOfClass(enclosingClass);\n                targetClassType = classTypeInfo ? classTypeInfo.classType : types_1.UnknownType.create();\n            }\n            else {\n                addError(localize_1.Localizer.Diagnostic.superCallZeroArgForm(), node.leftExpression);\n                targetClassType = types_1.UnknownType.create();\n            }\n        }\n        // Determine whether there is a further constraint.\n        let constrainedClassType;\n        if (node.arguments.length > 1) {\n            constrainedClassType = typeUtils_1.specializeType(getTypeOfExpression(node.arguments[1].valueExpression).type, \n            /* typeVarMap */ undefined);\n            let reportError = false;\n            if (types_1.isAnyOrUnknown(constrainedClassType)) {\n                // Ignore unknown or any types.\n            }\n            else if (types_1.isObject(constrainedClassType)) {\n                const childClassType = constrainedClassType.classType;\n                if (types_1.isClass(targetClassType)) {\n                    if (!typeUtils_1.derivesFromClassRecursive(childClassType, targetClassType, /* ignoreUnknown */ true)) {\n                        reportError = true;\n                    }\n                }\n            }\n            else if (types_1.isClass(constrainedClassType)) {\n                if (types_1.isClass(targetClassType)) {\n                    if (!typeUtils_1.derivesFromClassRecursive(constrainedClassType, targetClassType, /* ignoreUnknown */ true)) {\n                        reportError = true;\n                    }\n                }\n            }\n            else {\n                reportError = true;\n            }\n            if (reportError) {\n                const fileInfo = getFileInfo(node);\n                addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.superCallSecondArg().format({ type: printType(targetClassType) }), node.arguments[1].valueExpression);\n            }\n        }\n        // Python docs indicate that super() isn't valid for\n        // operations other than member accesses or attribute lookups.\n        const parentNode = node.parent;\n        if (parentNode.nodeType === 36 /* MemberAccess */) {\n            const memberName = parentNode.memberName.value;\n            const lookupResults = typeUtils_1.lookUpClassMember(targetClassType, memberName, 1 /* SkipOriginalClass */);\n            if (lookupResults && types_1.isClass(lookupResults.classType)) {\n                return types_1.ObjectType.create(lookupResults.classType);\n            }\n        }\n        // If the lookup failed, try to return the first base class. An error\n        // will be reported by the member lookup logic at a later time.\n        if (types_1.isClass(targetClassType)) {\n            const baseClasses = targetClassType.details.baseClasses;\n            if (baseClasses.length > 0) {\n                const baseClassType = baseClasses[0];\n                if (types_1.isClass(baseClassType)) {\n                    return types_1.ObjectType.create(baseClassType);\n                }\n            }\n        }\n        return types_1.UnknownType.create();\n    }\n    function getTypeFromCallWithBaseType(errorNode, argList, baseTypeResult, expectedType, flags) {\n        let type;\n        const callType = typeUtils_1.makeTypeVarsConcrete(baseTypeResult.type);\n        const skipUnknownArgCheck = (flags & 16 /* DoNotCheckForUnknownArgs */) !== 0;\n        switch (callType.category) {\n            case 7 /* Class */: {\n                if (types_1.ClassType.isBuiltIn(callType)) {\n                    const className = callType.details.name;\n                    if (className === 'type') {\n                        // Handle the 'type' call specially.\n                        if (argList.length === 1) {\n                            // The one-parameter form of \"type\" returns the class\n                            // for the specified object.\n                            const argType = getTypeForArgument(argList[0]);\n                            if (types_1.isObject(argType)) {\n                                type = argType.classType;\n                            }\n                            else if (argType.category === 3 /* None */) {\n                                type = types_1.NoneType.createType();\n                            }\n                        }\n                        else if (argList.length >= 2) {\n                            // The two-parameter form of \"type\" returns a new class type\n                            // built from the specified base types.\n                            type = createType(errorNode, argList);\n                        }\n                        // If the parameter to type() is not statically known,\n                        // fall back to Any.\n                        if (!type) {\n                            type = types_1.AnyType.create();\n                        }\n                    }\n                    else if (className === 'TypeVar') {\n                        type = createTypeVarType(errorNode, argList, /* isParamSpec */ false);\n                    }\n                    else if (className === 'ParamSpec') {\n                        type = createTypeVarType(errorNode, argList, /* isParamSpec */ true);\n                    }\n                    else if (className === 'NamedTuple') {\n                        type = createNamedTupleType(errorNode, argList, true);\n                    }\n                    else if (className === 'Protocol' ||\n                        className === 'Generic' ||\n                        className === 'Callable' ||\n                        className === 'Type') {\n                        const fileInfo = getFileInfo(errorNode);\n                        addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.typeNotIntantiable().format({ type: className }), errorNode);\n                    }\n                    else if (className === 'Enum' ||\n                        className === 'IntEnum' ||\n                        className === 'Flag' ||\n                        className === 'IntFlag') {\n                        type = createEnumType(errorNode, callType, argList);\n                    }\n                    else if (className === 'TypedDict') {\n                        type = createTypedDictType(errorNode, callType, argList);\n                    }\n                    else if (className === 'auto' && argList.length === 0) {\n                        type = getBuiltInObject(errorNode, 'int');\n                    }\n                }\n                else if (types_1.isClass(baseTypeResult.type) && types_1.ClassType.hasAbstractMethods(callType)) {\n                    // If the class is abstract, it can't be instantiated.\n                    const abstractMethods = getAbstractMethods(callType);\n                    const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n                    const errorsToDisplay = 2;\n                    abstractMethods.forEach((abstractMethod, index) => {\n                        if (index === errorsToDisplay) {\n                            diagAddendum.addMessage(localize_1.Localizer.DiagnosticAddendum.memberIsAbstractMore().format({\n                                count: abstractMethods.length - errorsToDisplay,\n                            }));\n                        }\n                        else if (index < errorsToDisplay) {\n                            if (types_1.isClass(abstractMethod.classType)) {\n                                const className = abstractMethod.classType.details.name;\n                                diagAddendum.addMessage(localize_1.Localizer.DiagnosticAddendum.memberIsAbstract().format({\n                                    type: className,\n                                    name: abstractMethod.symbolName,\n                                }));\n                            }\n                        }\n                    });\n                    const fileInfo = getFileInfo(errorNode);\n                    addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.typeAbstract().format({ type: callType.details.name }) +\n                        diagAddendum.getString(), errorNode);\n                }\n                // Assume this is a call to the constructor.\n                if (!type) {\n                    type = validateConstructorArguments(errorNode, argList, callType, skipUnknownArgCheck, expectedType)\n                        .returnType;\n                }\n                break;\n            }\n            case 5 /* Function */: {\n                // The stdlib collections/__init__.pyi stub file defines namedtuple\n                // as a function rather than a class, so we need to check for it here.\n                if (callType.details.builtInName === 'namedtuple') {\n                    addDiagnostic(getFileInfo(errorNode).diagnosticRuleSet.reportUntypedNamedTuple, \"reportUntypedNamedTuple\" /* reportUntypedNamedTuple */, localize_1.Localizer.Diagnostic.namedTupleNoTypes(), errorNode);\n                    type = createNamedTupleType(errorNode, argList, false);\n                }\n                else if (callType.details.builtInName === 'NewType') {\n                    const callResult = validateCallArguments(errorNode, argList, callType, new typeVarMap_1.TypeVarMap(), skipUnknownArgCheck, \n                    /* inferReturnTypeIfNeeded */ true, expectedType);\n                    // If the call's arguments were validated, replace the\n                    // type with a new synthesized subclass.\n                    type = callResult.argumentErrors ? callResult.returnType : createNewType(errorNode, argList);\n                }\n                else {\n                    type = validateCallArguments(errorNode, argList, callType, new typeVarMap_1.TypeVarMap(), skipUnknownArgCheck, \n                    /* inferReturnTypeIfNeeded */ true, expectedType).returnType;\n                    if (callType.details.builtInName === '__import__') {\n                        // For the special __import__ type, we'll override the return type to be \"Any\".\n                        // This is required because we don't know what module was imported, and we don't\n                        // want to fail type checks when accessing members of the resulting module type.\n                        type = types_1.AnyType.create();\n                    }\n                }\n                if (!type) {\n                    type = types_1.UnknownType.create();\n                }\n                break;\n            }\n            case 6 /* OverloadedFunction */: {\n                // Determine which of the overloads (if any) match.\n                const functionType = findOverloadedFunctionType(errorNode, argList, callType, expectedType);\n                if (functionType) {\n                    if (functionType.details.builtInName === 'cast' && argList.length === 2) {\n                        // Verify that the cast is necessary.\n                        const castToType = getTypeForArgumentExpectingType(argList[0], getFileInfo(errorNode));\n                        const castFromType = getTypeForArgument(argList[1]);\n                        if (types_1.isClass(castToType) && types_1.isObject(castFromType)) {\n                            if (types_1.isTypeSame(castToType, castFromType.classType)) {\n                                addDiagnostic(getFileInfo(errorNode).diagnosticRuleSet.reportUnnecessaryCast, \"reportUnnecessaryCast\" /* reportUnnecessaryCast */, localize_1.Localizer.Diagnostic.unnecessaryCast().format({ type: printType(castFromType) }), errorNode);\n                            }\n                        }\n                        type = typeUtils_1.convertToInstance(castToType);\n                    }\n                    else {\n                        // If this is a stub file, analyze the first argument using the\n                        // \"expecting type\" semantics. This will cache the type for later. Some\n                        // type stubs rely on using forward declarations for this parameter.\n                        if (argList.length > 0) {\n                            const fileInfo = getFileInfo(errorNode);\n                            if (fileInfo.isStubFile) {\n                                getTypeForArgumentExpectingType(argList[0], fileInfo);\n                            }\n                        }\n                        type = validateCallArguments(errorNode, argList, functionType, new typeVarMap_1.TypeVarMap(), skipUnknownArgCheck, \n                        /* inferReturnTypeIfNeeded */ true, expectedType).returnType;\n                        if (!type) {\n                            type = types_1.UnknownType.create();\n                        }\n                    }\n                }\n                else {\n                    const exprString = ParseTreeUtils.printExpression(errorNode);\n                    const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n                    const argTypes = argList.map((t) => printType(getTypeForArgument(t)));\n                    if (errorNode.nodeType !== 9 /* Call */ && callType.overloads[0].details.name) {\n                        // If the expression isn't an explicit call, it is probably an implicit\n                        // call to a magic method. Provide additional information in this case\n                        // to make it clear that a call was being evaluated.\n                        diagAddendum.addMessage(localize_1.Localizer.DiagnosticAddendum.overloadCallName().format({\n                            name: callType.overloads[0].details.name,\n                        }));\n                    }\n                    diagAddendum.addMessage(localize_1.Localizer.DiagnosticAddendum.argumentTypes().format({ types: argTypes.join(', ') }));\n                    const fileInfo = getFileInfo(errorNode);\n                    addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.noOverload().format({ expression: exprString }) + diagAddendum.getString(), errorNode);\n                    type = types_1.UnknownType.create();\n                }\n                break;\n            }\n            case 8 /* Object */: {\n                // Handle the \"Type\" object specially.\n                const classFromTypeObject = getClassFromPotentialTypeObject(callType);\n                if (classFromTypeObject) {\n                    if (types_1.isAnyOrUnknown(classFromTypeObject)) {\n                        type = classFromTypeObject;\n                    }\n                    else if (types_1.isClass(classFromTypeObject)) {\n                        type = validateConstructorArguments(errorNode, argList, classFromTypeObject, skipUnknownArgCheck, expectedType).returnType;\n                    }\n                }\n                else {\n                    const memberType = getTypeFromObjectMember(errorNode, callType, '__call__', { method: 'get' }, new diagnostic_1.DiagnosticAddendum(), 9 /* SkipForMethodLookup */);\n                    if (memberType) {\n                        type = validateCallArguments(errorNode, argList, memberType, new typeVarMap_1.TypeVarMap(), skipUnknownArgCheck, \n                        /* inferReturnTypeIfNeeded */ true, expectedType).returnType;\n                        if (!type) {\n                            type = types_1.UnknownType.create();\n                        }\n                    }\n                }\n                break;\n            }\n            case 10 /* Union */: {\n                const returnTypes = [];\n                callType.subtypes.forEach((typeEntry) => {\n                    if (types_1.isNone(typeEntry)) {\n                        addDiagnostic(getFileInfo(errorNode).diagnosticRuleSet.reportOptionalCall, \"reportOptionalCall\" /* reportOptionalCall */, localize_1.Localizer.Diagnostic.noneNotCallable(), errorNode);\n                    }\n                    else {\n                        const typeResult = getTypeFromCallWithBaseType(errorNode, argList, {\n                            type: typeEntry,\n                            node: baseTypeResult.node,\n                        }, expectedType, flags);\n                        if (typeResult) {\n                            returnTypes.push(typeResult.type);\n                        }\n                    }\n                });\n                if (returnTypes.length > 0) {\n                    type = types_1.combineTypes(returnTypes);\n                }\n                break;\n            }\n            case 2 /* Any */:\n            case 1 /* Unknown */: {\n                // Mark the arguments accessed.\n                argList.forEach((arg) => getTypeForArgument(arg));\n                type = callType;\n                break;\n            }\n        }\n        if (!type) {\n            const fileInfo = getFileInfo(errorNode);\n            addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.typeNotCallable().format({\n                expression: ParseTreeUtils.printExpression(errorNode),\n                type: printType(callType),\n            }), errorNode);\n            type = types_1.UnknownType.create();\n            // Evaluate the arguments to generate errors and mark\n            // symbols as referenced.\n            argList.forEach((arg) => {\n                if (!arg.type && arg.valueExpression) {\n                    getTypeOfExpression(arg.valueExpression);\n                }\n            });\n        }\n        // Should we specialize the class?\n        if ((flags & 2 /* DoNotSpecialize */) === 0) {\n            if (types_1.isClass(type)) {\n                type = createSpecializedClassType(type, undefined, flags, errorNode);\n            }\n        }\n        return { type, node: baseTypeResult.node };\n    }\n    function findOverloadedFunctionType(errorNode, argList, callType, expectedType) {\n        let validOverload;\n        for (const overload of callType.overloads) {\n            // Only iterate through the functions that have the @overload\n            // decorator, not the final function that omits the overload.\n            // This is the intended behavior according to PEP 484.\n            if (types_1.FunctionType.isOverloaded(overload)) {\n                // Temporarily disable diagnostic output.\n                useSpeculativeMode(errorNode, () => {\n                    const callResult = validateCallArguments(errorNode, argList, overload, new typeVarMap_1.TypeVarMap(), \n                    /* skipUnknownArgCheck */ true, \n                    /* inferReturnTypeIfNeeded */ false, expectedType);\n                    if (!callResult.argumentErrors) {\n                        validOverload = overload;\n                    }\n                });\n                if (validOverload) {\n                    break;\n                }\n            }\n        }\n        return validOverload;\n    }\n    // Tries to match the arguments of a call to the constructor for a class.\n    // If successful, it returns the resulting (specialized) object type that\n    // is allocated by the constructor. If unsuccessful, it records diagnostic\n    // information and returns undefined.\n    function validateConstructorArguments(errorNode, argList, type, skipUnknownArgCheck, expectedType) {\n        let validatedTypes = false;\n        let returnType;\n        let reportedErrors = false;\n        // Create a helper function that determines whether we should skip argument\n        // validation for either __init__ or __new__. This is required for certain\n        // synthesized constructor types, namely NamedTuples.\n        const skipConstructorCheck = (type) => {\n            if (type.category !== 5 /* Function */) {\n                return false;\n            }\n            return types_1.FunctionType.isSkipConstructorCheck(type);\n        };\n        // Validate __init__\n        // We validate __init__ before __new__ because the former typically has\n        // more specific type annotations, and we want to evaluate the arguments\n        // in the context of these types. The __new__ method often uses generic\n        // vargs and kwargs.\n        const initMethodType = getTypeFromObjectMember(errorNode, types_1.ObjectType.create(type), '__init__', { method: 'get' }, new diagnostic_1.DiagnosticAddendum(), 9 /* SkipForMethodLookup */ | 4 /* SkipObjectBaseClass */);\n        if (initMethodType && !skipConstructorCheck(initMethodType)) {\n            const typeVarMap = new typeVarMap_1.TypeVarMap();\n            if (expectedType) {\n                populateTypeVarMapBasedOnExpectedType(types_1.ObjectType.create(type), expectedType, typeVarMap);\n            }\n            const callResult = validateCallArguments(errorNode, argList, initMethodType, typeVarMap, skipUnknownArgCheck, \n            /* inferReturnTypeIfNeeded */ true, types_1.NoneType.createInstance());\n            if (!callResult.argumentErrors) {\n                const specializedClassType = applyExpectedTypeForConstructor(typeUtils_1.specializeType(type, typeVarMap, /* makeConcrete */ true), expectedType);\n                returnType = types_1.ObjectType.create(specializedClassType);\n            }\n            else {\n                reportedErrors = true;\n            }\n            validatedTypes = true;\n            skipUnknownArgCheck = true;\n        }\n        // Validate __new__\n        // Don't report errors for __new__ if __init__ already generated errors. They're\n        // probably going to be entirely redundant anyway.\n        if (!reportedErrors) {\n            const constructorMethodInfo = getTypeFromClassMemberName(errorNode, type, '__new__', { method: 'get' }, new diagnostic_1.DiagnosticAddendum(), 9 /* SkipForMethodLookup */ | 4 /* SkipObjectBaseClass */);\n            if (constructorMethodInfo && !skipConstructorCheck(constructorMethodInfo.type)) {\n                const constructorMethodType = bindFunctionToClassOrObject(type, constructorMethodInfo.type, \n                /* treatAsClassMember */ true);\n                const typeVarMap = new typeVarMap_1.TypeVarMap();\n                // Skip the unknown argument check if we've already checked for __init__.\n                const callResult = validateCallArguments(errorNode, argList, constructorMethodType, typeVarMap, skipUnknownArgCheck, \n                /* inferReturnTypeIfNeeded */ true, expectedType);\n                if (callResult.argumentErrors) {\n                    reportedErrors = true;\n                }\n                else {\n                    const newReturnType = callResult.returnType;\n                    // If the constructor returned an object whose type matches the class of\n                    // the original type being constructed, use the return type in case it was\n                    // specialized.If it doesn't match, we'll fall back on the assumption that\n                    // the constructed type is an instance of the class type. We need to do this\n                    // in cases where we're inferring the return type based on a call to\n                    // super().__new__().\n                    if (newReturnType) {\n                        if (types_1.isObject(newReturnType) && types_1.ClassType.isSameGenericClass(newReturnType.classType, type)) {\n                            // If the specialized return type derived from the __init__\n                            // method is \"better\" than the return type provided by the\n                            // __new__ method (where \"better\" means that the type arguments\n                            // are all known), stick with the __init__ result.\n                            if ((!typeUtils_1.isPartlyUnknown(newReturnType) && !typeUtils_1.requiresSpecialization(newReturnType)) ||\n                                returnType === undefined) {\n                                returnType = newReturnType;\n                            }\n                        }\n                    }\n                }\n                if (!returnType) {\n                    const specializedClassType = applyExpectedTypeForConstructor(typeUtils_1.specializeType(type, typeVarMap, /* makeConcrete */ true), expectedType);\n                    returnType = types_1.ObjectType.create(specializedClassType);\n                }\n                validatedTypes = true;\n            }\n        }\n        // If we weren't able to validate the args, analyze the expressions\n        // here to mark symbols as referenced and report expression-level errors.\n        if (!validatedTypes) {\n            argList.forEach((arg) => {\n                if (arg.valueExpression) {\n                    getTypeOfExpression(arg.valueExpression);\n                }\n            });\n        }\n        if (!validatedTypes && argList.length > 0) {\n            const fileInfo = getFileInfo(errorNode);\n            addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.constructorNoArgs().format({ type: type.details.name }), errorNode);\n        }\n        else if (!returnType) {\n            // There was no __new__ or __init__, so fall back on the\n            // object.__new__ which takes no parameters.\n            const specializedClassType = applyExpectedTypeForConstructor(type, expectedType);\n            returnType = types_1.ObjectType.create(specializedClassType);\n        }\n        return { argumentErrors: reportedErrors, returnType };\n    }\n    function applyExpectedTypeForConstructor(type, expectedType) {\n        if (!expectedType) {\n            return type;\n        }\n        // It's common for the expected type to contain a None. Strip\n        // this out because we're trying to match the non-optional part.\n        const expectedTypeWithoutNone = types_1.removeNoneFromUnion(expectedType);\n        if (!types_1.isObject(expectedTypeWithoutNone)) {\n            return type;\n        }\n        const expectedClass = expectedTypeWithoutNone.classType;\n        const typeVarMap = new typeVarMap_1.TypeVarMap();\n        if (canAssignType(expectedClass, type, new diagnostic_1.DiagnosticAddendum(), typeVarMap)) {\n            return typeUtils_1.specializeType(expectedClass, typeVarMap);\n        }\n        // If it's the same generic class, see if we can assign the type arguments\n        // without the variance rules that canAssignType uses.\n        if (types_1.ClassType.isSameGenericClass(type, expectedClass) &&\n            expectedClass.typeArguments &&\n            type.typeArguments &&\n            !type.isTypeArgumentExplicit &&\n            expectedClass.typeArguments.length === type.typeArguments.length) {\n            let isAssignable = true;\n            expectedClass.typeArguments.forEach((expectedTypeArg, index) => {\n                const typeTypeArg = type.typeArguments[index];\n                if (!canAssignType(expectedTypeArg, typeTypeArg, new diagnostic_1.DiagnosticAddendum(), typeVarMap)) {\n                    isAssignable = false;\n                }\n            });\n            if (isAssignable) {\n                return typeUtils_1.specializeType(expectedClass, typeVarMap);\n            }\n        }\n        return type;\n    }\n    // In cases where the expected type is a specialized base class of the\n    // source type, we need to determine which type arguments in the derived\n    // class will make it compatible with the specialized base class. This method\n    // performs this reverse mapping of type arguments and populates the type var\n    // map for the target type.\n    function populateTypeVarMapBasedOnExpectedType(type, expectedType, typeVarMap) {\n        // It's common for the expected type to be Optional. Remove the None\n        // to see if the resulting type is an object.\n        const expectedTypeWithoutNone = types_1.removeNoneFromUnion(expectedType);\n        // If the resulting type isn't an object, we can't proceed.\n        if (!types_1.isObject(expectedTypeWithoutNone)) {\n            return;\n        }\n        // If the target type isn't generic, there's nothing for us to do.\n        if (!typeUtils_1.requiresSpecialization(type)) {\n            return;\n        }\n        // If the expected type is generic (not specialized), we can't proceed.\n        const expectedTypeArgs = expectedTypeWithoutNone.classType.typeArguments;\n        if (expectedTypeArgs === undefined) {\n            return;\n        }\n        // If the expected type is the same as the target type (commonly the case),\n        // we can use a faster method.\n        if (types_1.ClassType.isSameGenericClass(expectedTypeWithoutNone.classType, type.classType)) {\n            canAssignType(type, expectedTypeWithoutNone, new diagnostic_1.DiagnosticAddendum(), typeVarMap);\n            return;\n        }\n        // Create a generic (not specialized) version of the expected type.\n        const genericExpectedType = types_1.ClassType.cloneForSpecialization(expectedTypeWithoutNone.classType, undefined, \n        /* isTypeArgumentExplicit */ false);\n        // For each type param in the target type, create a placeholder type variable.\n        const typeArgs = type.classType.details.typeParameters.map((_, index) => {\n            const typeVar = types_1.TypeVarType.createInstance(`__${index}`, /* isParamSpec */ false, /* isSynthesized */ true);\n            typeVar.synthesizedIndex = index;\n            return typeVar;\n        });\n        const specializedType = types_1.ClassType.cloneForSpecialization(type.classType, typeArgs, \n        /* isTypeArgumentExplicit */ true);\n        const syntheticTypeVarMap = new typeVarMap_1.TypeVarMap();\n        if (canAssignType(genericExpectedType, specializedType, new diagnostic_1.DiagnosticAddendum(), syntheticTypeVarMap)) {\n            genericExpectedType.details.typeParameters.forEach((typeVar, index) => {\n                const synthTypeVar = syntheticTypeVarMap.getTypeVar(typeVar.name);\n                // Is this one of the synthesized type vars we allocated above? If so,\n                // the type arg that corresponds to this type var maps back to the target type.\n                if (synthTypeVar &&\n                    types_1.isTypeVar(synthTypeVar) &&\n                    synthTypeVar.isSynthesized &&\n                    synthTypeVar.synthesizedIndex !== undefined) {\n                    const targetTypeVar = specializedType.details.typeParameters[synthTypeVar.synthesizedIndex];\n                    if (index < expectedTypeArgs.length) {\n                        typeVarMap.setTypeVar(targetTypeVar.name, expectedTypeArgs[index], /* isNarrowable */ false);\n                    }\n                }\n            });\n        }\n    }\n    // Validates that the arguments can be assigned to the call's parameter\n    // list, specializes the call based on arg types, and returns the\n    // specialized type of the return value. If it detects an error along\n    // the way, it emits a diagnostic and returns undefined.\n    function validateCallArguments(errorNode, argList, callType, typeVarMap, skipUnknownArgCheck, inferReturnTypeIfNeeded = true, expectedType) {\n        let callResult = { argumentErrors: false };\n        switch (callType.category) {\n            case 1 /* Unknown */:\n            case 2 /* Any */: {\n                // Touch all of the args so they're marked accessed.\n                argList.forEach((arg) => getTypeForArgument(arg));\n                callResult.returnType = callType;\n                break;\n            }\n            case 5 /* Function */: {\n                callResult = validateFunctionArguments(errorNode, argList, callType, typeVarMap, skipUnknownArgCheck, inferReturnTypeIfNeeded, expectedType);\n                break;\n            }\n            case 6 /* OverloadedFunction */: {\n                const overloadedFunctionType = findOverloadedFunctionType(errorNode, argList, callType, expectedType);\n                if (overloadedFunctionType) {\n                    callResult = validateFunctionArguments(errorNode, argList, overloadedFunctionType, typeVarMap, skipUnknownArgCheck, inferReturnTypeIfNeeded, expectedType);\n                }\n                else {\n                    const exprString = ParseTreeUtils.printExpression(errorNode);\n                    const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n                    const argTypes = argList.map((t) => printType(getTypeForArgument(t)));\n                    if (errorNode.nodeType !== 9 /* Call */ && callType.overloads[0].details.name) {\n                        // If the expression isn't an explicit call, it is probably an implicit\n                        // call to a magic method. Provide additional information in this case\n                        // to make it clear that a call was being evaluated.\n                        diagAddendum.addMessage(localize_1.Localizer.DiagnosticAddendum.overloadCallName().format({\n                            name: callType.overloads[0].details.name,\n                        }));\n                    }\n                    diagAddendum.addMessage(localize_1.Localizer.DiagnosticAddendum.argumentTypes().format({ types: argTypes.join(', ') }));\n                    const fileInfo = getFileInfo(errorNode);\n                    addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.noOverload().format({ expression: exprString }) + diagAddendum.getString(), errorNode);\n                }\n                break;\n            }\n            case 7 /* Class */: {\n                if (!types_1.ClassType.isSpecialBuiltIn(callType)) {\n                    callResult = validateConstructorArguments(errorNode, argList, callType, skipUnknownArgCheck, expectedType);\n                }\n                else {\n                    const fileInfo = getFileInfo(errorNode);\n                    addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.typeNotIntantiable().format({ type: callType.details.name }), errorNode);\n                }\n                break;\n            }\n            case 8 /* Object */: {\n                const memberType = getTypeFromObjectMember(errorNode, callType, '__call__', { method: 'get' }, new diagnostic_1.DiagnosticAddendum(), 9 /* SkipForMethodLookup */);\n                if (memberType && memberType.category === 5 /* Function */) {\n                    const callMethodType = typeUtils_1.stripFirstParameter(memberType);\n                    callResult = validateCallArguments(errorNode, argList, callMethodType, typeVarMap, skipUnknownArgCheck, inferReturnTypeIfNeeded, expectedType);\n                }\n                else {\n                    const fileInfo = getFileInfo(errorNode);\n                    addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.objectNotCallable().format({ type: printType(callType) }), errorNode);\n                }\n                break;\n            }\n            case 10 /* Union */: {\n                const returnTypes = [];\n                for (const type of callType.subtypes) {\n                    if (types_1.isNone(type)) {\n                        addDiagnostic(getFileInfo(errorNode).diagnosticRuleSet.reportOptionalCall, \"reportOptionalCall\" /* reportOptionalCall */, localize_1.Localizer.Diagnostic.noneNotCallable(), errorNode);\n                    }\n                    else {\n                        const subtypeCallResult = validateCallArguments(errorNode, argList, type, typeVarMap, skipUnknownArgCheck, inferReturnTypeIfNeeded, expectedType);\n                        if (subtypeCallResult.returnType) {\n                            returnTypes.push(subtypeCallResult.returnType);\n                        }\n                    }\n                }\n                if (returnTypes.length > 0) {\n                    callResult.returnType = types_1.combineTypes(returnTypes);\n                }\n                break;\n            }\n        }\n        if (!callResult.returnType) {\n            // Touch all of the args so they're marked accessed.\n            argList.forEach((arg) => getTypeForArgument(arg));\n        }\n        return callResult;\n    }\n    // Tries to assign the call arguments to the function parameter\n    // list and reports any mismatches in types or counts. Returns the\n    // specialized return type of the call.\n    // This logic is based on PEP 3102: https://www.python.org/dev/peps/pep-3102/\n    function validateFunctionArguments(errorNode, argList, type, typeVarMap, skipUnknownArgCheck, inferReturnTypeIfNeeded = true, expectedType) {\n        let argIndex = 0;\n        const typeParams = type.details.parameters;\n        if (expectedType && !typeUtils_1.requiresSpecialization(expectedType) && type.details.declaredReturnType) {\n            // Prepopulate the typeVarMap based on the specialized expected type if the callee has a declared\n            // return type. This will allow us to more closely match the expected type if possible.\n            canAssignType(type.details.declaredReturnType, expectedType, new diagnostic_1.DiagnosticAddendum(), typeVarMap);\n        }\n        // The last parameter might be a var arg dictionary. If so, strip it off.\n        const varArgDictParam = typeParams.find((param) => param.category === 2 /* VarArgDictionary */);\n        let reportedArgError = false;\n        // Build a map of parameters by name.\n        const paramMap = new Map();\n        typeParams.forEach((param) => {\n            if (param.name) {\n                paramMap.set(param.name, {\n                    argsNeeded: param.category === 0 /* Simple */ && !param.hasDefault ? 1 : 0,\n                    argsReceived: 0,\n                });\n            }\n        });\n        // Is there a bare (nameless) \"*\" parameter? If so, it signifies the end\n        // of the positional parameter list.\n        let positionalParamCount = typeParams.findIndex((param) => param.category === 1 /* VarArgList */ && !param.name);\n        // Is there a positional-only \"/\" parameter? If so, it separates the\n        // positional-only from positional or keyword parameters.\n        const positionalOnlyIndex = typeParams.findIndex((param) => param.category === 0 /* Simple */ && !param.name);\n        // Is there a var-arg (named \"*\") parameter? If so, it is the last of\n        // the positional parameters.\n        if (positionalParamCount < 0) {\n            positionalParamCount = typeParams.findIndex((param) => param.category === 1 /* VarArgList */);\n            if (positionalParamCount >= 0) {\n                positionalParamCount++;\n            }\n        }\n        // Is there a keyword var-arg (\"**\") parameter? If so, it's not included\n        // in the list of positional parameters.\n        if (positionalParamCount < 0) {\n            positionalParamCount = typeParams.findIndex((param) => param.category === 2 /* VarArgDictionary */);\n        }\n        // If we didn't see any special cases, then all parameters are positional.\n        if (positionalParamCount < 0) {\n            positionalParamCount = typeParams.length;\n        }\n        // Determine how many positional args are being passed before\n        // we see a named arg.\n        let positionalArgCount = argList.findIndex((arg) => arg.argumentCategory === 2 /* UnpackedDictionary */ || arg.name !== undefined);\n        if (positionalArgCount < 0) {\n            positionalArgCount = argList.length;\n        }\n        // If there weren't enough positional arguments to populate all of\n        // the positional-only parameters, force the named parameters\n        // into positional-only slots so we can report errors for them.\n        if (positionalOnlyIndex >= 0 && positionalArgCount < positionalOnlyIndex) {\n            const firstParamWithDefault = typeParams.findIndex((param) => param.hasDefault);\n            const positionOnlyWithoutDefaultsCount = firstParamWithDefault >= 0 && firstParamWithDefault < positionalOnlyIndex\n                ? firstParamWithDefault\n                : positionalOnlyIndex;\n            positionalArgCount = Math.min(positionOnlyWithoutDefaultsCount, argList.length);\n        }\n        const validateArgTypeParams = [];\n        let activeParam;\n        function trySetActive(arg, param) {\n            if (arg.active) {\n                activeParam = param;\n            }\n        }\n        let foundUnpackedListArg = argList.find((arg) => arg.argumentCategory === 1 /* UnpackedList */) !== undefined;\n        // Map the positional args to parameters.\n        let paramIndex = 0;\n        let unpackedArgIndex = 0;\n        while (argIndex < positionalArgCount) {\n            if (paramIndex === positionalOnlyIndex) {\n                paramIndex++;\n                continue;\n            }\n            if (argIndex < positionalOnlyIndex && argList[argIndex].name) {\n                const fileInfo = getFileInfo(argList[argIndex].name);\n                addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.argPositional(), argList[argIndex].name);\n            }\n            if (paramIndex >= positionalParamCount) {\n                if (!foundUnpackedListArg || argList[argIndex].argumentCategory !== 1 /* UnpackedList */) {\n                    const adjustedCount = positionalParamCount;\n                    const fileInfo = getFileInfo(errorNode);\n                    addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, adjustedCount === 1\n                        ? localize_1.Localizer.Diagnostic.argPositionalExpectedOne()\n                        : localize_1.Localizer.Diagnostic.argPositionalExpectedCount().format({ expected: adjustedCount }), argList[argIndex].valueExpression || errorNode);\n                    reportedArgError = true;\n                }\n                break;\n            }\n            const paramType = types_1.FunctionType.getEffectiveParameterType(type, paramIndex);\n            if (argList[argIndex].argumentCategory === 1 /* UnpackedList */) {\n                if (!argList[argIndex].valueExpression) {\n                    break;\n                }\n                const argType = getTypeForArgument(argList[argIndex]);\n                let listElementType;\n                let advanceToNextArg = false;\n                // If this is a tuple with specified element types, use those\n                // specified types rather than using the more generic iterator\n                // type which will be a union of all element types.\n                if (types_1.isObject(argType) &&\n                    types_1.ClassType.isBuiltIn(argType.classType, 'Tuple') &&\n                    argType.classType.typeArguments &&\n                    argType.classType.typeArguments.length > 0 &&\n                    !typeUtils_1.isEllipsisType(argType.classType.typeArguments[argType.classType.typeArguments.length - 1])) {\n                    listElementType = argType.classType.typeArguments[unpackedArgIndex];\n                    // Determine if there are any more unpacked list arguments after\n                    // this one. If not, we'll clear this flag because this unpacked\n                    // list arg is bounded in length.\n                    foundUnpackedListArg =\n                        argList.find((arg, index) => index > argIndex && arg.argumentCategory === 1 /* UnpackedList */) !== undefined;\n                    unpackedArgIndex++;\n                    if (unpackedArgIndex >= argType.classType.typeArguments.length) {\n                        unpackedArgIndex = 0;\n                        advanceToNextArg = true;\n                    }\n                }\n                else {\n                    listElementType = getTypeFromIterable(argType, \n                    /* isAsync */ false, argList[argIndex].valueExpression, \n                    /* supportGetItem */ false);\n                }\n                const funcArg = {\n                    argumentCategory: 0 /* Simple */,\n                    type: listElementType,\n                };\n                const paramName = typeParams[paramIndex].name;\n                validateArgTypeParams.push({\n                    paramType,\n                    requiresTypeVarMatching: typeUtils_1.requiresSpecialization(paramType),\n                    argument: funcArg,\n                    errorNode: argList[argIndex].valueExpression || errorNode,\n                    paramName: paramName,\n                });\n                trySetActive(argList[argIndex], typeParams[paramIndex]);\n                // Note that the parameter has received an argument.\n                if (paramName) {\n                    paramMap.get(paramName).argsReceived++;\n                }\n                if (advanceToNextArg || typeParams[paramIndex].category === 1 /* VarArgList */) {\n                    argIndex++;\n                }\n                if (typeParams[paramIndex].category !== 1 /* VarArgList */) {\n                    paramIndex++;\n                }\n            }\n            else if (typeParams[paramIndex].category === 1 /* VarArgList */) {\n                validateArgTypeParams.push({\n                    paramType,\n                    requiresTypeVarMatching: typeUtils_1.requiresSpecialization(paramType),\n                    argument: argList[argIndex],\n                    errorNode: argList[argIndex].valueExpression || errorNode,\n                    paramName: typeParams[paramIndex].name,\n                });\n                trySetActive(argList[argIndex], typeParams[paramIndex]);\n                argIndex++;\n            }\n            else {\n                const paramName = typeParams[paramIndex].name;\n                validateArgTypeParams.push({\n                    paramType,\n                    requiresTypeVarMatching: typeUtils_1.requiresSpecialization(paramType),\n                    argument: argList[argIndex],\n                    errorNode: argList[argIndex].valueExpression || errorNode,\n                    paramName: paramName,\n                });\n                trySetActive(argList[argIndex], typeParams[paramIndex]);\n                // Note that the parameter has received an argument.\n                if (paramName) {\n                    paramMap.get(paramName).argsReceived++;\n                }\n                argIndex++;\n                paramIndex++;\n            }\n        }\n        if (!reportedArgError) {\n            let foundUnpackedDictionaryArg = false;\n            // Now consume any named parameters.\n            while (argIndex < argList.length) {\n                if (argList[argIndex].argumentCategory === 2 /* UnpackedDictionary */) {\n                    // Mark the arg as accessed.\n                    getTypeForArgument(argList[argIndex]);\n                    foundUnpackedDictionaryArg = true;\n                }\n                else {\n                    // Protect against the case where a non-named argument appears after\n                    // a named argument. This will have already been reported as a parse\n                    // error, but we need to protect against it here.\n                    const paramName = argList[argIndex].name;\n                    if (paramName) {\n                        const paramNameValue = paramName.value;\n                        const paramEntry = paramMap.get(paramNameValue);\n                        if (paramEntry) {\n                            if (paramEntry.argsReceived > 0) {\n                                addDiagnostic(getFileInfo(paramName).diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.paramAlreadyAssigned().format({ name: paramNameValue }), paramName);\n                                reportedArgError = true;\n                            }\n                            else {\n                                paramMap.get(paramName.value).argsReceived++;\n                                const paramInfoIndex = typeParams.findIndex((param) => param.name === paramNameValue);\n                                debug_1.assert(paramInfoIndex >= 0);\n                                const paramType = types_1.FunctionType.getEffectiveParameterType(type, paramInfoIndex);\n                                validateArgTypeParams.push({\n                                    paramType,\n                                    requiresTypeVarMatching: typeUtils_1.requiresSpecialization(paramType),\n                                    argument: argList[argIndex],\n                                    errorNode: argList[argIndex].valueExpression || errorNode,\n                                    paramName: paramNameValue,\n                                });\n                                trySetActive(argList[argIndex], typeParams[paramInfoIndex]);\n                            }\n                        }\n                        else if (varArgDictParam) {\n                            validateArgTypeParams.push({\n                                paramType: varArgDictParam.type,\n                                requiresTypeVarMatching: typeUtils_1.requiresSpecialization(varArgDictParam.type),\n                                argument: argList[argIndex],\n                                errorNode: argList[argIndex].valueExpression || errorNode,\n                                paramName: paramNameValue,\n                            });\n                            trySetActive(argList[argIndex], varArgDictParam);\n                        }\n                        else {\n                            addDiagnostic(getFileInfo(paramName).diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.paramNameMissing().format({ name: paramName.value }), paramName);\n                            reportedArgError = true;\n                        }\n                    }\n                }\n                argIndex++;\n            }\n            // Determine whether there are any parameters that require arguments\n            // but have not yet received them. If we received a dictionary argument\n            // (i.e. an arg starting with a \"**\") or a list argument (i.e. an arg\n            // starting with a \"*\"), we will assume that all parameters are matched.\n            if (!foundUnpackedDictionaryArg &&\n                !foundUnpackedListArg &&\n                !types_1.FunctionType.isDefaultParameterCheckDisabled(type)) {\n                const unassignedParams = [...paramMap.keys()].filter((name) => {\n                    const entry = paramMap.get(name);\n                    return entry.argsReceived < entry.argsNeeded;\n                });\n                if (unassignedParams.length > 0) {\n                    const missingParamNames = unassignedParams.map((p) => `\"${p}\"`).join(', ');\n                    addDiagnostic(getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, unassignedParams.length === 1\n                        ? localize_1.Localizer.Diagnostic.argMissingForParam().format({ name: missingParamNames })\n                        : localize_1.Localizer.Diagnostic.argMissingForParams().format({ names: missingParamNames }), errorNode);\n                    reportedArgError = true;\n                }\n                // Add any implicit (default) arguments that are needed for resolving\n                // generic types. For example, if the function is defined as\n                // def foo(v1: _T = 'default')\n                // and _T is a TypeVar, we need to match the TypeVar to the default\n                // value's type if it's not provided by the caller.\n                typeParams.forEach((param) => {\n                    if (param.category === 0 /* Simple */ && param.name) {\n                        const entry = paramMap.get(param.name);\n                        if (entry.argsNeeded === 0 && entry.argsReceived === 0) {\n                            if (param.defaultType && typeUtils_1.requiresSpecialization(param.type)) {\n                                validateArgTypeParams.push({\n                                    paramType: param.type,\n                                    requiresTypeVarMatching: true,\n                                    argument: {\n                                        argumentCategory: 0 /* Simple */,\n                                        type: param.defaultType,\n                                    },\n                                    errorNode: errorNode,\n                                    paramName: param.name,\n                                });\n                            }\n                        }\n                    }\n                });\n            }\n        }\n        // Special-case a few built-in calls that are often used for\n        // casting or checking for unknown types.\n        if (['cast', 'isinstance', 'issubclass'].some((name) => name === type.details.builtInName)) {\n            skipUnknownArgCheck = true;\n        }\n        // Run through all args and validate them against their matched parameter.\n        // We'll do two passes. The first one will match any type arguments. The second\n        // will perform the actual validation. We can skip the first pass if there\n        // are no type vars to match.\n        const typeVarMatchingCount = validateArgTypeParams.filter((arg) => arg.requiresTypeVarMatching).length;\n        if (typeVarMatchingCount > 0) {\n            // In theory, we may need to do up to n passes where n is the number of\n            // arguments that need type var matching. That's because later matches\n            // can provide bidirectional type hints for earlier matches. The best\n            // example of this is the built-in \"map\" method whose first parameter is\n            // a lambda and second parameter indicates what type the lambda should accept.\n            // In practice, we will limit the number of passes to 2 because it can get\n            // very expensive to go beyond this, and we don't see generally see cases\n            // where more than two passes are needed.\n            const passCount = Math.min(typeVarMatchingCount, 2);\n            for (let i = 0; i < passCount; i++) {\n                useSpeculativeMode(errorNode, () => {\n                    validateArgTypeParams.forEach((argParam) => {\n                        if (argParam.requiresTypeVarMatching) {\n                            validateArgType(argParam, typeVarMap, type.details.name, skipUnknownArgCheck);\n                        }\n                    });\n                });\n            }\n            // Lock the type var map so it cannot be modified and revalidate the\n            // arguments in a second pass.\n            typeVarMap.lock();\n        }\n        validateArgTypeParams.forEach((argParam) => {\n            if (!validateArgType(argParam, typeVarMap, type.details.name, skipUnknownArgCheck)) {\n                reportedArgError = true;\n            }\n        });\n        // Run through all the args that were not validated and evaluate their types\n        // to ensure that we haven't missed any (due to arg/param mismatches). This will\n        // ensure that referenced symbols are not reported as unaccessed.\n        if (!isSpeculativeMode(undefined) && !incompleteTypeTracker.isIncompleteTypeMode()) {\n            argList.forEach((arg) => {\n                if (arg.valueExpression) {\n                    if (!validateArgTypeParams.some((validatedArg) => validatedArg.argument === arg)) {\n                        getTypeOfExpression(arg.valueExpression);\n                    }\n                }\n            });\n        }\n        // Calculate the return type. If there was an error matching arguments to\n        // parameters, don't bother attempting to infer the return type.\n        const returnType = getFunctionEffectiveReturnType(type, validateArgTypeParams, inferReturnTypeIfNeeded && !reportedArgError);\n        const specializedReturnType = typeUtils_1.specializeType(returnType, typeVarMap);\n        return { argumentErrors: reportedArgError, returnType: specializedReturnType, activeParam };\n    }\n    function validateArgType(argParam, typeVarMap, functionName, skipUnknownCheck) {\n        let argType;\n        let expectedTypeDiag;\n        if (argParam.argument.valueExpression) {\n            let expectedType = typeUtils_1.specializeType(argParam.paramType, typeVarMap);\n            // If the expected type is unknown, don't use an expected type. Instead,\n            // use default rules for evaluating the expression type.\n            if (types_1.isUnknown(expectedType)) {\n                expectedType = undefined;\n            }\n            const exprType = getTypeOfExpression(argParam.argument.valueExpression, expectedType);\n            argType = exprType.type;\n            expectedTypeDiag = exprType.expectedTypeDiagAddendum;\n            if (argParam.argument && argParam.argument.name && !isSpeculativeMode(argParam.errorNode)) {\n                writeTypeCache(argParam.argument.name, expectedType || argType);\n            }\n        }\n        else {\n            argType = getTypeForArgument(argParam.argument);\n        }\n        let diag = new diagnostic_1.DiagnosticAddendum();\n        if (!canAssignType(argParam.paramType, argType, diag.createAddendum(), typeVarMap)) {\n            const fileInfo = getFileInfo(argParam.errorNode);\n            const argTypeText = printType(argType);\n            const paramTypeText = printType(argParam.paramType);\n            let message;\n            if (argParam.paramName) {\n                if (functionName) {\n                    message = localize_1.Localizer.Diagnostic.argAssignmentParamFunction().format({\n                        argType: argTypeText,\n                        paramType: paramTypeText,\n                        functionName,\n                        paramName: argParam.paramName,\n                    });\n                }\n                else {\n                    message = localize_1.Localizer.Diagnostic.argAssignmentParam().format({\n                        argType: argTypeText,\n                        paramType: paramTypeText,\n                        paramName: argParam.paramName,\n                    });\n                }\n            }\n            else {\n                if (functionName) {\n                    message = localize_1.Localizer.Diagnostic.argAssignmentFunction().format({\n                        argType: argTypeText,\n                        paramType: paramTypeText,\n                        functionName,\n                    });\n                }\n                else {\n                    message = localize_1.Localizer.Diagnostic.argAssignment().format({\n                        argType: argTypeText,\n                        paramType: paramTypeText,\n                    });\n                }\n            }\n            // If we have an expected type diagnostic addendum, use that\n            // instead of the local diagnostic addendum because it will\n            // be more informative.\n            if (expectedTypeDiag) {\n                diag = expectedTypeDiag;\n            }\n            addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, message + diag.getString(), argParam.errorNode);\n            return false;\n        }\n        else if (!skipUnknownCheck) {\n            const simplifiedType = types_1.removeUnboundFromUnion(argType);\n            const fileInfo = getFileInfo(argParam.errorNode);\n            const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n            if (argParam.paramName) {\n                diagAddendum.addMessage((functionName\n                    ? localize_1.Localizer.DiagnosticAddendum.argParamFunction().format({\n                        paramName: argParam.paramName,\n                        functionName,\n                    })\n                    : localize_1.Localizer.DiagnosticAddendum.argParam().format({ paramName: argParam.paramName })) +\n                    diagAddendum.getString());\n            }\n            if (types_1.isUnknown(simplifiedType)) {\n                addDiagnostic(fileInfo.diagnosticRuleSet.reportUnknownArgumentType, \"reportUnknownArgumentType\" /* reportUnknownArgumentType */, localize_1.Localizer.Diagnostic.argTypeUnknown() + diagAddendum.getString(), argParam.errorNode);\n            }\n            else if (typeUtils_1.isPartlyUnknown(simplifiedType, true)) {\n                // Don't report an error if the type is a partially-specialized\n                // class. This comes up frequently in cases where a type is passed\n                // as an argument (e.g. \"defaultdict(list)\").\n                // If the parameter type is also partially unknown, don't report\n                // the error because it's likely that the partially-unknown type\n                // arose due to bidirectional type matching.\n                if (!typeUtils_1.isPartlyUnknown(argParam.paramType) && !types_1.isClass(simplifiedType)) {\n                    diagAddendum.addMessage(localize_1.Localizer.DiagnosticAddendum.argumentType().format({ type: printType(simplifiedType) }));\n                    addDiagnostic(fileInfo.diagnosticRuleSet.reportUnknownArgumentType, \"reportUnknownArgumentType\" /* reportUnknownArgumentType */, localize_1.Localizer.Diagnostic.argTypePartiallyUnknown() + diagAddendum.getString(), argParam.errorNode);\n                }\n            }\n        }\n        return true;\n    }\n    function createTypeVarType(errorNode, argList, isParamSpec) {\n        let typeVarName = '';\n        if (isParamSpec) {\n            const fileInfo = getFileInfo(errorNode);\n            if (!fileInfo.isStubFile && fileInfo.executionEnvironment.pythonVersion < pythonVersion_1.PythonVersion.V3_9) {\n                addError(localize_1.Localizer.Diagnostic.paramSpecIllegal(), errorNode);\n            }\n        }\n        if (argList.length === 0) {\n            addError(isParamSpec ? localize_1.Localizer.Diagnostic.paramSpecFirstArg() : localize_1.Localizer.Diagnostic.typeVarFirstArg(), errorNode);\n            return undefined;\n        }\n        const firstArg = argList[0];\n        if (firstArg.valueExpression && firstArg.valueExpression.nodeType === 49 /* StringList */) {\n            typeVarName = firstArg.valueExpression.strings.map((s) => s.value).join('');\n        }\n        else {\n            addError(isParamSpec ? localize_1.Localizer.Diagnostic.paramSpecFirstArg() : localize_1.Localizer.Diagnostic.typeVarFirstArg(), firstArg.valueExpression || errorNode);\n        }\n        const typeVar = types_1.TypeVarType.createInstantiable(typeVarName, isParamSpec);\n        // Parse the remaining parameters.\n        for (let i = 1; i < argList.length; i++) {\n            const paramNameNode = argList[i].name;\n            const paramName = paramNameNode ? paramNameNode.value : undefined;\n            const paramNameMap = new Map();\n            if (paramName) {\n                if (paramNameMap.get(paramName)) {\n                    addError(localize_1.Localizer.Diagnostic.duplicateParam().format({ name: paramName }), argList[i].valueExpression || errorNode);\n                }\n                if (paramName === 'bound' && !isParamSpec) {\n                    if (typeVar.constraints.length > 0) {\n                        addError(localize_1.Localizer.Diagnostic.typeVarBoundAndConstrained(), argList[i].valueExpression || errorNode);\n                    }\n                    else {\n                        const argType = getTypeForArgumentExpectingType(argList[i], getFileInfo(errorNode));\n                        if (typeUtils_1.requiresSpecialization(argType)) {\n                            addError(localize_1.Localizer.Diagnostic.typeVarGeneric(), argList[i].valueExpression || errorNode);\n                        }\n                        typeVar.boundType = typeUtils_1.convertToInstance(argType);\n                    }\n                }\n                else if (paramName === 'covariant' && !isParamSpec) {\n                    if (argList[i].valueExpression && getBooleanValue(argList[i].valueExpression)) {\n                        if (typeVar.isContravariant) {\n                            addError(localize_1.Localizer.Diagnostic.typeVarVariance(), argList[i].valueExpression);\n                        }\n                        else {\n                            typeVar.isCovariant = true;\n                        }\n                    }\n                }\n                else if (paramName === 'contravariant' && !isParamSpec) {\n                    if (argList[i].valueExpression && getBooleanValue(argList[i].valueExpression)) {\n                        if (typeVar.isContravariant) {\n                            addError(localize_1.Localizer.Diagnostic.typeVarVariance(), argList[i].valueExpression);\n                        }\n                        else {\n                            typeVar.isContravariant = true;\n                        }\n                    }\n                }\n                else {\n                    addError(isParamSpec\n                        ? localize_1.Localizer.Diagnostic.paramSpecUnknownParam().format({ name: paramName })\n                        : localize_1.Localizer.Diagnostic.typeVarUnknownParam().format({ name: paramName }), argList[i].valueExpression || errorNode);\n                }\n                paramNameMap.set(paramName, paramName);\n            }\n            else if (!isParamSpec) {\n                if (typeVar.boundType) {\n                    addError(localize_1.Localizer.Diagnostic.typeVarBoundAndConstrained(), argList[i].valueExpression || errorNode);\n                }\n                else {\n                    const argType = getTypeForArgumentExpectingType(argList[i], getFileInfo(errorNode));\n                    if (typeUtils_1.requiresSpecialization(argType)) {\n                        addError(localize_1.Localizer.Diagnostic.typeVarGeneric(), argList[i].valueExpression || errorNode);\n                    }\n                    types_1.TypeVarType.addConstraint(typeVar, typeUtils_1.convertToInstance(argType));\n                }\n            }\n            else {\n                addError(localize_1.Localizer.Diagnostic.paramSpecUnknownArg(), argList[i].valueExpression || errorNode);\n                break;\n            }\n        }\n        return typeVar;\n    }\n    function getBooleanValue(node) {\n        if (node.nodeType === 11 /* Constant */) {\n            if (node.constType === 14 /* False */) {\n                return false;\n            }\n            else if (node.constType === 31 /* True */) {\n                return true;\n            }\n        }\n        addError(localize_1.Localizer.Diagnostic.expectedBoolLiteral(), node);\n        return false;\n    }\n    // Creates a new custom enum class with named values.\n    function createEnumType(errorNode, enumClass, argList) {\n        let className = 'enum';\n        if (argList.length === 0) {\n            addError(localize_1.Localizer.Diagnostic.enumFirstArg(), errorNode);\n        }\n        else {\n            const nameArg = argList[0];\n            if (nameArg.argumentCategory !== 0 /* Simple */) {\n                addError(localize_1.Localizer.Diagnostic.enumFirstArg(), argList[0].valueExpression || errorNode);\n            }\n            else if (nameArg.valueExpression && nameArg.valueExpression.nodeType === 49 /* StringList */) {\n                className = nameArg.valueExpression.strings.map((s) => s.value).join('');\n            }\n        }\n        const classType = types_1.ClassType.create(className, 64 /* EnumClass */, errorNode.id);\n        classType.details.baseClasses.push(enumClass);\n        typeUtils_1.computeMroLinearization(classType);\n        const classFields = classType.details.fields;\n        classFields.set('__class__', symbol_1.Symbol.createWithType(4 /* ClassMember */ | 64 /* IgnoredForProtocolMatch */, classType));\n        if (argList.length < 2) {\n            addError(localize_1.Localizer.Diagnostic.enumSecondArg(), errorNode);\n        }\n        else {\n            const entriesArg = argList[1];\n            if (entriesArg.argumentCategory !== 0 /* Simple */ ||\n                !entriesArg.valueExpression ||\n                entriesArg.valueExpression.nodeType !== 49 /* StringList */) {\n                // Technically, the Enum constructor supports a bunch of different\n                // ways to specify the items: space-delimited string, a string\n                // iterator, an iterator of name/value tuples, and a dictionary\n                // of name/value pairs. We support only the simple space-delimited\n                // string here. For users who are interested in type checking, we\n                // recommend using the more standard class declaration syntax.\n                // This diagnostic is part of the reportGeneralTypeIssues since\n                // it is of interest only to those who care about types.\n                const fileInfo = getFileInfo(errorNode);\n                addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.enumSecondArg(), argList[1].valueExpression || errorNode);\n            }\n            else {\n                const entries = entriesArg.valueExpression.strings\n                    .map((s) => s.value)\n                    .join('')\n                    .split(' ');\n                entries.forEach((entryName) => {\n                    entryName = entryName.trim();\n                    if (entryName) {\n                        const entryType = types_1.UnknownType.create();\n                        const newSymbol = symbol_1.Symbol.createWithType(4 /* ClassMember */, entryType);\n                        // We need to associate the declaration with a parse node.\n                        // In this case it's just part of a string literal value.\n                        // The definition provider won't necessarily take the\n                        // user to the exact spot in the string, but it's close enough.\n                        const stringNode = entriesArg.valueExpression;\n                        debug_1.assert(stringNode.nodeType === 49 /* StringList */);\n                        const declaration = {\n                            type: 1 /* Variable */,\n                            node: stringNode,\n                            path: getFileInfo(errorNode).filePath,\n                            range: positionUtils_1.convertOffsetsToRange(stringNode.start, textRange_1.TextRange.getEnd(stringNode), getFileInfo(errorNode).lines),\n                        };\n                        newSymbol.addDeclaration(declaration);\n                        classFields.set(entryName, newSymbol);\n                    }\n                });\n            }\n        }\n        return classType;\n    }\n    // Implements the semantics of the NewType call as documented\n    // in the Python specification: The static type checker will treat\n    // the new type as if it were a subclass of the original type.\n    function createNewType(errorNode, argList) {\n        let className = '_';\n        if (argList.length >= 1) {\n            const nameArg = argList[0];\n            if (nameArg.argumentCategory === 0 /* Simple */) {\n                if (nameArg.valueExpression && nameArg.valueExpression.nodeType === 49 /* StringList */) {\n                    className = nameArg.valueExpression.strings.map((s) => s.value).join('');\n                }\n            }\n        }\n        if (argList.length >= 2) {\n            const baseClass = getTypeForArgumentExpectingType(argList[1], getFileInfo(errorNode));\n            if (types_1.isClass(baseClass)) {\n                const classFlags = baseClass.details.flags & ~(1 /* BuiltInClass */ | 2 /* SpecialBuiltIn */);\n                const classType = types_1.ClassType.create(className, classFlags, errorNode.id);\n                classType.details.baseClasses.push(baseClass);\n                typeUtils_1.computeMroLinearization(classType);\n                // Synthesize an __init__ method that accepts only the specified type.\n                const initType = types_1.FunctionType.createInstance('__init__', 64 /* SynthesizedMethod */);\n                types_1.FunctionType.addParameter(initType, {\n                    category: 0 /* Simple */,\n                    name: 'self',\n                    type: types_1.ObjectType.create(classType),\n                });\n                types_1.FunctionType.addParameter(initType, {\n                    category: 0 /* Simple */,\n                    name: '_x',\n                    type: types_1.ObjectType.create(baseClass),\n                });\n                initType.details.declaredReturnType = types_1.NoneType.createInstance();\n                classType.details.fields.set('__init__', symbol_1.Symbol.createWithType(4 /* ClassMember */, initType));\n                // Synthesize a trivial __new__ method.\n                const newType = types_1.FunctionType.createInstance('__new__', 1 /* ConstructorMethod */ | 64 /* SynthesizedMethod */);\n                types_1.FunctionType.addParameter(newType, {\n                    category: 0 /* Simple */,\n                    name: 'cls',\n                    type: classType,\n                });\n                types_1.FunctionType.addDefaultParameters(newType);\n                newType.details.declaredReturnType = types_1.ObjectType.create(classType);\n                classType.details.fields.set('__new__', symbol_1.Symbol.createWithType(4 /* ClassMember */, newType));\n                return classType;\n            }\n        }\n        return undefined;\n    }\n    // Implements the semantics of the multi-parameter variant of the \"type\" call.\n    function createType(errorNode, argList) {\n        const arg0Type = getTypeForArgument(argList[0]);\n        if (!types_1.isObject(arg0Type) || !types_1.ClassType.isBuiltIn(arg0Type.classType, 'str')) {\n            return undefined;\n        }\n        const className = arg0Type.classType.literalValue || '_';\n        const arg1Type = getTypeForArgument(argList[1]);\n        if (!types_1.isObject(arg1Type) ||\n            !types_1.ClassType.isBuiltIn(arg1Type.classType, 'Tuple') ||\n            arg1Type.classType.typeArguments === undefined) {\n            return undefined;\n        }\n        const classType = types_1.ClassType.create(className, 0 /* None */, errorNode.id);\n        arg1Type.classType.typeArguments.forEach((baseClass) => {\n            if (types_1.isClass(baseClass) || types_1.isAnyOrUnknown(baseClass)) {\n                classType.details.baseClasses.push(baseClass);\n            }\n            else {\n                addExpectedClassDiagnostic(baseClass, argList[1].valueExpression || errorNode);\n            }\n        });\n        if (!typeUtils_1.computeMroLinearization(classType)) {\n            addError(localize_1.Localizer.Diagnostic.methodOrdering(), errorNode);\n        }\n        return classType;\n    }\n    // Creates a new custom TypedDict factory class.\n    function createTypedDictType(errorNode, typedDictClass, argList) {\n        // TypedDict supports two different syntaxes:\n        // Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})\n        // Point2D = TypedDict('Point2D', x=int, y=int, label=str)\n        let className = 'TypedDict';\n        if (argList.length === 0) {\n            addError(localize_1.Localizer.Diagnostic.typedDictFirstArg(), errorNode);\n        }\n        else {\n            const nameArg = argList[0];\n            if (nameArg.argumentCategory !== 0 /* Simple */ ||\n                !nameArg.valueExpression ||\n                nameArg.valueExpression.nodeType !== 49 /* StringList */) {\n                addError(localize_1.Localizer.Diagnostic.typedDictFirstArg(), argList[0].valueExpression || errorNode);\n            }\n            else {\n                className = nameArg.valueExpression.strings.map((s) => s.value).join('');\n            }\n        }\n        const classType = types_1.ClassType.create(className, 16 /* TypedDictClass */, errorNode.id);\n        classType.details.baseClasses.push(typedDictClass);\n        typeUtils_1.computeMroLinearization(classType);\n        const classFields = classType.details.fields;\n        classFields.set('__class__', symbol_1.Symbol.createWithType(4 /* ClassMember */ | 64 /* IgnoredForProtocolMatch */, classType));\n        let usingDictSyntax = false;\n        if (argList.length < 2) {\n            addError(localize_1.Localizer.Diagnostic.typedDictSecondArgDict(), errorNode);\n        }\n        else {\n            const entriesArg = argList[1];\n            const entryMap = new Map();\n            if (entriesArg.argumentCategory === 0 /* Simple */ &&\n                entriesArg.valueExpression &&\n                entriesArg.valueExpression.nodeType === 15 /* Dictionary */) {\n                usingDictSyntax = true;\n                const entryDict = entriesArg.valueExpression;\n                entryDict.entries.forEach((entry) => {\n                    if (entry.nodeType !== 17 /* DictionaryKeyEntry */) {\n                        addError(localize_1.Localizer.Diagnostic.typedDictSecondArgDictEntry(), entry);\n                        return;\n                    }\n                    if (entry.keyExpression.nodeType !== 49 /* StringList */) {\n                        addError(localize_1.Localizer.Diagnostic.typedDictEntryName(), entry.keyExpression);\n                        return;\n                    }\n                    const entryName = entry.keyExpression.strings.map((s) => s.value).join('');\n                    if (!entryName) {\n                        addError(localize_1.Localizer.Diagnostic.typedDictEmptyName(), entry.keyExpression);\n                        return;\n                    }\n                    if (entryMap.has(entryName)) {\n                        addError(localize_1.Localizer.Diagnostic.typedDictEntryUnique(), entry.keyExpression);\n                        return;\n                    }\n                    // Record names in a map to detect duplicates.\n                    entryMap.set(entryName, true);\n                    // Cache the annotation type.\n                    getTypeOfAnnotation(entry.valueExpression, /* allowFinal */ true);\n                    const newSymbol = new symbol_1.Symbol(8 /* InstanceMember */);\n                    const declaration = {\n                        type: 1 /* Variable */,\n                        node: entry.keyExpression,\n                        path: getFileInfo(errorNode).filePath,\n                        typeAnnotationNode: entry.valueExpression,\n                        range: positionUtils_1.convertOffsetsToRange(entry.keyExpression.start, textRange_1.TextRange.getEnd(entry.keyExpression), getFileInfo(errorNode).lines),\n                    };\n                    newSymbol.addDeclaration(declaration);\n                    classFields.set(entryName, newSymbol);\n                });\n            }\n            else if (entriesArg.name) {\n                for (let i = 1; i < argList.length; i++) {\n                    const entry = argList[i];\n                    if (!entry.name || !entry.valueExpression) {\n                        continue;\n                    }\n                    if (entryMap.has(entry.name.value)) {\n                        addError(localize_1.Localizer.Diagnostic.typedDictEntryUnique(), entry.valueExpression);\n                        continue;\n                    }\n                    // Record names in a map to detect duplicates.\n                    entryMap.set(entry.name.value, true);\n                    // Cache the annotation type.\n                    getTypeOfAnnotation(entry.valueExpression, /* allowFinal */ true);\n                    const newSymbol = new symbol_1.Symbol(8 /* InstanceMember */);\n                    const declaration = {\n                        type: 1 /* Variable */,\n                        node: entry.name,\n                        path: getFileInfo(errorNode).filePath,\n                        typeAnnotationNode: entry.valueExpression,\n                        range: positionUtils_1.convertOffsetsToRange(entry.name.start, textRange_1.TextRange.getEnd(entry.valueExpression), getFileInfo(errorNode).lines),\n                    };\n                    newSymbol.addDeclaration(declaration);\n                    classFields.set(entry.name.value, newSymbol);\n                }\n            }\n            else {\n                addError(localize_1.Localizer.Diagnostic.typedDictSecondArgDict(), errorNode);\n            }\n        }\n        if (usingDictSyntax) {\n            if (argList.length >= 3) {\n                if (!argList[2].name ||\n                    argList[2].name.value !== 'total' ||\n                    !argList[2].valueExpression ||\n                    argList[2].valueExpression.nodeType !== 11 /* Constant */ ||\n                    !(argList[2].valueExpression.constType === 14 /* False */ ||\n                        argList[2].valueExpression.constType === 31 /* True */)) {\n                    addError(localize_1.Localizer.Diagnostic.typedDictTotalParam(), argList[2].valueExpression || errorNode);\n                }\n                else if (argList[2].valueExpression.constType === 14 /* False */) {\n                    classType.details.flags |= 32 /* CanOmitDictValues */;\n                }\n            }\n            if (argList.length > 3) {\n                addError(localize_1.Localizer.Diagnostic.typedDictExtraArgs(), argList[3].valueExpression || errorNode);\n            }\n        }\n        synthesizeTypedDictClassMethods(errorNode, classType);\n        return classType;\n    }\n    // Creates a new custom tuple factory class with named values.\n    // Supports both typed and untyped variants.\n    function createNamedTupleType(errorNode, argList, includesTypes) {\n        let className = 'namedtuple';\n        if (argList.length === 0) {\n            addError(localize_1.Localizer.Diagnostic.namedTupleFirstArg(), errorNode);\n        }\n        else {\n            const nameArg = argList[0];\n            if (nameArg.argumentCategory !== 0 /* Simple */) {\n                addError(localize_1.Localizer.Diagnostic.namedTupleFirstArg(), argList[0].valueExpression || errorNode);\n            }\n            else if (nameArg.valueExpression && nameArg.valueExpression.nodeType === 49 /* StringList */) {\n                className = nameArg.valueExpression.strings.map((s) => s.value).join('');\n            }\n        }\n        const classType = types_1.ClassType.create(className, 0 /* None */, errorNode.id);\n        const builtInNamedTuple = getTypingType(errorNode, 'NamedTuple') || types_1.UnknownType.create();\n        classType.details.baseClasses.push(builtInNamedTuple);\n        typeUtils_1.computeMroLinearization(classType);\n        const classFields = classType.details.fields;\n        classFields.set('__class__', symbol_1.Symbol.createWithType(4 /* ClassMember */ | 64 /* IgnoredForProtocolMatch */, classType));\n        const builtInTupleType = getBuiltInType(errorNode, 'Tuple');\n        if (types_1.isClass(builtInTupleType)) {\n            const constructorType = types_1.FunctionType.createInstance('__new__', 1 /* ConstructorMethod */ | 64 /* SynthesizedMethod */);\n            constructorType.details.declaredReturnType = types_1.ObjectType.create(classType);\n            if (ParseTreeUtils.isAssignmentToDefaultsFollowingNamedTuple(errorNode)) {\n                constructorType.details.flags |= 32 /* DisableDefaultChecks */;\n            }\n            types_1.FunctionType.addParameter(constructorType, {\n                category: 0 /* Simple */,\n                name: 'cls',\n                type: classType,\n            });\n            const selfParameter = {\n                category: 0 /* Simple */,\n                name: 'self',\n                type: types_1.ObjectType.create(classType),\n            };\n            let addGenericGetAttribute = false;\n            if (argList.length < 2) {\n                addError(localize_1.Localizer.Diagnostic.namedTupleSecondArg(), errorNode);\n                addGenericGetAttribute = true;\n            }\n            else {\n                const entriesArg = argList[1];\n                if (entriesArg.argumentCategory !== 0 /* Simple */) {\n                    addGenericGetAttribute = true;\n                }\n                else {\n                    if (!includesTypes &&\n                        entriesArg.valueExpression &&\n                        entriesArg.valueExpression.nodeType === 49 /* StringList */) {\n                        const entries = entriesArg.valueExpression.strings\n                            .map((s) => s.value)\n                            .join('')\n                            .split(/[,\\s]+/);\n                        entries.forEach((entryName) => {\n                            entryName = entryName.trim();\n                            if (entryName) {\n                                const entryType = types_1.UnknownType.create();\n                                const paramInfo = {\n                                    category: 0 /* Simple */,\n                                    name: entryName,\n                                    hasDeclaredType: includesTypes,\n                                    type: entryType,\n                                };\n                                types_1.FunctionType.addParameter(constructorType, paramInfo);\n                                const newSymbol = symbol_1.Symbol.createWithType(8 /* InstanceMember */, entryType);\n                                // We need to associate the declaration with a parse node.\n                                // In this case it's just part of a string literal value.\n                                // The definition provider won't necessarily take the\n                                // user to the exact spot in the string, but it's close enough.\n                                const stringNode = entriesArg.valueExpression;\n                                const declaration = {\n                                    type: 1 /* Variable */,\n                                    node: stringNode,\n                                    path: getFileInfo(errorNode).filePath,\n                                    range: positionUtils_1.convertOffsetsToRange(stringNode.start, textRange_1.TextRange.getEnd(stringNode), getFileInfo(errorNode).lines),\n                                };\n                                newSymbol.addDeclaration(declaration);\n                                classFields.set(entryName, newSymbol);\n                            }\n                        });\n                    }\n                    else if (entriesArg.valueExpression &&\n                        entriesArg.valueExpression.nodeType === 32 /* List */) {\n                        const entryList = entriesArg.valueExpression;\n                        const entryMap = new Map();\n                        entryList.entries.forEach((entry, index) => {\n                            let entryTypeNode;\n                            let entryType;\n                            let entryNameNode;\n                            let entryName = '';\n                            if (includesTypes) {\n                                // Handle the variant that includes name/type tuples.\n                                if (entry.nodeType === 53 /* Tuple */ && entry.expressions.length === 2) {\n                                    entryNameNode = entry.expressions[0];\n                                    entryTypeNode = entry.expressions[1];\n                                    const entryTypeInfo = getTypeOfExpression(entryTypeNode, undefined, 256 /* ExpectingType */ |\n                                        32 /* EvaluateStringLiteralAsType */ |\n                                        128 /* ParamSpecDisallowed */);\n                                    if (entryTypeInfo) {\n                                        entryType = typeUtils_1.convertToInstance(entryTypeInfo.type);\n                                    }\n                                }\n                                else {\n                                    addError(localize_1.Localizer.Diagnostic.namedTupleNameType(), entry);\n                                }\n                            }\n                            else {\n                                entryNameNode = entry;\n                                entryType = types_1.UnknownType.create();\n                            }\n                            if (entryNameNode && entryNameNode.nodeType === 49 /* StringList */) {\n                                entryName = entryNameNode.strings.map((s) => s.value).join('');\n                                if (!entryName) {\n                                    addError(localize_1.Localizer.Diagnostic.namedTupleEmptyName(), entryNameNode);\n                                }\n                            }\n                            else {\n                                addError(localize_1.Localizer.Diagnostic.namedTupleNameString(), entryNameNode || entry);\n                            }\n                            if (!entryName) {\n                                entryName = `_${index.toString()}`;\n                            }\n                            if (entryMap.has(entryName)) {\n                                addError(localize_1.Localizer.Diagnostic.namedTupleNameUnique(), entryNameNode || entry);\n                            }\n                            // Record names in a map to detect duplicates.\n                            entryMap.set(entryName, entryName);\n                            if (!entryType) {\n                                entryType = types_1.UnknownType.create();\n                            }\n                            const paramInfo = {\n                                category: 0 /* Simple */,\n                                name: entryName,\n                                hasDeclaredType: includesTypes,\n                                type: entryType,\n                            };\n                            types_1.FunctionType.addParameter(constructorType, paramInfo);\n                            const newSymbol = symbol_1.Symbol.createWithType(8 /* InstanceMember */, entryType);\n                            if (entryNameNode && entryNameNode.nodeType === 49 /* StringList */) {\n                                const declaration = {\n                                    type: 1 /* Variable */,\n                                    node: entryNameNode,\n                                    path: getFileInfo(errorNode).filePath,\n                                    typeAnnotationNode: entryTypeNode,\n                                    range: positionUtils_1.convertOffsetsToRange(entryNameNode.start, textRange_1.TextRange.getEnd(entryNameNode), getFileInfo(errorNode).lines),\n                                };\n                                newSymbol.addDeclaration(declaration);\n                            }\n                            classFields.set(entryName, newSymbol);\n                        });\n                    }\n                    else {\n                        // A dynamic expression was used, so we can't evaluate\n                        // the named tuple statically.\n                        addGenericGetAttribute = true;\n                    }\n                }\n            }\n            if (addGenericGetAttribute) {\n                types_1.FunctionType.addDefaultParameters(constructorType);\n            }\n            // Always use generic parameters for __init__. The __new__ method\n            // will handle property type checking. We may need to disable default\n            // parameter processing for __new__ (see isAssignmentToDefaultsFollowingNamedTuple),\n            // and we don't want to do it for __init__ as well.\n            const initType = types_1.FunctionType.createInstance('__init__', 64 /* SynthesizedMethod */ | 128 /* SkipConstructorCheck */);\n            types_1.FunctionType.addParameter(initType, selfParameter);\n            types_1.FunctionType.addDefaultParameters(initType);\n            initType.details.declaredReturnType = types_1.NoneType.createInstance();\n            classFields.set('__new__', symbol_1.Symbol.createWithType(4 /* ClassMember */, constructorType));\n            classFields.set('__init__', symbol_1.Symbol.createWithType(4 /* ClassMember */, initType));\n            const keysItemType = types_1.FunctionType.createInstance('keys', 64 /* SynthesizedMethod */);\n            const itemsItemType = types_1.FunctionType.createInstance('items', 64 /* SynthesizedMethod */);\n            keysItemType.details.declaredReturnType = getBuiltInObject(errorNode, 'list', [\n                getBuiltInObject(errorNode, 'str'),\n            ]);\n            itemsItemType.details.declaredReturnType = keysItemType.details.declaredReturnType;\n            classFields.set('keys', symbol_1.Symbol.createWithType(8 /* InstanceMember */, keysItemType));\n            classFields.set('items', symbol_1.Symbol.createWithType(8 /* InstanceMember */, itemsItemType));\n            const lenType = types_1.FunctionType.createInstance('__len__', 64 /* SynthesizedMethod */);\n            lenType.details.declaredReturnType = getBuiltInObject(errorNode, 'int');\n            types_1.FunctionType.addParameter(lenType, selfParameter);\n            classFields.set('__len__', symbol_1.Symbol.createWithType(4 /* ClassMember */, lenType));\n            if (addGenericGetAttribute) {\n                const getAttribType = types_1.FunctionType.createInstance('__getattribute__', 64 /* SynthesizedMethod */);\n                getAttribType.details.declaredReturnType = types_1.AnyType.create();\n                types_1.FunctionType.addParameter(getAttribType, selfParameter);\n                types_1.FunctionType.addParameter(getAttribType, {\n                    category: 0 /* Simple */,\n                    name: 'name',\n                    type: getBuiltInObject(errorNode, 'str'),\n                });\n                classFields.set('__getattribute__', symbol_1.Symbol.createWithType(4 /* ClassMember */, getAttribType));\n            }\n        }\n        return classType;\n    }\n    function getTypeFromConstant(node, flags) {\n        let type;\n        if (node.constType === 24 /* None */) {\n            type = (flags & 256 /* ExpectingType */) !== 0 ? types_1.NoneType.createType() : types_1.NoneType.createInstance();\n        }\n        else if (node.constType === 31 /* True */ ||\n            node.constType === 14 /* False */ ||\n            node.constType === 8 /* Debug */) {\n            type = getBuiltInObject(node, 'bool');\n            // For True and False, we can create truthy and falsy\n            // versions of 'bool'.\n            if (type && types_1.isObject(type)) {\n                if (node.constType === 31 /* True */) {\n                    type = types_1.ObjectType.create(types_1.ClassType.cloneWithLiteral(type.classType, true));\n                }\n                else if (node.constType === 14 /* False */) {\n                    type = types_1.ObjectType.create(types_1.ClassType.cloneWithLiteral(type.classType, false));\n                }\n            }\n        }\n        if (!type) {\n            return undefined;\n        }\n        return { type, node };\n    }\n    function getTypeFromUnaryOperation(node, expectedType) {\n        let exprType = typeUtils_1.makeTypeVarsConcrete(getTypeOfExpression(node.expression).type);\n        // Map unary operators to magic functions. Note that the bitwise\n        // invert has two magic functions that are aliases of each other.\n        const unaryOperatorMap = {\n            [0 /* Add */]: '__pos__',\n            [33 /* Subtract */]: '__neg__',\n            [5 /* BitwiseInvert */]: '__invert__',\n        };\n        let type;\n        if (node.operator !== 38 /* Not */) {\n            if (typeUtils_1.isOptionalType(exprType)) {\n                addDiagnostic(getFileInfo(node).diagnosticRuleSet.reportOptionalOperand, \"reportOptionalOperand\" /* reportOptionalOperand */, localize_1.Localizer.Diagnostic.noneOperator().format({\n                    operator: ParseTreeUtils.printOperator(node.operator),\n                }), node.expression);\n                exprType = types_1.removeNoneFromUnion(exprType);\n            }\n        }\n        // __not__ always returns a boolean.\n        if (node.operator === 38 /* Not */) {\n            type = getBuiltInObject(node, 'bool');\n            if (!type) {\n                type = types_1.UnknownType.create();\n            }\n        }\n        else {\n            if (types_1.isAnyOrUnknown(exprType)) {\n                type = exprType;\n            }\n            else {\n                const magicMethodName = unaryOperatorMap[node.operator];\n                type = getTypeFromMagicMethodReturn(exprType, [], magicMethodName, node, expectedType);\n            }\n            if (!type) {\n                const fileInfo = getFileInfo(node);\n                addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.typeNotSupportUnaryOperator().format({\n                    operator: ParseTreeUtils.printOperator(node.operator),\n                    type: printType(exprType),\n                }), node);\n                type = types_1.UnknownType.create();\n            }\n        }\n        return { type, node };\n    }\n    function getTypeFromBinaryOperation(node, expectedType, flags) {\n        let leftExpression = node.leftExpression;\n        // If this is a comparison and the left expression is also a comparison,\n        // we need to change the behavior to accommodate python's \"chained\n        // comparisons\" feature.\n        if (comparisonOperatorMap[node.operator]) {\n            if (node.leftExpression.nodeType === 7 /* BinaryOperation */ &&\n                !node.leftExpression.parenthesized &&\n                comparisonOperatorMap[node.leftExpression.operator]) {\n                // Evaluate the left expression so it is type checked.\n                getTypeFromBinaryOperation(node.leftExpression, expectedType, flags);\n                // Use the right side of the left expression for comparison purposes.\n                leftExpression = node.leftExpression.rightExpression;\n            }\n        }\n        let leftType = typeUtils_1.makeTypeVarsConcrete(getTypeOfExpression(leftExpression).type);\n        let rightType = typeUtils_1.makeTypeVarsConcrete(getTypeOfExpression(node.rightExpression).type);\n        // Is this a \"|\" operator used in a context where it is supposed to be\n        // interpreted as a union operator?\n        if (node.operator === 6 /* BitwiseOr */) {\n            let adjustedRightType = rightType;\n            if (!types_1.isNone(leftType) && types_1.isNone(rightType) && types_1.TypeBase.isInstance(rightType)) {\n                // Handle the special case where \"None\" is being added to the union\n                // with something else. Even though \"None\" will normally be interpreted\n                // as the None singleton object in contexts where a type annotation isn't\n                // assumed, we'll allow it here.\n                adjustedRightType = types_1.NoneType.createType();\n            }\n            if (types_1.isUnionableType([leftType, adjustedRightType])) {\n                const fileInfo = getFileInfo(node);\n                const unionNotationSupported = fileInfo.isStubFile || fileInfo.executionEnvironment.pythonVersion >= pythonVersion_1.PythonVersion.V3_10;\n                if (!unionNotationSupported) {\n                    addError(localize_1.Localizer.Diagnostic.unionSyntaxIllegal(), node, node.operatorToken);\n                }\n                return {\n                    type: types_1.combineTypes([leftType, adjustedRightType]),\n                    node,\n                };\n            }\n        }\n        // Optional checks apply to all operations except for boolean operations.\n        if (booleanOperatorMap[node.operator] === undefined) {\n            if (typeUtils_1.isOptionalType(leftType)) {\n                // Skip the optional error reporting for == and !=, since\n                // None is a valid operand for these operators.\n                if (node.operator !== 12 /* Equals */ && node.operator !== 28 /* NotEquals */) {\n                    addDiagnostic(getFileInfo(node).diagnosticRuleSet.reportOptionalOperand, \"reportOptionalOperand\" /* reportOptionalOperand */, localize_1.Localizer.Diagnostic.noneOperator().format({\n                        operator: ParseTreeUtils.printOperator(node.operator),\n                    }), node.leftExpression);\n                }\n                leftType = types_1.removeNoneFromUnion(leftType);\n            }\n            // None is a valid operand for == and != even if the type stub says otherwise.\n            if (node.operator === 12 /* Equals */ || node.operator === 28 /* NotEquals */) {\n                rightType = types_1.removeNoneFromUnion(rightType);\n            }\n        }\n        return {\n            type: validateBinaryOperation(node.operator, leftType, rightType, node, expectedType),\n            node,\n        };\n    }\n    function getTypeFromAugmentedAssignment(node, expectedType) {\n        const operatorMap = {\n            [1 /* AddEqual */]: ['__iadd__', 0 /* Add */],\n            [34 /* SubtractEqual */]: ['__isub__', 33 /* Subtract */],\n            [27 /* MultiplyEqual */]: ['__imul__', 26 /* Multiply */],\n            [14 /* FloorDivideEqual */]: ['__ifloordiv__', 13 /* FloorDivide */],\n            [11 /* DivideEqual */]: ['__itruediv__', 10 /* Divide */],\n            [25 /* ModEqual */]: ['__imod__', 24 /* Mod */],\n            [30 /* PowerEqual */]: ['__ipow__', 29 /* Power */],\n            [23 /* MatrixMultiplyEqual */]: ['__imatmul__', 22 /* MatrixMultiply */],\n            [4 /* BitwiseAndEqual */]: ['__iand__', 3 /* BitwiseAnd */],\n            [7 /* BitwiseOrEqual */]: ['__ior__', 6 /* BitwiseOr */],\n            [9 /* BitwiseXorEqual */]: ['__ixor__', 8 /* BitwiseXor */],\n            [18 /* LeftShiftEqual */]: ['__ilshift__', 17 /* LeftShift */],\n            [32 /* RightShiftEqual */]: ['__irshift__', 31 /* RightShift */],\n        };\n        let type;\n        const leftType = typeUtils_1.makeTypeVarsConcrete(getTypeOfExpression(node.leftExpression).type);\n        const rightType = typeUtils_1.makeTypeVarsConcrete(getTypeOfExpression(node.rightExpression).type);\n        type = typeUtils_1.doForSubtypes(leftType, (leftSubtype) => {\n            return typeUtils_1.doForSubtypes(rightType, (rightSubtype) => {\n                if (types_1.isAnyOrUnknown(leftSubtype) || types_1.isAnyOrUnknown(rightSubtype)) {\n                    // If either type is \"Unknown\" (versus Any), propagate the Unknown.\n                    if (types_1.isUnknown(leftSubtype) || types_1.isUnknown(rightSubtype)) {\n                        return types_1.UnknownType.create();\n                    }\n                    else {\n                        return types_1.AnyType.create();\n                    }\n                }\n                const magicMethodName = operatorMap[node.operator][0];\n                return getTypeFromMagicMethodReturn(leftSubtype, [rightSubtype], magicMethodName, node, expectedType);\n            });\n        });\n        // If the LHS class didn't support the magic method for augmented\n        // assignment, fall back on the normal binary expression evaluator.\n        if (!type || types_1.isNever(type)) {\n            const binaryOperator = operatorMap[node.operator][1];\n            type = validateBinaryOperation(binaryOperator, leftType, rightType, node, expectedType);\n        }\n        return type;\n    }\n    function validateBinaryOperation(operator, leftType, rightType, errorNode, expectedType) {\n        let type;\n        if (arithmeticOperatorMap[operator]) {\n            type = typeUtils_1.doForSubtypes(leftType, (leftSubtype) => {\n                return typeUtils_1.doForSubtypes(rightType, (rightSubtype) => {\n                    if (types_1.isAnyOrUnknown(leftSubtype) || types_1.isAnyOrUnknown(rightSubtype)) {\n                        // If either type is \"Unknown\" (versus Any), propagate the Unknown.\n                        if (types_1.isUnknown(leftSubtype) || types_1.isUnknown(rightSubtype)) {\n                            return types_1.UnknownType.create();\n                        }\n                        else {\n                            return types_1.AnyType.create();\n                        }\n                    }\n                    const magicMethodName = arithmeticOperatorMap[operator][0];\n                    const resultType = getTypeFromMagicMethodReturn(leftSubtype, [rightSubtype], magicMethodName, errorNode, expectedType);\n                    if (resultType) {\n                        return resultType;\n                    }\n                    const altMagicMethodName = arithmeticOperatorMap[operator][1];\n                    return getTypeFromMagicMethodReturn(rightSubtype, [leftSubtype], altMagicMethodName, errorNode, expectedType);\n                });\n            });\n        }\n        else if (bitwiseOperatorMap[operator]) {\n            type = typeUtils_1.doForSubtypes(leftType, (leftSubtype) => {\n                return typeUtils_1.doForSubtypes(rightType, (rightSubtype) => {\n                    if (types_1.isAnyOrUnknown(leftSubtype) || types_1.isAnyOrUnknown(rightSubtype)) {\n                        // If either type is \"Unknown\" (versus Any), propagate the Unknown.\n                        if (types_1.isUnknown(leftSubtype) || types_1.isUnknown(rightSubtype)) {\n                            return types_1.UnknownType.create();\n                        }\n                        else {\n                            return types_1.AnyType.create();\n                        }\n                    }\n                    // Handle the general case.\n                    const magicMethodName = bitwiseOperatorMap[operator][0];\n                    return getTypeFromMagicMethodReturn(leftSubtype, [rightSubtype], magicMethodName, errorNode, expectedType);\n                });\n            });\n        }\n        else if (comparisonOperatorMap[operator]) {\n            type = typeUtils_1.doForSubtypes(leftType, (leftSubtype) => {\n                return typeUtils_1.doForSubtypes(rightType, (rightSubtype) => {\n                    if (types_1.isAnyOrUnknown(leftSubtype) || types_1.isAnyOrUnknown(rightSubtype)) {\n                        // If either type is \"Unknown\" (versus Any), propagate the Unknown.\n                        if (types_1.isUnknown(leftSubtype) || types_1.isUnknown(rightSubtype)) {\n                            return types_1.UnknownType.create();\n                        }\n                        else {\n                            return types_1.AnyType.create();\n                        }\n                    }\n                    const magicMethodName = comparisonOperatorMap[operator][0];\n                    const resultType = getTypeFromMagicMethodReturn(leftSubtype, [rightSubtype], magicMethodName, errorNode, expectedType);\n                    if (resultType) {\n                        return resultType;\n                    }\n                    const altMagicMethodName = comparisonOperatorMap[operator][1];\n                    return getTypeFromMagicMethodReturn(rightSubtype, [leftSubtype], altMagicMethodName, errorNode, expectedType);\n                });\n            });\n        }\n        else if (booleanOperatorMap[operator]) {\n            // If it's an AND or OR, we need to handle short-circuiting by\n            // eliminating any known-truthy or known-falsy types.\n            if (operator === 36 /* And */) {\n                leftType = typeUtils_1.removeTruthinessFromType(leftType);\n                // If the LHS evaluates to False, the And expression will\n                // always return the type of the right-hand side.\n                if (types_1.isNever(leftType)) {\n                    return rightType;\n                }\n            }\n            else if (operator === 37 /* Or */) {\n                leftType = typeUtils_1.removeFalsinessFromType(leftType);\n                // If the LHS evaluates to True, the Or expression will\n                // always return the type of the right-hand side.\n                if (types_1.isNever(leftType)) {\n                    return rightType;\n                }\n            }\n            // The \"in\" and \"not in\" operators make use of the __contains__\n            // magic method.\n            if (operator === 41 /* In */ || operator === 42 /* NotIn */) {\n                type = typeUtils_1.doForSubtypes(rightType, (rightSubtype) => {\n                    return typeUtils_1.doForSubtypes(leftType, (leftSubtype) => {\n                        if (types_1.isAnyOrUnknown(rightSubtype) || types_1.isAnyOrUnknown(leftSubtype)) {\n                            // If either type is \"Unknown\" (versus Any), propagate the Unknown.\n                            if (types_1.isUnknown(leftSubtype) || types_1.isUnknown(rightSubtype)) {\n                                return types_1.UnknownType.create();\n                            }\n                            else {\n                                return types_1.AnyType.create();\n                            }\n                        }\n                        return getTypeFromMagicMethodReturn(rightSubtype, [leftSubtype], '__contains__', errorNode, \n                        /* expectedType */ undefined);\n                    });\n                });\n                // Assume that a bool is returned even if the type is unknown\n                if (type && !types_1.isNever(type)) {\n                    type = getBuiltInObject(errorNode, 'bool');\n                }\n            }\n            else {\n                type = typeUtils_1.doForSubtypes(leftType, (leftSubtype) => {\n                    return typeUtils_1.doForSubtypes(rightType, (rightSubtype) => {\n                        // If the operator is an AND or OR, we need to combine the two types.\n                        if (operator === 36 /* And */ || operator === 37 /* Or */) {\n                            return types_1.combineTypes([leftSubtype, rightSubtype]);\n                        }\n                        // The other boolean operators always return a bool value.\n                        return getBuiltInObject(errorNode, 'bool');\n                    });\n                });\n            }\n        }\n        if (!type || types_1.isNever(type)) {\n            const fileInfo = getFileInfo(errorNode);\n            addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.typeNotSupportBinaryOperator().format({\n                operator: ParseTreeUtils.printOperator(operator),\n                leftType: printType(leftType),\n                rightType: printType(rightType),\n            }), errorNode);\n            type = types_1.UnknownType.create();\n        }\n        return type;\n    }\n    function getTypeFromMagicMethodReturn(objType, args, magicMethodName, errorNode, expectedType) {\n        let magicMethodSupported = true;\n        // Create a helper lambda for object subtypes.\n        const handleObjectSubtype = (subtype, bindToClassType) => {\n            const magicMethodType = getTypeFromObjectMember(errorNode, subtype, magicMethodName, { method: 'get' }, new diagnostic_1.DiagnosticAddendum(), 9 /* SkipForMethodLookup */, bindToClassType);\n            if (magicMethodType) {\n                const functionArgs = args.map((arg) => {\n                    return {\n                        argumentCategory: 0 /* Simple */,\n                        type: arg,\n                    };\n                });\n                let callResult;\n                suppressDiagnostics(() => {\n                    callResult = validateCallArguments(errorNode, functionArgs, magicMethodType, new typeVarMap_1.TypeVarMap(), \n                    /* skipUnknownArgCheck */ true, \n                    /* inferFunctionReturnType */ true, expectedType);\n                });\n                if (callResult.argumentErrors) {\n                    magicMethodSupported = false;\n                }\n                return callResult.returnType;\n            }\n            magicMethodSupported = false;\n            return undefined;\n        };\n        const returnType = typeUtils_1.doForSubtypes(objType, (subtype) => {\n            if (types_1.isAnyOrUnknown(subtype)) {\n                return subtype;\n            }\n            if (types_1.isObject(subtype)) {\n                return handleObjectSubtype(subtype);\n            }\n            else if (types_1.isClass(subtype)) {\n                // See if the class has a metaclass that handles the operation.\n                const metaclass = typeUtils_1.getMetaclass(subtype);\n                if (metaclass && types_1.isClass(metaclass)) {\n                    return handleObjectSubtype(types_1.ObjectType.create(metaclass), subtype);\n                }\n            }\n            else if (types_1.isNone(subtype)) {\n                // NoneType derives from 'object', so do the lookup on 'object'\n                // in this case.\n                const obj = getBuiltInObject(errorNode, 'object');\n                if (types_1.isObject(obj)) {\n                    return handleObjectSubtype(obj);\n                }\n            }\n            magicMethodSupported = false;\n            return undefined;\n        });\n        if (!magicMethodSupported) {\n            return undefined;\n        }\n        return returnType;\n    }\n    function getTypeFromSet(node, expectedType) {\n        const entryTypes = node.entries.map((entryNode) => {\n            if (entryNode.nodeType === 33 /* ListComprehension */) {\n                return getElementTypeFromListComprehension(entryNode);\n            }\n            return getTypeOfExpression(entryNode).type;\n        });\n        // If there is an expected type, see if we can match it.\n        if (expectedType && entryTypes.length > 0) {\n            const narrowedExpectedType = typeUtils_1.doForSubtypes(expectedType, (subtype) => {\n                if (types_1.isObject(subtype)) {\n                    const classAlias = subtype.classType.details.aliasClass || subtype.classType;\n                    if (types_1.ClassType.isBuiltIn(classAlias, 'set') && subtype.classType.typeArguments) {\n                        const typeArg = subtype.classType.typeArguments[0];\n                        const typeVarMap = new typeVarMap_1.TypeVarMap();\n                        for (const entryType of entryTypes) {\n                            if (!canAssignType(typeArg, entryType, new diagnostic_1.DiagnosticAddendum(), typeVarMap)) {\n                                return undefined;\n                            }\n                        }\n                        return typeUtils_1.specializeType(subtype, typeVarMap);\n                    }\n                }\n                return undefined;\n            });\n            if (!types_1.isNever(narrowedExpectedType)) {\n                return { type: narrowedExpectedType, node };\n            }\n        }\n        let inferredEntryType = entryTypes.length > 0 ? types_1.combineTypes(entryTypes.map((t) => typeUtils_1.stripLiteralValue(t))) : types_1.AnyType.create();\n        // If we weren't provided an expected type, strip away any\n        // literals from the set.\n        if (!expectedType) {\n            inferredEntryType = typeUtils_1.stripLiteralValue(inferredEntryType);\n        }\n        const type = getBuiltInObject(node, 'set', [inferredEntryType]);\n        return { type, node };\n    }\n    function getTypeFromDictionary(node, expectedType) {\n        let keyType = types_1.AnyType.create();\n        let valueType = types_1.AnyType.create();\n        let keyTypes = [];\n        let valueTypes = [];\n        let expectedKeyType;\n        let expectedValueType;\n        let expectedTypedDictEntries;\n        const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n        if (expectedType && types_1.isObject(expectedType)) {\n            const expectedClass = expectedType.classType;\n            if (types_1.ClassType.isBuiltIn(expectedClass, 'Dict') || types_1.ClassType.isBuiltIn(expectedClass, 'dict')) {\n                if (expectedClass.typeArguments && expectedClass.typeArguments.length === 2) {\n                    expectedKeyType = typeUtils_1.specializeType(expectedClass.typeArguments[0], /* typeVarMap */ undefined);\n                    expectedValueType = typeUtils_1.specializeType(expectedClass.typeArguments[1], /* typeVarMap */ undefined);\n                }\n            }\n            else if (types_1.ClassType.isTypedDictClass(expectedClass)) {\n                expectedTypedDictEntries = getTypedDictMembersForClass(expectedClass);\n            }\n        }\n        // Infer the key and value types if possible.\n        node.entries.forEach((entryNode) => {\n            let addUnknown = true;\n            if (entryNode.nodeType === 17 /* DictionaryKeyEntry */) {\n                const keyType = getTypeOfExpression(entryNode.keyExpression, expectedKeyType).type;\n                let valueType;\n                if (expectedTypedDictEntries &&\n                    types_1.isObject(keyType) &&\n                    types_1.ClassType.isBuiltIn(keyType.classType, 'str') &&\n                    keyType.classType.literalValue &&\n                    expectedTypedDictEntries.has(keyType.classType.literalValue)) {\n                    valueType = getTypeOfExpression(entryNode.valueExpression, expectedTypedDictEntries.get(keyType.classType.literalValue).valueType).type;\n                }\n                else {\n                    valueType = getTypeOfExpression(entryNode.valueExpression, expectedValueType).type;\n                }\n                keyTypes.push(keyType);\n                valueTypes.push(valueType);\n                addUnknown = false;\n            }\n            else if (entryNode.nodeType === 16 /* DictionaryExpandEntry */) {\n                const unexpandedType = getTypeOfExpression(entryNode.expandExpression).type;\n                if (types_1.isAnyOrUnknown(unexpandedType)) {\n                    addUnknown = false;\n                }\n                else {\n                    if (types_1.isObject(unexpandedType)) {\n                        const classType = unexpandedType.classType;\n                        const aliasType = classType.details.aliasClass || classType;\n                        if (types_1.ClassType.isBuiltIn(aliasType, 'dict')) {\n                            const typeArgs = classType.typeArguments;\n                            if (typeArgs && typeArgs.length >= 2) {\n                                keyTypes.push(typeArgs[0]);\n                                valueTypes.push(typeArgs[1]);\n                                addUnknown = false;\n                            }\n                        }\n                    }\n                }\n            }\n            else if (entryNode.nodeType === 33 /* ListComprehension */) {\n                const dictEntryType = getElementTypeFromListComprehension(entryNode);\n                // The result should be a Tuple\n                if (types_1.isObject(dictEntryType)) {\n                    const classType = dictEntryType.classType;\n                    if (types_1.ClassType.isBuiltIn(classType, 'Tuple')) {\n                        const typeArgs = classType.typeArguments;\n                        if (typeArgs && typeArgs.length === 2) {\n                            keyTypes.push(typeArgs[0]);\n                            valueTypes.push(typeArgs[1]);\n                            addUnknown = false;\n                        }\n                    }\n                }\n            }\n            if (addUnknown) {\n                keyTypes.push(types_1.UnknownType.create());\n                valueTypes.push(types_1.UnknownType.create());\n            }\n        });\n        // If there is an expected type, see if we can match any parts of it.\n        if (expectedType) {\n            const narrowedExpectedType = typeUtils_1.doForSubtypes(expectedType, (subtype) => {\n                if (!types_1.isObject(subtype)) {\n                    return undefined;\n                }\n                if (types_1.ClassType.isTypedDictClass(subtype.classType) &&\n                    canAssignToTypedDict(subtype.classType, keyTypes, valueTypes, diagAddendum)) {\n                    return subtype;\n                }\n                const classAlias = subtype.classType.details.aliasClass || subtype.classType;\n                if (types_1.ClassType.isBuiltIn(classAlias, 'dict') && subtype.classType.typeArguments) {\n                    const typeArg0 = subtype.classType.typeArguments[0];\n                    const typeArg1 = subtype.classType.typeArguments[1];\n                    const typeVarMap = new typeVarMap_1.TypeVarMap();\n                    for (const keyType of keyTypes) {\n                        if (!canAssignType(typeArg0, keyType, new diagnostic_1.DiagnosticAddendum(), typeVarMap)) {\n                            return undefined;\n                        }\n                    }\n                    for (const valueType of valueTypes) {\n                        if (!canAssignType(typeArg1, valueType, new diagnostic_1.DiagnosticAddendum(), typeVarMap)) {\n                            return undefined;\n                        }\n                    }\n                    return typeUtils_1.specializeType(subtype, typeVarMap);\n                }\n                return undefined;\n            });\n            if (!types_1.isNever(narrowedExpectedType)) {\n                return { type: narrowedExpectedType, node };\n            }\n        }\n        // Strip any literal values.\n        keyTypes = keyTypes.map((t) => typeUtils_1.stripLiteralValue(t));\n        valueTypes = valueTypes.map((t) => typeUtils_1.stripLiteralValue(t));\n        keyType = keyTypes.length > 0 ? types_1.combineTypes(keyTypes) : types_1.AnyType.create();\n        // If the value type differs and we're not using \"strict inference mode\",\n        // we need to back off because we can't properly represent the mappings\n        // between different keys and associated value types. If all the values\n        // are the same type, we'll assume that all values in this dictionary should\n        // be the same.\n        if (valueTypes.length > 0) {\n            if (getFileInfo(node).diagnosticRuleSet.strictDictionaryInference) {\n                valueType = types_1.combineTypes(valueTypes);\n            }\n            else {\n                valueType = typeUtils_1.areTypesSame(valueTypes) ? valueTypes[0] : types_1.UnknownType.create();\n            }\n        }\n        else {\n            valueType = types_1.AnyType.create();\n        }\n        // If we weren't provided an expected type, strip away any\n        // literals from the key and value.\n        if (!expectedType) {\n            keyType = typeUtils_1.stripLiteralValue(keyType);\n            valueType = typeUtils_1.stripLiteralValue(valueType);\n        }\n        const type = getBuiltInObject(node, 'dict', [keyType, valueType]);\n        return { type, node, expectedTypeDiagAddendum: !diagAddendum.isEmpty() ? diagAddendum : undefined };\n    }\n    function getTypeFromList(node, expectedType) {\n        // Define a local helper function that determines whether a\n        // type is a list and returns the list element type if it is.\n        const getListTypeArg = (potentialList) => {\n            return typeUtils_1.doForSubtypes(potentialList, (subtype) => {\n                if (!types_1.isObject(subtype)) {\n                    return undefined;\n                }\n                const classAlias = subtype.classType.details.aliasClass || subtype.classType;\n                if (!types_1.ClassType.isBuiltIn(classAlias, 'list') || !subtype.classType.typeArguments) {\n                    return undefined;\n                }\n                return subtype.classType.typeArguments[0];\n            });\n        };\n        const expectedEntryType = expectedType ? getListTypeArg(expectedType) : undefined;\n        let entryTypes = node.entries.map((entry) => {\n            if (entry.nodeType === 33 /* ListComprehension */) {\n                return getElementTypeFromListComprehension(entry);\n            }\n            return getTypeOfExpression(entry, expectedEntryType).type;\n        });\n        // If there is an expected type, see if we can match it.\n        if (expectedType && entryTypes.length > 0) {\n            const narrowedExpectedType = typeUtils_1.doForSubtypes(expectedType, (subtype) => {\n                const listElementType = getListTypeArg(subtype);\n                if (listElementType) {\n                    const typeVarMap = new typeVarMap_1.TypeVarMap();\n                    for (const entryType of entryTypes) {\n                        if (!canAssignType(listElementType, entryType, new diagnostic_1.DiagnosticAddendum(), typeVarMap)) {\n                            return undefined;\n                        }\n                    }\n                    return typeUtils_1.specializeType(subtype, typeVarMap);\n                }\n                return undefined;\n            });\n            if (!types_1.isNever(narrowedExpectedType)) {\n                return { type: narrowedExpectedType, node };\n            }\n        }\n        entryTypes = entryTypes.map((t) => typeUtils_1.stripLiteralValue(t));\n        let inferredEntryType = types_1.AnyType.create();\n        if (entryTypes.length > 0) {\n            // If there was an expected type or we're using strict list inference,\n            // combine the types into a union.\n            if (expectedType || getFileInfo(node).diagnosticRuleSet.strictListInference) {\n                inferredEntryType = types_1.combineTypes(entryTypes);\n            }\n            else {\n                // Is the list homogeneous? If so, use stricter rules. Otherwise relax the rules.\n                inferredEntryType = typeUtils_1.areTypesSame(entryTypes) ? entryTypes[0] : types_1.UnknownType.create();\n            }\n        }\n        // If we weren't provided an expected type, strip away any\n        // literals from the list. The user is probably not expecting\n        // ['a'] to be interpreted as type List[Literal['a']] but\n        // instead List[str].\n        if (!expectedType) {\n            inferredEntryType = typeUtils_1.stripLiteralValue(inferredEntryType);\n        }\n        const type = getBuiltInObject(node, 'list', [inferredEntryType]);\n        return { type, node };\n    }\n    function getTypeFromTernary(node, flags) {\n        getTypeOfExpression(node.testExpression);\n        const ifType = getTypeOfExpression(node.ifExpression, undefined, flags);\n        const elseType = getTypeOfExpression(node.elseExpression, undefined, flags);\n        const type = types_1.combineTypes([ifType.type, elseType.type]);\n        return { type, node };\n    }\n    function getTypeFromYield(node) {\n        let sentType;\n        const enclosingFunction = ParseTreeUtils.getEnclosingFunction(node);\n        if (enclosingFunction) {\n            const functionTypeInfo = getTypeOfFunction(enclosingFunction);\n            if (functionTypeInfo) {\n                sentType = typeUtils_1.getDeclaredGeneratorSendType(functionTypeInfo.functionType);\n            }\n        }\n        if (!sentType) {\n            sentType = types_1.UnknownType.create();\n        }\n        if (node.expression) {\n            getTypeOfExpression(node.expression, sentType);\n        }\n        return { type: sentType, node };\n    }\n    function getTypeFromYieldFrom(node) {\n        let sentType;\n        const enclosingFunction = ParseTreeUtils.getEnclosingFunction(node);\n        if (enclosingFunction) {\n            const functionTypeInfo = getTypeOfFunction(enclosingFunction);\n            if (functionTypeInfo) {\n                sentType = typeUtils_1.getDeclaredGeneratorSendType(functionTypeInfo.functionType);\n            }\n        }\n        if (!sentType) {\n            sentType = types_1.UnknownType.create();\n        }\n        if (node.expression) {\n            getTypeOfExpression(node.expression, sentType);\n        }\n        return { type: sentType, node };\n    }\n    function getTypeFromLambda(node, expectedType) {\n        const functionType = types_1.FunctionType.createInstance('', 0 /* None */);\n        // Pre-cache the newly-created function type.\n        writeTypeCache(node, functionType);\n        let expectedFunctionType;\n        if (expectedType) {\n            if (expectedType.category === 5 /* Function */) {\n                expectedFunctionType = expectedType;\n            }\n            else if (expectedType.category === 10 /* Union */) {\n                // It's not clear what we should do with a union type. For now,\n                // simply use the first function in the union.\n                expectedFunctionType = expectedType.subtypes.find((t) => t.category === 5 /* Function */);\n            }\n        }\n        node.parameters.forEach((param, index) => {\n            let paramType = types_1.UnknownType.create();\n            if (expectedFunctionType && index < expectedFunctionType.details.parameters.length) {\n                paramType = types_1.FunctionType.getEffectiveParameterType(expectedFunctionType, index);\n                paramType = typeUtils_1.specializeType(paramType, /* typeVarMap */ undefined, /* makeConcrete */ true);\n            }\n            if (param.name) {\n                writeTypeCache(param.name, paramType);\n            }\n            if (param.defaultValue) {\n                // Evaluate the default value if it's present.\n                getTypeOfExpression(param.defaultValue, undefined, 1 /* ConvertEllipsisToAny */);\n            }\n            const functionParam = {\n                category: param.category,\n                name: param.name ? param.name.value : undefined,\n                hasDefault: !!param.defaultValue,\n                type: paramType,\n            };\n            types_1.FunctionType.addParameter(functionType, functionParam);\n        });\n        const expectedReturnType = expectedFunctionType\n            ? getFunctionEffectiveReturnType(expectedFunctionType)\n            : undefined;\n        functionType.inferredReturnType = getTypeOfExpression(node.expression, expectedReturnType).type;\n        return { type: functionType, node };\n    }\n    function getTypeFromListComprehension(node) {\n        const elementType = getElementTypeFromListComprehension(node);\n        const isAsync = node.comprehensions.some((comp) => {\n            return comp.nodeType === 34 /* ListComprehensionFor */ && comp.isAsync;\n        });\n        let type = types_1.UnknownType.create();\n        const builtInIteratorType = getTypingType(node, isAsync ? 'AsyncGenerator' : 'Generator');\n        if (builtInIteratorType && types_1.isClass(builtInIteratorType)) {\n            type = types_1.ObjectType.create(types_1.ClassType.cloneForSpecialization(builtInIteratorType, [elementType], /* isTypeArgumentExplicit */ false));\n        }\n        return { type, node };\n    }\n    function reportPossibleUnknownAssignment(diagLevel, rule, target, type, errorNode) {\n        // Don't bother if the feature is disabled.\n        if (diagLevel === 'none') {\n            return;\n        }\n        const nameValue = target.value;\n        // Sometimes variables contain an \"unbound\" type if they're\n        // assigned only within conditional statements. Remove this\n        // to avoid confusion.\n        const simplifiedType = types_1.removeUnboundFromUnion(type);\n        if (types_1.isUnknown(simplifiedType)) {\n            addDiagnostic(diagLevel, rule, localize_1.Localizer.Diagnostic.typeUnknown().format({ name: nameValue }), errorNode);\n        }\n        else if (typeUtils_1.isPartlyUnknown(simplifiedType)) {\n            const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n            diagAddendum.addMessage(localize_1.Localizer.DiagnosticAddendum.typeOfSymbol().format({ name: nameValue, type: printType(simplifiedType) }));\n            addDiagnostic(diagLevel, rule, localize_1.Localizer.Diagnostic.typePartiallyUnknown().format({ name: nameValue }) + diagAddendum.getString(), errorNode);\n        }\n    }\n    // Returns the type of one entry returned by the list comprehension,\n    // as opposed to the entire list.\n    function getElementTypeFromListComprehension(node) {\n        // \"Execute\" the list comprehensions from start to finish.\n        for (const comprehension of node.comprehensions) {\n            if (comprehension.nodeType === 34 /* ListComprehensionFor */) {\n                const iterableType = typeUtils_1.stripLiteralValue(getTypeOfExpression(comprehension.iterableExpression).type);\n                const itemType = getTypeFromIterable(iterableType, !!comprehension.isAsync, comprehension.iterableExpression, \n                /* supportGetItem */ false);\n                const targetExpr = comprehension.targetExpression;\n                assignTypeToExpression(targetExpr, itemType, comprehension.iterableExpression);\n            }\n            else {\n                debug_1.assert(comprehension.nodeType === 35 /* ListComprehensionIf */);\n                // Evaluate the test expression to validate it and mark symbols\n                // as referenced. Don't bother doing this if we're in speculative\n                // mode because it doesn't affect the element type.\n                if (!isSpeculativeMode(comprehension.testExpression)) {\n                    getTypeOfExpression(comprehension.testExpression);\n                }\n            }\n        }\n        let type = types_1.UnknownType.create();\n        if (node.expression.nodeType === 17 /* DictionaryKeyEntry */) {\n            // Create a tuple with the key/value types.\n            const keyType = typeUtils_1.stripLiteralValue(getTypeOfExpression(node.expression.keyExpression).type);\n            const valueType = typeUtils_1.stripLiteralValue(getTypeOfExpression(node.expression.valueExpression).type);\n            type = getBuiltInObject(node, 'Tuple', [keyType, valueType]);\n        }\n        else if (node.expression.nodeType === 16 /* DictionaryExpandEntry */) {\n            getTypeOfExpression(node.expression.expandExpression);\n            // TODO - need to implement\n        }\n        else if (parseNodes_1.isExpressionNode(node)) {\n            type = typeUtils_1.stripLiteralValue(getTypeOfExpression(node.expression).type);\n        }\n        return type;\n    }\n    function getTypeFromSlice(node) {\n        // Evaluate the expressions to report errors and record symbol references.\n        if (node.startValue) {\n            getTypeOfExpression(node.startValue);\n        }\n        if (node.endValue) {\n            getTypeOfExpression(node.endValue);\n        }\n        if (node.stepValue) {\n            getTypeOfExpression(node.stepValue);\n        }\n        return { type: getBuiltInObject(node, 'slice'), node };\n    }\n    // Converts the type parameters for a Callable type. It should\n    // have zero to two parameters. The first parameter, if present, should be\n    // either an ellipsis or a list of parameter types. The second parameter, if\n    // present, should specify the return type.\n    function createCallableType(typeArgs) {\n        const functionType = types_1.FunctionType.createInstantiable('', 0 /* None */);\n        functionType.details.declaredReturnType = types_1.AnyType.create();\n        if (typeArgs && typeArgs.length > 0) {\n            if (typeArgs[0].typeList) {\n                typeArgs[0].typeList.forEach((entry, index) => {\n                    if (typeUtils_1.isEllipsisType(entry.type)) {\n                        addError(localize_1.Localizer.Diagnostic.ellipsisContext(), entry.node);\n                    }\n                    else if (types_1.isModule(entry.type)) {\n                        addError(localize_1.Localizer.Diagnostic.moduleContext(), entry.node);\n                    }\n                    else if (typeUtils_1.isParamSpecType(entry.type)) {\n                        addError(localize_1.Localizer.Diagnostic.paramSpecContext(), entry.node);\n                    }\n                    types_1.FunctionType.addParameter(functionType, {\n                        category: 0 /* Simple */,\n                        name: `p${index.toString()}`,\n                        isNameSynthesized: true,\n                        type: typeUtils_1.convertToInstance(entry.type),\n                        hasDeclaredType: true,\n                    });\n                });\n            }\n            else if (typeUtils_1.isEllipsisType(typeArgs[0].type)) {\n                types_1.FunctionType.addDefaultParameters(functionType);\n            }\n            else if (typeUtils_1.isParamSpecType(typeArgs[0].type)) {\n                types_1.FunctionType.addDefaultParameters(functionType);\n                functionType.details.paramSpec = typeArgs[0].type;\n            }\n            else {\n                addError(localize_1.Localizer.Diagnostic.callableFirstArg(), typeArgs[0].node);\n            }\n        }\n        else {\n            types_1.FunctionType.addDefaultParameters(functionType, /* useUnknown */ true);\n        }\n        if (typeArgs && typeArgs.length > 1) {\n            if (typeUtils_1.isEllipsisType(typeArgs[1].type)) {\n                addError(localize_1.Localizer.Diagnostic.ellipsisContext(), typeArgs[1].node);\n            }\n            else if (types_1.isModule(typeArgs[1].type)) {\n                addError(localize_1.Localizer.Diagnostic.moduleContext(), typeArgs[1].node);\n            }\n            else if (typeUtils_1.isParamSpecType(typeArgs[1].type)) {\n                addError(localize_1.Localizer.Diagnostic.paramSpecContext(), typeArgs[1].node);\n            }\n            functionType.details.declaredReturnType = typeUtils_1.convertToInstance(typeArgs[1].type);\n        }\n        else {\n            functionType.details.declaredReturnType = types_1.UnknownType.create();\n        }\n        if (typeArgs && typeArgs.length > 2) {\n            addError(localize_1.Localizer.Diagnostic.callableExtraArgs(), typeArgs[2].node);\n        }\n        return functionType;\n    }\n    // Creates an Optional[X, Y, Z] type.\n    function createOptionalType(errorNode, typeArgs) {\n        if (!typeArgs || typeArgs.length !== 1) {\n            addError(localize_1.Localizer.Diagnostic.optionalExtraArgs(), errorNode);\n            return types_1.UnknownType.create();\n        }\n        if (typeUtils_1.isEllipsisType(typeArgs[0].type)) {\n            addError(localize_1.Localizer.Diagnostic.ellipsisContext(), typeArgs[0].node);\n        }\n        else if (types_1.isModule(typeArgs[0].type)) {\n            addError(localize_1.Localizer.Diagnostic.moduleContext(), typeArgs[0].node);\n        }\n        else if (typeUtils_1.isParamSpecType(typeArgs[0].type)) {\n            addError(localize_1.Localizer.Diagnostic.paramSpecContext(), typeArgs[0].node);\n        }\n        else if (!types_1.TypeBase.isInstantiable(typeArgs[0].type)) {\n            addExpectedClassDiagnostic(typeArgs[0].type, typeArgs[0].node);\n        }\n        return types_1.combineTypes([typeArgs[0].type, types_1.NoneType.createType()]);\n    }\n    function cloneBuiltinObjectWithLiteral(node, builtInName, value) {\n        const type = getBuiltInObject(node, builtInName);\n        if (types_1.isObject(type)) {\n            return types_1.ObjectType.create(types_1.ClassType.cloneWithLiteral(type.classType, value));\n        }\n        return types_1.UnknownType.create();\n    }\n    function cloneBuiltinClassWithLiteral(node, builtInName, value) {\n        const type = getBuiltInObject(node, builtInName);\n        if (types_1.isObject(type)) {\n            return types_1.ClassType.cloneWithLiteral(type.classType, value);\n        }\n        return types_1.UnknownType.create();\n    }\n    // Creates a type that represents a Literal. This is not an officially-supported\n    // feature of Python but is instead a mypy extension described here:\n    // https://mypy.readthedocs.io/en/latest/literal_types.html\n    function createLiteralType(node) {\n        if (node.items.items.length === 0) {\n            addError(localize_1.Localizer.Diagnostic.literalEmptyArgs(), node.baseExpression);\n            return types_1.UnknownType.create();\n        }\n        // As per the specification, we support None, int, bool, str, bytes literals\n        // plus enum values.\n        const literalTypes = [];\n        for (const item of node.items.items) {\n            let type;\n            if (item.nodeType === 49 /* StringList */) {\n                const isBytes = (item.strings[0].token.flags & 32 /* Bytes */) !== 0;\n                const value = item.strings.map((s) => s.value).join('');\n                if (isBytes) {\n                    type = cloneBuiltinClassWithLiteral(node, 'bytes', value);\n                }\n                else {\n                    type = cloneBuiltinClassWithLiteral(node, 'str', value);\n                }\n            }\n            else if (item.nodeType === 41 /* Number */) {\n                if (!item.isImaginary && item.isInteger) {\n                    type = cloneBuiltinClassWithLiteral(node, 'int', item.value);\n                }\n            }\n            else if (item.nodeType === 11 /* Constant */) {\n                if (item.constType === 31 /* True */) {\n                    type = cloneBuiltinClassWithLiteral(node, 'bool', true);\n                }\n                else if (item.constType === 14 /* False */) {\n                    type = cloneBuiltinClassWithLiteral(node, 'bool', false);\n                }\n                else if (item.constType === 24 /* None */) {\n                    type = types_1.NoneType.createType();\n                }\n            }\n            else if (item.nodeType === 56 /* UnaryOperation */ && item.operator === 33 /* Subtract */) {\n                if (item.expression.nodeType === 41 /* Number */) {\n                    if (!item.expression.isImaginary && item.expression.isInteger) {\n                        type = cloneBuiltinClassWithLiteral(node, 'int', -item.expression.value);\n                    }\n                }\n            }\n            if (!type) {\n                const exprType = getTypeOfExpression(item);\n                // Is this an enum type?\n                if (types_1.isObject(exprType.type) &&\n                    types_1.ClassType.isEnumClass(exprType.type.classType) &&\n                    exprType.type.classType.literalValue !== undefined) {\n                    type = exprType.type.classType;\n                }\n                else {\n                    // Is this a type alias to an existing literal type?\n                    let isLiteralType = true;\n                    typeUtils_1.doForSubtypes(exprType.type, (subtype) => {\n                        if (!types_1.isClass(subtype) || subtype.literalValue === undefined) {\n                            isLiteralType = false;\n                        }\n                        return undefined;\n                    });\n                    if (isLiteralType) {\n                        type = exprType.type;\n                    }\n                }\n            }\n            if (!type) {\n                addError(localize_1.Localizer.Diagnostic.literalUnsupportedType(), item);\n                type = types_1.UnknownType.create();\n            }\n            literalTypes.push(type);\n        }\n        return types_1.combineTypes(literalTypes);\n    }\n    // Creates a ClassVar type.\n    function createClassVarType(errorNode, typeArgs) {\n        if (!typeArgs || typeArgs.length === 0) {\n            addError(localize_1.Localizer.Diagnostic.classVarFirstArgMissing(), errorNode);\n            return types_1.UnknownType.create();\n        }\n        else if (typeArgs.length > 1) {\n            addError(localize_1.Localizer.Diagnostic.classVarTooManyArgs(), typeArgs[1].node);\n            return types_1.UnknownType.create();\n        }\n        let type = typeArgs[0].type;\n        if (typeUtils_1.requiresSpecialization(type)) {\n            // A ClassVar should not allow generic types, but the typeshed\n            // stubs use this in a few cases. For now, just specialize\n            // it in a general way.\n            type = typeUtils_1.specializeType(type, /* typeVarMap */ undefined);\n        }\n        return type;\n    }\n    // Creates a \"Final\" type.\n    function createFinalType(errorNode, typeArgs, flags) {\n        if (flags & 64 /* FinalDisallowed */) {\n            addError(localize_1.Localizer.Diagnostic.finalContext(), errorNode);\n            return types_1.AnyType.create();\n        }\n        if (!typeArgs || typeArgs.length === 0) {\n            return types_1.AnyType.create();\n        }\n        if (typeArgs.length > 1) {\n            addError(localize_1.Localizer.Diagnostic.finalTooManyArgs(), errorNode);\n        }\n        return typeArgs[0].type;\n    }\n    function createAnnotatedType(errorNode, typeArgs) {\n        if (!typeArgs || typeArgs.length < 1) {\n            addError(localize_1.Localizer.Diagnostic.annotatedTypeArgMissing(), errorNode);\n            return types_1.AnyType.create();\n        }\n        if (typeUtils_1.isEllipsisType(typeArgs[0].type)) {\n            addError(localize_1.Localizer.Diagnostic.ellipsisContext(), typeArgs[0].node);\n        }\n        else if (types_1.isModule(typeArgs[0].type)) {\n            addError(localize_1.Localizer.Diagnostic.moduleContext(), typeArgs[0].node);\n        }\n        else if (typeUtils_1.isParamSpecType(typeArgs[0].type)) {\n            addError(localize_1.Localizer.Diagnostic.paramSpecContext(), typeArgs[1].node);\n        }\n        return typeArgs[0].type;\n    }\n    // Creates one of several \"special\" types that are defined in typing.pyi\n    // but not declared in their entirety. This includes the likes of \"Tuple\",\n    // \"Dict\", etc.\n    function createSpecialType(classType, typeArgs, paramLimit, allowEllipsis = false, allowParamSpec = false) {\n        if (typeArgs) {\n            // Verify that we didn't receive any inappropriate ellipses or modules.\n            typeArgs.forEach((typeArg, index) => {\n                if (typeUtils_1.isEllipsisType(typeArg.type)) {\n                    if (!allowEllipsis) {\n                        addError(localize_1.Localizer.Diagnostic.ellipsisContext(), typeArg.node);\n                    }\n                    else if (typeArgs.length !== 2 || index !== 1) {\n                        addError(localize_1.Localizer.Diagnostic.ellipsisSecondArg(), typeArg.node);\n                    }\n                }\n                else if (types_1.isModule(typeArg.type)) {\n                    addError(localize_1.Localizer.Diagnostic.moduleContext(), typeArg.node);\n                }\n                else if (!allowParamSpec && typeUtils_1.isParamSpecType(typeArg.type)) {\n                    addError(localize_1.Localizer.Diagnostic.paramSpecContext(), typeArg.node);\n                }\n            });\n            // Handle Tuple[()] as a special case, as defined in PEP 483.\n            if (types_1.ClassType.isBuiltIn(classType, 'Tuple')) {\n                if (typeArgs.length === 1) {\n                    const arg0Type = typeArgs[0].type;\n                    if (types_1.isObject(arg0Type) &&\n                        types_1.ClassType.isBuiltIn(arg0Type.classType, 'Tuple') &&\n                        arg0Type.classType.typeArguments &&\n                        arg0Type.classType.typeArguments.length === 0) {\n                        typeArgs = [];\n                    }\n                }\n            }\n        }\n        let typeArgTypes = typeArgs ? typeArgs.map((t) => typeUtils_1.convertToInstance(t.type)) : [];\n        // Make sure the argument list count is correct.\n        if (paramLimit !== undefined) {\n            if (typeArgs && typeArgTypes.length > paramLimit) {\n                addError(localize_1.Localizer.Diagnostic.typeArgsTooMany().format({\n                    expected: paramLimit,\n                    received: typeArgTypes.length,\n                }), typeArgs[paramLimit].node);\n                typeArgTypes = typeArgTypes.slice(0, paramLimit);\n            }\n            else if (typeArgTypes.length < paramLimit) {\n                // Fill up the remainder of the slots with unknown types.\n                while (typeArgTypes.length < paramLimit) {\n                    typeArgTypes.push(types_1.UnknownType.create());\n                }\n            }\n        }\n        // If no type args are provided and ellipses are allowed,\n        // default to [Any, ...]. For example, Tuple is equivalent\n        // to Tuple[Any, ...].\n        if (!typeArgs && allowEllipsis) {\n            typeArgTypes.push(types_1.AnyType.create(false));\n            typeArgTypes.push(types_1.AnyType.create(true));\n        }\n        const specializedType = types_1.ClassType.cloneForSpecialization(classType, typeArgTypes, typeArgs !== undefined);\n        return specializedType;\n    }\n    // Unpacks the index expression for a \"Union[X, Y, Z]\" type annotation.\n    function createUnionType(typeArgs) {\n        const types = [];\n        if (typeArgs) {\n            for (const typeArg of typeArgs) {\n                types.push(typeArg.type);\n                // Verify that we didn't receive any inappropriate ellipses.\n                if (typeUtils_1.isEllipsisType(typeArg.type)) {\n                    addError(localize_1.Localizer.Diagnostic.ellipsisContext(), typeArg.node);\n                }\n                else if (types_1.isModule(typeArg.type)) {\n                    addError(localize_1.Localizer.Diagnostic.moduleContext(), typeArg.node);\n                }\n                else if (typeUtils_1.isParamSpecType(typeArg.type)) {\n                    addError(localize_1.Localizer.Diagnostic.paramSpecContext(), typeArg.node);\n                }\n                else if (!types_1.TypeBase.isInstantiable(typeArg.type)) {\n                    addExpectedClassDiagnostic(typeArg.type, typeArg.node);\n                }\n            }\n        }\n        if (types.length > 0) {\n            return types_1.combineTypes(types);\n        }\n        return types_1.NeverType.create();\n    }\n    // Creates a type that represents \"Generic[T1, T2, ...]\", used in the\n    // definition of a generic class.\n    function createGenericType(errorNode, classType, typeArgs) {\n        // Make sure there's at least one type arg.\n        if (!typeArgs || typeArgs.length === 0) {\n            addError(localize_1.Localizer.Diagnostic.genericTypeArgMissing(), errorNode);\n        }\n        // Make sure that all of the type args are typeVars and are unique.\n        const uniqueTypeVars = [];\n        if (typeArgs) {\n            typeArgs.forEach((typeArg) => {\n                if (!types_1.isTypeVar(typeArg.type)) {\n                    addError(localize_1.Localizer.Diagnostic.genericTypeArgTypeVar(), typeArg.node);\n                }\n                else {\n                    for (const typeVar of uniqueTypeVars) {\n                        if (typeVar === typeArg.type) {\n                            addError(localize_1.Localizer.Diagnostic.genericTypeArgUnique(), typeArg.node);\n                            break;\n                        }\n                    }\n                    uniqueTypeVars.push(typeArg.type);\n                }\n            });\n        }\n        return createSpecialType(classType, typeArgs, \n        /* paramLimit */ undefined, \n        /* allowEllipsis */ false, \n        /* allowParamSpec */ true);\n    }\n    function transformTypeForPossibleEnumClass(node, typeOfExpr) {\n        // If the node is within a class that derives from the metaclass\n        // \"EnumMeta\", we need to treat assignments differently.\n        const enclosingClassNode = ParseTreeUtils.getEnclosingClass(node, true);\n        if (enclosingClassNode) {\n            const enumClassInfo = getTypeOfClass(enclosingClassNode);\n            if (enumClassInfo && types_1.ClassType.isEnumClass(enumClassInfo.classType)) {\n                if (types_1.ClassType.isBuiltIn(enumClassInfo.classType)) {\n                    // Handle several built-in classes specially. We don't\n                    // want to interpret their class variables as enumerations.\n                    const className = enumClassInfo.classType.details.name;\n                    const builtInEnumClasses = ['Enum', 'IntEnum', 'Flag', 'IntFlag'];\n                    if (builtInEnumClasses.find((c) => c === className)) {\n                        return typeOfExpr;\n                    }\n                }\n                return types_1.ObjectType.create(types_1.ClassType.cloneWithLiteral(enumClassInfo.classType, new types_1.EnumLiteral(enumClassInfo.classType.details.name, node.value)));\n            }\n        }\n        return typeOfExpr;\n    }\n    function createSpecialBuiltInClass(node, assignedName, aliasMapEntry) {\n        const specialClassType = types_1.ClassType.create(assignedName, 1 /* BuiltInClass */ | 2 /* SpecialBuiltIn */, node.id);\n        const fileInfo = getFileInfo(node);\n        if (fileInfo.isTypingExtensionsStubFile) {\n            specialClassType.details.flags |= 16384 /* TypingExtensionClass */;\n        }\n        const baseClassName = aliasMapEntry.alias ? aliasMapEntry.alias : 'object';\n        let aliasClass;\n        if (aliasMapEntry.module === 'builtins') {\n            aliasClass = getBuiltInType(node, baseClassName);\n        }\n        else if (aliasMapEntry.module === 'collections') {\n            // The typing.pyi file imports collections.\n            if (fileInfo.collectionsModulePath) {\n                const lookupResult = importLookup(fileInfo.collectionsModulePath);\n                if (lookupResult) {\n                    const symbol = lookupResult.symbolTable.get(baseClassName);\n                    if (symbol) {\n                        aliasClass = getEffectiveTypeOfSymbol(symbol);\n                    }\n                }\n            }\n        }\n        else if (aliasMapEntry.module === 'self') {\n            const symbolWithScope = lookUpSymbolRecursive(node, baseClassName, /* honorCodeFlow */ false);\n            if (symbolWithScope) {\n                aliasClass = getEffectiveTypeOfSymbol(symbolWithScope.symbol);\n            }\n        }\n        if (aliasClass && types_1.isClass(aliasClass) && types_1.isClass(specialClassType)) {\n            specialClassType.details.baseClasses.push(aliasClass);\n            if (aliasMapEntry.alias) {\n                specialClassType.details.aliasClass = aliasClass;\n            }\n        }\n        else {\n            specialClassType.details.baseClasses.push(types_1.UnknownType.create());\n        }\n        typeUtils_1.computeMroLinearization(specialClassType);\n        return specialClassType;\n    }\n    // Handles some special-case type annotations that are found\n    // within the typings.pyi file.\n    function handleTypingStubTypeAnnotation(node) {\n        if (!node.parent || node.parent.nodeType !== 55 /* TypeAnnotation */) {\n            return undefined;\n        }\n        if (node.parent.valueExpression.nodeType !== 39 /* Name */) {\n            return undefined;\n        }\n        const nameNode = node.parent.valueExpression;\n        const assignedName = nameNode.value;\n        const specialTypes = {\n            Tuple: { alias: 'tuple', module: 'builtins' },\n            Generic: { alias: '', module: 'builtins' },\n            Protocol: { alias: '', module: 'builtins' },\n            Callable: { alias: '', module: 'builtins' },\n            Type: { alias: 'type', module: 'builtins' },\n            ClassVar: { alias: '', module: 'builtins' },\n            Final: { alias: '', module: 'builtins' },\n            Literal: { alias: '', module: 'builtins' },\n            TypedDict: { alias: '_TypedDict', module: 'self' },\n            Union: { alias: '', module: 'builtins' },\n            Optional: { alias: '', module: 'builtins' },\n            Annotated: { alias: '', module: 'builtins' },\n            TypeAlias: { alias: '', module: 'builtins' },\n        };\n        const aliasMapEntry = specialTypes[assignedName];\n        if (aliasMapEntry) {\n            return createSpecialBuiltInClass(node, assignedName, aliasMapEntry);\n        }\n        return undefined;\n    }\n    // Handles some special-case assignment statements that are found\n    // within the typings.pyi file.\n    function handleTypingStubAssignment(node) {\n        if (node.leftExpression.nodeType !== 39 /* Name */) {\n            return undefined;\n        }\n        const nameNode = node.leftExpression;\n        const assignedName = nameNode.value;\n        if (assignedName === 'Any') {\n            return types_1.AnyType.create();\n        }\n        const specialTypes = {\n            overload: { alias: '', module: 'builtins' },\n            TypeVar: { alias: '', module: 'builtins' },\n            _promote: { alias: '', module: 'builtins' },\n            no_type_check: { alias: '', module: 'builtins' },\n            NoReturn: { alias: '', module: 'builtins' },\n            List: { alias: 'list', module: 'builtins' },\n            Dict: { alias: 'dict', module: 'builtins' },\n            DefaultDict: { alias: 'defaultdict', module: 'collections' },\n            Set: { alias: 'set', module: 'builtins' },\n            FrozenSet: { alias: 'frozenset', module: 'builtins' },\n            Deque: { alias: 'deque', module: 'collections' },\n            ChainMap: { alias: 'ChainMap', module: 'collections' },\n            OrderedDict: { alias: 'OrderedDict', module: 'collections' },\n        };\n        const aliasMapEntry = specialTypes[assignedName];\n        if (aliasMapEntry) {\n            return createSpecialBuiltInClass(node, assignedName, aliasMapEntry);\n        }\n        return undefined;\n    }\n    function evaluateTypesForAssignmentStatement(node) {\n        const fileInfo = getFileInfo(node);\n        // If the entire statement has already been evaluated, don't\n        // re-evaluate it.\n        if (readTypeCache(node)) {\n            return;\n        }\n        // Is this type already cached?\n        let rightHandType = readTypeCache(node.rightExpression);\n        let isResolutionCycle = false;\n        let expectedTypeDiagAddendum;\n        if (!rightHandType) {\n            // Special-case the typing.pyi file, which contains some special\n            // types that the type analyzer needs to interpret differently.\n            if (fileInfo.isTypingStubFile || fileInfo.isTypingExtensionsStubFile) {\n                rightHandType = handleTypingStubAssignment(node);\n                if (rightHandType) {\n                    writeTypeCache(node.rightExpression, rightHandType);\n                }\n            }\n            if (!rightHandType) {\n                // Determine whether there is a declared type.\n                const declaredType = getDeclaredTypeForExpression(node.leftExpression);\n                // Evaluate the type of the right-hand side. Don't specialize it in\n                // case it's a type alias with generic type arguments.\n                let flags = 2 /* DoNotSpecialize */;\n                if (fileInfo.isStubFile) {\n                    // An assignment of ellipsis means \"Any\" within a type stub file.\n                    flags |= 1024 /* ConvertEllipsisToUnknown */;\n                }\n                const isTypeAlias = isDeclaredTypeAlias(node.leftExpression);\n                let typeAliasNameNode;\n                if (isTypeAlias) {\n                    flags |=\n                        256 /* ExpectingType */ |\n                            32 /* EvaluateStringLiteralAsType */ |\n                            128 /* ParamSpecDisallowed */;\n                    typeAliasNameNode = node.leftExpression.valueExpression;\n                }\n                else {\n                    // The assignment isn't a declared type alias. See if it is potentially\n                    // a type alias. We'll consider it a potential type alias if the target\n                    // of the assignment is a simple name and this is the only place where\n                    // it is assigned.\n                    if (node.leftExpression.nodeType === 39 /* Name */) {\n                        const targetSymbolWithScope = lookUpSymbolRecursive(node.leftExpression, node.leftExpression.value, \n                        /* honorCodeFlow */ false);\n                        if (targetSymbolWithScope && targetSymbolWithScope.symbol.getDeclarations().length === 1) {\n                            typeAliasNameNode = node.leftExpression;\n                        }\n                    }\n                }\n                const srcTypeResult = getTypeOfExpression(node.rightExpression, declaredType, flags);\n                let srcType = srcTypeResult.type;\n                expectedTypeDiagAddendum = srcTypeResult.expectedTypeDiagAddendum;\n                if (srcTypeResult.isResolutionCyclical) {\n                    isResolutionCycle = true;\n                }\n                // If the RHS is a constant boolean expression, assign it a literal type.\n                const constExprValue = staticExpressions_1.evaluateStaticBoolExpression(node.rightExpression, fileInfo.executionEnvironment);\n                if (constExprValue !== undefined) {\n                    const boolType = getBuiltInObject(node, 'bool');\n                    if (types_1.isObject(boolType)) {\n                        srcType = types_1.ObjectType.create(types_1.ClassType.cloneWithLiteral(boolType.classType, constExprValue));\n                    }\n                }\n                // If there was a declared type, make sure the RHS value is compatible.\n                if (declaredType) {\n                    const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n                    if (canAssignType(declaredType, srcType, diagAddendum)) {\n                        // Constrain the resulting type to match the declared type.\n                        srcType = narrowDeclaredTypeBasedOnAssignedType(declaredType, srcType);\n                    }\n                }\n                // If this is an enum, transform the type as required.\n                rightHandType = srcType;\n                if (node.leftExpression.nodeType === 39 /* Name */ && !node.typeAnnotationComment) {\n                    rightHandType = transformTypeForPossibleEnumClass(node.leftExpression, rightHandType);\n                }\n                // If this is a type alias, record its name based on the assignment target.\n                if (typeAliasNameNode && types_1.TypeBase.isInstantiable(rightHandType)) {\n                    // Determine if there are any generic type parameters associated\n                    // with this type alias.\n                    const typeParameters = [];\n                    // Skip this for a simple TypeVar (one that's not part of a union).\n                    if (!types_1.isTypeVar(rightHandType)) {\n                        typeUtils_1.doForSubtypes(rightHandType, (subtype) => {\n                            typeUtils_1.addTypeVarsToListIfUnique(typeParameters, typeUtils_1.getTypeVarArgumentsRecursive(subtype));\n                            return undefined;\n                        });\n                    }\n                    rightHandType = types_1.TypeBase.cloneForTypeAlias(rightHandType, typeAliasNameNode.value, typeParameters.length > 0 ? typeParameters : undefined);\n                }\n            }\n        }\n        // Don't write back an unbound type that results from a resolution cycle. We'll\n        // write back the type when the stack unwinds and the type is fully evaluated.\n        if (!isResolutionCycle) {\n            assignTypeToExpression(node.leftExpression, rightHandType, node.rightExpression, expectedTypeDiagAddendum);\n            writeTypeCache(node, rightHandType);\n        }\n    }\n    function evaluateTypesForAugmentedAssignment(node) {\n        if (readTypeCache(node)) {\n            return;\n        }\n        const destType = getTypeFromAugmentedAssignment(node, /* expectedType */ undefined);\n        assignTypeToExpression(node.destExpression, destType, node.rightExpression);\n        writeTypeCache(node, destType);\n    }\n    function getTypeOfClass(node) {\n        // Is this type already cached?\n        let classType = readTypeCache(node.name);\n        let decoratedType = readTypeCache(node);\n        if (classType) {\n            return { classType, decoratedType: decoratedType || types_1.UnknownType.create() };\n        }\n        // The type wasn't cached, so we need to create a new one.\n        const scope = ScopeUtils.getScopeForNode(node);\n        const fileInfo = getFileInfo(node);\n        let classFlags = 0 /* None */;\n        if ((scope === null || scope === void 0 ? void 0 : scope.type) === 4 /* Builtin */ ||\n            fileInfo.isTypingStubFile ||\n            fileInfo.isTypingExtensionsStubFile ||\n            fileInfo.isBuiltInStubFile) {\n            classFlags |= 1 /* BuiltInClass */;\n            if (fileInfo.isTypingExtensionsStubFile) {\n                classFlags |= 16384 /* TypingExtensionClass */;\n            }\n            if (node.name.value === 'property') {\n                classFlags |= 512 /* PropertyClass */;\n            }\n        }\n        classType = types_1.ClassType.create(node.name.value, classFlags, node.id, ParseTreeUtils.getDocString(node.suite.statements));\n        // Some classes refer to themselves within type arguments used within\n        // base classes. We'll register the partially-constructed class type\n        // to allow these to be resolved.\n        const classSymbol = scope === null || scope === void 0 ? void 0 : scope.lookUpSymbol(node.name.value);\n        let classDecl;\n        const decl = AnalyzerNodeInfo.getDeclaration(node);\n        if (decl) {\n            classDecl = decl;\n        }\n        if (classDecl) {\n            setSymbolResolutionPartialType(classSymbol, classDecl, classType);\n        }\n        writeTypeCache(node, classType);\n        writeTypeCache(node.name, classType);\n        // Keep a list of unique type parameters that are used in the\n        // base class arguments.\n        const typeParameters = [];\n        // If the class derives from \"Generic\" directly, it will provide\n        // all of the type parameters in the specified order.\n        let genericTypeParameters;\n        let sawMetaclass = false;\n        let nonMetaclassBaseClassCount = 0;\n        node.arguments.forEach((arg) => {\n            // Ignore keyword parameters other than metaclass or total.\n            if (!arg.name || arg.name.value === 'metaclass') {\n                let argType = getTypeOfExpression(arg.valueExpression, undefined, 256 /* ExpectingType */ | 2048 /* GenericClassTypeAllowed */).type;\n                const isMetaclass = !!arg.name;\n                if (isMetaclass) {\n                    if (sawMetaclass) {\n                        addError(localize_1.Localizer.Diagnostic.metaclassDuplicate(), arg);\n                    }\n                    sawMetaclass = true;\n                }\n                // In some stub files, classes are conditionally defined (e.g. based\n                // on platform type). We'll assume that the conditional logic is correct\n                // and strip off the \"unbound\" union.\n                if (argType.category === 10 /* Union */) {\n                    argType = types_1.removeUnboundFromUnion(argType);\n                }\n                if (!types_1.isAnyOrUnknown(argType) && !types_1.isUnbound(argType)) {\n                    // Handle \"Type[X]\" object.\n                    argType = typeUtils_1.transformTypeObjectToClass(argType);\n                    if (!types_1.isClass(argType)) {\n                        addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.baseClassInvalid(), arg);\n                        argType = types_1.UnknownType.create();\n                    }\n                    else {\n                        if (types_1.ClassType.isBuiltIn(argType, 'Protocol')) {\n                            if (!fileInfo.isStubFile &&\n                                !types_1.ClassType.isTypingExtensionClass(argType) &&\n                                fileInfo.executionEnvironment.pythonVersion < pythonVersion_1.PythonVersion.V3_7) {\n                                addError(localize_1.Localizer.Diagnostic.protocolIllegal(), arg.valueExpression);\n                            }\n                            classType.details.flags |= 2048 /* ProtocolClass */;\n                        }\n                        if (types_1.ClassType.isBuiltIn(argType, 'property')) {\n                            classType.details.flags |= 512 /* PropertyClass */;\n                        }\n                        // If the class directly derives from NamedTuple (in Python 3.6 or\n                        // newer), it's considered a dataclass.\n                        if (fileInfo.executionEnvironment.pythonVersion >= pythonVersion_1.PythonVersion.V3_6) {\n                            if (types_1.ClassType.isBuiltIn(argType, 'NamedTuple')) {\n                                classType.details.flags |= 4 /* DataClass */;\n                            }\n                        }\n                        // If the class directly derives from TypedDict or from a class that is\n                        // a TypedDict, it is considered a TypedDict.\n                        if (types_1.ClassType.isBuiltIn(argType, 'TypedDict') || types_1.ClassType.isTypedDictClass(argType)) {\n                            classType.details.flags |= 16 /* TypedDictClass */;\n                        }\n                        else if (types_1.ClassType.isTypedDictClass(classType) && !types_1.ClassType.isTypedDictClass(argType)) {\n                            // TypedDict classes must derive only from other\n                            // TypedDict classes.\n                            addError(localize_1.Localizer.Diagnostic.typedDictBaseClass(), arg);\n                        }\n                        // Validate that the class isn't deriving from itself, creating a\n                        // circular dependency.\n                        if (typeUtils_1.derivesFromClassRecursive(argType, classType, /* ignoreUnknown */ true)) {\n                            addError(localize_1.Localizer.Diagnostic.baseClassCircular(), arg);\n                            argType = types_1.UnknownType.create();\n                        }\n                    }\n                }\n                if (types_1.isUnknown(argType)) {\n                    addDiagnostic(fileInfo.diagnosticRuleSet.reportUntypedBaseClass, \"reportUntypedBaseClass\" /* reportUntypedBaseClass */, localize_1.Localizer.Diagnostic.baseClassUnknown(), arg);\n                }\n                if (isMetaclass) {\n                    if (types_1.isClass(argType) || types_1.isUnknown(argType)) {\n                        classType.details.metaClass = argType;\n                        if (types_1.isClass(argType)) {\n                            if (types_1.ClassType.isBuiltIn(argType, 'EnumMeta')) {\n                                classType.details.flags |= 64 /* EnumClass */;\n                            }\n                            else if (types_1.ClassType.isBuiltIn(argType, 'ABCMeta')) {\n                                classType.details.flags |= 128 /* SupportsAbstractMethods */;\n                            }\n                        }\n                    }\n                }\n                else {\n                    classType.details.baseClasses.push(argType);\n                    if (types_1.isClass(argType)) {\n                        if (types_1.ClassType.isEnumClass(argType)) {\n                            classType.details.flags |= 64 /* EnumClass */;\n                        }\n                        if (types_1.ClassType.supportsAbstractMethods(argType)) {\n                            classType.details.flags |= 128 /* SupportsAbstractMethods */;\n                        }\n                        if (types_1.ClassType.isPropertyClass(argType)) {\n                            classType.details.flags |= 512 /* PropertyClass */;\n                        }\n                        if (types_1.ClassType.isFinal(argType)) {\n                            const className = printObjectTypeForClass(argType);\n                            addError(localize_1.Localizer.Diagnostic.baseClassFinal().format({ type: className }), arg.valueExpression);\n                        }\n                    }\n                }\n                typeUtils_1.addTypeVarsToListIfUnique(typeParameters, typeUtils_1.getTypeVarArgumentsRecursive(argType));\n                if (types_1.isClass(argType) && types_1.ClassType.isBuiltIn(argType, 'Generic')) {\n                    if (genericTypeParameters) {\n                        addError(localize_1.Localizer.Diagnostic.baseClassDoubleGeneric(), arg.valueExpression);\n                    }\n                    else {\n                        genericTypeParameters = [];\n                        typeUtils_1.addTypeVarsToListIfUnique(genericTypeParameters, typeUtils_1.getTypeVarArgumentsRecursive(argType));\n                    }\n                }\n                if (!isMetaclass) {\n                    nonMetaclassBaseClassCount++;\n                }\n            }\n            else if (arg.name.value === 'total') {\n                // The \"total\" parameter name applies only for TypedDict classes.\n                if (types_1.ClassType.isTypedDictClass(classType)) {\n                    // PEP 589 specifies that the parameter must be either True or False.\n                    const constArgValue = staticExpressions_1.evaluateStaticBoolExpression(arg.valueExpression, fileInfo.executionEnvironment);\n                    if (constArgValue === undefined) {\n                        addError(localize_1.Localizer.Diagnostic.typedDictTotalParam(), arg.valueExpression);\n                    }\n                    else if (!constArgValue) {\n                        classType.details.flags |= 32 /* CanOmitDictValues */;\n                    }\n                }\n            }\n        });\n        if (nonMetaclassBaseClassCount === 0) {\n            // Make sure we don't have 'object' derive from itself. Infinite\n            // recursion will result.\n            if (!types_1.ClassType.isBuiltIn(classType, 'object')) {\n                classType.details.baseClasses.push(getBuiltInType(node, 'object'));\n            }\n        }\n        // TODO - validate that we are not adding type parameters that\n        // are unique type vars but have conflicting names.\n        // TODO - if genericTypeParameters are provided, make sure that\n        // typeParameters is a proper subset.\n        classType.details.typeParameters = genericTypeParameters || typeParameters;\n        if (!typeUtils_1.computeMroLinearization(classType)) {\n            addError(localize_1.Localizer.Diagnostic.methodOrdering(), node.name);\n        }\n        // The scope for this class becomes the \"fields\" for the corresponding type.\n        const innerScope = ScopeUtils.getScopeForNode(node.suite);\n        classType.details.fields = (innerScope === null || innerScope === void 0 ? void 0 : innerScope.symbolTable) || new Map();\n        if (types_1.ClassType.isTypedDictClass(classType)) {\n            synthesizeTypedDictClassMethods(node, classType);\n        }\n        // Determine if the class should be a \"pseudo-generic\" class, characterized\n        // by having an __init__ method with parameters that lack type annotations.\n        // For such classes, we'll treat them as generic, with the type arguments provided\n        // by the callers of the constructor.\n        if (!fileInfo.isStubFile && classType.details.typeParameters.length === 0) {\n            const initMethod = classType.details.fields.get('__init__');\n            if (initMethod) {\n                const initDecls = initMethod.getTypedDeclarations();\n                if (initDecls.length === 1 && initDecls[0].type === 3 /* Function */) {\n                    const initDeclNode = initDecls[0].node;\n                    const initParams = initDeclNode.parameters;\n                    if (initParams.length > 1 && !initParams.some((param) => param.typeAnnotation)) {\n                        const genericParams = initParams.filter((param, index) => index > 0 && param.name && param.category === 0 /* Simple */);\n                        if (genericParams.length > 0) {\n                            classType.details.flags |= 4096 /* PseudoGenericClass */;\n                            // Create a type parameter for each simple, named parameter\n                            // in the __init__ method.\n                            classType.details.typeParameters = genericParams.map((param) => types_1.TypeVarType.createInstance(`__type_of_${param.name.value}`, \n                            /* isParamSpec */ false, \n                            /* isSynthesized */ true));\n                        }\n                    }\n                }\n            }\n        }\n        // Determine if the class is abstract.\n        if (types_1.ClassType.supportsAbstractMethods(classType)) {\n            if (getAbstractMethods(classType).length > 0) {\n                classType.details.flags |= 256 /* HasAbstractMethods */;\n            }\n        }\n        // Now determine the decorated type of the class.\n        decoratedType = classType;\n        let foundUnknown = false;\n        for (let i = node.decorators.length - 1; i >= 0; i--) {\n            const decorator = node.decorators[i];\n            const newDecoratedType = applyClassDecorator(decoratedType, classType, decorator);\n            if (types_1.isUnknown(newDecoratedType)) {\n                // Report this error only on the first unknown type.\n                if (!foundUnknown) {\n                    addDiagnostic(fileInfo.diagnosticRuleSet.reportUntypedClassDecorator, \"reportUntypedClassDecorator\" /* reportUntypedClassDecorator */, localize_1.Localizer.Diagnostic.classDecoratorTypeUnknown(), node.decorators[i].leftExpression);\n                    foundUnknown = true;\n                }\n            }\n            else {\n                // Apply the decorator only if the type is known.\n                decoratedType = newDecoratedType;\n            }\n        }\n        if (types_1.ClassType.isDataClass(classType)) {\n            let skipSynthesizedInit = types_1.ClassType.isSkipSynthesizedInit(classType);\n            if (!skipSynthesizedInit) {\n                // See if there's already a non-synthesized __init__ method.\n                // We shouldn't override it.\n                const initSymbol = typeUtils_1.lookUpClassMember(classType, '__init__', 2 /* SkipBaseClasses */);\n                if (initSymbol) {\n                    const initSymbolType = getTypeOfMember(initSymbol);\n                    if (initSymbolType.category === 5 /* Function */) {\n                        if (!types_1.FunctionType.isSynthesizedMethod(initSymbolType)) {\n                            skipSynthesizedInit = true;\n                        }\n                    }\n                    else {\n                        skipSynthesizedInit = true;\n                    }\n                }\n            }\n            synthesizeDataClassMethods(node, classType, skipSynthesizedInit);\n        }\n        // Update the undecorated class type.\n        writeTypeCache(node.name, classType);\n        // Update the decorated class type.\n        writeTypeCache(node, decoratedType);\n        return { classType, decoratedType };\n    }\n    function applyClassDecorator(inputClassType, originalClassType, decoratorNode) {\n        const decoratorType = getTypeOfExpression(decoratorNode.leftExpression).type;\n        // Is this a @dataclass?\n        if (decoratorType.category === 6 /* OverloadedFunction */) {\n            const overloads = decoratorType.overloads;\n            if (overloads.length > 0 && overloads[0].details.builtInName === 'dataclass') {\n                // Determine whether we should skip synthesizing the init method.\n                let skipSynthesizeInit = false;\n                if (decoratorNode.arguments) {\n                    decoratorNode.arguments.forEach((arg) => {\n                        if (arg.name && arg.name.value === 'init') {\n                            if (arg.valueExpression) {\n                                const fileInfo = getFileInfo(decoratorNode);\n                                const value = staticExpressions_1.evaluateStaticBoolExpression(arg.valueExpression, fileInfo.executionEnvironment);\n                                if (!value) {\n                                    skipSynthesizeInit = true;\n                                }\n                            }\n                        }\n                    });\n                }\n                originalClassType.details.flags |= 4 /* DataClass */;\n                if (skipSynthesizeInit) {\n                    originalClassType.details.flags |= 8 /* SkipSynthesizedInit */;\n                }\n                return inputClassType;\n            }\n        }\n        else if (decoratorType.category === 5 /* Function */) {\n            if (decoratorType.details.builtInName === 'final') {\n                originalClassType.details.flags |= 1024 /* Final */;\n            }\n            else if (decoratorType.details.builtInName === 'runtime_checkable') {\n                originalClassType.details.flags |= 8192 /* RuntimeCheckable */;\n            }\n        }\n        return getTypeFromDecorator(decoratorNode, inputClassType);\n    }\n    function getTypeOfFunction(node) {\n        const fileInfo = getFileInfo(node);\n        // Is this type already cached?\n        let functionType = readTypeCache(node.name);\n        let decoratedType = readTypeCache(node);\n        if (functionType) {\n            return { functionType, decoratedType: decoratedType || types_1.UnknownType.create() };\n        }\n        let functionDecl;\n        const decl = AnalyzerNodeInfo.getDeclaration(node);\n        if (decl) {\n            functionDecl = decl;\n        }\n        // There was no cached type, so create a new one.\n        // Retrieve the containing class node if the function is a method.\n        const containingClassNode = ParseTreeUtils.getEnclosingClass(node, true);\n        let containingClassType;\n        if (containingClassNode) {\n            const classInfo = getTypeOfClass(containingClassNode);\n            if (!classInfo) {\n                return undefined;\n            }\n            containingClassType = classInfo.classType;\n        }\n        let functionFlags = getFunctionFlagsFromDecorators(node, !!containingClassNode);\n        if (functionDecl === null || functionDecl === void 0 ? void 0 : functionDecl.isGenerator) {\n            functionFlags |= 16 /* Generator */;\n        }\n        if (fileInfo.isStubFile) {\n            functionFlags |= 2048 /* StubDefinition */;\n        }\n        if (node.isAsync) {\n            functionFlags |= 512 /* Async */;\n        }\n        functionType = types_1.FunctionType.createInstance(node.name.value, functionFlags, ParseTreeUtils.getDocString(node.suite.statements));\n        if (fileInfo.isBuiltInStubFile || fileInfo.isTypingStubFile || fileInfo.isTypingExtensionsStubFile) {\n            // Stash away the name of the function since we need to handle\n            // 'namedtuple', 'abstractmethod', 'dataclass' and 'NewType'\n            // specially.\n            functionType.details.builtInName = node.name.value;\n        }\n        functionType.details.declaration = functionDecl;\n        // Allow recursion by registering the partially-constructed\n        // function type.\n        const scope = ScopeUtils.getScopeForNode(node);\n        const functionSymbol = scope === null || scope === void 0 ? void 0 : scope.lookUpSymbol(node.name.value);\n        if (functionDecl) {\n            setSymbolResolutionPartialType(functionSymbol, functionDecl, functionType);\n        }\n        writeTypeCache(node, functionType);\n        writeTypeCache(node.name, functionType);\n        // Is this an \"__init__\" method within a pseudo-generic class? If so,\n        // we'll add generic types to the constructor's parameters.\n        const addGenericParamTypes = containingClassType &&\n            types_1.ClassType.isPseudoGenericClass(containingClassType) &&\n            node.name.value === '__init__';\n        // If there was a defined return type, analyze that first so when we\n        // walk the contents of the function, return statements can be\n        // validated against this type.\n        if (node.returnTypeAnnotation) {\n            // Temporarily set the return type to unknown in case of recursion.\n            functionType.details.declaredReturnType = types_1.UnknownType.create();\n            const returnType = getTypeOfAnnotation(node.returnTypeAnnotation);\n            functionType.details.declaredReturnType = returnType;\n        }\n        else {\n            // If there was no return type annotation and this is a type stub,\n            // we have no opportunity to infer the return type, so we'll indicate\n            // that it's unknown.\n            if (fileInfo.isStubFile) {\n                // Special-case the __init__ method, which is commonly left without\n                // an annotated return type, but we can assume it returns None.\n                if (node.name.value === '__init__') {\n                    functionType.details.declaredReturnType = types_1.NoneType.createInstance();\n                }\n                else {\n                    functionType.details.declaredReturnType = types_1.UnknownType.create();\n                }\n            }\n        }\n        const paramTypes = [];\n        let typeParamIndex = 0;\n        node.parameters.forEach((param, index) => {\n            let paramType;\n            let annotatedType;\n            let concreteAnnotatedType;\n            let isNoneWithoutOptional = false;\n            if (param.typeAnnotation) {\n                annotatedType = getTypeOfAnnotation(param.typeAnnotation);\n            }\n            else if (addGenericParamTypes) {\n                if (index > 0 && param.category === 0 /* Simple */ && param.name) {\n                    annotatedType = containingClassType.details.typeParameters[typeParamIndex];\n                    typeParamIndex++;\n                }\n            }\n            if (annotatedType) {\n                // PEP 484 indicates that if a parameter has a default value of 'None'\n                // the type checker should assume that the type is optional (i.e. a union\n                // of the specified type and 'None').\n                if (param.defaultValue && param.defaultValue.nodeType === 11 /* Constant */) {\n                    if (param.defaultValue.constType === 24 /* None */) {\n                        isNoneWithoutOptional = true;\n                        if (!fileInfo.diagnosticRuleSet.strictParameterNoneValue) {\n                            annotatedType = types_1.combineTypes([annotatedType, types_1.NoneType.createInstance()]);\n                        }\n                    }\n                }\n                concreteAnnotatedType = typeUtils_1.specializeType(annotatedType, /* typeVarMap */ undefined);\n            }\n            let defaultValueType;\n            if (param.defaultValue) {\n                defaultValueType = getTypeOfExpression(param.defaultValue, annotatedType, 1 /* ConvertEllipsisToAny */).type;\n            }\n            if (annotatedType) {\n                // If there was both a type annotation and a default value, verify\n                // that the default value matches the annotation.\n                if (param.defaultValue && defaultValueType && concreteAnnotatedType) {\n                    const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n                    if (!canAssignType(concreteAnnotatedType, defaultValueType, diagAddendum)) {\n                        const diag = addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.paramAssignmentMismatch().format({\n                            sourceType: printType(defaultValueType),\n                            paramType: printType(annotatedType),\n                        }) + diagAddendum.getString(), param.defaultValue);\n                        if (isNoneWithoutOptional && param.typeAnnotation) {\n                            const addOptionalAction = {\n                                action: \"pyright.addoptionalforparam\" /* addMissingOptionalToParam */,\n                                offsetOfTypeNode: param.typeAnnotation.start + 1,\n                            };\n                            if (diag) {\n                                diag.addAction(addOptionalAction);\n                            }\n                        }\n                    }\n                }\n                paramType = annotatedType;\n            }\n            const functionParam = {\n                category: param.category,\n                name: param.name ? param.name.value : undefined,\n                hasDefault: !!param.defaultValue,\n                defaultType: defaultValueType,\n                hasDeclaredType: !!param.typeAnnotation,\n                type: paramType || types_1.UnknownType.create(),\n            };\n            types_1.FunctionType.addParameter(functionType, functionParam);\n            if (param.name) {\n                const variadicParamType = transformVariadicParamType(node, param.category, functionParam.type);\n                paramTypes.push(variadicParamType);\n            }\n            else {\n                paramTypes.push(functionParam.type);\n            }\n        });\n        if (containingClassType) {\n            // If the first parameter doesn't have an explicit type annotation,\n            // provide a type if it's an instance, class or constructor method.\n            if (functionType.details.parameters.length > 0 && !node.parameters[0].typeAnnotation) {\n                const inferredParamType = inferFirstParamType(functionType.details.flags, containingClassType);\n                if (inferredParamType) {\n                    functionType.details.parameters[0].type = inferredParamType;\n                    if (!types_1.isAnyOrUnknown(inferredParamType)) {\n                        functionType.details.parameters[0].isTypeInferred = true;\n                    }\n                    paramTypes[0] = inferredParamType;\n                }\n            }\n        }\n        // Update the types for the nodes associated with the parameters.\n        paramTypes.forEach((paramType, index) => {\n            const paramNameNode = node.parameters[index].name;\n            if (paramNameNode) {\n                if (types_1.isUnknown(paramType)) {\n                    functionType.details.flags |= 8192 /* UnannotatedParams */;\n                }\n                writeTypeCache(paramNameNode, paramType);\n            }\n        });\n        // If it's an async function, wrap the return type in an Awaitable or Generator.\n        const preDecoratedType = node.isAsync ? createAsyncFunction(node, functionType) : functionType;\n        // Apply all of the decorators in reverse order.\n        decoratedType = preDecoratedType;\n        let foundUnknown = false;\n        for (let i = node.decorators.length - 1; i >= 0; i--) {\n            const decorator = node.decorators[i];\n            const newDecoratedType = applyFunctionDecorator(decoratedType, functionType, decorator);\n            if (types_1.isUnknown(newDecoratedType)) {\n                // Report this error only on the first unknown type.\n                if (!foundUnknown) {\n                    addDiagnostic(fileInfo.diagnosticRuleSet.reportUntypedFunctionDecorator, \"reportUntypedFunctionDecorator\" /* reportUntypedFunctionDecorator */, localize_1.Localizer.Diagnostic.functionDecoratorTypeUnknown(), node.decorators[i].leftExpression);\n                    foundUnknown = true;\n                }\n            }\n            else {\n                // Apply the decorator only if the type is known.\n                decoratedType = newDecoratedType;\n            }\n        }\n        // See if there are any overloads provided by previous function declarations.\n        if (decoratedType.category === 5 /* Function */) {\n            decoratedType = addOverloadsToFunctionType(node, decoratedType);\n        }\n        writeTypeCache(node.name, functionType);\n        writeTypeCache(node, decoratedType);\n        return { functionType, decoratedType };\n    }\n    function inferFirstParamType(flags, containingClassType) {\n        if ((flags & 4 /* StaticMethod */) === 0) {\n            if (containingClassType) {\n                if (types_1.ClassType.isProtocolClass(containingClassType)) {\n                    // Don't specialize the \"self\" for protocol classes because type\n                    // comparisons will fail during structural typing analysis. We'll\n                    // use an \"Any\" type here to avoid triggering errors about Unknown\n                    // types.\n                    return types_1.AnyType.create();\n                }\n                if (flags & (2 /* ClassMethod */ | 1 /* ConstructorMethod */)) {\n                    // For class methods, the cls parameter is allowed to skip the\n                    // abstract class test because the caller is possibly passing\n                    // in a non-abstract subclass.\n                    const clsType = types_1.TypeVarType.createInstance(`__type_of_cls_${containingClassType.details.name}`, \n                    /* isParamSpec */ false, \n                    /* isSynthesized */ true);\n                    clsType.boundType = typeUtils_1.selfSpecializeClassType(containingClassType, \n                    /* setSkipAbstractClassTest */ true);\n                    return clsType;\n                }\n                else if ((flags & 4 /* StaticMethod */) === 0) {\n                    const selfType = types_1.TypeVarType.createInstance(`__type_of_self_${containingClassType.details.name}`, \n                    /* isParamSpec */ false, \n                    /* isSynthesized */ true);\n                    selfType.boundType = types_1.ObjectType.create(typeUtils_1.selfSpecializeClassType(containingClassType, /* setSkipAbstractClassTest */ true));\n                    return selfType;\n                }\n            }\n        }\n        return undefined;\n    }\n    // Transforms the parameter type based on its category. If it's a simple parameter,\n    // no transform is applied. If it's a var-arg or keyword-arg parameter, the type\n    // is wrapped in a List or Dict.\n    function transformVariadicParamType(node, paramCategory, type) {\n        switch (paramCategory) {\n            case 0 /* Simple */: {\n                return type;\n            }\n            case 1 /* VarArgList */: {\n                // Create a Tuple[X, ...] type.\n                const tupleType = getTypingType(node, 'Tuple');\n                if (tupleType && types_1.isClass(tupleType)) {\n                    return types_1.ObjectType.create(types_1.ClassType.cloneForSpecialization(tupleType, [type, types_1.AnyType.create(true)], \n                    /* isTypeArgumentExplicit */ false));\n                }\n                return types_1.UnknownType.create();\n            }\n            case 2 /* VarArgDictionary */: {\n                const dictType = getBuiltInType(node, 'Dict');\n                const strType = getBuiltInObject(node, 'str');\n                if (types_1.isClass(dictType) && types_1.isObject(strType)) {\n                    return types_1.ObjectType.create(types_1.ClassType.cloneForSpecialization(dictType, [strType, type], /* isTypeArgumentExplicit */ false));\n                }\n                return types_1.UnknownType.create();\n            }\n        }\n    }\n    // Scans through the decorators to find a few built-in decorators\n    // that affect the function flags.\n    function getFunctionFlagsFromDecorators(node, isInClass) {\n        const fileInfo = getFileInfo(node);\n        let flags = 0 /* None */;\n        // The \"__new__\" magic method is not an instance method.\n        // It acts as a static method instead.\n        if (node.name.value === '__new__' && isInClass) {\n            flags |= 1 /* ConstructorMethod */;\n        }\n        for (const decoratorNode of node.decorators) {\n            let evaluatorFlags = 2 /* DoNotSpecialize */;\n            if (fileInfo.isStubFile) {\n                // Some stub files (e.g. builtins.pyi) rely on forward\n                // declarations of decorators.\n                evaluatorFlags |= 4 /* AllowForwardReferences */;\n            }\n            const decoratorType = getTypeOfExpression(decoratorNode.leftExpression, undefined, evaluatorFlags).type;\n            if (decoratorType.category === 5 /* Function */) {\n                if (decoratorType.details.builtInName === 'abstractmethod') {\n                    if (isInClass) {\n                        flags |= 8 /* AbstractMethod */;\n                    }\n                }\n                else if (decoratorType.details.builtInName === 'final') {\n                    flags |= 4096 /* Final */;\n                }\n            }\n            else if (types_1.isClass(decoratorType)) {\n                if (types_1.ClassType.isBuiltIn(decoratorType, 'staticmethod')) {\n                    if (isInClass) {\n                        flags |= 4 /* StaticMethod */;\n                    }\n                }\n                else if (types_1.ClassType.isBuiltIn(decoratorType, 'classmethod')) {\n                    if (isInClass) {\n                        flags |= 2 /* ClassMethod */;\n                    }\n                }\n            }\n        }\n        return flags;\n    }\n    // Transforms the input function type into an output type based on the\n    // decorator function described by the decoratorNode.\n    function applyFunctionDecorator(inputFunctionType, originalFunctionType, decoratorNode) {\n        let evaluatorFlags = 2 /* DoNotSpecialize */;\n        if (getFileInfo(decoratorNode).isStubFile) {\n            // Some stub files (e.g. builtins.pyi) rely on forward\n            // declarations of decorators.\n            evaluatorFlags |= 4 /* AllowForwardReferences */;\n        }\n        const decoratorType = getTypeOfExpression(decoratorNode.leftExpression, undefined, evaluatorFlags).type;\n        // Special-case the \"overload\" because it has no definition.\n        if (types_1.isClass(decoratorType) && types_1.ClassType.isSpecialBuiltIn(decoratorType, 'overload')) {\n            if (inputFunctionType.category === 5 /* Function */) {\n                inputFunctionType.details.flags |= 256 /* Overloaded */;\n                return inputFunctionType;\n            }\n        }\n        const returnType = getTypeFromDecorator(decoratorNode, inputFunctionType);\n        // Check for some built-in decorator types with known semantics.\n        if (decoratorType.category === 5 /* Function */) {\n            if (decoratorType.details.builtInName === 'abstractmethod') {\n                return inputFunctionType;\n            }\n            // Handle property setters and deleters.\n            if (decoratorNode.leftExpression.nodeType === 36 /* MemberAccess */) {\n                const baseType = getTypeOfExpression(decoratorNode.leftExpression.leftExpression).type;\n                if (typeUtils_1.isProperty(baseType)) {\n                    const memberName = decoratorNode.leftExpression.memberName.value;\n                    if (memberName === 'setter') {\n                        return clonePropertyWithSetter(baseType, originalFunctionType);\n                    }\n                    else if (memberName === 'deleter') {\n                        return clonePropertyWithDeleter(baseType, originalFunctionType);\n                    }\n                }\n            }\n        }\n        else if (types_1.isClass(decoratorType)) {\n            if (types_1.ClassType.isBuiltIn(decoratorType)) {\n                switch (decoratorType.details.name) {\n                    case 'classmethod':\n                    case 'staticmethod': {\n                        return inputFunctionType;\n                    }\n                }\n            }\n            // Handle properties and subclasses of properties specially.\n            if (types_1.ClassType.isPropertyClass(decoratorType)) {\n                if (inputFunctionType.category === 5 /* Function */) {\n                    return createProperty(decoratorType.details.name, inputFunctionType, decoratorNode.id);\n                }\n            }\n        }\n        // Copy the overload flag from the input function type.\n        if (inputFunctionType.category === 5 /* Function */ && returnType.category === 5 /* Function */) {\n            if (types_1.FunctionType.isOverloaded(inputFunctionType)) {\n                returnType.details.flags |= 256 /* Overloaded */;\n            }\n        }\n        return returnType;\n    }\n    function createProperty(className, fget, typeSourceId) {\n        const propertyClass = types_1.ClassType.create(className, 512 /* PropertyClass */, typeSourceId);\n        typeUtils_1.computeMroLinearization(propertyClass);\n        const propertyObject = types_1.ObjectType.create(propertyClass);\n        // Fill in the fget method.\n        const fields = propertyClass.details.fields;\n        const fgetSymbol = symbol_1.Symbol.createWithType(4 /* ClassMember */, fget);\n        fields.set('fget', fgetSymbol);\n        // Fill in the __get__ method.\n        const getFunction = types_1.FunctionType.createInstance('__get__', 64 /* SynthesizedMethod */);\n        getFunction.details.parameters.push({\n            category: 0 /* Simple */,\n            name: 'self',\n            type: fget.details.parameters.length > 0 ? fget.details.parameters[0].type : types_1.AnyType.create(),\n        });\n        getFunction.details.parameters.push({\n            category: 0 /* Simple */,\n            name: 'obj',\n            type: propertyObject,\n        });\n        getFunction.details.declaredReturnType = fget.details.declaredReturnType;\n        getFunction.details.declaration = fget.details.declaration;\n        const getSymbol = symbol_1.Symbol.createWithType(4 /* ClassMember */, getFunction);\n        fields.set('__get__', getSymbol);\n        // Fill in the getter, setter and deleter methods.\n        ['getter', 'setter', 'deleter'].forEach((accessorName) => {\n            const accessorFunction = types_1.FunctionType.createInstance(accessorName, 64 /* SynthesizedMethod */);\n            accessorFunction.details.parameters.push({\n                category: 0 /* Simple */,\n                name: 'self',\n                type: propertyObject,\n            });\n            accessorFunction.details.parameters.push({\n                category: 0 /* Simple */,\n                name: 'accessor',\n                type: types_1.AnyType.create(),\n            });\n            accessorFunction.details.declaredReturnType = propertyObject;\n            const accessorSymbol = symbol_1.Symbol.createWithType(4 /* ClassMember */, accessorFunction);\n            fields.set(accessorName, accessorSymbol);\n        });\n        return propertyObject;\n    }\n    function clonePropertyWithSetter(prop, fset) {\n        if (!typeUtils_1.isProperty(prop)) {\n            return prop;\n        }\n        const classType = prop.classType;\n        const propertyClass = types_1.ClassType.create(classType.details.name, classType.details.flags, classType.details.typeSourceId);\n        typeUtils_1.computeMroLinearization(propertyClass);\n        const propertyObject = types_1.ObjectType.create(propertyClass);\n        // Clone the symbol table of the old class type.\n        const fields = propertyClass.details.fields;\n        classType.details.fields.forEach((symbol, name) => {\n            if (!symbol.isIgnoredForProtocolMatch()) {\n                fields.set(name, symbol);\n            }\n        });\n        // Fill in the fset method.\n        const fsetSymbol = symbol_1.Symbol.createWithType(4 /* ClassMember */, fset);\n        fields.set('fset', fsetSymbol);\n        // Fill in the __set__ method.\n        const setFunction = types_1.FunctionType.createInstance('__set__', 64 /* SynthesizedMethod */);\n        setFunction.details.parameters.push({\n            category: 0 /* Simple */,\n            name: 'self',\n            type: fset.details.parameters.length > 0 ? fset.details.parameters[0].type : types_1.AnyType.create(),\n        });\n        setFunction.details.parameters.push({\n            category: 0 /* Simple */,\n            name: 'obj',\n            type: propertyObject,\n        });\n        setFunction.details.declaredReturnType = types_1.NoneType.createInstance();\n        let setParamType = types_1.UnknownType.create();\n        if (fset.details.parameters.length >= 2 &&\n            fset.details.parameters[1].category === 0 /* Simple */ &&\n            fset.details.parameters[1].name) {\n            setParamType = fset.details.parameters[1].type;\n        }\n        setFunction.details.parameters.push({\n            category: 0 /* Simple */,\n            name: 'value',\n            type: setParamType,\n        });\n        const setSymbol = symbol_1.Symbol.createWithType(4 /* ClassMember */, setFunction);\n        fields.set('__set__', setSymbol);\n        return propertyObject;\n    }\n    function clonePropertyWithDeleter(prop, fdel) {\n        if (!typeUtils_1.isProperty(prop)) {\n            return prop;\n        }\n        const classType = prop.classType;\n        const propertyClass = types_1.ClassType.create(classType.details.name, classType.details.flags, classType.details.typeSourceId);\n        typeUtils_1.computeMroLinearization(propertyClass);\n        const propertyObject = types_1.ObjectType.create(propertyClass);\n        // Clone the symbol table of the old class type.\n        const fields = propertyClass.details.fields;\n        classType.details.fields.forEach((symbol, name) => {\n            if (!symbol.isIgnoredForProtocolMatch()) {\n                fields.set(name, symbol);\n            }\n        });\n        // Fill in the fdel method.\n        const fdelSymbol = symbol_1.Symbol.createWithType(4 /* ClassMember */, fdel);\n        fields.set('fdel', fdelSymbol);\n        // Fill in the __delete__ method.\n        const delFunction = types_1.FunctionType.createInstance('__delete__', 64 /* SynthesizedMethod */);\n        delFunction.details.parameters.push({\n            category: 0 /* Simple */,\n            name: 'self',\n            type: fdel.details.parameters.length > 0 ? fdel.details.parameters[0].type : types_1.AnyType.create(),\n        });\n        delFunction.details.parameters.push({\n            category: 0 /* Simple */,\n            name: 'obj',\n            type: propertyObject,\n        });\n        delFunction.details.declaredReturnType = types_1.NoneType.createInstance();\n        const delSymbol = symbol_1.Symbol.createWithType(4 /* ClassMember */, delFunction);\n        fields.set('__delete__', delSymbol);\n        return propertyObject;\n    }\n    // Given a function node and the function type associated with it, this\n    // method search for prior function nodes that are marked as @overload\n    // and creates an OverloadedFunctionType that includes this function and\n    // all previous ones.\n    function addOverloadsToFunctionType(node, type) {\n        let functionDecl;\n        const decl = AnalyzerNodeInfo.getDeclaration(node);\n        if (decl) {\n            functionDecl = decl;\n        }\n        const symbolWithScope = lookUpSymbolRecursive(node, node.name.value, /* honorCodeFlow */ false);\n        if (symbolWithScope) {\n            const decls = symbolWithScope.symbol.getDeclarations();\n            // Find this function's declaration.\n            let declIndex = decls.findIndex((decl) => decl === functionDecl);\n            if (declIndex > 0) {\n                const overloadedTypes = [type];\n                while (declIndex > 0) {\n                    const decl = decls[declIndex - 1];\n                    if (decl.type !== 3 /* Function */) {\n                        break;\n                    }\n                    const declTypeInfo = getTypeOfFunction(decl.node);\n                    if (!declTypeInfo) {\n                        break;\n                    }\n                    if (declTypeInfo.decoratedType.category === 5 /* Function */) {\n                        if (types_1.FunctionType.isOverloaded(declTypeInfo.decoratedType)) {\n                            overloadedTypes.unshift(declTypeInfo.decoratedType);\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    else if (declTypeInfo.decoratedType.category === 6 /* OverloadedFunction */) {\n                        // If the previous declaration was itself an overloaded function,\n                        // copy the last entry out of it.\n                        const lastOverload = declTypeInfo.decoratedType.overloads[declTypeInfo.decoratedType.overloads.length - 1];\n                        if (types_1.FunctionType.isOverloaded(lastOverload)) {\n                            overloadedTypes.unshift(lastOverload);\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                    declIndex--;\n                }\n                if (overloadedTypes.length > 1) {\n                    // Create a new overloaded type that copies the contents of the previous\n                    // one and adds a new function.\n                    const newOverload = types_1.OverloadedFunctionType.create();\n                    newOverload.overloads = overloadedTypes;\n                    return newOverload;\n                }\n            }\n        }\n        return type;\n    }\n    function createAsyncFunction(node, functionType) {\n        // Clone the original function and replace its return type with an\n        // Awaitable[<returnType>].\n        const awaitableFunctionType = types_1.FunctionType.clone(functionType);\n        if (functionType.details.declaredReturnType) {\n            awaitableFunctionType.details.declaredReturnType = createAwaitableReturnType(node, functionType.details.declaredReturnType);\n        }\n        // Note that the inferred type, once lazily computed, needs to wrap the\n        // resulting type in an awaitable.\n        awaitableFunctionType.details.flags |= 1024 /* WrapReturnTypeInAwait */;\n        return awaitableFunctionType;\n    }\n    function createAwaitableReturnType(node, returnType) {\n        let awaitableReturnType;\n        if (types_1.isObject(returnType)) {\n            const classType = returnType.classType;\n            if (types_1.ClassType.isBuiltIn(classType)) {\n                if (classType.details.name === 'Generator') {\n                    // If the return type is a Generator, change it to an AsyncGenerator.\n                    const asyncGeneratorType = getTypingType(node, 'AsyncGenerator');\n                    if (asyncGeneratorType && types_1.isClass(asyncGeneratorType)) {\n                        const typeArgs = [];\n                        const generatorTypeArgs = classType.typeArguments;\n                        if (generatorTypeArgs && generatorTypeArgs.length > 0) {\n                            typeArgs.push(generatorTypeArgs[0]);\n                        }\n                        if (generatorTypeArgs && generatorTypeArgs.length > 1) {\n                            typeArgs.push(generatorTypeArgs[1]);\n                        }\n                        awaitableReturnType = types_1.ObjectType.create(types_1.ClassType.cloneForSpecialization(asyncGeneratorType, typeArgs, \n                        /* isTypeArgumentExplicit */ false));\n                    }\n                }\n                else if (['AsyncGenerator', 'AsyncIterator', 'AsyncIterable'].some((name) => name === classType.details.name)) {\n                    // If it's already an AsyncGenerator, AsyncIterator or AsyncIterable,\n                    // leave it as is.\n                    awaitableReturnType = returnType;\n                }\n            }\n        }\n        if (!awaitableReturnType) {\n            // Wrap in a Coroutine, which is a subclass of Awaitable.\n            const coroutineType = getTypingType(node, 'Coroutine');\n            if (coroutineType && types_1.isClass(coroutineType)) {\n                awaitableReturnType = types_1.ObjectType.create(types_1.ClassType.cloneForSpecialization(coroutineType, [types_1.AnyType.create(), types_1.AnyType.create(), returnType], \n                /* isTypeArgumentExplicit */ true));\n            }\n            else {\n                awaitableReturnType = types_1.UnknownType.create();\n            }\n        }\n        return awaitableReturnType;\n    }\n    function inferFunctionReturnType(node, isAbstract) {\n        // This shouldn't be called if there is a declared return type.\n        debug_1.assert(!node.returnTypeAnnotation);\n        // Is this type already cached?\n        let inferredReturnType = readTypeCache(node.suite);\n        if (inferredReturnType) {\n            return inferredReturnType;\n        }\n        if (!functionRecursionMap.has(node.id)) {\n            functionRecursionMap.set(node.id, true);\n            try {\n                let functionDecl;\n                const decl = AnalyzerNodeInfo.getDeclaration(node);\n                if (decl) {\n                    functionDecl = decl;\n                }\n                // Is it a generator?\n                if (functionDecl === null || functionDecl === void 0 ? void 0 : functionDecl.yieldExpressions) {\n                    const inferredYieldTypes = [];\n                    functionDecl.yieldExpressions.forEach((yieldNode) => {\n                        if (isNodeReachable(yieldNode)) {\n                            if (yieldNode.nodeType === 62 /* YieldFrom */) {\n                                const iteratorType = getTypeOfExpression(yieldNode.expression).type;\n                                const yieldType = getTypeFromIterable(iteratorType, \n                                /* isAsync */ false, yieldNode, \n                                /* supportGetItem */ false);\n                                inferredYieldTypes.push(yieldType || types_1.UnknownType.create());\n                            }\n                            else {\n                                if (yieldNode.expression) {\n                                    const yieldType = getTypeOfExpression(yieldNode.expression).type;\n                                    inferredYieldTypes.push(yieldType || types_1.UnknownType.create());\n                                }\n                                else {\n                                    inferredYieldTypes.push(types_1.NoneType.createInstance());\n                                }\n                            }\n                        }\n                    });\n                    if (inferredYieldTypes.length === 0) {\n                        inferredYieldTypes.push(types_1.NoneType.createInstance());\n                    }\n                    inferredReturnType = types_1.combineTypes(inferredYieldTypes);\n                    // Inferred yield types need to be wrapped in a Generator to\n                    // produce the final result.\n                    const generatorType = getTypingType(node, 'Generator');\n                    if (generatorType && types_1.isClass(generatorType)) {\n                        inferredReturnType = types_1.ObjectType.create(types_1.ClassType.cloneForSpecialization(generatorType, [inferredReturnType], \n                        /* isTypeArgumentExplicit */ false));\n                    }\n                    else {\n                        inferredReturnType = types_1.UnknownType.create();\n                    }\n                }\n                else {\n                    const functionNeverReturns = !isAfterNodeReachable(node);\n                    const implicitlyReturnsNone = isAfterNodeReachable(node.suite);\n                    // Infer the return type based on all of the return statements in the function's body.\n                    if (getFileInfo(node).isStubFile) {\n                        // If a return type annotation is missing in a stub file, assume\n                        // it's an \"unknown\" type. In normal source files, we can infer the\n                        // type from the implementation.\n                        inferredReturnType = types_1.UnknownType.create();\n                    }\n                    else if (functionNeverReturns) {\n                        // If the function always raises and never returns, assume a \"NoReturn\" type.\n                        // Skip this for abstract methods which often are implemented with \"raise\n                        // NotImplementedError()\".\n                        if (isAbstract) {\n                            inferredReturnType = types_1.UnknownType.create();\n                        }\n                        else {\n                            const noReturnClass = getTypingType(node, 'NoReturn');\n                            if (noReturnClass && types_1.isClass(noReturnClass)) {\n                                inferredReturnType = types_1.ObjectType.create(noReturnClass);\n                            }\n                            else {\n                                inferredReturnType = types_1.UnknownType.create();\n                            }\n                        }\n                    }\n                    else {\n                        const inferredReturnTypes = [];\n                        if (functionDecl === null || functionDecl === void 0 ? void 0 : functionDecl.returnExpressions) {\n                            functionDecl.returnExpressions.forEach((returnNode) => {\n                                if (isNodeReachable(returnNode)) {\n                                    if (returnNode.returnExpression) {\n                                        const returnType = getTypeOfExpression(returnNode.returnExpression).type;\n                                        inferredReturnTypes.push(returnType || types_1.UnknownType.create());\n                                    }\n                                    else {\n                                        inferredReturnTypes.push(types_1.NoneType.createInstance());\n                                    }\n                                }\n                            });\n                        }\n                        if (!functionNeverReturns && implicitlyReturnsNone) {\n                            inferredReturnTypes.push(types_1.NoneType.createInstance());\n                        }\n                        inferredReturnType = types_1.combineTypes(inferredReturnTypes);\n                    }\n                }\n                // Remove any unbound values since those would generate an exception\n                // before being returned.\n                inferredReturnType = types_1.removeUnboundFromUnion(inferredReturnType);\n                writeTypeCache(node.suite, inferredReturnType);\n            }\n            finally {\n                functionRecursionMap.delete(node.id);\n            }\n        }\n        return inferredReturnType;\n    }\n    function evaluateTypesForForStatement(node) {\n        if (readTypeCache(node)) {\n            return;\n        }\n        const iteratorType = getTypeOfExpression(node.iterableExpression).type;\n        const iteratedType = getTypeFromIterable(iteratorType, !!node.isAsync, node.iterableExpression, !node.isAsync);\n        assignTypeToExpression(node.targetExpression, iteratedType, node.targetExpression);\n        writeTypeCache(node, iteratedType);\n    }\n    function evaluateTypesForExceptStatement(node) {\n        // This should be called only if the except node has a target exception.\n        debug_1.assert(node.typeExpression !== undefined);\n        if (readTypeCache(node)) {\n            return;\n        }\n        const exceptionTypes = getTypeOfExpression(node.typeExpression).type;\n        function getExceptionType(exceptionType, errorNode) {\n            if (types_1.isAnyOrUnknown(exceptionType)) {\n                return exceptionType;\n            }\n            if (types_1.isObject(exceptionType)) {\n                exceptionType = typeUtils_1.transformTypeObjectToClass(exceptionType);\n            }\n            if (types_1.isClass(exceptionType)) {\n                return types_1.ObjectType.create(exceptionType);\n            }\n            if (types_1.isObject(exceptionType)) {\n                const iterableType = getTypeFromIterable(exceptionType, \n                /* isAsync */ false, errorNode, \n                /* supportGetItem */ false);\n                return typeUtils_1.doForSubtypes(iterableType, (subtype) => {\n                    if (types_1.isAnyOrUnknown(subtype)) {\n                        return subtype;\n                    }\n                    const transformedSubtype = typeUtils_1.transformTypeObjectToClass(subtype);\n                    if (types_1.isClass(transformedSubtype)) {\n                        return types_1.ObjectType.create(transformedSubtype);\n                    }\n                    return types_1.UnknownType.create();\n                });\n            }\n            return types_1.UnknownType.create();\n        }\n        const targetType = typeUtils_1.doForSubtypes(exceptionTypes, (subType) => {\n            // If more than one type was specified for the exception, we'll receive\n            // a specialized tuple object here.\n            const tupleType = typeUtils_1.getSpecializedTupleType(subType);\n            if (tupleType && tupleType.typeArguments) {\n                const entryTypes = tupleType.typeArguments.map((t) => {\n                    return getExceptionType(t, node.typeExpression);\n                });\n                return types_1.combineTypes(entryTypes);\n            }\n            return getExceptionType(subType, node.typeExpression);\n        });\n        if (node.name) {\n            assignTypeToExpression(node.name, targetType);\n        }\n        writeTypeCache(node, targetType);\n    }\n    function evaluateTypesForWithStatement(node) {\n        if (readTypeCache(node)) {\n            return;\n        }\n        let exprType = getTypeOfExpression(node.expression).type;\n        const isAsync = node.parent && node.parent.nodeType === 59 /* With */ && !!node.parent.isAsync;\n        if (typeUtils_1.isOptionalType(exprType)) {\n            const fileInfo = getFileInfo(node);\n            addDiagnostic(fileInfo.diagnosticRuleSet.reportOptionalContextManager, \"reportOptionalContextManager\" /* reportOptionalContextManager */, localize_1.Localizer.Diagnostic.noneNotUsableWith(), node.expression);\n            exprType = types_1.removeNoneFromUnion(exprType);\n        }\n        // Verify that the target has an __enter__ or __aenter__ method defined.\n        const enterMethodName = isAsync ? '__aenter__' : '__enter__';\n        const scopedType = typeUtils_1.doForSubtypes(exprType, (subtype) => {\n            subtype = typeUtils_1.makeTypeVarsConcrete(subtype);\n            if (types_1.isAnyOrUnknown(subtype)) {\n                return subtype;\n            }\n            const diag = new diagnostic_1.DiagnosticAddendum();\n            const additionalHelp = new diagnostic_1.DiagnosticAddendum();\n            if (types_1.isObject(subtype)) {\n                const enterType = getTypeFromObjectMember(node.expression, subtype, enterMethodName, { method: 'get' }, diag, 0 /* None */);\n                if (enterType) {\n                    let memberReturnType;\n                    if (enterType.category === 5 /* Function */) {\n                        memberReturnType = getFunctionEffectiveReturnType(enterType);\n                    }\n                    else {\n                        memberReturnType = types_1.UnknownType.create();\n                    }\n                    // For \"async while\", an implicit \"await\" is performed.\n                    if (isAsync) {\n                        memberReturnType = getTypeFromAwaitable(memberReturnType, node);\n                    }\n                    return memberReturnType;\n                }\n                if (!isAsync) {\n                    const memberType = getTypeFromObjectMember(node.expression, subtype, '__aenter__', { method: 'get' }, diag, 0 /* None */);\n                    if (memberType) {\n                        additionalHelp.addMessage(localize_1.Localizer.DiagnosticAddendum.asyncHelp());\n                    }\n                }\n            }\n            const fileInfo = getFileInfo(node);\n            addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.typeNotUsableWith().format({ type: printType(subtype), method: enterMethodName }) +\n                additionalHelp.getString(), node.expression);\n            return types_1.UnknownType.create();\n        });\n        // Verify that the target has an __exit__ or __aexit__ method defined.\n        const exitMethodName = isAsync ? '__aexit__' : '__exit__';\n        typeUtils_1.doForSubtypes(exprType, (subtype) => {\n            subtype = typeUtils_1.makeTypeVarsConcrete(subtype);\n            if (types_1.isAnyOrUnknown(subtype)) {\n                return undefined;\n            }\n            const diag = new diagnostic_1.DiagnosticAddendum();\n            if (types_1.isObject(subtype)) {\n                const exitType = getTypeFromObjectMember(node.expression, subtype, exitMethodName, { method: 'get' }, diag, 0 /* None */);\n                if (exitType) {\n                    return undefined;\n                }\n            }\n            const fileInfo = getFileInfo(node);\n            addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.typeNotUsableWith().format({ type: printType(subtype), method: exitMethodName }), node.expression);\n            return undefined;\n        });\n        if (node.target) {\n            assignTypeToExpression(node.target, scopedType, node.target);\n        }\n        writeTypeCache(node, scopedType);\n    }\n    function evaluateTypesForImportAs(node) {\n        if (readTypeCache(node)) {\n            return;\n        }\n        let symbolNameNode;\n        if (node.alias) {\n            // The symbol name is defined by the alias.\n            symbolNameNode = node.alias;\n        }\n        else {\n            // There was no alias, so we need to use the first element of\n            // the name parts as the symbol.\n            symbolNameNode = node.module.nameParts[0];\n        }\n        if (!symbolNameNode) {\n            // This can happen in certain cases where there are parse errors.\n            return;\n        }\n        // Look up the symbol to find the alias declaration.\n        let symbolType = getAliasedSymbolTypeForName(node, symbolNameNode.value) || types_1.UnknownType.create();\n        // Is there a cached module type associated with this node? If so, use\n        // it instead of the type we just created.\n        const cachedModuleType = readTypeCache(node);\n        if (cachedModuleType && types_1.isModule(cachedModuleType) && symbolType) {\n            if (types_1.isTypeSame(symbolType, cachedModuleType)) {\n                symbolType = cachedModuleType;\n            }\n        }\n        assignTypeToNameNode(symbolNameNode, symbolType);\n        writeTypeCache(node, symbolType);\n    }\n    function evaluateTypesForImportFromAs(node) {\n        if (readTypeCache(node)) {\n            return;\n        }\n        const aliasNode = node.alias || node.name;\n        let symbolType = getAliasedSymbolTypeForName(node, aliasNode.value);\n        if (!symbolType) {\n            const parentNode = node.parent;\n            debug_1.assert(parentNode && parentNode.nodeType === 22 /* ImportFrom */);\n            debug_1.assert(!parentNode.isWildcardImport);\n            const importInfo = AnalyzerNodeInfo.getImportInfo(parentNode.module);\n            if (importInfo && importInfo.isImportFound && !importInfo.isNativeLib) {\n                const resolvedPath = importInfo.resolvedPaths[importInfo.resolvedPaths.length - 1];\n                const importLookupInfo = importLookup(resolvedPath);\n                const fileInfo = getFileInfo(node);\n                let reportError = false;\n                // If we were able to resolve the import, report the error as\n                // an unresolved symbol.\n                if (importLookupInfo) {\n                    // Handle PEP 562 support for module-level __getattr__ function,\n                    // introduced in Python 3.7.\n                    if (fileInfo.executionEnvironment.pythonVersion < pythonVersion_1.PythonVersion.V3_7 ||\n                        !importLookupInfo.symbolTable.get('__getattr__')) {\n                        reportError = true;\n                    }\n                }\n                else if (!resolvedPath) {\n                    // This corresponds to the \"from . import a\" form.\n                    reportError = true;\n                }\n                if (reportError) {\n                    addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.importSymbolUnknown().format({ name: node.name.value }), node.name);\n                }\n            }\n            symbolType = types_1.UnknownType.create();\n        }\n        assignTypeToNameNode(aliasNode, symbolType);\n        writeTypeCache(node, symbolType);\n    }\n    function evaluateTypesForImportFrom(node) {\n        if (readTypeCache(node)) {\n            return;\n        }\n        // Use the first element of the name parts as the symbol.\n        const symbolNameNode = node.module.nameParts[0];\n        // Look up the symbol to find the alias declaration.\n        let symbolType = getAliasedSymbolTypeForName(node, symbolNameNode.value) || types_1.UnknownType.create();\n        // Is there a cached module type associated with this node? If so, use\n        // it instead of the type we just created.\n        const cachedModuleType = readTypeCache(node);\n        if (cachedModuleType && types_1.isModule(cachedModuleType) && symbolType) {\n            if (types_1.isTypeSame(symbolType, cachedModuleType)) {\n                symbolType = cachedModuleType;\n            }\n        }\n        assignTypeToNameNode(symbolNameNode, symbolType);\n        writeTypeCache(node, symbolType);\n    }\n    function getAliasedSymbolTypeForName(node, name) {\n        const symbolWithScope = lookUpSymbolRecursive(node, name, /* honorCodeFlow */ true);\n        if (!symbolWithScope) {\n            return undefined;\n        }\n        let aliasDecl = symbolWithScope.symbol.getDeclarations().find((decl) => decl.node === node);\n        // If we didn't find an exact match, look for any alias associated with\n        // this symbol. In cases where we have multiple ImportAs nodes that share\n        // the same first-part name (e.g. \"import asyncio\" and \"import asyncio.tasks\"),\n        // we may not find the declaration associated with this node.\n        if (!aliasDecl) {\n            aliasDecl = symbolWithScope.symbol.getDeclarations().find((decl) => decl.type === 6 /* Alias */);\n        }\n        if (!aliasDecl) {\n            return undefined;\n        }\n        debug_1.assert(aliasDecl.type === 6 /* Alias */);\n        const resolvedDecl = resolveAliasDeclaration(aliasDecl, /* resolveLocalNames */ true);\n        if (!resolvedDecl) {\n            return resolvedDecl;\n        }\n        return getInferredTypeOfDeclaration(aliasDecl);\n    }\n    // In some cases, an expression must be evaluated in the context of another\n    // expression or statement that contains it. This contextual evaluation\n    // allows for bidirectional type evaluation.\n    function evaluateTypesForExpressionInContext(node) {\n        let lastContextualExpression = node;\n        let curNode = node;\n        function isContextual(node) {\n            // Parameters are contextual only for lambdas.\n            if (node.nodeType === 42 /* Parameter */ &&\n                node.parent &&\n                node.parent.nodeType === 31 /* Lambda */) {\n                return true;\n            }\n            // Arguments are contextual only for call nodes.\n            if (node.nodeType === 1 /* Argument */ &&\n                node.parent &&\n                node.parent.nodeType === 9 /* Call */) {\n                return true;\n            }\n            return (node.nodeType === 9 /* Call */ ||\n                node.nodeType === 15 /* Dictionary */ ||\n                node.nodeType === 28 /* FormatString */ ||\n                node.nodeType === 32 /* List */ ||\n                node.nodeType === 31 /* Lambda */ ||\n                node.nodeType === 36 /* MemberAccess */ ||\n                node.nodeType === 46 /* Set */ ||\n                node.nodeType === 50 /* String */ ||\n                node.nodeType === 53 /* Tuple */ ||\n                node.nodeType === 57 /* Unpack */ ||\n                node.nodeType === 17 /* DictionaryKeyEntry */ ||\n                node.nodeType === 16 /* DictionaryExpandEntry */ ||\n                node.nodeType === 33 /* ListComprehension */);\n        }\n        // Scan up the parse tree until we find a non-expression (while\n        // looking for contextual expressions in the process).\n        while (curNode) {\n            const isNodeContextual = isContextual(curNode);\n            if (!isNodeContextual && !parseNodes_1.isExpressionNode(curNode)) {\n                break;\n            }\n            if (isNodeContextual) {\n                lastContextualExpression = curNode;\n            }\n            curNode = curNode.parent;\n        }\n        const parent = lastContextualExpression.parent;\n        if (parent.nodeType === 3 /* Assignment */) {\n            if (lastContextualExpression === parent.typeAnnotationComment) {\n                getTypeOfAnnotation(lastContextualExpression, ParseTreeUtils.isFinalAllowedForAssignmentTarget(parent.leftExpression));\n            }\n            else {\n                evaluateTypesForAssignmentStatement(parent);\n            }\n            return;\n        }\n        if (parent.nodeType === 5 /* AugmentedAssignment */) {\n            evaluateTypesForAugmentedAssignment(parent);\n            return;\n        }\n        const evaluateTypeAnnotationExpression = (node) => {\n            const annotationParent = node.parent;\n            if ((annotationParent === null || annotationParent === void 0 ? void 0 : annotationParent.nodeType) === 3 /* Assignment */ && annotationParent.leftExpression === parent) {\n                evaluateTypesForAssignmentStatement(annotationParent);\n            }\n            else {\n                const annotationType = getTypeOfAnnotation(node.typeAnnotation, ParseTreeUtils.isFinalAllowedForAssignmentTarget(node.valueExpression));\n                if (annotationType) {\n                    writeTypeCache(node.valueExpression, annotationType);\n                }\n            }\n        };\n        if (parent.nodeType === 55 /* TypeAnnotation */) {\n            evaluateTypeAnnotationExpression(parent);\n            return;\n        }\n        if (parent.nodeType === 38 /* ModuleName */) {\n            getTypeOfExpression(lastContextualExpression);\n            return;\n        }\n        if (parent.nodeType === 45 /* Return */ && parent.returnExpression) {\n            const enclosingFunctionNode = ParseTreeUtils.getEnclosingFunction(node);\n            const declaredReturnType = enclosingFunctionNode\n                ? getFunctionDeclaredReturnType(enclosingFunctionNode)\n                : undefined;\n            getTypeOfExpression(parent.returnExpression, declaredReturnType, 0 /* None */);\n            return;\n        }\n        // If the parent is an expression, we'll evaluate it to provide\n        // the context for its child. If it's not, we'll evaluate the\n        // child directly without any context.\n        const nodeToEvaluate = parseNodes_1.isExpressionNode(parent) && parent.nodeType !== 0 /* Error */\n            ? parent\n            : lastContextualExpression;\n        if (nodeToEvaluate.nodeType === 55 /* TypeAnnotation */) {\n            evaluateTypeAnnotationExpression(nodeToEvaluate);\n        }\n        else {\n            getTypeOfExpression(nodeToEvaluate);\n        }\n    }\n    function evaluateTypeOfParameter(node) {\n        debug_1.assert(node.name !== undefined);\n        // We need to handle lambdas differently from functions because\n        // the former never have parameter type annotations but can\n        // be inferred, whereas the latter sometimes have type annotations\n        // but cannot be inferred.\n        const parent = node.parent;\n        if (parent.nodeType === 31 /* Lambda */) {\n            evaluateTypesForExpressionInContext(parent);\n            return;\n        }\n        debug_1.assert(parent.nodeType === 29 /* Function */);\n        const functionNode = parent;\n        if (node.typeAnnotation) {\n            writeTypeCache(node.name, transformVariadicParamType(node, node.category, getTypeOfAnnotation(node.typeAnnotation)));\n            return;\n        }\n        const paramIndex = functionNode.parameters.findIndex((param) => param === node);\n        // We may be able to infer the type of the first parameter.\n        if (paramIndex === 0) {\n            const containingClassNode = ParseTreeUtils.getEnclosingClass(functionNode, true);\n            if (containingClassNode) {\n                const classInfo = getTypeOfClass(containingClassNode);\n                if (classInfo) {\n                    const functionFlags = getFunctionFlagsFromDecorators(functionNode, true);\n                    // If the first parameter doesn't have an explicit type annotation,\n                    // provide a type if it's an instance, class or constructor method.\n                    const inferredParamType = inferFirstParamType(functionFlags, classInfo.classType);\n                    writeTypeCache(node.name, inferredParamType || types_1.UnknownType.create());\n                    return;\n                }\n            }\n        }\n        // We weren't able to infer the input parameter type. Set its\n        // type to unknown.\n        writeTypeCache(node.name, transformVariadicParamType(node, node.category, types_1.UnknownType.create()));\n    }\n    // Evaluates the types that are assigned within the statement that contains\n    // the specified parse node. In some cases, a broader statement may need to\n    // be evaluated to provide sufficient context for the type. Evaluated types\n    // are written back to the type cache for later retrieval.\n    function evaluateTypesForStatement(node) {\n        let curNode = node;\n        while (curNode) {\n            switch (curNode.nodeType) {\n                case 3 /* Assignment */: {\n                    evaluateTypesForAssignmentStatement(curNode);\n                    return;\n                }\n                case 4 /* AssignmentExpression */: {\n                    getTypeOfExpression(curNode);\n                    return;\n                }\n                case 5 /* AugmentedAssignment */: {\n                    evaluateTypesForAugmentedAssignment(curNode);\n                    return;\n                }\n                case 10 /* Class */: {\n                    getTypeOfClass(curNode);\n                    return;\n                }\n                case 42 /* Parameter */: {\n                    evaluateTypeOfParameter(curNode);\n                    return;\n                }\n                case 31 /* Lambda */: {\n                    evaluateTypesForExpressionInContext(curNode);\n                    return;\n                }\n                case 29 /* Function */: {\n                    getTypeOfFunction(curNode);\n                    return;\n                }\n                case 27 /* For */: {\n                    evaluateTypesForForStatement(curNode);\n                    return;\n                }\n                case 26 /* Except */: {\n                    evaluateTypesForExceptStatement(curNode);\n                    return;\n                }\n                case 60 /* WithItem */: {\n                    evaluateTypesForWithStatement(curNode);\n                    return;\n                }\n                case 34 /* ListComprehensionFor */: {\n                    const listComprehension = curNode.parent;\n                    debug_1.assert(listComprehension.nodeType === 33 /* ListComprehension */);\n                    evaluateTypesForExpressionInContext(listComprehension);\n                    return;\n                }\n                case 21 /* ImportAs */: {\n                    evaluateTypesForImportAs(curNode);\n                    return;\n                }\n                case 23 /* ImportFromAs */: {\n                    evaluateTypesForImportFromAs(curNode);\n                    return;\n                }\n                case 22 /* ImportFrom */: {\n                    evaluateTypesForImportFrom(curNode);\n                    return;\n                }\n            }\n            curNode = curNode.parent;\n        }\n        debug_1.fail('Unexpected assignment target');\n        return undefined;\n    }\n    function getTypeFromWildcardImport(flowNode, name) {\n        const importInfo = AnalyzerNodeInfo.getImportInfo(flowNode.node.module);\n        debug_1.assert(importInfo !== undefined && importInfo.isImportFound);\n        debug_1.assert(flowNode.node.isWildcardImport);\n        const symbolWithScope = lookUpSymbolRecursive(flowNode.node, name, /* honorCodeFlow */ false);\n        debug_1.assert(symbolWithScope !== undefined);\n        const decls = symbolWithScope.symbol.getDeclarations();\n        const wildcardDecl = decls.find((decl) => decl.node === flowNode.node);\n        if (!wildcardDecl) {\n            return types_1.UnknownType.create();\n        }\n        return getInferredTypeOfDeclaration(wildcardDecl) || types_1.UnknownType.create();\n    }\n    // When we're evaluating a call to determine whether it returns NoReturn,\n    // we don't want to do a full type evaluation, which would be expensive\n    // and create circular dependencies in type evaluation. Instead, we do\n    // a best-effort evaluation using only declared types (functions, parameters,\n    // etc.).\n    function getDeclaredCallBaseType(node) {\n        if (node.nodeType === 39 /* Name */) {\n            const symbolWithScope = lookUpSymbolRecursive(node, node.value, /* honorCodeFlow */ false);\n            if (!symbolWithScope) {\n                return undefined;\n            }\n            const symbol = symbolWithScope.symbol;\n            const type = getDeclaredTypeOfSymbol(symbol);\n            if (type) {\n                return type;\n            }\n            // There was no declared type. Before we give up, see if the\n            // symbol is a function parameter whose value can be inferred\n            // or an imported symbol.\n            const declarations = symbol.getDeclarations();\n            if (declarations.length === 0) {\n                return undefined;\n            }\n            const decl = declarations[declarations.length - 1];\n            if (decl.type === 2 /* Parameter */) {\n                evaluateTypeOfParameter(decl.node);\n                return readTypeCache(decl.node.name);\n            }\n            if (decl.type === 6 /* Alias */) {\n                return getInferredTypeOfDeclaration(decl);\n            }\n            return undefined;\n        }\n        if (node.nodeType === 36 /* MemberAccess */) {\n            const memberName = node.memberName.value;\n            let baseType = getDeclaredCallBaseType(node.leftExpression);\n            if (!baseType) {\n                return undefined;\n            }\n            baseType = typeUtils_1.makeTypeVarsConcrete(baseType);\n            let symbol;\n            if (types_1.isModule(baseType)) {\n                symbol = types_1.ModuleType.getField(baseType, memberName);\n            }\n            else if (types_1.isClass(baseType)) {\n                const classMemberInfo = typeUtils_1.lookUpClassMember(baseType, memberName);\n                symbol = classMemberInfo ? classMemberInfo.symbol : undefined;\n            }\n            else if (types_1.isObject(baseType)) {\n                const classMemberInfo = typeUtils_1.lookUpClassMember(baseType.classType, memberName);\n                symbol = classMemberInfo ? classMemberInfo.symbol : undefined;\n            }\n            if (!symbol) {\n                return undefined;\n            }\n            return getDeclaredTypeOfSymbol(symbol);\n        }\n        return undefined;\n    }\n    // Determines whether a call never returns without fully evaluating its type.\n    function isCallNoReturn(node) {\n        // See if this information is cached already.\n        if (callIsNoReturnCache.has(node.id)) {\n            return callIsNoReturnCache.get(node.id);\n        }\n        // Initially set to false to avoid infinite recursion.\n        callIsNoReturnCache.set(node.id, false);\n        let callIsNoReturn = false;\n        // Evaluate the call base type.\n        const callType = getDeclaredCallBaseType(node.leftExpression);\n        if (callType) {\n            // We assume here that no constructors or __call__ methods\n            // will be inferred \"no return\" types, so we can restrict\n            // our check to functions.\n            let functionType;\n            if (callType.category === 5 /* Function */) {\n                functionType = callType;\n            }\n            else if (callType.category === 6 /* OverloadedFunction */) {\n                // Use the last overload, which should be the most general.\n                const overloadedFunction = callType;\n                functionType = overloadedFunction.overloads[overloadedFunction.overloads.length - 1];\n            }\n            if (functionType) {\n                if (functionType.details.declaredReturnType) {\n                    callIsNoReturn = typeUtils_1.isNoReturnType(functionType.details.declaredReturnType);\n                }\n                else if (functionType.inferredReturnType) {\n                    // If the inferred return type has already been lazily\n                    // evaluated, use it.\n                    callIsNoReturn = typeUtils_1.isNoReturnType(functionType.inferredReturnType);\n                }\n                else if (functionType.details.declaration) {\n                    // If the function has yield expressions, it's a generator, and\n                    // we'll assume the yield statements are reachable. Also, don't\n                    // infer a \"no return\" type for abstract methods.\n                    if (!functionType.details.declaration.yieldExpressions &&\n                        !types_1.FunctionType.isAbstractMethod(functionType) &&\n                        !types_1.FunctionType.isStubDefinition(functionType)) {\n                        callIsNoReturn = !isAfterNodeReachable(functionType.details.declaration.node);\n                    }\n                }\n            }\n        }\n        // Cache the value for next time.\n        callIsNoReturnCache.set(node.id, callIsNoReturn);\n        return callIsNoReturn;\n    }\n    // Attempts to determine the type of the reference expression at the\n    // point in the code. If the code flow analysis has nothing to say\n    // about that expression, it return undefined.\n    function getFlowTypeOfReference(reference, targetSymbolId, initialType) {\n        // See if this execution scope requires code flow for this reference expression.\n        const referenceKey = codeFlow_1.createKeyForReference(reference);\n        const executionScope = ParseTreeUtils.getExecutionScopeNode(reference);\n        const codeFlowExpressions = AnalyzerNodeInfo.getCodeFlowExpressions(executionScope);\n        debug_1.assert(codeFlowExpressions !== undefined);\n        if (!codeFlowExpressions.has(referenceKey)) {\n            return undefined;\n        }\n        // Is there an code flow analyzer cached for this execution scope?\n        const executionNode = ParseTreeUtils.getExecutionScopeNode(reference);\n        let analyzer;\n        if (isNodeInReturnTypeInferenceContext(executionNode)) {\n            // If we're performing the analysis within a temporary\n            // context of a function for purposes of inferring its\n            // return type for a specified set of arguments, use\n            // a temporary analyzer that we'll use only for this context.\n            analyzer = getCodeFlowAnalyzerForReturnTypeInferenceContext();\n        }\n        else {\n            analyzer = codeFlowAnalyzerCache.get(executionNode.id);\n            if (!analyzer) {\n                // Allocate a new code flow analyzer.\n                analyzer = createCodeFlowAnalyzer();\n                codeFlowAnalyzerCache.set(executionNode.id, analyzer);\n            }\n        }\n        const wasIncompleteTypeMode = incompleteTypeTracker.isIncompleteTypeMode();\n        const codeFlowResult = analyzer.getTypeFromCodeFlow(reference, targetSymbolId, initialType);\n        if (codeFlowResult.isIncomplete) {\n            incompleteTypeTracker.enterIncompleteTypeMode();\n        }\n        else if (!wasIncompleteTypeMode) {\n            incompleteTypeTracker.leaveIncompleteTypeMode();\n        }\n        return codeFlowResult.type;\n    }\n    // Creates a new code flow analyzer that can be used to narrow the types\n    // of the expressions within an execution context. Each code flow analyzer\n    // instance maintains a cache of types it has already determined.\n    function createCodeFlowAnalyzer() {\n        const flowNodeTypeCacheSet = new Map();\n        function getTypeFromCodeFlow(reference, targetSymbolId, initialType) {\n            const flowNode = AnalyzerNodeInfo.getFlowNode(reference);\n            const referenceKey = codeFlow_1.createKeyForReference(reference) + `.${targetSymbolId.toString()}`;\n            let flowNodeTypeCache = flowNodeTypeCacheSet.get(referenceKey);\n            if (!flowNodeTypeCache) {\n                flowNodeTypeCache = new Map();\n                flowNodeTypeCacheSet.set(referenceKey, flowNodeTypeCache);\n            }\n            // Caches the type of the flow node in our local cache, keyed by the flow node ID.\n            function setCacheEntry(flowNode, type, isIncomplete) {\n                if (!isIncomplete) {\n                    flowIncompleteGeneration++;\n                }\n                else {\n                    const prevEntry = flowNodeTypeCache.get(flowNode.id);\n                    if (prevEntry === undefined) {\n                        flowIncompleteGeneration++;\n                    }\n                    else if (type && prevEntry.isIncompleteType) {\n                        const prevIncompleteType = prevEntry;\n                        if (prevIncompleteType.type && !types_1.isTypeSame(prevIncompleteType.type, type)) {\n                            flowIncompleteGeneration++;\n                        }\n                    }\n                }\n                // For speculative or incomplete types, we'll create a separate\n                // object. For non-speculative and complete types, we'll store\n                // the type directly.\n                const entry = isIncomplete\n                    ? {\n                        isIncompleteType: true,\n                        type,\n                        incompleteSubtypes: [],\n                        generationCount: flowIncompleteGeneration,\n                    }\n                    : type;\n                flowNodeTypeCache.set(flowNode.id, entry);\n                speculativeTypeTracker.trackEntry(flowNodeTypeCache, flowNode.id);\n                return {\n                    type,\n                    isIncomplete,\n                    generationCount: flowIncompleteGeneration,\n                    incompleteSubtypes: isIncomplete ? [] : undefined,\n                };\n            }\n            function setIncompleteSubtype(flowNode, index, type) {\n                const cachedEntry = flowNodeTypeCache.get(flowNode.id);\n                if (cachedEntry === undefined || !typeCache_1.isIncompleteType(cachedEntry)) {\n                    debug_1.fail('setIncompleteSubtype can be called only on a valid incomplete cache entry');\n                }\n                const incompleteEntries = cachedEntry.incompleteSubtypes;\n                if (index < incompleteEntries.length) {\n                    incompleteEntries[index] = type;\n                }\n                else {\n                    debug_1.assert(incompleteEntries.length === index);\n                    incompleteEntries.push(type);\n                }\n                flowIncompleteGeneration++;\n                return getCacheEntry(flowNode);\n            }\n            function deleteCacheEntry(flowNode) {\n                flowNodeTypeCache.delete(flowNode.id);\n            }\n            function getCacheEntry(flowNode) {\n                if (!flowNodeTypeCache.has(flowNode.id)) {\n                    return undefined;\n                }\n                const cachedEntry = flowNodeTypeCache.get(flowNode.id);\n                if (cachedEntry === undefined) {\n                    return {\n                        type: cachedEntry,\n                        isIncomplete: false,\n                    };\n                }\n                if (!typeCache_1.isIncompleteType(cachedEntry)) {\n                    return {\n                        type: cachedEntry,\n                        isIncomplete: false,\n                    };\n                }\n                let type = cachedEntry.type;\n                if (cachedEntry.incompleteSubtypes.length > 0) {\n                    // Recompute the effective type based on all of the incomplete\n                    // types we've accumulated so far.\n                    const typesToCombine = [];\n                    cachedEntry.incompleteSubtypes.forEach((t) => {\n                        if (t) {\n                            typesToCombine.push(t);\n                        }\n                    });\n                    type = typesToCombine.length > 0 ? types_1.combineTypes(typesToCombine) : undefined;\n                }\n                return {\n                    type,\n                    isIncomplete: true,\n                    incompleteSubtypes: cachedEntry.incompleteSubtypes,\n                    generationCount: cachedEntry.generationCount,\n                };\n            }\n            function evaluateAssignmentFlowNode(flowNode) {\n                // For function and class nodes, the reference node is the name\n                // node, but we need to use the parent node (the FunctionNode or ClassNode)\n                // to access the decorated type in the type cache.\n                let nodeForCacheLookup = flowNode.node;\n                const parentNode = flowNode.node.parent;\n                if (parentNode) {\n                    if (parentNode.nodeType === 29 /* Function */ || parentNode.nodeType === 10 /* Class */) {\n                        nodeForCacheLookup = parentNode;\n                    }\n                }\n                let cachedType = readTypeCache(nodeForCacheLookup);\n                if (!cachedType) {\n                    // There is no cached type for this expression, so we need to\n                    // evaluate it.\n                    evaluateTypesForStatement(flowNode.node);\n                    cachedType = readTypeCache(nodeForCacheLookup);\n                }\n                return cachedType;\n            }\n            // If this flow has no knowledge of the target expression, it returns undefined.\n            // If the start flow node for this scope is reachable, the typeAtStart value is\n            // returned.\n            function getTypeFromFlowNode(flowNode, reference, targetSymbolId, initialType) {\n                let curFlowNode = flowNode;\n                // This is a frequently-called routine, so it's a good place to call\n                // the cancellation check. If the operation is canceled, an exception\n                // will be thrown at this point.\n                checkForCancellation();\n                while (true) {\n                    // Have we already been here? If so, use the cached value.\n                    const cachedEntry = getCacheEntry(curFlowNode);\n                    if (cachedEntry) {\n                        // If the cached entry is incomplete, we can use it only if nothing\n                        // has changed that may cause the previously-reported incomplete type to change.\n                        if (!cachedEntry.isIncomplete || cachedEntry.generationCount === flowIncompleteGeneration) {\n                            return cachedEntry;\n                        }\n                    }\n                    if (curFlowNode.flags & codeFlow_1.FlowFlags.Unreachable) {\n                        // We can get here if there are nodes in a compound logical expression\n                        // (e.g. \"False and x\") that are never executed but are evaluated.\n                        // The type doesn't matter in this case.\n                        return setCacheEntry(curFlowNode, undefined, /* isIncomplete */ false);\n                    }\n                    if (curFlowNode.flags & codeFlow_1.FlowFlags.Call) {\n                        const callFlowNode = curFlowNode;\n                        // If this function returns a \"NoReturn\" type, that means\n                        // it always raises an exception or otherwise doesn't return,\n                        // so we can assume that the code before this is unreachable.\n                        if (isCallNoReturn(callFlowNode.node)) {\n                            return setCacheEntry(curFlowNode, undefined, /* isIncomplete */ false);\n                        }\n                        curFlowNode = callFlowNode.antecedent;\n                        continue;\n                    }\n                    if (curFlowNode.flags & codeFlow_1.FlowFlags.Assignment) {\n                        const assignmentFlowNode = curFlowNode;\n                        // Are we targeting the same symbol? We need to do this extra check because the same\n                        // symbol name might refer to different symbols in different scopes (e.g. a list\n                        // comprehension introduces a new scope).\n                        if (targetSymbolId === assignmentFlowNode.targetSymbolId &&\n                            ParseTreeUtils.isMatchingExpression(reference, assignmentFlowNode.node)) {\n                            // Is this a special \"unbind\" assignment? If so,\n                            // we can handle it immediately without any further evaluation.\n                            if (curFlowNode.flags & codeFlow_1.FlowFlags.Unbind) {\n                                return setCacheEntry(curFlowNode, types_1.UnboundType.create(), /* isIncomplete */ false);\n                            }\n                            // If there was a cache entry already, that means we hit a recursive\n                            // case (something like \"int: int = 4\"). Avoid infinite recursion\n                            // by returning an undefined type.\n                            if (cachedEntry) {\n                                return { type: undefined, isIncomplete: true };\n                            }\n                            // Set the cache entry to undefined before evaluating the\n                            // expression in case it depends on itself.\n                            setCacheEntry(curFlowNode, undefined, /* isIncomplete */ true);\n                            const flowType = evaluateAssignmentFlowNode(assignmentFlowNode);\n                            return setCacheEntry(curFlowNode, flowType, /* isIncomplete */ false);\n                        }\n                        curFlowNode = assignmentFlowNode.antecedent;\n                        continue;\n                    }\n                    if (curFlowNode.flags & codeFlow_1.FlowFlags.AssignmentAlias) {\n                        const aliasFlowNode = curFlowNode;\n                        // If the target symbol ID matches, replace with its alias\n                        // and continue to traverse the code flow graph.\n                        if (targetSymbolId === aliasFlowNode.targetSymbolId) {\n                            targetSymbolId = aliasFlowNode.aliasSymbolId;\n                        }\n                        curFlowNode = aliasFlowNode.antecedent;\n                        continue;\n                    }\n                    if (curFlowNode.flags & codeFlow_1.FlowFlags.BranchLabel) {\n                        const labelNode = curFlowNode;\n                        const typesToCombine = [];\n                        let sawIncomplete = false;\n                        labelNode.antecedents.forEach((antecedent) => {\n                            const flowTypeResult = getTypeFromFlowNode(antecedent, reference, targetSymbolId, initialType);\n                            if (flowTypeResult.isIncomplete) {\n                                sawIncomplete = true;\n                            }\n                            if (flowTypeResult.type) {\n                                typesToCombine.push(flowTypeResult.type);\n                            }\n                        });\n                        const effectiveType = types_1.combineTypes(typesToCombine);\n                        return setCacheEntry(curFlowNode, effectiveType, sawIncomplete);\n                    }\n                    if (curFlowNode.flags & codeFlow_1.FlowFlags.LoopLabel) {\n                        const labelNode = curFlowNode;\n                        let firstWasIncomplete = false;\n                        let isFirstTimeInLoop = false;\n                        // See if we've been here before. If so, there will be an incomplete cache entry.\n                        let cacheEntry = getCacheEntry(curFlowNode);\n                        if (cacheEntry === undefined) {\n                            // We haven't been here before, so create a new incomplete cache entry.\n                            isFirstTimeInLoop = true;\n                            cacheEntry = setCacheEntry(curFlowNode, undefined, /* isIncomplete */ true);\n                        }\n                        labelNode.antecedents.forEach((antecedent, index) => {\n                            // Have we already been here? If so, there will be an entry\n                            // for this index, and we can use the type that was already\n                            // computed.\n                            if (index >= cacheEntry.incompleteSubtypes.length) {\n                                // Set the incomplete type for this index to undefined to prevent\n                                // infinite recursion. We'll set it to the computed value below.\n                                cacheEntry = setIncompleteSubtype(curFlowNode, index, undefined);\n                                const flowTypeResult = getTypeFromFlowNode(antecedent, reference, targetSymbolId, initialType);\n                                if (flowTypeResult.isIncomplete && index === 0) {\n                                    firstWasIncomplete = true;\n                                }\n                                cacheEntry = setIncompleteSubtype(curFlowNode, index, flowTypeResult.type);\n                            }\n                        });\n                        if (!isFirstTimeInLoop) {\n                            // This was not the first time through the loop, so we are recursively trying\n                            // to resolve other parts of the incomplete type. It will be marked complete\n                            // once the stack pops back up to the first caller.\n                            return cacheEntry;\n                        }\n                        // The result is incomplete only if the first antecedent (the edge\n                        // that feeds the loop) is incomplete.\n                        if (firstWasIncomplete) {\n                            deleteCacheEntry(curFlowNode);\n                            return { type: cacheEntry.type, isIncomplete: true };\n                        }\n                        // We have made it all the way through all the antecedents, and we can\n                        // mark the type as complete.\n                        return setCacheEntry(curFlowNode, cacheEntry.type, /* isIncomplete */ false);\n                    }\n                    if (curFlowNode.flags & (codeFlow_1.FlowFlags.TrueCondition | codeFlow_1.FlowFlags.FalseCondition)) {\n                        const conditionalFlowNode = curFlowNode;\n                        const typeNarrowingCallback = getTypeNarrowingCallback(reference, conditionalFlowNode);\n                        if (typeNarrowingCallback) {\n                            const flowTypeResult = getTypeFromFlowNode(conditionalFlowNode.antecedent, reference, targetSymbolId, initialType);\n                            let flowType = flowTypeResult.type;\n                            if (flowType) {\n                                flowType = typeNarrowingCallback(flowType);\n                            }\n                            return setCacheEntry(curFlowNode, flowType, flowTypeResult.isIncomplete);\n                        }\n                        curFlowNode = conditionalFlowNode.antecedent;\n                        continue;\n                    }\n                    if (curFlowNode.flags & codeFlow_1.FlowFlags.PreFinallyGate) {\n                        const preFinallyFlowNode = curFlowNode;\n                        if (preFinallyFlowNode.isGateClosed) {\n                            return { type: undefined, isIncomplete: false };\n                        }\n                        curFlowNode = preFinallyFlowNode.antecedent;\n                        continue;\n                    }\n                    if (curFlowNode.flags & codeFlow_1.FlowFlags.PostFinally) {\n                        const postFinallyFlowNode = curFlowNode;\n                        const wasGateClosed = postFinallyFlowNode.preFinallyGate.isGateClosed;\n                        try {\n                            postFinallyFlowNode.preFinallyGate.isGateClosed = true;\n                            const flowTypeResult = getTypeFromFlowNode(postFinallyFlowNode.antecedent, reference, targetSymbolId, initialType);\n                            // If the type is incomplete, don't write back to the cache.\n                            return flowTypeResult.isIncomplete\n                                ? flowTypeResult\n                                : setCacheEntry(curFlowNode, flowTypeResult.type, /* isIncomplete */ false);\n                        }\n                        finally {\n                            postFinallyFlowNode.preFinallyGate.isGateClosed = wasGateClosed;\n                        }\n                    }\n                    if (curFlowNode.flags & codeFlow_1.FlowFlags.Start) {\n                        return setCacheEntry(curFlowNode, initialType, /* isIncomplete */ false);\n                    }\n                    if (curFlowNode.flags & codeFlow_1.FlowFlags.WildcardImport) {\n                        const wildcardImportFlowNode = curFlowNode;\n                        if (reference.nodeType === 39 /* Name */) {\n                            const nameValue = reference.value;\n                            if (wildcardImportFlowNode.names.some((name) => name === nameValue)) {\n                                const type = getTypeFromWildcardImport(wildcardImportFlowNode, nameValue);\n                                return setCacheEntry(curFlowNode, type, /* isIncomplete */ false);\n                            }\n                        }\n                        curFlowNode = wildcardImportFlowNode.antecedent;\n                        continue;\n                    }\n                    // We shouldn't get here.\n                    debug_1.fail('Unexpected flow node flags');\n                    return setCacheEntry(curFlowNode, undefined, /* isIncomplete */ false);\n                }\n            }\n            if (!flowNode) {\n                // This should happen only in cases where we're evaluating\n                // parse nodes that are created after the initial parse\n                // (namely, string literals that are used for forward\n                // referenced types).\n                return {\n                    type: initialType,\n                    isIncomplete: false,\n                };\n            }\n            return getTypeFromFlowNode(flowNode, reference, targetSymbolId, initialType);\n        }\n        return {\n            getTypeFromCodeFlow,\n        };\n    }\n    // Determines whether the specified flowNode can be reached by any\n    // control flow path within the execution context. If sourceFlowNode\n    // is specified, it returns true only if at least one control flow\n    // path passes through sourceFlowNode.\n    function isFlowNodeReachable(flowNode, sourceFlowNode) {\n        const visitedFlowNodeMap = new Map();\n        function isFlowNodeReachableRecursive(flowNode, sourceFlowNode) {\n            let curFlowNode = flowNode;\n            while (true) {\n                // If we've already visited this node, we can assume\n                // it wasn't reachable.\n                if (visitedFlowNodeMap.has(curFlowNode.id)) {\n                    return false;\n                }\n                // Note that we've been here before.\n                visitedFlowNodeMap.set(curFlowNode.id, true);\n                if (curFlowNode.flags & codeFlow_1.FlowFlags.Unreachable) {\n                    return false;\n                }\n                if (curFlowNode === sourceFlowNode) {\n                    return true;\n                }\n                if (curFlowNode.flags & codeFlow_1.FlowFlags.Call) {\n                    const callFlowNode = curFlowNode;\n                    // If we're determining whether a specified source flow node is\n                    // reachable, don't take into consideration possible \"no return\"\n                    // calls.\n                    if (sourceFlowNode === undefined) {\n                        // If this function returns a \"NoReturn\" type, that means\n                        // it always raises an exception or otherwise doesn't return,\n                        // so we can assume that the code before this is unreachable.\n                        if (isCallNoReturn(callFlowNode.node)) {\n                            return false;\n                        }\n                    }\n                    curFlowNode = callFlowNode.antecedent;\n                    continue;\n                }\n                if (curFlowNode.flags & codeFlow_1.FlowFlags.Assignment) {\n                    const assignmentFlowNode = curFlowNode;\n                    curFlowNode = assignmentFlowNode.antecedent;\n                    continue;\n                }\n                if (curFlowNode.flags & codeFlow_1.FlowFlags.AssignmentAlias) {\n                    const aliasFlowNode = curFlowNode;\n                    curFlowNode = aliasFlowNode.antecedent;\n                    continue;\n                }\n                if (curFlowNode.flags & (codeFlow_1.FlowFlags.BranchLabel | codeFlow_1.FlowFlags.LoopLabel)) {\n                    const labelNode = curFlowNode;\n                    for (const antecedent of labelNode.antecedents) {\n                        if (isFlowNodeReachableRecursive(antecedent, sourceFlowNode)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n                if (curFlowNode.flags & (codeFlow_1.FlowFlags.TrueCondition | codeFlow_1.FlowFlags.FalseCondition)) {\n                    const conditionalFlowNode = curFlowNode;\n                    curFlowNode = conditionalFlowNode.antecedent;\n                    continue;\n                }\n                if (curFlowNode.flags & codeFlow_1.FlowFlags.PreFinallyGate) {\n                    const preFinallyFlowNode = curFlowNode;\n                    if (preFinallyFlowNode.isGateClosed) {\n                        return false;\n                    }\n                    curFlowNode = preFinallyFlowNode.antecedent;\n                    continue;\n                }\n                if (curFlowNode.flags & codeFlow_1.FlowFlags.PostFinally) {\n                    const postFinallyFlowNode = curFlowNode;\n                    const wasGateClosed = postFinallyFlowNode.preFinallyGate.isGateClosed;\n                    try {\n                        postFinallyFlowNode.preFinallyGate.isGateClosed = true;\n                        return isFlowNodeReachableRecursive(postFinallyFlowNode.antecedent, sourceFlowNode);\n                    }\n                    finally {\n                        postFinallyFlowNode.preFinallyGate.isGateClosed = wasGateClosed;\n                    }\n                }\n                if (curFlowNode.flags & codeFlow_1.FlowFlags.Start) {\n                    // If we hit the start but were looking for a particular source flow\n                    // node, return false. Otherwise, the start is what we're looking for.\n                    return sourceFlowNode ? false : true;\n                }\n                if (curFlowNode.flags & codeFlow_1.FlowFlags.WildcardImport) {\n                    const wildcardImportFlowNode = curFlowNode;\n                    curFlowNode = wildcardImportFlowNode.antecedent;\n                    continue;\n                }\n                // We shouldn't get here.\n                debug_1.fail('Unexpected flow node flags');\n                return false;\n            }\n        }\n        // Protect against infinite recursion.\n        if (isReachableRecursionMap.has(flowNode.id)) {\n            return true;\n        }\n        isReachableRecursionMap.set(flowNode.id, true);\n        try {\n            return isFlowNodeReachableRecursive(flowNode, sourceFlowNode);\n        }\n        finally {\n            isReachableRecursionMap.delete(flowNode.id);\n        }\n    }\n    // Given a reference expression and a flow node, returns a callback that\n    // can be used to narrow the type described by the target expression.\n    // If the specified flow node is not associated with the target expression,\n    // it returns undefined.\n    function getTypeNarrowingCallback(reference, flowNode) {\n        let testExpression = flowNode.expression;\n        const isPositiveTest = !!(flowNode.flags & codeFlow_1.FlowFlags.TrueCondition);\n        if (testExpression.nodeType === 4 /* AssignmentExpression */) {\n            if (ParseTreeUtils.isMatchingExpression(reference, testExpression.rightExpression)) {\n                testExpression = testExpression.rightExpression;\n            }\n            else if (ParseTreeUtils.isMatchingExpression(reference, testExpression.name)) {\n                testExpression = testExpression.name;\n            }\n        }\n        if (testExpression.nodeType === 7 /* BinaryOperation */) {\n            const isOrIsNotOperator = testExpression.operator === 39 /* Is */ || testExpression.operator === 40 /* IsNot */;\n            const equalsOrNotEqualsOperator = testExpression.operator === 12 /* Equals */ || testExpression.operator === 28 /* NotEquals */;\n            if (isOrIsNotOperator || equalsOrNotEqualsOperator) {\n                // Invert the \"isPositiveTest\" value if this is an \"is not\" operation.\n                const adjIsPositiveTest = testExpression.operator === 39 /* Is */ || testExpression.operator === 12 /* Equals */\n                    ? isPositiveTest\n                    : !isPositiveTest;\n                // Look for \"X is None\", \"X is not None\", \"X == None\", and \"X != None\".\n                // These are commonly-used patterns used in control flow.\n                if (testExpression.rightExpression.nodeType === 11 /* Constant */ &&\n                    testExpression.rightExpression.constType === 24 /* None */) {\n                    // Allow the LHS to be either a simple expression or an assignment\n                    // expression that assigns to a simple name.\n                    let leftExpression = testExpression.leftExpression;\n                    if (leftExpression.nodeType === 4 /* AssignmentExpression */) {\n                        leftExpression = leftExpression.name;\n                    }\n                    if (ParseTreeUtils.isMatchingExpression(reference, leftExpression)) {\n                        // Narrow the type by filtering on \"None\".\n                        return (type) => {\n                            if (type.category === 10 /* Union */) {\n                                const remainingTypes = type.subtypes.filter((t) => {\n                                    if (types_1.isAnyOrUnknown(t)) {\n                                        // We need to assume that \"Any\" is always both None and not None,\n                                        // so it matches regardless of whether the test is positive or negative.\n                                        return true;\n                                    }\n                                    // See if it's a match for None.\n                                    return types_1.isNone(t) === adjIsPositiveTest;\n                                });\n                                return types_1.combineTypes(remainingTypes);\n                            }\n                            else if (types_1.isNone(type)) {\n                                if (!adjIsPositiveTest) {\n                                    // Use a \"Never\" type (which is a special form\n                                    // of None) to indicate that the condition will\n                                    // always evaluate to false.\n                                    return types_1.NeverType.create();\n                                }\n                            }\n                            return type;\n                        };\n                    }\n                }\n                // Look for \"type(X) is Y\" or \"type(X) is not Y\".\n                if (isOrIsNotOperator && testExpression.leftExpression.nodeType === 9 /* Call */) {\n                    const callType = getTypeOfExpression(testExpression.leftExpression.leftExpression).type;\n                    if (types_1.isClass(callType) &&\n                        types_1.ClassType.isBuiltIn(callType, 'type') &&\n                        testExpression.leftExpression.arguments.length === 1 &&\n                        testExpression.leftExpression.arguments[0].argumentCategory === 0 /* Simple */) {\n                        const arg0Expr = testExpression.leftExpression.arguments[0].valueExpression;\n                        if (ParseTreeUtils.isMatchingExpression(reference, arg0Expr)) {\n                            const classType = getTypeOfExpression(testExpression.rightExpression).type;\n                            if (types_1.isClass(classType)) {\n                                return (type) => {\n                                    // Narrow the type based on whether the type matches the specified type.\n                                    return typeUtils_1.doForSubtypes(type, (subtype) => {\n                                        if (types_1.isObject(subtype)) {\n                                            const matches = types_1.ClassType.isSameGenericClass(subtype.classType, classType);\n                                            if (adjIsPositiveTest) {\n                                                return matches ? subtype : undefined;\n                                            }\n                                            else {\n                                                return matches ? undefined : subtype;\n                                            }\n                                        }\n                                        else if (types_1.isNone(subtype)) {\n                                            return adjIsPositiveTest ? undefined : subtype;\n                                        }\n                                        return subtype;\n                                    });\n                                };\n                            }\n                        }\n                    }\n                }\n                // Look for \"X is Y\" or \"X is not Y\" where Y is a an enum.\n                if (isOrIsNotOperator) {\n                    if (ParseTreeUtils.isMatchingExpression(reference, testExpression.leftExpression)) {\n                        const rightType = getTypeOfExpression(testExpression.rightExpression).type;\n                        if (types_1.isObject(rightType) &&\n                            types_1.ClassType.isEnumClass(rightType.classType) &&\n                            rightType.classType.literalValue !== undefined) {\n                            return (type) => {\n                                return narrowTypeForLiteralComparison(type, rightType, adjIsPositiveTest);\n                            };\n                        }\n                    }\n                }\n                // Look for X == <literal> or X != <literal>\n                if (equalsOrNotEqualsOperator) {\n                    const adjIsPositiveTest = testExpression.operator === 12 /* Equals */ ? isPositiveTest : !isPositiveTest;\n                    if (ParseTreeUtils.isMatchingExpression(reference, testExpression.leftExpression)) {\n                        const rightType = getTypeOfExpression(testExpression.rightExpression).type;\n                        if (types_1.isObject(rightType) && rightType.classType.literalValue !== undefined) {\n                            return (type) => {\n                                return narrowTypeForLiteralComparison(type, rightType, adjIsPositiveTest);\n                            };\n                        }\n                    }\n                    if (ParseTreeUtils.isMatchingExpression(reference, testExpression.rightExpression)) {\n                        const leftType = getTypeOfExpression(testExpression.leftExpression).type;\n                        if (types_1.isObject(leftType) && leftType.classType.literalValue !== undefined) {\n                            return (type) => {\n                                return narrowTypeForLiteralComparison(type, leftType, adjIsPositiveTest);\n                            };\n                        }\n                    }\n                }\n            }\n            if (testExpression.operator === 41 /* In */ && isPositiveTest) {\n                if (ParseTreeUtils.isMatchingExpression(reference, testExpression.leftExpression)) {\n                    const rightType = getTypeOfExpression(testExpression.rightExpression).type;\n                    return (type) => {\n                        return narrowTypeForContains(type, rightType);\n                    };\n                }\n            }\n        }\n        if (testExpression.nodeType === 9 /* Call */) {\n            if (testExpression.leftExpression.nodeType === 39 /* Name */) {\n                // Look for \"isinstance(X, Y)\" or \"issubclass(X, Y)\".\n                if ((testExpression.leftExpression.value === 'isinstance' ||\n                    testExpression.leftExpression.value === 'issubclass') &&\n                    testExpression.arguments.length === 2) {\n                    // Make sure the first parameter is a supported expression type\n                    // and the second parameter is a valid class type or a tuple\n                    // of valid class types.\n                    const isInstanceCheck = testExpression.leftExpression.value === 'isinstance';\n                    const arg0Expr = testExpression.arguments[0].valueExpression;\n                    const arg1Expr = testExpression.arguments[1].valueExpression;\n                    if (ParseTreeUtils.isMatchingExpression(reference, arg0Expr)) {\n                        const arg1Type = getTypeOfExpression(arg1Expr, undefined, 32 /* EvaluateStringLiteralAsType */ | 128 /* ParamSpecDisallowed */).type;\n                        const classTypeList = getIsInstanceClassTypes(arg1Type);\n                        if (classTypeList) {\n                            return (type) => {\n                                return narrowTypeForIsInstance(type, classTypeList, isInstanceCheck, isPositiveTest);\n                            };\n                        }\n                    }\n                }\n                else if (testExpression.leftExpression.value === 'callable' &&\n                    testExpression.arguments.length === 1) {\n                    const arg0Expr = testExpression.arguments[0].valueExpression;\n                    if (ParseTreeUtils.isMatchingExpression(reference, arg0Expr)) {\n                        return (type) => {\n                            return narrowTypeForCallable(type, isPositiveTest, testExpression);\n                        };\n                    }\n                }\n            }\n        }\n        if (ParseTreeUtils.isMatchingExpression(reference, testExpression)) {\n            return (type) => {\n                // Narrow the type based on whether the subtype can be true or false.\n                return typeUtils_1.doForSubtypes(type, (subtype) => {\n                    if (isPositiveTest) {\n                        if (typeUtils_1.canBeTruthy(subtype)) {\n                            return typeUtils_1.removeFalsinessFromType(subtype);\n                        }\n                    }\n                    else {\n                        if (typeUtils_1.canBeFalsy(subtype)) {\n                            return typeUtils_1.removeTruthinessFromType(subtype);\n                        }\n                    }\n                    return undefined;\n                });\n            };\n        }\n        return undefined;\n    }\n    // The \"isinstance\" and \"issubclass\" calls support two forms - a simple form\n    // that accepts a single class, and a more complex form that accepts a tuple\n    // of classes. This method determines which form and returns a list of classes\n    // or undefined.\n    function getIsInstanceClassTypes(argType) {\n        if (types_1.isClass(argType)) {\n            return [argType];\n        }\n        if (types_1.isObject(argType)) {\n            const objClass = argType.classType;\n            if (types_1.ClassType.isBuiltIn(objClass, 'Tuple') && objClass.typeArguments) {\n                let foundNonClassType = false;\n                const classTypeList = [];\n                objClass.typeArguments.forEach((typeArg) => {\n                    if (types_1.isClass(typeArg)) {\n                        classTypeList.push(typeArg);\n                    }\n                    else {\n                        foundNonClassType = true;\n                    }\n                });\n                if (!foundNonClassType) {\n                    return classTypeList;\n                }\n            }\n        }\n        return undefined;\n    }\n    // Attempts to narrow a type (make it more constrained) based on a\n    // call to isinstance or issubclass. For example, if the original\n    // type of expression \"x\" is \"Mammal\" and the test expression is\n    // \"isinstance(x, Cow)\", (assuming \"Cow\" is a subclass of \"Mammal\"),\n    // we can conclude that x must be constrained to \"Cow\".\n    function narrowTypeForIsInstance(type, classTypeList, isInstanceCheck, isPositiveTest) {\n        let effectiveType = typeUtils_1.doForSubtypes(type, (subtype) => {\n            return typeUtils_1.transformTypeObjectToClass(subtype);\n        });\n        // Handle bound TypeVar.\n        effectiveType = typeUtils_1.makeTypeVarsConcrete(effectiveType);\n        // Filters the varType by the parameters of the isinstance\n        // and returns the list of types the varType could be after\n        // applying the filter.\n        const filterType = (varType) => {\n            const filteredTypes = [];\n            let foundSuperclass = false;\n            let isClassRelationshipIndeterminate = false;\n            for (const filterType of classTypeList) {\n                const filterIsSuperclass = types_1.ClassType.isDerivedFrom(varType, filterType);\n                const filterIsSubclass = types_1.ClassType.isDerivedFrom(filterType, varType);\n                if (filterIsSuperclass) {\n                    foundSuperclass = true;\n                }\n                // Normally, a type should never be both a subclass or a superclass.\n                // This can happen if either of the class types derives from a\n                // class whose type is unknown (e.g. an import failed). We'll\n                // note this case specially so we don't do any narrowing, which\n                // will generate false positives.\n                if (filterIsSubclass && filterIsSuperclass && !types_1.ClassType.isSameGenericClass(varType, filterType)) {\n                    isClassRelationshipIndeterminate = true;\n                }\n                if (isPositiveTest) {\n                    if (filterIsSuperclass) {\n                        // If the variable type is a subclass of the isinstance\n                        // filter, we haven't learned anything new about the\n                        // variable type.\n                        filteredTypes.push(varType);\n                    }\n                    else if (filterIsSubclass) {\n                        // If the variable type is a superclass of the isinstance\n                        // filter, we can narrow the type to the subclass.\n                        filteredTypes.push(filterType);\n                    }\n                }\n            }\n            // In the negative case, if one or more of the filters\n            // always match the type (i.e. they are an exact match or\n            // a superclass of the type), then there's nothing left after\n            // the filter is applied. If we didn't find any superclass\n            // match, then the original variable type survives the filter.\n            if (!isPositiveTest) {\n                if (!foundSuperclass || isClassRelationshipIndeterminate) {\n                    filteredTypes.push(varType);\n                }\n            }\n            if (!isInstanceCheck) {\n                return filteredTypes;\n            }\n            return filteredTypes.map((t) => types_1.ObjectType.create(t));\n        };\n        if (isInstanceCheck && types_1.isObject(effectiveType)) {\n            const filteredType = filterType(effectiveType.classType);\n            return types_1.combineTypes(filteredType);\n        }\n        else if (!isInstanceCheck && types_1.isClass(effectiveType)) {\n            const filteredType = filterType(effectiveType);\n            return types_1.combineTypes(filteredType);\n        }\n        else if (effectiveType.category === 10 /* Union */) {\n            let remainingTypes = [];\n            effectiveType.subtypes.forEach((t) => {\n                if (types_1.isAnyOrUnknown(t)) {\n                    // Any types always remain for both positive and negative\n                    // checks because we can't say anything about them.\n                    remainingTypes.push(t);\n                }\n                else if (isInstanceCheck && types_1.isObject(t)) {\n                    remainingTypes = remainingTypes.concat(filterType(t.classType));\n                }\n                else if (!isInstanceCheck && types_1.isClass(t)) {\n                    remainingTypes = remainingTypes.concat(filterType(t));\n                }\n                else {\n                    // All other types are never instances of a class.\n                    if (!isPositiveTest) {\n                        remainingTypes.push(t);\n                    }\n                }\n            });\n            return types_1.combineTypes(remainingTypes);\n        }\n        else if (isInstanceCheck && isPositiveTest && types_1.isAnyOrUnknown(effectiveType)) {\n            // If this is a positive test for isinstance and the effective\n            // type is Any or Unknown, we can assume that the type matches\n            // one of the specified types.\n            type = types_1.combineTypes(classTypeList.map((classType) => types_1.ObjectType.create(classType)));\n        }\n        // Return the original type.\n        return type;\n    }\n    // Attempts to narrow a type (make it more constrained) based on an \"in\" or\n    // \"not in\" binary expression.\n    function narrowTypeForContains(referenceType, containerType) {\n        // We support contains narrowing only for certain built-in types that have been specialized.\n        if (!types_1.isObject(containerType) || !types_1.ClassType.isBuiltIn(containerType.classType)) {\n            return referenceType;\n        }\n        const classType = containerType.classType;\n        const builtInName = classType.details.aliasClass\n            ? classType.details.aliasClass.details.name\n            : classType.details.name;\n        if (!['list', 'set', 'frozenset', 'deque'].some((name) => name === builtInName)) {\n            return referenceType;\n        }\n        if (!classType.typeArguments || classType.typeArguments.length !== 1) {\n            return referenceType;\n        }\n        const typeArg = classType.typeArguments[0];\n        let canNarrow = true;\n        const narrowedType = typeUtils_1.doForSubtypes(referenceType, (subtype) => {\n            if (types_1.isAnyOrUnknown(subtype)) {\n                canNarrow = false;\n                return subtype;\n            }\n            if (!canAssignType(typeArg, subtype, new diagnostic_1.DiagnosticAddendum())) {\n                // If the reference type isn't assignable to the element type, we will\n                // assume that the __contains__ method will return false.\n                return undefined;\n            }\n            return subtype;\n        });\n        return canNarrow ? narrowedType : referenceType;\n    }\n    // Attempts to narrow a type (make it more constrained) based on a comparison\n    // (equal or not equal) to a literal value.\n    function narrowTypeForLiteralComparison(referenceType, literalType, isPositiveTest) {\n        let canNarrow = true;\n        const narrowedType = typeUtils_1.doForSubtypes(referenceType, (subtype) => {\n            if (types_1.isObject(subtype) && types_1.ClassType.isSameGenericClass(literalType.classType, subtype.classType)) {\n                if (subtype.classType.literalValue !== undefined) {\n                    const literalValueMatches = types_1.ClassType.isLiteralValueSame(subtype.classType, literalType.classType);\n                    if ((literalValueMatches && !isPositiveTest) || (!literalValueMatches && isPositiveTest)) {\n                        return undefined;\n                    }\n                    return subtype;\n                }\n                else if (isPositiveTest) {\n                    return literalType;\n                }\n                else {\n                    // If we're able to enumerate all possible literal values\n                    // (for bool or enum), we can eliminate all others in a negative test.\n                    const allLiteralTypes = typeUtils_1.enumerateLiteralsForType(subtype);\n                    if (allLiteralTypes) {\n                        return types_1.combineTypes(allLiteralTypes.filter((type) => !types_1.ClassType.isLiteralValueSame(type.classType, literalType.classType)));\n                    }\n                }\n            }\n            canNarrow = false;\n            return subtype;\n        });\n        return canNarrow ? narrowedType : referenceType;\n    }\n    // Attempts to narrow a type (make it more constrained) based on a\n    // call to \"callable\". For example, if the original type of expression \"x\" is\n    // Union[Callable[..., Any], Type[int], int], it would remove the \"int\" because\n    // it's not callable.\n    function narrowTypeForCallable(type, isPositiveTest, errorNode) {\n        return typeUtils_1.doForSubtypes(type, (subtype) => {\n            switch (subtype.category) {\n                case 5 /* Function */:\n                case 6 /* OverloadedFunction */:\n                case 7 /* Class */: {\n                    return isPositiveTest ? subtype : undefined;\n                }\n                case 9 /* Module */: {\n                    return isPositiveTest ? undefined : subtype;\n                }\n                case 8 /* Object */: {\n                    const classFromTypeObject = getClassFromPotentialTypeObject(subtype);\n                    if (classFromTypeObject && types_1.isClass(classFromTypeObject)) {\n                        // It's a Type object, which is a class.\n                        return isPositiveTest ? subtype : undefined;\n                    }\n                    // See if the object is callable.\n                    const callMemberType = getTypeFromObjectMember(errorNode, subtype, '__call__', { method: 'get' }, new diagnostic_1.DiagnosticAddendum(), 9 /* SkipForMethodLookup */);\n                    if (!callMemberType) {\n                        return isPositiveTest ? undefined : subtype;\n                    }\n                    else {\n                        return isPositiveTest ? subtype : undefined;\n                    }\n                }\n                default: {\n                    // For all other types, we can't determine whether it's\n                    // callable or not, so we can't eliminate them.\n                    return subtype;\n                }\n            }\n        });\n    }\n    // Specializes the specified (potentially generic) class type using\n    // the specified type arguments, reporting errors as appropriate.\n    // Returns the specialized type and a boolean indicating whether\n    // the type indicates a class type (true) or an object type (false).\n    function createSpecializedClassType(classType, typeArgs, flags, errorNode) {\n        // Handle the special-case classes that are not defined\n        // in the type stubs.\n        if (types_1.ClassType.isSpecialBuiltIn(classType)) {\n            switch (classType.details.name) {\n                case 'Callable': {\n                    return createCallableType(typeArgs);\n                }\n                case 'Optional': {\n                    return createOptionalType(errorNode, typeArgs);\n                }\n                case 'Type': {\n                    return createSpecialType(classType, typeArgs, 1);\n                }\n                case 'ClassVar': {\n                    return createClassVarType(errorNode, typeArgs);\n                }\n                case 'Deque':\n                case 'List':\n                case 'FrozenSet':\n                case 'Set': {\n                    return createSpecialType(classType, typeArgs, 1);\n                }\n                case 'ChainMap':\n                case 'Dict':\n                case 'DefaultDict': {\n                    return createSpecialType(classType, typeArgs, 2);\n                }\n                case 'Protocol': {\n                    return createSpecialType(classType, typeArgs, undefined);\n                }\n                case 'Tuple': {\n                    return createSpecialType(classType, typeArgs, undefined, true);\n                }\n                case 'Union': {\n                    return createUnionType(typeArgs);\n                }\n                case 'Generic': {\n                    return createGenericType(errorNode, classType, typeArgs);\n                }\n                case 'Final': {\n                    return createFinalType(errorNode, typeArgs, flags);\n                }\n                case 'Annotated': {\n                    return createAnnotatedType(errorNode, typeArgs);\n                }\n            }\n        }\n        let typeArgCount = typeArgs ? typeArgs.length : 0;\n        // Make sure the argument list count is correct.\n        const typeParameters = types_1.ClassType.getTypeParameters(classType);\n        // If there are no type parameters or args, the class is already specialized.\n        // No need to do any more work.\n        if (typeParameters.length === 0 && typeArgCount === 0) {\n            return classType;\n        }\n        if (typeArgs && typeArgCount > typeParameters.length) {\n            if (typeParameters.length === 0) {\n                addError(localize_1.Localizer.Diagnostic.typeArgsExpectingNone(), typeArgs[typeParameters.length].node);\n            }\n            else {\n                addError(localize_1.Localizer.Diagnostic.typeArgsTooMany().format({\n                    expected: typeParameters.length,\n                    received: typeArgCount,\n                }), typeArgs[typeParameters.length].node);\n            }\n            typeArgCount = typeParameters.length;\n        }\n        if (typeArgs) {\n            typeArgs.forEach((typeArg) => {\n                // Verify that we didn't receive any inappropriate ellipses or modules.\n                if (typeUtils_1.isEllipsisType(typeArg.type)) {\n                    addError(localize_1.Localizer.Diagnostic.ellipsisContext(), typeArg.node);\n                }\n                else if (types_1.isModule(typeArg.type)) {\n                    addError(localize_1.Localizer.Diagnostic.moduleContext(), typeArg.node);\n                }\n            });\n        }\n        // Fill in any missing type arguments with Any.\n        const typeArgTypes = typeArgs ? typeArgs.map((t) => typeUtils_1.convertToInstance(t.type)) : [];\n        const typeParams = types_1.ClassType.getTypeParameters(classType);\n        for (let i = typeArgTypes.length; i < typeParams.length; i++) {\n            typeArgTypes.push(typeUtils_1.getConcreteTypeFromTypeVar(typeParams[i]));\n        }\n        typeArgTypes.forEach((typeArgType, index) => {\n            if (index < typeArgCount) {\n                const diag = new diagnostic_1.DiagnosticAddendum();\n                if (!canAssignToTypeVar(typeParameters[index], typeArgType, diag)) {\n                    const fileInfo = getFileInfo(typeArgs[index].node);\n                    addDiagnostic(fileInfo.diagnosticRuleSet.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, localize_1.Localizer.Diagnostic.typeVarAssignmentMismatch().format({\n                        type: printType(typeArgType),\n                        name: typeParameters[index].name,\n                    }) + diag.getString(), typeArgs[index].node);\n                }\n            }\n        });\n        const specializedClass = types_1.ClassType.cloneForSpecialization(classType, typeArgTypes, typeArgs !== undefined);\n        return specializedClass;\n    }\n    function getTypeForArgument(arg) {\n        if (arg.type) {\n            return arg.type;\n        }\n        // If there was no defined type provided, there should always\n        // be a value expression from which we can retrieve the type.\n        return getTypeOfExpression(arg.valueExpression).type;\n    }\n    // This function is like getTypeForArgument except that it is\n    // used in cases where the argument is expected to be a type\n    // and therefore follows the normal rules of types (e.g. they\n    // can be forward-declared in stubs, etc.).\n    function getTypeForArgumentExpectingType(arg, fileInfo) {\n        if (arg.type) {\n            return arg.type;\n        }\n        let flags = 256 /* ExpectingType */ |\n            32 /* EvaluateStringLiteralAsType */ |\n            128 /* ParamSpecDisallowed */;\n        if (fileInfo.isStubFile) {\n            flags |= 4 /* AllowForwardReferences */;\n        }\n        // If there was no defined type provided, there should always\n        // be a value expression from which we can retrieve the type.\n        return getTypeOfExpression(arg.valueExpression, undefined, flags).type;\n    }\n    function getBuiltInType(node, name) {\n        const scope = ScopeUtils.getScopeForNode(node);\n        if (scope) {\n            const builtInScope = ScopeUtils.getBuiltInScope(scope);\n            const nameType = builtInScope.lookUpSymbol(name);\n            if (nameType) {\n                return getEffectiveTypeOfSymbol(nameType);\n            }\n        }\n        return types_1.UnknownType.create();\n    }\n    function getBuiltInObject(node, name, typeArguments) {\n        const nameType = getBuiltInType(node, name);\n        if (types_1.isClass(nameType)) {\n            let classType = nameType;\n            if (typeArguments) {\n                classType = types_1.ClassType.cloneForSpecialization(classType, typeArguments, \n                /* isTypeArgumentExplicit */ false);\n            }\n            return types_1.ObjectType.create(classType);\n        }\n        return nameType;\n    }\n    function lookUpSymbolRecursive(node, name, honorCodeFlow) {\n        const scope = ScopeUtils.getScopeForNode(node);\n        let symbolWithScope = scope === null || scope === void 0 ? void 0 : scope.lookUpSymbolRecursive(name);\n        if (symbolWithScope && honorCodeFlow) {\n            // Filter the declarations based on flow reachability.\n            const decls = symbolWithScope.symbol.getDeclarations().filter((decl) => {\n                if (decl.type !== 6 /* Alias */) {\n                    // Is the declaration in the same execution scope as the \"usageNode\" node?\n                    const usageScope = ParseTreeUtils.getExecutionScopeNode(node);\n                    const declNode = decl.type === 4 /* Class */ || decl.type === 3 /* Function */\n                        ? decl.node.name\n                        : decl.node;\n                    const declScope = ParseTreeUtils.getExecutionScopeNode(declNode);\n                    if (usageScope === declScope) {\n                        if (!isFlowPathBetweenNodes(declNode, node)) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            });\n            // If none of the declarations are reachable from the current node,\n            // search for the symbol in outer scopes.\n            if (decls.length === 0) {\n                if (symbolWithScope.scope.parent) {\n                    symbolWithScope = symbolWithScope.scope.parent.lookUpSymbolRecursive(name);\n                }\n                else {\n                    symbolWithScope = undefined;\n                }\n            }\n        }\n        return symbolWithScope;\n    }\n    // Disables recording of errors and warnings.\n    function suppressDiagnostics(callback) {\n        const wasSuppressed = isDiagnosticSuppressed;\n        isDiagnosticSuppressed = true;\n        try {\n            callback();\n        }\n        finally {\n            isDiagnosticSuppressed = wasSuppressed;\n        }\n    }\n    // Disables recording of errors and warnings and disables\n    // any caching of types, under the assumption that we're\n    // performing speculative evaluations.\n    function useSpeculativeMode(speculativeNode, callback) {\n        speculativeTypeTracker.enterSpeculativeContext(speculativeNode);\n        try {\n            callback();\n        }\n        finally {\n            speculativeTypeTracker.leaveSpeculativeContext();\n        }\n    }\n    // Determines whether the specified node is within a part of the parse tree that\n    // is being \"speculatively\" evaluated. If so, it should not be written to the type\n    // cache, and diagnostics should not be reported for it.\n    function isSpeculativeMode(node) {\n        const speculativeRootNode = speculativeTypeTracker.getSpeculativeRootNode();\n        if (!speculativeRootNode) {\n            return false;\n        }\n        return node === undefined || ParseTreeUtils.isNodeContainedWithin(node, speculativeRootNode);\n    }\n    function disableSpeculativeMode(callback) {\n        const stack = speculativeTypeTracker.disableSpeculativeMode();\n        try {\n            callback();\n        }\n        finally {\n            speculativeTypeTracker.enableSpeculativeMode(stack);\n        }\n    }\n    function getFileInfo(node) {\n        while (node.nodeType !== 37 /* Module */) {\n            node = node.parent;\n        }\n        return AnalyzerNodeInfo.getFileInfo(node);\n    }\n    function getDeclarationFromFunctionNamedParameter(type, paramName) {\n        if (type.category === 5 /* Function */) {\n            if (type.details.declaration) {\n                const functionDecl = type.details.declaration;\n                if (functionDecl.type === 3 /* Function */) {\n                    const functionNode = functionDecl.node;\n                    const functionScope = AnalyzerNodeInfo.getScope(functionNode);\n                    if (functionScope) {\n                        const paramSymbol = functionScope.lookUpSymbol(paramName);\n                        if (paramSymbol) {\n                            return paramSymbol\n                                .getDeclarations()\n                                .find((decl) => decl.type === 2 /* Parameter */);\n                        }\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n    function getDeclarationsForNameNode(node) {\n        if (AnalyzerNodeInfo.isCodeUnreachable(node)) {\n            return undefined;\n        }\n        const declarations = [];\n        // If the node is part of a \"from X import Y as Z\" statement and the node\n        // is the \"Y\" (non-aliased) name, we need to look up the alias symbol\n        // since the non-aliased name is not in the symbol table.\n        if (node.parent &&\n            node.parent.nodeType === 23 /* ImportFromAs */ &&\n            node.parent.alias &&\n            node === node.parent.name) {\n            const scope = ScopeUtils.getScopeForNode(node);\n            if (scope) {\n                // Look up the alias symbol.\n                const symbolInScope = scope.lookUpSymbolRecursive(node.parent.alias.value);\n                if (symbolInScope) {\n                    // The alias could have more decls that don't refer to this import. Filter\n                    // out the one(s) that specifically associated with this import statement.\n                    const declsForThisImport = symbolInScope.symbol.getDeclarations().filter((decl) => {\n                        return decl.type === 6 /* Alias */ && decl.node === node.parent;\n                    });\n                    // Make a shallow copy and clear the \"usesLocalName\" field.\n                    const nonLocalDecls = declsForThisImport.map((localDecl) => {\n                        if (localDecl.type === 6 /* Alias */) {\n                            const nonLocalDecl = Object.assign({}, localDecl);\n                            nonLocalDecl.usesLocalName = false;\n                            return nonLocalDecl;\n                        }\n                        return localDecl;\n                    });\n                    declarations.push(...nonLocalDecls);\n                }\n            }\n        }\n        else if (node.parent &&\n            node.parent.nodeType === 36 /* MemberAccess */ &&\n            node === node.parent.memberName) {\n            let baseType = getType(node.parent.leftExpression);\n            if (baseType) {\n                baseType = typeUtils_1.specializeType(baseType, /* typeVarMap */ undefined);\n                const memberName = node.parent.memberName.value;\n                typeUtils_1.doForSubtypes(baseType, (subtype) => {\n                    let symbol;\n                    if (types_1.isClass(subtype)) {\n                        // Try to find a member that has a declared type. If so, that\n                        // overrides any inferred types.\n                        let member = typeUtils_1.lookUpClassMember(subtype, memberName, 32 /* DeclaredTypesOnly */);\n                        if (!member) {\n                            member = typeUtils_1.lookUpClassMember(subtype, memberName);\n                        }\n                        if (member) {\n                            symbol = member.symbol;\n                        }\n                    }\n                    else if (types_1.isObject(subtype)) {\n                        // Try to find a member that has a declared type. If so, that\n                        // overrides any inferred types.\n                        let member = typeUtils_1.lookUpObjectMember(subtype, memberName, 32 /* DeclaredTypesOnly */);\n                        if (!member) {\n                            member = typeUtils_1.lookUpObjectMember(subtype, memberName);\n                        }\n                        if (member) {\n                            symbol = member.symbol;\n                        }\n                    }\n                    else if (types_1.isModule(subtype)) {\n                        symbol = types_1.ModuleType.getField(subtype, memberName);\n                    }\n                    if (symbol) {\n                        // By default, report only the declarations that have type annotations.\n                        // If there are none, then report all of the unannotated declarations,\n                        // which includes every assignment of that symbol.\n                        const typedDecls = symbol.getTypedDeclarations();\n                        if (typedDecls.length > 0) {\n                            declarations.push(...typedDecls);\n                        }\n                        else {\n                            declarations.push(...symbol.getDeclarations());\n                        }\n                    }\n                    return subtype;\n                });\n            }\n        }\n        else if (node.parent && node.parent.nodeType === 38 /* ModuleName */) {\n            const namePartIndex = node.parent.nameParts.findIndex((part) => part === node);\n            const importInfo = AnalyzerNodeInfo.getImportInfo(node.parent);\n            if (namePartIndex >= 0 &&\n                importInfo &&\n                !importInfo.isNativeLib &&\n                namePartIndex < importInfo.resolvedPaths.length) {\n                if (importInfo.resolvedPaths[namePartIndex]) {\n                    // Synthesize an alias declaration for this name part. The only\n                    // time this case is used is for the hover provider.\n                    const aliasDeclaration = {\n                        type: 6 /* Alias */,\n                        node: undefined,\n                        path: importInfo.resolvedPaths[namePartIndex],\n                        range: textRange_1.getEmptyRange(),\n                        implicitImports: new Map(),\n                        usesLocalName: false,\n                    };\n                    declarations.push(aliasDeclaration);\n                }\n            }\n        }\n        else if (node.parent && node.parent.nodeType === 1 /* Argument */ && node === node.parent.name) {\n            // The target node is the name in a named argument. We need to determine whether\n            // the corresponding named parameter can be determined from the context.\n            const argNode = node.parent;\n            const paramName = node.value;\n            if (argNode.parent && argNode.parent.nodeType === 9 /* Call */) {\n                const baseType = getType(argNode.parent.leftExpression);\n                if (baseType) {\n                    if (baseType.category === 5 /* Function */ && baseType.details.declaration) {\n                        const paramDecl = getDeclarationFromFunctionNamedParameter(baseType, paramName);\n                        if (paramDecl) {\n                            declarations.push(paramDecl);\n                        }\n                    }\n                    else if (types_1.isClass(baseType)) {\n                        const initMethodType = getTypeFromObjectMember(argNode.parent.leftExpression, types_1.ObjectType.create(baseType), '__init__', { method: 'get' }, new diagnostic_1.DiagnosticAddendum(), 9 /* SkipForMethodLookup */ | 4 /* SkipObjectBaseClass */);\n                        if (initMethodType && initMethodType.category === 5 /* Function */) {\n                            const paramDecl = getDeclarationFromFunctionNamedParameter(initMethodType, paramName);\n                            if (paramDecl) {\n                                declarations.push(paramDecl);\n                            }\n                            else if (types_1.ClassType.isDataClass(baseType)) {\n                                const lookupResults = typeUtils_1.lookUpClassMember(baseType, paramName);\n                                if (lookupResults) {\n                                    declarations.push(...lookupResults.symbol.getDeclarations());\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            let allowForwardReferences = false;\n            // Determine if this node is within a quoted type annotation.\n            if (ParseTreeUtils.isWithinTypeAnnotation(node, !isAnnotationEvaluationPostponed(getFileInfo(node)))) {\n                allowForwardReferences = true;\n            }\n            const symbolWithScope = lookUpSymbolRecursive(node, node.value, !allowForwardReferences);\n            if (symbolWithScope) {\n                declarations.push(...symbolWithScope.symbol.getDeclarations());\n            }\n        }\n        return declarations;\n    }\n    function getTypeForDeclaration(declaration) {\n        switch (declaration.type) {\n            case 0 /* Intrinsic */: {\n                if (declaration.intrinsicType === 'Any') {\n                    return types_1.AnyType.create();\n                }\n                if (declaration.intrinsicType === 'class') {\n                    const classNode = ParseTreeUtils.getEnclosingClass(declaration.node);\n                    const classTypeInfo = getTypeOfClass(classNode);\n                    return classTypeInfo ? classTypeInfo.classType : undefined;\n                }\n                const strType = getBuiltInObject(declaration.node, 'str');\n                const intType = getBuiltInObject(declaration.node, 'int');\n                if (types_1.isObject(intType) && types_1.isObject(strType)) {\n                    if (declaration.intrinsicType === 'str') {\n                        return strType;\n                    }\n                    if (declaration.intrinsicType === 'int') {\n                        return intType;\n                    }\n                    if (declaration.intrinsicType === 'Iterable[str]') {\n                        const iterableType = getBuiltInType(declaration.node, 'Iterable');\n                        if (types_1.isClass(iterableType)) {\n                            return types_1.ObjectType.create(types_1.ClassType.cloneForSpecialization(iterableType, [strType], \n                            /* isTypeArgumentExplicit */ false));\n                        }\n                    }\n                    if (declaration.intrinsicType === 'Dict[str, Any]') {\n                        const dictType = getBuiltInType(declaration.node, 'Dict');\n                        if (types_1.isClass(dictType)) {\n                            return types_1.ObjectType.create(types_1.ClassType.cloneForSpecialization(dictType, [strType, types_1.AnyType.create()], \n                            /* isTypeArgumentExplicit */ false));\n                        }\n                    }\n                }\n                return types_1.UnknownType.create();\n            }\n            case 4 /* Class */: {\n                const classTypeInfo = getTypeOfClass(declaration.node);\n                return classTypeInfo ? classTypeInfo.decoratedType : undefined;\n            }\n            case 5 /* SpecialBuiltInClass */: {\n                return getTypeOfAnnotation(declaration.node.typeAnnotation);\n            }\n            case 3 /* Function */: {\n                const functionTypeInfo = getTypeOfFunction(declaration.node);\n                return functionTypeInfo ? functionTypeInfo.decoratedType : undefined;\n            }\n            case 2 /* Parameter */: {\n                let typeAnnotationNode = declaration.node.typeAnnotation;\n                if (typeAnnotationNode && typeAnnotationNode.nodeType === 49 /* StringList */) {\n                    typeAnnotationNode = typeAnnotationNode.typeAnnotation;\n                }\n                if (typeAnnotationNode) {\n                    const declaredType = getTypeOfAnnotation(typeAnnotationNode);\n                    return transformVariadicParamType(declaration.node, declaration.node.category, declaredType);\n                }\n                return undefined;\n            }\n            case 1 /* Variable */: {\n                let typeAnnotationNode = declaration.typeAnnotationNode;\n                if (typeAnnotationNode && typeAnnotationNode.nodeType === 49 /* StringList */) {\n                    typeAnnotationNode = typeAnnotationNode.typeAnnotation;\n                }\n                if (typeAnnotationNode) {\n                    let declaredType = getTypeOfAnnotation(typeAnnotationNode);\n                    if (declaredType) {\n                        // Apply enum transform if appropriate.\n                        if (declaration.node.nodeType === 39 /* Name */) {\n                            declaredType = transformTypeForPossibleEnumClass(declaration.node, declaredType);\n                        }\n                        return declaredType;\n                    }\n                }\n                return undefined;\n            }\n            case 6 /* Alias */: {\n                return undefined;\n            }\n        }\n    }\n    function getInferredTypeOfDeclaration(decl) {\n        const resolvedDecl = resolveAliasDeclaration(decl, /* resolveLocalNames */ true);\n        // We couldn't resolve the alias. Substitute an unknown\n        // type in this case.\n        if (!resolvedDecl) {\n            return types_1.UnknownType.create();\n        }\n        function applyLoaderActionsToModuleType(moduleType, loaderActions, importLookup) {\n            if (loaderActions.path) {\n                const lookupResults = importLookup(loaderActions.path);\n                if (lookupResults) {\n                    moduleType.fields = lookupResults.symbolTable;\n                    moduleType.docString = lookupResults.docString;\n                }\n                else {\n                    return types_1.UnknownType.create();\n                }\n            }\n            if (loaderActions.implicitImports) {\n                loaderActions.implicitImports.forEach((implicitImport, name) => {\n                    // Recursively apply loader actions.\n                    const importedModuleType = types_1.ModuleType.create();\n                    const symbolType = applyLoaderActionsToModuleType(importedModuleType, implicitImport, importLookup);\n                    const importedModuleSymbol = symbol_1.Symbol.createWithType(0 /* None */, symbolType);\n                    moduleType.loaderFields.set(name, importedModuleSymbol);\n                });\n            }\n            return moduleType;\n        }\n        // If the resolved declaration is still an alias, the alias\n        // is pointing at a module, and we need to synthesize a\n        // module type.\n        if (resolvedDecl.type === 6 /* Alias */) {\n            // Build a module type that corresponds to the declaration and\n            // its associated loader actions.\n            const moduleType = types_1.ModuleType.create();\n            if (resolvedDecl.symbolName) {\n                if (resolvedDecl.submoduleFallback) {\n                    return applyLoaderActionsToModuleType(moduleType, resolvedDecl.symbolName && resolvedDecl.submoduleFallback\n                        ? resolvedDecl.submoduleFallback\n                        : resolvedDecl, importLookup);\n                }\n            }\n            else {\n                return applyLoaderActionsToModuleType(moduleType, resolvedDecl, importLookup);\n            }\n        }\n        const declaredType = getTypeForDeclaration(resolvedDecl);\n        if (declaredType) {\n            return declaredType;\n        }\n        // If the resolved declaration had no defined type, use the\n        // inferred type for this node.\n        if (resolvedDecl.type === 2 /* Parameter */) {\n            const cachedValue = readTypeCache(resolvedDecl.node.name);\n            if (cachedValue) {\n                return cachedValue;\n            }\n            evaluateTypeOfParameter(resolvedDecl.node);\n            return readTypeCache(resolvedDecl.node.name);\n        }\n        if (resolvedDecl.type === 1 /* Variable */ && resolvedDecl.inferredTypeSource) {\n            let inferredType = readTypeCache(resolvedDecl.node);\n            if (!inferredType) {\n                evaluateTypesForStatement(resolvedDecl.inferredTypeSource);\n                inferredType = readTypeCache(resolvedDecl.node);\n            }\n            if (inferredType && resolvedDecl.node.nodeType === 39 /* Name */) {\n                inferredType = transformTypeForPossibleEnumClass(resolvedDecl.node, inferredType);\n            }\n            return inferredType;\n        }\n        return undefined;\n    }\n    // If the specified declaration is an alias declaration that points to a symbol,\n    // it resolves the alias and looks up the symbol, then returns the first declaration\n    // associated with that symbol. It does this recursively if necessary. If a symbol\n    // lookup fails, undefined is returned. If resolveLocalNames is true, the method\n    // resolves aliases through local renames (\"as\" clauses found in import statements).\n    function resolveAliasDeclaration(declaration, resolveLocalNames) {\n        let curDeclaration = declaration;\n        const alreadyVisited = [];\n        while (true) {\n            if (curDeclaration.type !== 6 /* Alias */) {\n                return curDeclaration;\n            }\n            if (!curDeclaration.symbolName) {\n                return curDeclaration;\n            }\n            // If we are not supposed to follow local alias names and this\n            // is a local name, don't continue to follow the alias.\n            if (!resolveLocalNames && curDeclaration.usesLocalName) {\n                return curDeclaration;\n            }\n            let lookupResult;\n            if (curDeclaration.path) {\n                lookupResult = importLookup(curDeclaration.path);\n                if (!lookupResult) {\n                    return undefined;\n                }\n            }\n            const symbol = lookupResult\n                ? lookupResult.symbolTable.get(curDeclaration.symbolName)\n                : undefined;\n            if (!symbol) {\n                if (curDeclaration.submoduleFallback) {\n                    return resolveAliasDeclaration(curDeclaration.submoduleFallback, resolveLocalNames);\n                }\n                return undefined;\n            }\n            // Prefer declarations with specified types. If we don't have any of those,\n            // fall back on declarations with inferred types.\n            let declarations = symbol.getTypedDeclarations();\n            if (declarations.length === 0) {\n                declarations = symbol.getDeclarations();\n                if (declarations.length === 0) {\n                    return undefined;\n                }\n            }\n            // Prefer the last declaration in the list. This ensures that\n            // we use all of the overloads if it's an overloaded function.\n            curDeclaration = declarations[declarations.length - 1];\n            // Make sure we don't follow a circular list indefinitely.\n            if (alreadyVisited.find((decl) => decl === curDeclaration)) {\n                return declaration;\n            }\n            alreadyVisited.push(curDeclaration);\n        }\n    }\n    // Returns the type of the symbol. If the type is explicitly declared, that type\n    // is returned. If not, the type is inferred from assignments to the symbol. All\n    // assigned types are evaluated and combined into a union. If a \"usageNode\"\n    // node is specified, only declarations that are outside of the current execution\n    // scope or that are reachable (as determined by code flow analysis) are considered.\n    // This helps in cases where there are cyclical dependencies between symbols.\n    function getEffectiveTypeOfSymbol(symbol) {\n        return getEffectiveTypeOfSymbolForUsage(symbol).type;\n    }\n    function getEffectiveTypeOfSymbolForUsage(symbol, usageNode) {\n        // If there's a declared type, it takes precedence over\n        // inferred types.\n        if (symbol.hasTypedDeclarations()) {\n            return {\n                type: getDeclaredTypeOfSymbol(symbol) || types_1.UnknownType.create(),\n                isResolutionCyclical: false,\n            };\n        }\n        // Infer the type.\n        const typesToCombine = [];\n        const isPrivate = symbol.isPrivateMember();\n        const decls = symbol.getDeclarations();\n        const isFinalVar = symbolUtils_1.isFinalVariable(symbol);\n        let isResolutionCyclical = false;\n        decls.forEach((decl) => {\n            let considerDecl = true;\n            if (usageNode !== undefined) {\n                if (decl.type !== 6 /* Alias */) {\n                    // Is the declaration in the same execution scope as the \"usageNode\" node?\n                    const usageScope = ParseTreeUtils.getExecutionScopeNode(usageNode);\n                    const declScope = ParseTreeUtils.getExecutionScopeNode(decl.node);\n                    if (usageScope === declScope) {\n                        if (!isFlowPathBetweenNodes(decl.node, usageNode)) {\n                            considerDecl = false;\n                        }\n                    }\n                }\n            }\n            if (considerDecl) {\n                if (pushSymbolResolution(symbol, decl)) {\n                    try {\n                        let type = getInferredTypeOfDeclaration(decl);\n                        if (popSymbolResolution(symbol)) {\n                            isResolutionCyclical = true;\n                        }\n                        if (type) {\n                            const isConstant = decl.type === 1 /* Variable */ && !!decl.isConstant;\n                            type = typeUtils_1.stripLiteralTypeArgsValue(type);\n                            if (decl.type === 1 /* Variable */) {\n                                const isEnum = types_1.isObject(type) && types_1.ClassType.isEnumClass(type.classType);\n                                // If the symbol is private or constant, we can retain the literal\n                                // value. Otherwise, strip them off to make the type less specific,\n                                // allowing other values to be assigned to it in subclasses.\n                                if (!isPrivate && !isConstant && !isEnum && !isFinalVar) {\n                                    type = typeUtils_1.stripLiteralValue(type);\n                                }\n                            }\n                            typesToCombine.push(type);\n                        }\n                    }\n                    catch (e) {\n                        // Clean up the stack before rethrowing.\n                        popSymbolResolution(symbol);\n                        throw e;\n                    }\n                }\n                else {\n                    isResolutionCyclical = true;\n                }\n            }\n        });\n        if (typesToCombine.length > 0) {\n            return {\n                type: types_1.combineTypes(typesToCombine),\n                isResolutionCyclical: false,\n            };\n        }\n        return {\n            type: types_1.UnboundType.create(),\n            isResolutionCyclical,\n        };\n    }\n    function getDeclaredTypeOfSymbol(symbol) {\n        const synthesizedType = symbol.getSynthesizedType();\n        if (synthesizedType) {\n            return synthesizedType;\n        }\n        const typedDecls = symbol.getTypedDeclarations();\n        if (typedDecls.length === 0) {\n            // There was no declaration with a defined type.\n            return undefined;\n        }\n        // Start with the last decl. If that's already being resolved,\n        // use the next-to-last decl, etc. This can happen when resolving\n        // property methods. Often the setter method is defined in reference to\n        // the initial property, which defines the getter method with the same\n        // symbol name.\n        let declIndex = typedDecls.length - 1;\n        while (declIndex >= 0) {\n            const decl = typedDecls[declIndex];\n            // If there's a partially-constructed type that is allowed\n            // for recursive symbol resolution, return it as the resolved type.\n            const partialType = getSymbolResolutionPartialType(symbol, decl);\n            if (partialType) {\n                return partialType;\n            }\n            if (getIndexOfSymbolResolution(symbol, decl) < 0) {\n                if (pushSymbolResolution(symbol, decl)) {\n                    try {\n                        const type = getTypeForDeclaration(decl);\n                        if (!popSymbolResolution(symbol)) {\n                            return undefined;\n                        }\n                        return type;\n                    }\n                    catch (e) {\n                        // Clean up the stack before rethrowing.\n                        popSymbolResolution(symbol);\n                        throw e;\n                    }\n                }\n                break;\n            }\n            declIndex--;\n        }\n        return undefined;\n    }\n    // Returns the return type of the function. If the type is explicitly provided in\n    // a type annotation, that type is returned. If not, an attempt is made to infer\n    // the return type. If a list of args is provided, the inference logic may take\n    // into account argument types to infer the return type.\n    function getFunctionEffectiveReturnType(type, args, inferTypeIfNeeded = true) {\n        const specializedReturnType = types_1.FunctionType.getSpecializedReturnType(type);\n        if (specializedReturnType) {\n            return specializedReturnType;\n        }\n        if (inferTypeIfNeeded) {\n            return getFunctionInferredReturnType(type, args);\n        }\n        return types_1.UnknownType.create();\n    }\n    function getFunctionInferredReturnType(type, args) {\n        let returnType;\n        // Don't attempt to infer the return type for a stub file.\n        if (types_1.FunctionType.isStubDefinition(type)) {\n            return types_1.UnknownType.create();\n        }\n        // If the return type has already been lazily evaluated,\n        // don't bother computing it again.\n        if (type.inferredReturnType) {\n            returnType = type.inferredReturnType;\n        }\n        else {\n            if (type.details.declaration) {\n                const functionNode = type.details.declaration.node;\n                // Temporarily disable speculative mode while we\n                // lazily evaluate the return type.\n                disableSpeculativeMode(() => {\n                    returnType = inferFunctionReturnType(functionNode, types_1.FunctionType.isAbstractMethod(type));\n                });\n                // Do we need to wrap this in an awaitable?\n                if (returnType && types_1.FunctionType.isWrapReturnTypeInAwait(type)) {\n                    returnType = createAwaitableReturnType(functionNode, returnType);\n                }\n            }\n            if (!returnType) {\n                returnType = types_1.UnknownType.create();\n            }\n            // Cache the type for next time.\n            type.inferredReturnType = returnType;\n        }\n        // If the type is partially unknown and the function has one or more unannotated\n        // params, try to analyze the function with the provided argument types and\n        // attempt to do a better job at inference.\n        if (typeUtils_1.isPartlyUnknown(returnType) &&\n            types_1.FunctionType.hasUnannotatedParams(type) &&\n            !types_1.FunctionType.isStubDefinition(type) &&\n            args) {\n            const contextualReturnType = getFunctionInferredReturnTypeUsingArguments(type, args);\n            if (contextualReturnType) {\n                returnType = contextualReturnType;\n            }\n        }\n        return returnType;\n    }\n    function getFunctionInferredReturnTypeUsingArguments(type, args) {\n        let contextualReturnType;\n        if (!type.details.declaration) {\n            return undefined;\n        }\n        const functionNode = type.details.declaration.node;\n        // If an arg hasn't been matched to a specific named parameter,\n        // it's an unpacked value that corresponds to multiple parameters.\n        // That's an edge case that we don't handle here.\n        if (args.some((arg) => !arg.paramName)) {\n            return undefined;\n        }\n        // Detect recurrence. If a function invokes itself either directly\n        // or indirectly, we won't attempt to infer contextual return\n        // types any further.\n        if (returnTypeInferenceContextStack.some((context) => context.functionNode === functionNode)) {\n            return undefined;\n        }\n        const functionType = getTypeOfFunction(functionNode);\n        if (!functionType) {\n            return undefined;\n        }\n        // Don't explore arbitrarily deep in the call graph.\n        if (returnTypeInferenceContextStack.length >= maxReturnTypeInferenceStackSize) {\n            return undefined;\n        }\n        // Suppress diagnostics because we don't want to generate errors.\n        suppressDiagnostics(() => {\n            // Allocate a new temporary type cache for the context of just\n            // this function so we can analyze it separately without polluting\n            // the main type cache.\n            const prevTypeCache = returnTypeInferenceTypeCache;\n            returnTypeInferenceContextStack.push({\n                functionNode,\n                codeFlowAnalyzer: createCodeFlowAnalyzer(),\n            });\n            try {\n                returnTypeInferenceTypeCache = new Map();\n                let allArgTypesAreUnknown = true;\n                functionNode.parameters.forEach((param, index) => {\n                    if (param.name) {\n                        let paramType;\n                        const arg = args.find((arg) => param.name.value === arg.paramName);\n                        if (arg && arg.argument.valueExpression) {\n                            paramType = getTypeOfExpression(arg.argument.valueExpression).type;\n                            allArgTypesAreUnknown = false;\n                        }\n                        else if (param.defaultValue) {\n                            paramType = getTypeOfExpression(param.defaultValue).type;\n                            allArgTypesAreUnknown = false;\n                        }\n                        else if (index === 0) {\n                            // If this is an instance or class method, use the implied\n                            // parameter type for the \"self\" or \"cls\" parameter.\n                            if (types_1.FunctionType.isInstanceMethod(functionType.functionType) ||\n                                types_1.FunctionType.isClassMethod(functionType.functionType)) {\n                                if (functionType.functionType.details.parameters.length > 0) {\n                                    if (functionNode.parameters[0].name) {\n                                        paramType = functionType.functionType.details.parameters[0].type;\n                                    }\n                                }\n                            }\n                        }\n                        if (!paramType) {\n                            paramType = types_1.UnknownType.create();\n                        }\n                        writeTypeCache(param.name, paramType);\n                    }\n                });\n                // Don't bother trying to determine the contextual return\n                // type if none of the argument types are known.\n                if (!allArgTypesAreUnknown) {\n                    contextualReturnType = inferFunctionReturnType(functionNode, types_1.FunctionType.isAbstractMethod(type));\n                }\n            }\n            finally {\n                returnTypeInferenceContextStack.pop();\n                returnTypeInferenceTypeCache = prevTypeCache;\n            }\n        });\n        if (contextualReturnType) {\n            // Do we need to wrap this in an awaitable?\n            if (types_1.FunctionType.isWrapReturnTypeInAwait(type) && !typeUtils_1.isNoReturnType(contextualReturnType)) {\n                contextualReturnType = createAwaitableReturnType(functionNode, contextualReturnType);\n            }\n            return contextualReturnType;\n        }\n        return undefined;\n    }\n    function getFunctionDeclaredReturnType(node) {\n        const functionTypeInfo = getTypeOfFunction(node);\n        if (!functionTypeInfo) {\n            // We hit a recursive dependency.\n            return types_1.AnyType.create();\n        }\n        // Ignore this check for abstract methods, which often\n        // don't actually return any value.\n        if (types_1.FunctionType.isAbstractMethod(functionTypeInfo.functionType)) {\n            return types_1.AnyType.create();\n        }\n        if (types_1.FunctionType.isGenerator(functionTypeInfo.functionType)) {\n            return typeUtils_1.getDeclaredGeneratorReturnType(functionTypeInfo.functionType);\n        }\n        return functionTypeInfo.functionType.details.declaredReturnType;\n    }\n    function getTypeOfMember(member) {\n        if (types_1.isClass(member.classType)) {\n            return typeUtils_1.partiallySpecializeType(getEffectiveTypeOfSymbol(member.symbol), member.classType);\n        }\n        return types_1.UnknownType.create();\n    }\n    function canAssignClassToProtocol(destType, srcType, diag, typeVarMap, recursionCount) {\n        const destClassFields = destType.details.fields;\n        // Some protocol definitions include recursive references to themselves.\n        // We need to protect against infinite recursion, so we'll check for that here.\n        if (types_1.isTypeSame(srcType, destType)) {\n            return true;\n        }\n        // Strip the type arguments off the dest protocol if they are provided.\n        const genericDestType = types_1.ClassType.cloneForSpecialization(destType, undefined, \n        /* isTypeArgumentExplicit */ false);\n        const genericDestTypeVarMap = new typeVarMap_1.TypeVarMap();\n        let typesAreConsistent = true;\n        const srcClassTypeVarMap = typeUtils_1.buildTypeVarMapFromSpecializedClass(srcType);\n        destClassFields.forEach((symbol, name) => {\n            if (symbol.isClassMember() && !symbol.isIgnoredForProtocolMatch()) {\n                const memberInfo = typeUtils_1.lookUpClassMember(srcType, name);\n                if (!memberInfo) {\n                    diag.addMessage(localize_1.Localizer.DiagnosticAddendum.protocolMemberMissing().format({ name }));\n                    typesAreConsistent = false;\n                }\n                else {\n                    const declaredType = getDeclaredTypeOfSymbol(symbol);\n                    if (declaredType) {\n                        const srcMemberType = typeUtils_1.specializeType(getTypeOfMember(memberInfo), srcClassTypeVarMap, \n                        /* makeConcrete */ false);\n                        if (!canAssignType(declaredType, srcMemberType, diag.createAddendum(), genericDestTypeVarMap, 0 /* Default */, recursionCount + 1)) {\n                            diag.addMessage(localize_1.Localizer.DiagnosticAddendum.memberTypeMismatch().format({ name }));\n                            typesAreConsistent = false;\n                        }\n                    }\n                    if (symbol.isClassVar() && !memberInfo.symbol.isClassMember()) {\n                        diag.addMessage(localize_1.Localizer.DiagnosticAddendum.protocolMemberClassVar().format({ name }));\n                        typesAreConsistent = false;\n                    }\n                }\n            }\n        });\n        // Now handle base classes of the dest protocol.\n        destType.details.baseClasses.forEach((baseClass) => {\n            if (types_1.isClass(baseClass) &&\n                !types_1.ClassType.isBuiltIn(baseClass, 'object') &&\n                !types_1.ClassType.isBuiltIn(baseClass, 'Protocol')) {\n                const specializedBaseClass = specializeForBaseClass(destType, baseClass, recursionCount + 1);\n                if (!canAssignClassToProtocol(specializedBaseClass, srcType, diag, typeVarMap, recursionCount + 1)) {\n                    typesAreConsistent = false;\n                }\n            }\n        });\n        // If the dest protocol has type parameters, make sure the source type arguments match.\n        if (typesAreConsistent && destType.details.typeParameters.length > 0 && destType.typeArguments !== undefined) {\n            // Create a specialized version of the protocol defined by the dest and\n            // make sure the resulting type args can be assigned.\n            const specializedSrcProtocol = typeUtils_1.specializeType(genericDestType, genericDestTypeVarMap, \n            /* makeConcrete */ false);\n            if (!verifyTypeArgumentsAssignable(destType, specializedSrcProtocol, diag, typeVarMap, recursionCount)) {\n                typesAreConsistent = false;\n            }\n        }\n        return typesAreConsistent;\n    }\n    function canAssignTypedDict(destType, srcType, diag, recursionCount) {\n        let typesAreConsistent = true;\n        const destEntries = getTypedDictMembersForClass(destType);\n        const srcEntries = getTypedDictMembersForClass(srcType);\n        destEntries.forEach((destEntry, name) => {\n            const srcEntry = srcEntries.get(name);\n            if (!srcEntry) {\n                diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typedDictFieldMissing().format({ name, type: printType(srcType) }));\n                typesAreConsistent = false;\n            }\n            else {\n                if (destEntry.isRequired && !srcEntry.isRequired) {\n                    diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typedDictFieldRequired().format({\n                        name,\n                        type: printType(destType),\n                    }));\n                    typesAreConsistent = false;\n                }\n                else if (!destEntry.isRequired && srcEntry.isRequired) {\n                    diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typedDictFieldNotRequired().format({\n                        name,\n                        type: printType(destType),\n                    }));\n                    typesAreConsistent = false;\n                }\n                if (!types_1.isTypeSame(destEntry.valueType, srcEntry.valueType, recursionCount + 1)) {\n                    diag.addMessage(localize_1.Localizer.DiagnosticAddendum.memberTypeMismatch().format({ name }));\n                    typesAreConsistent = false;\n                }\n            }\n        });\n        return typesAreConsistent;\n    }\n    function canAssignClass(destType, srcType, diag, typeVarMap, flags, recursionCount, reportErrorsUsingObjType) {\n        // Is it a structural type (i.e. a protocol)? If so, we need to\n        // perform a member-by-member check.\n        if (types_1.ClassType.isProtocolClass(destType)) {\n            return canAssignClassToProtocol(destType, srcType, diag, typeVarMap, recursionCount);\n        }\n        // Handle typed dicts. They also use a form of structural typing for type\n        // checking, as defined in PEP 589.\n        if (types_1.ClassType.isTypedDictClass(destType) && types_1.ClassType.isTypedDictClass(srcType)) {\n            return canAssignTypedDict(destType, srcType, diag, recursionCount);\n        }\n        // Handle property classes. They are special because each property\n        // class has a different source ID, so they wouldn't otherwise match.\n        // We need to see if the return types of the properties match.\n        if (types_1.ClassType.isPropertyClass(destType) && types_1.ClassType.isPropertyClass(srcType)) {\n            let typesAreConsistent = true;\n            const fgetDest = destType.details.fields.get('fget');\n            const fgetSrc = srcType.details.fields.get('fget');\n            if (fgetDest && fgetSrc) {\n                const fgetDestType = getDeclaredTypeOfSymbol(fgetDest);\n                const fgetSrcType = getDeclaredTypeOfSymbol(fgetSrc);\n                if (fgetDestType &&\n                    fgetSrcType &&\n                    fgetDestType.category === 5 /* Function */ &&\n                    fgetSrcType.category === 5 /* Function */) {\n                    const fgetDestReturnType = getFunctionEffectiveReturnType(fgetDestType);\n                    const fgetSrcReturnType = getFunctionEffectiveReturnType(fgetSrcType);\n                    if (!canAssignType(fgetDestReturnType, fgetSrcReturnType, diag)) {\n                        typesAreConsistent = false;\n                    }\n                }\n            }\n            return typesAreConsistent;\n        }\n        // Special-case conversion for the \"numeric tower\".\n        if (types_1.ClassType.isBuiltIn(destType, 'float')) {\n            if (types_1.ClassType.isBuiltIn(srcType, 'int')) {\n                if ((flags & 1 /* EnforceInvariance */) === 0) {\n                    return true;\n                }\n            }\n        }\n        if (types_1.ClassType.isBuiltIn(destType, 'complex')) {\n            if (types_1.ClassType.isBuiltIn(srcType, 'int') || types_1.ClassType.isBuiltIn(srcType, 'float')) {\n                if ((flags & 1 /* EnforceInvariance */) === 0) {\n                    return true;\n                }\n            }\n        }\n        if ((flags & 1 /* EnforceInvariance */) === 0 || types_1.ClassType.isSameGenericClass(srcType, destType)) {\n            const inheritanceChain = [];\n            if (types_1.ClassType.isDerivedFrom(srcType, destType, inheritanceChain)) {\n                debug_1.assert(inheritanceChain.length > 0);\n                return canAssignClassWithTypeArgs(destType, srcType, inheritanceChain, diag, typeVarMap, recursionCount + 1);\n            }\n        }\n        const destErrorType = reportErrorsUsingObjType ? types_1.ObjectType.create(destType) : destType;\n        const srcErrorType = reportErrorsUsingObjType ? types_1.ObjectType.create(srcType) : srcType;\n        diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeIncompatible().format({\n            sourceType: printType(srcErrorType),\n            destType: printType(destErrorType),\n        }));\n        return false;\n    }\n    // Determines the specialized base class type that srcType derives from.\n    function specializeForBaseClass(srcType, baseClass, recursionCount) {\n        const typeParams = types_1.ClassType.getTypeParameters(baseClass);\n        // If there are no type parameters for the specified base class,\n        // no specialization is required.\n        if (typeParams.length === 0) {\n            return baseClass;\n        }\n        const typeVarMap = typeUtils_1.buildTypeVarMapFromSpecializedClass(srcType);\n        const specializedType = typeUtils_1.specializeType(baseClass, typeVarMap, /* makeConcrete */ false, recursionCount + 1);\n        debug_1.assert(types_1.isClass(specializedType));\n        return specializedType;\n    }\n    // Determines whether the specified type can be assigned to the\n    // specified inheritance chain, taking into account its type arguments.\n    function canAssignClassWithTypeArgs(destType, srcType, inheritanceChain, diag, typeVarMap, recursionCount) {\n        let curSrcType = srcType;\n        let curTypeVarMap = typeVarMap;\n        for (let ancestorIndex = inheritanceChain.length - 1; ancestorIndex >= 0; ancestorIndex--) {\n            const ancestorType = inheritanceChain[ancestorIndex];\n            // If we've hit an \"unknown\", all bets are off, and we need to assume\n            // that the type is assignable.\n            if (types_1.isUnknown(ancestorType)) {\n                return true;\n            }\n            // If we've hit an 'object', it's assignable.\n            if (types_1.ClassType.isBuiltIn(ancestorType, 'object')) {\n                return true;\n            }\n            // If this isn't the first time through the loop, specialize\n            // for the next ancestor in the chain.\n            if (ancestorIndex < inheritanceChain.length - 1) {\n                curSrcType = specializeForBaseClass(curSrcType, ancestorType, recursionCount + 1);\n            }\n            // Do we need to do special-case processing for various built-in classes?\n            if (ancestorIndex === 0 && types_1.ClassType.isSpecialBuiltIn(destType)) {\n                // Handle built-in types that support arbitrary numbers\n                // of type parameters like Tuple.\n                if (destType.details.name === 'Tuple') {\n                    if (destType.typeArguments && curSrcType.typeArguments) {\n                        const destTypeArgs = destType.typeArguments;\n                        let destArgCount = destTypeArgs.length;\n                        const isDestHomogenousTuple = destArgCount === 2 && typeUtils_1.isEllipsisType(destTypeArgs[1]);\n                        if (isDestHomogenousTuple) {\n                            destArgCount = 1;\n                        }\n                        const srcTypeArgs = curSrcType.typeArguments;\n                        let srcArgCount = srcTypeArgs.length;\n                        const isSrcHomogeneousType = srcArgCount === 2 && typeUtils_1.isEllipsisType(srcTypeArgs[1]);\n                        if (isSrcHomogeneousType) {\n                            srcArgCount = 1;\n                        }\n                        if (srcTypeArgs.length === destArgCount || isDestHomogenousTuple || isSrcHomogeneousType) {\n                            for (let i = 0; i < Math.max(destArgCount, srcArgCount); i++) {\n                                const expectedDestType = (isDestHomogenousTuple ? destTypeArgs[0] : destTypeArgs[i]) || types_1.AnyType.create();\n                                const expectedSrcType = (isSrcHomogeneousType ? srcTypeArgs[0] : srcTypeArgs[i]) || types_1.AnyType.create();\n                                if (!canAssignType(expectedDestType, expectedSrcType, diag.createAddendum(), curTypeVarMap, 0 /* Default */, recursionCount + 1)) {\n                                    diag.addMessage(localize_1.Localizer.DiagnosticAddendum.tupleEntryTypeMismatch().format({ entry: i + 1 }));\n                                    return false;\n                                }\n                            }\n                        }\n                        else {\n                            diag.addMessage(localize_1.Localizer.DiagnosticAddendum.tupleSizeMismatch().format({\n                                expected: destArgCount,\n                                received: srcTypeArgs.length,\n                            }));\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            }\n            // If there are no type parameters on this class, we're done.\n            const ancestorTypeParams = types_1.ClassType.getTypeParameters(ancestorType);\n            if (ancestorTypeParams.length === 0) {\n                continue;\n            }\n            // If the dest type isn't specialized, there are no type args to validate.\n            const ancestorTypeArgs = ancestorType.typeArguments;\n            if (!ancestorTypeArgs) {\n                return true;\n            }\n            // Validate that the type arguments match.\n            if (!verifyTypeArgumentsAssignable(ancestorType, curSrcType, diag, curTypeVarMap, recursionCount)) {\n                return false;\n            }\n            // Allocate a new type var map for the next time through the loop.\n            curTypeVarMap = new typeVarMap_1.TypeVarMap();\n        }\n        if (destType.typeArguments) {\n            // If the dest type is specialized, make sure the specialized source\n            // type arguments are assignable to the dest type arguments.\n            if (!verifyTypeArgumentsAssignable(destType, curSrcType, diag, typeVarMap, recursionCount)) {\n                return false;\n            }\n        }\n        else if (typeVarMap &&\n            destType.details.typeParameters.length > 0 &&\n            curSrcType.typeArguments &&\n            !typeVarMap.isLocked()) {\n            // Populate the typeVar map with type arguments of the source.\n            for (let i = 0; i < destType.details.typeParameters.length; i++) {\n                const typeArgType = i < curSrcType.typeArguments.length ? curSrcType.typeArguments[i] : types_1.UnknownType.create();\n                typeVarMap.setTypeVar(destType.details.typeParameters[i].name, typeArgType, /* isNarrowable */ true);\n            }\n        }\n        return true;\n    }\n    function verifyTypeArgumentsAssignable(destType, srcType, diag, typeVarMap, recursionCount) {\n        debug_1.assert(types_1.ClassType.isSameGenericClass(destType, srcType));\n        const destTypeParams = types_1.ClassType.getTypeParameters(destType);\n        const destTypeArgs = destType.typeArguments;\n        debug_1.assert(destTypeArgs !== undefined);\n        const srcTypeArgs = srcType.typeArguments;\n        if (srcTypeArgs) {\n            if (types_1.ClassType.isSpecialBuiltIn(srcType) || srcTypeArgs.length === destTypeParams.length) {\n                for (let srcArgIndex = 0; srcArgIndex < srcTypeArgs.length; srcArgIndex++) {\n                    const srcTypeArg = srcTypeArgs[srcArgIndex];\n                    // In most cases, the number of type args should match the number\n                    // of type arguments, but there are a few special cases where this\n                    // isn't true (e.g. assigning a Tuple[X, Y, Z] to a tuple[W]).\n                    const destArgIndex = srcArgIndex >= destTypeArgs.length ? destTypeArgs.length - 1 : srcArgIndex;\n                    debug_1.assert(destArgIndex >= 0);\n                    const destTypeArg = destTypeArgs[destArgIndex];\n                    const destTypeParam = destArgIndex < destTypeParams.length ? destTypeParams[destArgIndex] : undefined;\n                    const assignmentDiag = new diagnostic_1.DiagnosticAddendum();\n                    if (!destTypeParam || destTypeParam.isCovariant) {\n                        if (!canAssignType(destTypeArg, srcTypeArg, assignmentDiag, typeVarMap, 0 /* Default */, recursionCount + 1)) {\n                            if (destTypeParam) {\n                                const childDiag = diag.createAddendum();\n                                childDiag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeVarIsCovariant().format({\n                                    name: destTypeParam.name,\n                                }));\n                                childDiag.addAddendum(assignmentDiag);\n                            }\n                            return false;\n                        }\n                    }\n                    else if (destTypeParam.isContravariant) {\n                        if (!canAssignType(srcTypeArg, destTypeArg, assignmentDiag, typeVarMap, 2 /* ReverseTypeVarMatching */, recursionCount + 1)) {\n                            const childDiag = diag.createAddendum();\n                            childDiag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeVarIsContravariant().format({\n                                name: destTypeParam.name,\n                            }));\n                            childDiag.addAddendum(assignmentDiag);\n                            return false;\n                        }\n                    }\n                    else {\n                        if (!canAssignType(destTypeArg, srcTypeArg, assignmentDiag, typeVarMap, 1 /* EnforceInvariance */, recursionCount + 1)) {\n                            const childDiag = diag.createAddendum();\n                            childDiag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeVarIsInvariant().format({\n                                name: destTypeParam.name,\n                            }));\n                            childDiag.addAddendum(assignmentDiag);\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    // Assigns the source type to the dest type var in the type map. If an existing type is\n    // already associated with that type var name, it attempts to either widen or narrow\n    // the type (depending on the value of the canNarrowType parameter). The goal is to\n    // produce the narrowest type that meets all of the requirements. If the type var map\n    // has been \"locked\", it simply validates that the srcType is compatible (with no attempt\n    // to widen or narrow).\n    function assignTypeToTypeVar(destType, srcType, canNarrowType, diag, typeVarMap, flags = 0 /* Default */, recursionCount = 0) {\n        const curTypeVarMapping = typeVarMap.getTypeVar(destType.name);\n        if (destType.isParamSpec) {\n            diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeParamSpec().format({\n                type: printType(srcType),\n                name: destType.name,\n            }));\n            return false;\n        }\n        // Handle the constrained case.\n        if (destType.constraints.length > 0) {\n            // Find the first constrained type that is compatible.\n            const constrainedType = destType.constraints.find((constraintType) => {\n                return canAssignType(constraintType, srcType, new diagnostic_1.DiagnosticAddendum());\n            });\n            if (!constrainedType) {\n                diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeConstraint().format({\n                    type: printType(srcType),\n                    name: destType.name,\n                }));\n                return false;\n            }\n            if (curTypeVarMapping && !types_1.isAnyOrUnknown(curTypeVarMapping)) {\n                if (!types_1.isTypeSame(curTypeVarMapping, constrainedType)) {\n                    diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeConstraint().format({\n                        type: printType(constrainedType),\n                        name: printType(curTypeVarMapping),\n                    }));\n                    return false;\n                }\n            }\n            else {\n                // Assign the type to the type var.\n                if (!typeVarMap.isLocked()) {\n                    typeVarMap.setTypeVar(destType.name, constrainedType, false);\n                }\n            }\n            return true;\n        }\n        // Handle the unconstrained (but possibly bound) case.\n        let updatedType = srcType;\n        const curTypeIsNarrowable = typeVarMap.isNarrowable(destType.name) && !typeVarMap.isLocked();\n        const updatedTypeIsNarrowable = canNarrowType && curTypeIsNarrowable;\n        if (curTypeVarMapping) {\n            const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n            if (canNarrowType) {\n                // Handle the narrowing case (used for contravariant type matching).\n                if (curTypeIsNarrowable &&\n                    canAssignType(srcType, curTypeVarMapping, diagAddendum, typeVarMap, flags, recursionCount + 1)) {\n                    // No need to narrow. Stick with the existing type unless it's an Unknown,\n                    // in which case we'll try to replace it with a known type.\n                    if (!types_1.isAnyOrUnknown(curTypeVarMapping) && !types_1.isUnknown(srcType)) {\n                        updatedType = curTypeVarMapping;\n                    }\n                }\n                else if (!canAssignType(curTypeVarMapping, srcType, new diagnostic_1.DiagnosticAddendum(), typeVarMap, flags, recursionCount + 1)) {\n                    diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({\n                        sourceType: printType(srcType),\n                        destType: printType(curTypeVarMapping),\n                    }));\n                    return false;\n                }\n            }\n            else {\n                // Handle the widen case.\n                if (canAssignType(curTypeVarMapping, srcType, diagAddendum, typeVarMap, flags, recursionCount + 1)) {\n                    if (curTypeIsNarrowable) {\n                        // The new srcType is narrower than the current type, but the current\n                        // type is allowed to be narrowed, so replace the current type with\n                        // the srcType.\n                    }\n                    else {\n                        // No need to widen. Stick with the existing type unless it's an Unknown,\n                        // in which case we'll replace it with a known type.\n                        if (!types_1.isUnknown(curTypeVarMapping)) {\n                            updatedType = curTypeVarMapping;\n                        }\n                    }\n                }\n                else {\n                    if (typeVarMap.isLocked()) {\n                        diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({\n                            sourceType: printType(curTypeVarMapping),\n                            destType: printType(srcType),\n                        }));\n                        return false;\n                    }\n                    if (!canAssignType(srcType, curTypeVarMapping, new diagnostic_1.DiagnosticAddendum(), typeVarMap, flags, recursionCount + 1)) {\n                        // Create a union, widening the type.\n                        updatedType = types_1.combineTypes([curTypeVarMapping, srcType]);\n                    }\n                }\n            }\n        }\n        // If there's a bound type, make sure the source is derived from it.\n        if (destType.boundType) {\n            if (!canAssignType(destType.boundType, updatedType, diag.createAddendum(), undefined, 0 /* Default */, recursionCount + 1)) {\n                // Avoid adding a message that will confuse users if the TypeVar was\n                // synthesized for internal purposes.\n                if (!destType.isSynthesized) {\n                    diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeBound().format({\n                        sourceType: printType(updatedType),\n                        destType: printType(destType.boundType),\n                        name: destType.name,\n                    }));\n                }\n                return false;\n            }\n        }\n        if (!typeVarMap.isLocked()) {\n            typeVarMap.setTypeVar(destType.name, updatedType, updatedTypeIsNarrowable);\n        }\n        return true;\n    }\n    // Determines if the source type can be assigned to the dest type.\n    // If typeVarMap is provided, type variables within the destType are\n    // matched against existing type variables in the map. If a type variable\n    // in the dest type is not in the type map already, it is assigned a type\n    // and added to the map.\n    function canAssignType(destType, srcType, diag, typeVarMap, flags = 0 /* Default */, recursionCount = 0) {\n        let checkNamedParams = false;\n        if (recursionCount > types_1.maxTypeRecursionCount) {\n            return true;\n        }\n        if (destType === srcType) {\n            return true;\n        }\n        // If the source or dest is unbound, allow the assignment. The\n        // error will be reported elsewhere.\n        if (types_1.isUnbound(destType) || types_1.isUnbound(srcType)) {\n            return true;\n        }\n        // Strip the ReverseTypeVarMatching from the incoming flags.\n        // We don't want to propagate this flag to any nested calls to\n        // canAssignType.\n        const reverseTypeVarMatching = (flags & 2 /* ReverseTypeVarMatching */) !== 0;\n        flags &= ~2 /* ReverseTypeVarMatching */;\n        // Before performing any other checks, see if the dest type is a\n        // TypeVar that we are attempting to match.\n        if (types_1.isTypeVar(destType)) {\n            if (!reverseTypeVarMatching) {\n                return assignTypeToTypeVar(destType, srcType, \n                /* canNarrowType */ false, diag, typeVarMap || new typeVarMap_1.TypeVarMap(), flags, recursionCount + 1);\n            }\n        }\n        if (types_1.isAnyOrUnknown(destType)) {\n            return true;\n        }\n        if (types_1.isAnyOrUnknown(srcType)) {\n            if (typeVarMap) {\n                // If it's an ellipsis type, convert it to a regular \"Any\"\n                // type. These are functionally equivalent, but \"Any\" looks\n                // better in the text representation.\n                const typeVarSubstitution = typeUtils_1.isEllipsisType(srcType) ? types_1.AnyType.create() : srcType;\n                typeUtils_1.setTypeArgumentsRecursive(destType, typeVarSubstitution, typeVarMap);\n            }\n            return true;\n        }\n        if (types_1.isNever(srcType)) {\n            if (typeVarMap) {\n                typeUtils_1.setTypeArgumentsRecursive(destType, types_1.UnknownType.create(), typeVarMap);\n            }\n            return true;\n        }\n        if (types_1.isTypeVar(srcType)) {\n            // In most cases, the source type will be specialized before\n            // canAssignType is called, so we won't get here. However, there\n            // are cases where this can occur (e.g. when we swap the src and dest\n            // types because they are contravariant).\n            if (reverseTypeVarMatching) {\n                return assignTypeToTypeVar(srcType, destType, \n                /* canNarrowType */ true, diag, typeVarMap || new typeVarMap_1.TypeVarMap(), flags, recursionCount + 1);\n            }\n            const specializedSrcType = typeUtils_1.getConcreteTypeFromTypeVar(srcType);\n            return canAssignType(destType, specializedSrcType, diag, undefined, flags, recursionCount + 1);\n        }\n        if (recursionCount > types_1.maxTypeRecursionCount) {\n            return true;\n        }\n        // If we need to enforce invariance, union types must match exactly.\n        if (flags & 1 /* EnforceInvariance */) {\n            if (srcType.category === 10 /* Union */ || destType.category === 10 /* Union */) {\n                if (!types_1.isTypeSame(srcType, destType)) {\n                    diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({\n                        sourceType: printType(srcType),\n                        destType: printType(destType),\n                    }));\n                    return false;\n                }\n                return true;\n            }\n        }\n        if (srcType.category === 10 /* Union */) {\n            let isIncompatible = false;\n            // For union sources, all of the types need to be assignable to the dest.\n            srcType.subtypes.forEach((t) => {\n                if (!canAssignType(destType, t, diag.createAddendum(), typeVarMap, flags, recursionCount + 1)) {\n                    diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({\n                        sourceType: printType(t),\n                        destType: printType(destType),\n                    }));\n                    isIncompatible = true;\n                }\n            });\n            if (isIncompatible) {\n                return false;\n            }\n            return true;\n        }\n        if (destType.category === 10 /* Union */) {\n            // For union destinations, we just need to match one of the types.\n            const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n            let foundMatch = false;\n            // Run through all subtypes in the union. Don't stop at the first\n            // match we find because we may need to match TypeVars in other\n            // subtypes. We special-case \"None\" so we can handle Optional[T]\n            // without matching the None to the type var.\n            if (srcType.category === 3 /* None */ &&\n                destType.subtypes.some((subtype) => subtype.category === 3 /* None */)) {\n                foundMatch = true;\n            }\n            else {\n                let bestTypeVarMap;\n                let bestTypeVarMapScore;\n                destType.subtypes.forEach((subtype) => {\n                    // Make a temporary clone of the typeVarMap. We don't want to modify\n                    // the original typeVarMap until we find the \"optimal\" typeVar mapping.\n                    const typeVarMapClone = typeVarMap === null || typeVarMap === void 0 ? void 0 : typeVarMap.clone();\n                    if (canAssignType(subtype, srcType, diagAddendum, typeVarMapClone, flags, recursionCount + 1)) {\n                        foundMatch = true;\n                        if (typeVarMapClone) {\n                            // Ask the typeVarMap to compute a \"score\" for the current\n                            // contents of the table.\n                            const typeVarMapScore = typeVarMapClone.getScore();\n                            if (bestTypeVarMapScore === undefined || bestTypeVarMapScore <= typeVarMapScore) {\n                                // We found a typeVar mapping with a higher score than before.\n                                bestTypeVarMapScore = typeVarMapScore;\n                                bestTypeVarMap = typeVarMapClone;\n                            }\n                        }\n                    }\n                });\n                // If we found a winning type var mapping, copy it back to typeVarMap.\n                if (typeVarMap && bestTypeVarMap) {\n                    typeVarMap.copyFromClone(bestTypeVarMap);\n                }\n            }\n            if (!foundMatch) {\n                diag.addAddendum(diagAddendum);\n                return false;\n            }\n            return true;\n        }\n        if (destType.category === 3 /* None */ && srcType.category === 3 /* None */) {\n            return true;\n        }\n        // Is the src a specialized \"Type\" object?\n        if (types_1.isObject(srcType) && types_1.ClassType.isBuiltIn(srcType.classType, 'Type')) {\n            const srcTypeArgs = srcType.classType.typeArguments;\n            if (srcTypeArgs && srcTypeArgs.length >= 1) {\n                if (types_1.isAnyOrUnknown(srcTypeArgs[0])) {\n                    return true;\n                }\n                else if (types_1.isObject(srcTypeArgs[0])) {\n                    return canAssignType(destType, srcTypeArgs[0].classType, diag.createAddendum(), typeVarMap, flags, recursionCount + 1);\n                }\n            }\n        }\n        if (types_1.isClass(destType)) {\n            if (types_1.isClass(srcType)) {\n                return canAssignClass(destType, srcType, diag, typeVarMap, flags, recursionCount + 1, \n                /* reportErrorsUsingObjType */ false);\n            }\n        }\n        if (types_1.isObject(destType)) {\n            const destClassType = destType.classType;\n            // Is the dest a generic \"type\" object?\n            if (types_1.ClassType.isBuiltIn(destClassType, 'type')) {\n                if (types_1.isClass(srcType) ||\n                    srcType.category === 5 /* Function */ ||\n                    srcType.category === 6 /* OverloadedFunction */) {\n                    return true;\n                }\n            }\n            // Is the dest a specialized \"Type\" object?\n            if (types_1.ClassType.isBuiltIn(destClassType, 'Type')) {\n                const destTypeArgs = destClassType.typeArguments;\n                if (destTypeArgs && destTypeArgs.length >= 1) {\n                    if (types_1.isAnyOrUnknown(destTypeArgs[0])) {\n                        return true;\n                    }\n                    else if (types_1.isObject(destTypeArgs[0])) {\n                        return canAssignType(destTypeArgs[0].classType, srcType, diag.createAddendum(), typeVarMap, flags, recursionCount + 1);\n                    }\n                    else if (types_1.isTypeVar(destTypeArgs[0])) {\n                        if (types_1.isClass(srcType) || (types_1.isNone(srcType) && types_1.TypeBase.isInstantiable(srcType))) {\n                            return canAssignType(destTypeArgs[0], typeUtils_1.convertToInstance(srcType), diag.createAddendum(), typeVarMap, flags, recursionCount + 1);\n                        }\n                        else if (srcType.category === 5 /* Function */ ||\n                            srcType.category === 6 /* OverloadedFunction */) {\n                            return canAssignType(destTypeArgs[0], srcType, diag.createAddendum(), typeVarMap, flags, recursionCount + 1);\n                        }\n                    }\n                }\n            }\n            if (types_1.isObject(srcType)) {\n                if (destType.classType.literalValue !== undefined) {\n                    const srcLiteral = srcType.classType.literalValue;\n                    if (srcLiteral === undefined ||\n                        !types_1.ClassType.isLiteralValueSame(srcType.classType, destType.classType)) {\n                        diag.addMessage(localize_1.Localizer.DiagnosticAddendum.literalAssignmentMismatch().format({\n                            sourceType: srcLiteral !== undefined ? typeUtils_1.printLiteralType(srcType) : printType(srcType),\n                            destType: typeUtils_1.printLiteralType(destType),\n                        }));\n                        return false;\n                    }\n                }\n                if (!canAssignClass(destClassType, srcType.classType, diag, typeVarMap, flags, recursionCount + 1, \n                /* reportErrorsUsingObjType */ true)) {\n                    return false;\n                }\n                return true;\n            }\n            else if (srcType.category === 5 /* Function */) {\n                // Is the destination a callback protocol (defined in PEP 544)?\n                const callbackType = getCallbackProtocolType(destType);\n                if (callbackType) {\n                    if (!canAssignFunction(callbackType, srcType, diag.createAddendum(), typeVarMap, recursionCount + 1, \n                    /* checkNamedParams */ true)) {\n                        return false;\n                    }\n                    return true;\n                }\n                // All functions are assignable to \"object\".\n                if (types_1.ClassType.isBuiltIn(destType.classType) && destType.classType.details.name === 'object') {\n                    return true;\n                }\n            }\n            else if (types_1.isModule(srcType)) {\n                // Is the destination the built-in \"ModuleType\"?\n                if (types_1.ClassType.isBuiltIn(destClassType, 'ModuleType')) {\n                    return true;\n                }\n            }\n            else if (types_1.isClass(srcType)) {\n                // All classes are assignable to \"object\".\n                if (types_1.ClassType.isBuiltIn(destType.classType, 'object')) {\n                    return true;\n                }\n                // Determine if the metaclass can be assigned to the object.\n                const metaclass = typeUtils_1.getMetaclass(srcType);\n                if (metaclass) {\n                    if (types_1.isAnyOrUnknown(metaclass)) {\n                        return true;\n                    }\n                    else if (types_1.isClass(metaclass)) {\n                        // Handle EnumMeta, which requires special-case handling because\n                        // of the way it's defined in enum.pyi. The type var _T must be\n                        // manually set to the corresponding enum object type.\n                        if (typeVarMap && types_1.ClassType.isBuiltIn(metaclass, 'EnumMeta')) {\n                            if (!typeVarMap.isLocked()) {\n                                typeVarMap.setTypeVar('_T', types_1.ObjectType.create(srcType), false);\n                            }\n                        }\n                        return canAssignClass(destClassType, metaclass, diag, typeVarMap, flags, recursionCount + 1, \n                        /* reportErrorsUsingObjType */ false);\n                    }\n                }\n            }\n            // See if the destType is an instantiation of a Protocol\n            // class that is effectively a function.\n            const callbackType = getCallbackProtocolType(destType);\n            if (callbackType) {\n                destType = callbackType;\n                checkNamedParams = true;\n            }\n        }\n        if (destType.category === 5 /* Function */) {\n            let srcFunction;\n            if (srcType.category === 6 /* OverloadedFunction */) {\n                // Find first overloaded function that matches the parameters.\n                // We don't want to pollute the current typeVarMap, so we'll\n                // make a copy of the existing one if it's specified.\n                const overloads = srcType.overloads;\n                const overloadIndex = overloads.findIndex((overload) => {\n                    const typeVarMapClone = typeVarMap ? typeVarMap.clone() : undefined;\n                    return canAssignType(destType, overload, diag.createAddendum(), typeVarMapClone, flags, recursionCount + 1);\n                });\n                if (overloadIndex < 0) {\n                    diag.addMessage(localize_1.Localizer.DiagnosticAddendum.noOverloadAssignable().format({ type: printType(destType) }));\n                    return false;\n                }\n                srcFunction = overloads[overloadIndex];\n            }\n            else if (srcType.category === 5 /* Function */) {\n                srcFunction = srcType;\n            }\n            else if (types_1.isObject(srcType)) {\n                const callMember = typeUtils_1.lookUpObjectMember(srcType, '__call__');\n                if (callMember) {\n                    const memberType = getTypeOfMember(callMember);\n                    if (memberType.category === 5 /* Function */) {\n                        srcFunction = typeUtils_1.stripFirstParameter(memberType);\n                    }\n                }\n            }\n            else if (types_1.isClass(srcType)) {\n                // Synthesize a function that represents the constructor for this class.\n                const constructorFunction = types_1.FunctionType.createInstance('__init__', 4 /* StaticMethod */ |\n                    1 /* ConstructorMethod */ |\n                    64 /* SynthesizedMethod */);\n                constructorFunction.details.declaredReturnType = types_1.ObjectType.create(srcType);\n                let constructorInfo = typeUtils_1.lookUpClassMember(srcType, '__init__', 8 /* SkipInstanceVariables */ | 4 /* SkipObjectBaseClass */);\n                if (!constructorInfo) {\n                    constructorInfo = typeUtils_1.lookUpClassMember(srcType, '__new__', 8 /* SkipInstanceVariables */ | 4 /* SkipObjectBaseClass */);\n                }\n                const constructorType = constructorInfo ? getTypeOfMember(constructorInfo) : undefined;\n                if (constructorType && constructorType.category === 5 /* Function */) {\n                    constructorType.details.parameters.forEach((param, index) => {\n                        // Skip the 'cls' or 'self' parameter.\n                        if (index > 0) {\n                            types_1.FunctionType.addParameter(constructorFunction, param);\n                        }\n                    });\n                }\n                else {\n                    types_1.FunctionType.addDefaultParameters(constructorFunction);\n                }\n                srcFunction = constructorFunction;\n            }\n            if (srcFunction) {\n                return canAssignFunction(destType, srcFunction, diag.createAddendum(), typeVarMap, recursionCount + 1, checkNamedParams);\n            }\n        }\n        // NoneType and ModuleType derive from object.\n        if (types_1.isNone(srcType) || types_1.isModule(srcType)) {\n            if (types_1.isObject(destType)) {\n                const destClassType = destType.classType;\n                if (types_1.ClassType.isBuiltIn(destClassType, 'object')) {\n                    return true;\n                }\n            }\n        }\n        if (types_1.isNone(destType)) {\n            diag.addMessage(localize_1.Localizer.DiagnosticAddendum.assignToNone());\n            return false;\n        }\n        diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({\n            sourceType: printType(srcType),\n            destType: printType(destType),\n        }));\n        return false;\n    }\n    function getCallbackProtocolType(objType) {\n        if (!types_1.ClassType.isProtocolClass(objType.classType)) {\n            return undefined;\n        }\n        const callMember = typeUtils_1.lookUpObjectMember(objType, '__call__');\n        if (!callMember) {\n            return undefined;\n        }\n        const memberType = getTypeOfMember(callMember);\n        if (memberType.category === 5 /* Function */) {\n            return bindFunctionToClassOrObject(objType, memberType);\n        }\n        return undefined;\n    }\n    function canAssignFunction(destType, srcType, diag, typeVarMap, recursionCount, checkNamedParams) {\n        let canAssign = true;\n        // Count the number of parameters that have names. We'll exclude\n        // pseudo-parameters (* and /) that designate name-only and position-only\n        // separators.\n        const srcParamCount = srcType.details.parameters.filter((param) => param.name).length;\n        const destParamCount = destType.details.parameters.filter((param) => param.name).length;\n        const minParamCount = Math.min(srcParamCount, destParamCount);\n        // Match as many input parameters as we can.\n        for (let paramIndex = 0; paramIndex < minParamCount; paramIndex++) {\n            const srcParam = srcType.details.parameters[paramIndex];\n            const destParam = destType.details.parameters[paramIndex];\n            const paramDiag = diag.createAddendum();\n            // If the dest or source involve var-args, no need to continue matching.\n            if (srcParam.category !== 0 /* Simple */ || destParam.category !== 0 /* Simple */) {\n                break;\n            }\n            const srcParamType = types_1.FunctionType.getEffectiveParameterType(srcType, paramIndex);\n            const destParamType = types_1.FunctionType.getEffectiveParameterType(destType, paramIndex);\n            // Call canAssignType once to perform any typeVarMap population.\n            canAssignType(srcParamType, destParamType, new diagnostic_1.DiagnosticAddendum(), typeVarMap, 2 /* ReverseTypeVarMatching */, recursionCount + 1);\n            // Make sure we can assign the specialized dest type to the\n            // source type.\n            const specializedDestParamType = typeUtils_1.specializeType(destParamType, typeVarMap, \n            /* makeConcrete */ false, recursionCount + 1);\n            if (!canAssignType(srcParamType, specializedDestParamType, paramDiag.createAddendum(), undefined, 0 /* Default */, recursionCount + 1)) {\n                paramDiag.addMessage(localize_1.Localizer.DiagnosticAddendum.paramAssignment().format({\n                    index: paramIndex + 1,\n                    sourceType: printType(specializedDestParamType),\n                    destType: printType(srcParamType),\n                }));\n                canAssign = false;\n            }\n        }\n        const srcParams = srcType.details.parameters;\n        const destParams = destType.details.parameters;\n        const srcHasVarArgs = srcParams.find((param) => param.name && param.category !== 0 /* Simple */) !== undefined;\n        const destHasVarArgs = destParams.find((param) => param.name && param.category !== 0 /* Simple */) !== undefined;\n        if (checkNamedParams) {\n            // Handle matching of named (keyword) parameters.\n            // Build a dictionary of named parameters in the dest.\n            const destParamMap = new Map();\n            let destHasNamedParam = false;\n            destParams.forEach((param) => {\n                if (destHasNamedParam) {\n                    if (param.name && param.category === 0 /* Simple */) {\n                        destParamMap.set(param.name, param);\n                    }\n                }\n                else if (param.category === 1 /* VarArgList */) {\n                    destHasNamedParam = true;\n                }\n            });\n            let srcHasNamedParam = false;\n            srcParams.forEach((param) => {\n                if (srcHasNamedParam) {\n                    if (param.name && param.category === 0 /* Simple */) {\n                        const destParam = destParamMap.get(param.name);\n                        const paramDiag = diag.createAddendum();\n                        if (!destParam) {\n                            paramDiag.addMessage(localize_1.Localizer.DiagnosticAddendum.namedParamMissingInDest().format({ name: param.name }));\n                            canAssign = false;\n                        }\n                        else {\n                            const specializedDestParamType = typeUtils_1.specializeType(destParam.type, typeVarMap, \n                            /* makeConcrete */ false, recursionCount + 1);\n                            if (!canAssignType(param.type, specializedDestParamType, paramDiag.createAddendum(), undefined, 0 /* Default */, recursionCount + 1)) {\n                                paramDiag.addMessage(localize_1.Localizer.DiagnosticAddendum.namedParamTypeMismatch().format({\n                                    name: param.name,\n                                    sourceType: printType(specializedDestParamType),\n                                    destType: printType(param.type),\n                                }));\n                                canAssign = false;\n                            }\n                            destParamMap.delete(param.name);\n                        }\n                    }\n                }\n                else if (param.category === 1 /* VarArgList */) {\n                    srcHasNamedParam = true;\n                }\n            });\n            // See if there are any unmatched named parameters.\n            destParamMap.forEach((_, paramName) => {\n                const paramDiag = diag.createAddendum();\n                paramDiag.addMessage(localize_1.Localizer.DiagnosticAddendum.namedParamMissingInSource().format({ name: paramName }));\n                canAssign = false;\n            });\n        }\n        // If we didn't find a var-arg parameter, the number of dest params\n        // must be enough to provide all of the non-default source params\n        // with values. Plus, the number of source params must be enough to\n        // accept all of the dest arguments.\n        if (!srcHasVarArgs && !destHasVarArgs) {\n            const nonDefaultSrcParamCount = srcParams.filter((param) => !!param.name && !param.hasDefault).length;\n            if (destParamCount < nonDefaultSrcParamCount) {\n                diag.addMessage(localize_1.Localizer.DiagnosticAddendum.functionTooFewParams().format({\n                    expected: nonDefaultSrcParamCount,\n                    received: destParamCount,\n                }));\n                canAssign = false;\n            }\n            if (destParamCount > srcParamCount) {\n                diag.addMessage(localize_1.Localizer.DiagnosticAddendum.functionTooManyParams().format({\n                    expected: srcParamCount,\n                    received: destParamCount,\n                }));\n                canAssign = false;\n            }\n        }\n        // Match the return parameter.\n        const destReturnType = getFunctionEffectiveReturnType(destType);\n        if (!types_1.isAnyOrUnknown(destReturnType)) {\n            const srcReturnType = getFunctionEffectiveReturnType(srcType);\n            if (!canAssignType(destReturnType, srcReturnType, diag.createAddendum(), typeVarMap, 0 /* Default */, recursionCount + 1)) {\n                diag.addMessage(localize_1.Localizer.DiagnosticAddendum.functionReturnTypeMismatch().format({\n                    sourceType: printType(srcReturnType),\n                    destType: printType(destReturnType),\n                }));\n                canAssign = false;\n            }\n        }\n        // Are we assigning to a function with a ParamSpec?\n        if (destType.details.paramSpec && typeVarMap && !typeVarMap.isLocked()) {\n            typeVarMap.setParamSpec(destType.details.paramSpec.name, srcType);\n        }\n        return canAssign;\n    }\n    // When a variable with a declared type is assigned and the declared\n    // type is a union, we may be able to further narrow the type.\n    function narrowDeclaredTypeBasedOnAssignedType(declaredType, assignedType) {\n        const diagAddendum = new diagnostic_1.DiagnosticAddendum();\n        if (declaredType.category === 10 /* Union */) {\n            return typeUtils_1.doForSubtypes(declaredType, (subtype) => {\n                if (assignedType.category === 10 /* Union */) {\n                    if (!assignedType.subtypes.some((t) => canAssignType(subtype, t, diagAddendum))) {\n                        return undefined;\n                    }\n                    else {\n                        return subtype;\n                    }\n                }\n                if (!canAssignType(subtype, assignedType, diagAddendum)) {\n                    return undefined;\n                }\n                return subtype;\n            });\n        }\n        if (!canAssignType(declaredType, assignedType, diagAddendum)) {\n            return types_1.NeverType.create();\n        }\n        return typeUtils_1.transformTypeObjectToClass(declaredType);\n    }\n    function canOverrideMethod(baseMethod, overrideMethod, diag) {\n        // If we're overriding an overloaded method, uses the last overload.\n        if (baseMethod.category === 6 /* OverloadedFunction */) {\n            baseMethod = baseMethod.overloads[baseMethod.overloads.length - 1];\n        }\n        // If we're overriding a non-method with a method, report it as an error.\n        // This occurs when a non-property overrides a property.\n        if (baseMethod.category !== 5 /* Function */) {\n            diag.addMessage(localize_1.Localizer.DiagnosticAddendum.overrideType().format({ type: printType(baseMethod) }));\n            return false;\n        }\n        let canOverride = true;\n        const baseParams = baseMethod.details.parameters;\n        const overrideParams = overrideMethod.details.parameters;\n        // Verify that the param count matches exactly or that the override\n        // adds only params that preserve the original signature.\n        let foundParamCountMismatch = false;\n        if (overrideParams.length < baseParams.length) {\n            foundParamCountMismatch = true;\n        }\n        else if (overrideParams.length > baseParams.length) {\n            // Verify that all of the override parameters that extend the\n            // signature are either *vars, **kwargs or parameters with\n            // default values.\n            for (let i = baseParams.length; i < overrideParams.length; i++) {\n                const overrideParam = overrideParams[i];\n                if (overrideParam.category === 0 /* Simple */ &&\n                    overrideParam.name &&\n                    !overrideParam.hasDefault) {\n                    foundParamCountMismatch = true;\n                }\n            }\n        }\n        if (foundParamCountMismatch) {\n            diag.addMessage(localize_1.Localizer.DiagnosticAddendum.overrideParamCount().format({\n                baseCount: baseParams.length,\n                overrideCount: overrideParams.length,\n            }));\n            canOverride = false;\n        }\n        const paramCount = Math.min(baseParams.length, overrideParams.length);\n        const positionOnlyIndex = baseParams.findIndex((param) => !param.name && param.category === 0 /* Simple */);\n        for (let i = 0; i < paramCount; i++) {\n            const baseParam = baseParams[i];\n            const overrideParam = overrideParams[i];\n            if (i > positionOnlyIndex &&\n                !symbolNameUtils_1.isPrivateOrProtectedName(baseParam.name || '') &&\n                baseParam.category === 0 /* Simple */ &&\n                baseParam.name !== overrideParam.name) {\n                diag.addMessage(localize_1.Localizer.DiagnosticAddendum.overrideParamName().format({\n                    index: i + 1,\n                    baseName: baseParam.name || '*',\n                    overrideName: overrideParam.name || '*',\n                }));\n                canOverride = false;\n            }\n            else {\n                const baseParamType = types_1.FunctionType.getEffectiveParameterType(baseMethod, i);\n                const overrideParamType = types_1.FunctionType.getEffectiveParameterType(overrideMethod, i);\n                if (baseParam.category !== overrideParam.category ||\n                    !canAssignType(baseParamType, overrideParamType, diag.createAddendum())) {\n                    diag.addMessage(localize_1.Localizer.DiagnosticAddendum.overrideParamType().format({\n                        index: i + 1,\n                        baseType: printType(baseParamType),\n                        overrideType: printType(overrideParamType),\n                    }));\n                    canOverride = false;\n                }\n            }\n        }\n        const baseReturnType = getFunctionEffectiveReturnType(baseMethod);\n        const overrideReturnType = getFunctionEffectiveReturnType(overrideMethod);\n        if (!canAssignType(baseReturnType, overrideReturnType, diag.createAddendum())) {\n            diag.addMessage(localize_1.Localizer.DiagnosticAddendum.overrideReturnType().format({\n                baseType: printType(baseReturnType),\n                overrideType: printType(overrideReturnType),\n            }));\n            canOverride = false;\n        }\n        return canOverride;\n    }\n    // Validates that the specified source type matches the constraints\n    // of the type variable.\n    function canAssignToTypeVar(destType, srcType, diag, flags = 0 /* Default */, recursionCount = 0) {\n        if (recursionCount > types_1.maxTypeRecursionCount) {\n            return true;\n        }\n        if (types_1.isAnyOrUnknown(srcType)) {\n            return true;\n        }\n        let effectiveSrcType = srcType;\n        if (types_1.isTypeVar(srcType)) {\n            if (types_1.isTypeSame(srcType, destType)) {\n                return true;\n            }\n            if (srcType.boundType) {\n                // If the source type is a type var itself and has a bound type,\n                // convert it to that bound type.\n                effectiveSrcType = typeUtils_1.getConcreteTypeFromTypeVar(srcType, recursionCount + 1);\n            }\n            else if (srcType.constraints) {\n                effectiveSrcType = types_1.combineTypes(srcType.constraints);\n            }\n            else {\n                effectiveSrcType = types_1.AnyType.create();\n            }\n        }\n        // If there's a bound type, make sure the source is derived from it.\n        const boundType = destType.boundType;\n        if (boundType) {\n            if (!canAssignType(boundType, effectiveSrcType, diag.createAddendum(), undefined, flags, recursionCount + 1)) {\n                // Avoid adding a message that will confuse users if the TypeVar was\n                // synthesized for internal purposes.\n                if (!destType.isSynthesized) {\n                    diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeBound().format({\n                        sourceType: printType(effectiveSrcType),\n                        destType: printType(boundType),\n                        name: destType.name,\n                    }));\n                }\n                return false;\n            }\n        }\n        // If there are no constraints, we're done.\n        const constraints = destType.constraints;\n        if (constraints.length === 0) {\n            return true;\n        }\n        // Try to find a match among the constraints.\n        for (const constraint of constraints) {\n            if (types_1.isAnyOrUnknown(constraint)) {\n                return true;\n            }\n            else if (effectiveSrcType.category === 10 /* Union */) {\n                // Does it match at least one of the constraints?\n                if (effectiveSrcType.subtypes.find((t) => types_1.isSameWithoutLiteralValue(constraint, t))) {\n                    return true;\n                }\n            }\n            else if (types_1.isSameWithoutLiteralValue(constraint, effectiveSrcType)) {\n                return true;\n            }\n        }\n        diag.addMessage(localize_1.Localizer.DiagnosticAddendum.typeConstrainedTypeVar().format({\n            type: printType(effectiveSrcType),\n            name: destType.name,\n        }));\n        return false;\n    }\n    function getAbstractMethods(classType) {\n        const symbolTable = new Map();\n        classType.details.mro.forEach((mroClass) => {\n            if (types_1.isClass(mroClass)) {\n                // See if this class is introducing a new abstract method that has not been\n                // introduced previously or if it is overriding an abstract method with\n                // a non-abstract one.\n                mroClass.details.fields.forEach((symbol, symbolName) => {\n                    // We do a quick-and-dirty evaluation of methods based on\n                    // decorators to determine which ones are abstract. This allows\n                    // us to avoid evaluating the full function types.\n                    if (symbol.isClassMember()) {\n                        let isAbstract;\n                        const decl = symbolUtils_1.getLastTypedDeclaredForSymbol(symbol);\n                        if (decl && decl.type === 3 /* Function */) {\n                            const functionFlags = getFunctionFlagsFromDecorators(decl.node, true);\n                            isAbstract = !!(functionFlags & 8 /* AbstractMethod */);\n                        }\n                        else {\n                            // If a symbol is overridden by a non-function, it is no longer\n                            // considered abstract. This can happen in some code, for example,\n                            // when a base class declares an abstract property and a subclass\n                            // \"overrides\" it with an instance variable.\n                            isAbstract = false;\n                        }\n                        if (!symbolTable.has(symbolName)) {\n                            symbolTable.set(symbolName, {\n                                symbol,\n                                symbolName,\n                                isAbstract,\n                                classType: mroClass,\n                            });\n                        }\n                    }\n                });\n            }\n        });\n        // Create a final list of methods that are abstract.\n        const methodList = [];\n        symbolTable.forEach((method) => {\n            if (method.isAbstract) {\n                methodList.push(method);\n            }\n        });\n        return methodList;\n    }\n    // Determines whether the specified keys and values can be assigned to\n    // a typed dictionary class. The caller should have already validated\n    // that the class is indeed a typed dict.\n    function canAssignToTypedDict(classType, keyTypes, valueTypes, diagAddendum) {\n        debug_1.assert(types_1.ClassType.isTypedDictClass(classType));\n        debug_1.assert(keyTypes.length === valueTypes.length);\n        let isMatch = true;\n        const symbolMap = getTypedDictMembersForClass(classType);\n        keyTypes.forEach((keyType, index) => {\n            if (!types_1.isObject(keyType) ||\n                !types_1.ClassType.isBuiltIn(keyType.classType, 'str') ||\n                keyType.classType.literalValue === undefined) {\n                isMatch = false;\n            }\n            else {\n                const keyValue = keyType.classType.literalValue;\n                const symbolEntry = symbolMap.get(keyValue);\n                if (!symbolEntry) {\n                    // The provided key name doesn't exist.\n                    isMatch = false;\n                    diagAddendum.addMessage(localize_1.Localizer.DiagnosticAddendum.typedDictFieldUndefined().format({\n                        name: keyType.classType.literalValue,\n                        type: printType(types_1.ObjectType.create(classType)),\n                    }));\n                }\n                else {\n                    // Can we assign the value to the declared type?\n                    const assignDiag = new diagnostic_1.DiagnosticAddendum();\n                    if (!canAssignType(symbolEntry.valueType, valueTypes[index], assignDiag)) {\n                        diagAddendum.addMessage(localize_1.Localizer.DiagnosticAddendum.typedDictFieldTypeMismatch().format({\n                            name: keyType.classType.literalValue,\n                            type: printType(valueTypes[index]),\n                        }));\n                        isMatch = false;\n                    }\n                    symbolEntry.isProvided = true;\n                }\n            }\n        });\n        if (!isMatch) {\n            return false;\n        }\n        // See if any required keys are missing.\n        symbolMap.forEach((entry, name) => {\n            if (entry.isRequired && !entry.isProvided) {\n                diagAddendum.addMessage(localize_1.Localizer.DiagnosticAddendum.typedDictFieldRequired().format({\n                    name,\n                    type: printType(types_1.ObjectType.create(classType)),\n                }));\n                isMatch = false;\n            }\n        });\n        return isMatch;\n    }\n    function getTypedDictMembersForClass(classType) {\n        const entries = new Map();\n        getTypedDictMembersForClassRecursive(classType, entries);\n        return entries;\n    }\n    function getTypedDictMembersForClassRecursive(classType, keyMap, recursionCount = 0) {\n        debug_1.assert(types_1.ClassType.isTypedDictClass(classType));\n        if (recursionCount > types_1.maxTypeRecursionCount) {\n            return;\n        }\n        classType.details.baseClasses.forEach((baseClassType) => {\n            if (types_1.isClass(baseClassType) && types_1.ClassType.isTypedDictClass(baseClassType)) {\n                getTypedDictMembersForClassRecursive(baseClassType, keyMap, recursionCount + 1);\n            }\n        });\n        // Add any new typed dict entries from this class.\n        classType.details.fields.forEach((symbol, name) => {\n            if (!symbol.isIgnoredForProtocolMatch()) {\n                // Only variables (not functions, classes, etc.) are considered.\n                const lastDecl = symbolUtils_1.getLastTypedDeclaredForSymbol(symbol);\n                if (lastDecl && lastDecl.type === 1 /* Variable */) {\n                    keyMap.set(name, {\n                        valueType: getDeclaredTypeOfSymbol(symbol) || types_1.UnknownType.create(),\n                        isRequired: !types_1.ClassType.isCanOmitDictValues(classType),\n                        isProvided: false,\n                    });\n                }\n            }\n        });\n    }\n    // If the memberType is an instance or class method, creates a new\n    // version of the function that has the \"self\" or \"cls\" parameter bound\n    // to it. If treatAsClassMember is true, the function is treated like a\n    // class member even if it's not marked as such. That's needed to\n    // special-case the __new__ magic method when it's invoked as a\n    // constructor (as opposed to by name).\n    function bindFunctionToClassOrObject(baseType, memberType, treatAsClassMember = false) {\n        if (memberType.category === 5 /* Function */) {\n            // If the caller specified no base type, always strip the\n            // first parameter. This is used in cases like constructors.\n            if (!baseType) {\n                return typeUtils_1.stripFirstParameter(memberType);\n            }\n            else if (types_1.FunctionType.isInstanceMethod(memberType) && !treatAsClassMember) {\n                if (types_1.isObject(baseType)) {\n                    return partiallySpecializeFunctionForBoundClassOrObject(baseType, memberType);\n                }\n            }\n            else if (types_1.FunctionType.isClassMethod(memberType) || treatAsClassMember) {\n                return partiallySpecializeFunctionForBoundClassOrObject(types_1.isClass(baseType) ? baseType : baseType.classType, memberType);\n            }\n        }\n        else if (memberType.category === 6 /* OverloadedFunction */) {\n            const newOverloadType = types_1.OverloadedFunctionType.create();\n            memberType.overloads.forEach((overload) => {\n                types_1.OverloadedFunctionType.addOverload(newOverloadType, bindFunctionToClassOrObject(baseType, overload, treatAsClassMember));\n            });\n            return newOverloadType;\n        }\n        return memberType;\n    }\n    function partiallySpecializeFunctionForBoundClassOrObject(baseType, memberType) {\n        const classType = types_1.isClass(baseType) ? baseType : baseType.classType;\n        // If the class has already been specialized (fully or partially), use its\n        // existing type arg mappings. If it hasn't, use a fresh type arg map.\n        const typeVarMap = classType.typeArguments ? typeUtils_1.buildTypeVarMapFromSpecializedClass(classType) : new typeVarMap_1.TypeVarMap();\n        if (memberType.details.parameters.length > 0) {\n            const firstParam = memberType.details.parameters[0];\n            // Fill out the typeVarMap.\n            canAssignType(firstParam.type, baseType, new diagnostic_1.DiagnosticAddendum(), typeVarMap);\n        }\n        // Get the effective return type, which will have the side effect of lazily\n        // evaluating (and caching) the inferred return type if there is no defined return type.\n        getFunctionEffectiveReturnType(memberType);\n        const specializedFunction = typeUtils_1.specializeType(memberType, typeVarMap, /* makeConcrete */ false);\n        return typeUtils_1.stripFirstParameter(specializedFunction);\n    }\n    function printObjectTypeForClass(type, recursionCount = 0) {\n        let objName = type.details.name;\n        // If this is a pseudo-generic class, don't display the type arguments\n        // or type parameters because it will confuse users.\n        if (!types_1.ClassType.isPseudoGenericClass(type)) {\n            // If there is a type arguments array, it's a specialized class.\n            if (type.typeArguments) {\n                // Handle Tuple[()] as a special case.\n                if (type.typeArguments.length > 0) {\n                    if ((printTypeFlags & 2 /* OmitTypeArgumentsIfAny */) === 0 ||\n                        type.typeArguments.some((typeArg) => !types_1.isAnyOrUnknown(typeArg))) {\n                        objName +=\n                            '[' +\n                                type.typeArguments\n                                    .map((typeArg) => {\n                                    return printType(typeArg, /* expandTypeAlias */ false, recursionCount + 1);\n                                })\n                                    .join(', ') +\n                                ']';\n                    }\n                }\n                else {\n                    if (types_1.ClassType.isBuiltIn(type, 'Tuple')) {\n                        objName += '[()]';\n                    }\n                }\n            }\n            else {\n                const typeParams = types_1.ClassType.getTypeParameters(type);\n                if (typeParams.length > 0) {\n                    if ((printTypeFlags & 2 /* OmitTypeArgumentsIfAny */) === 0 ||\n                        typeParams.some((typeParam) => !types_1.isAnyOrUnknown(typeParam))) {\n                        objName +=\n                            '[' +\n                                typeParams\n                                    .map((typeParam) => {\n                                    return printType(typeParam, /* expandTypeAlias */ false, recursionCount + 1);\n                                })\n                                    .join(', ') +\n                                ']';\n                    }\n                }\n            }\n        }\n        return objName;\n    }\n    function printFunctionParts(type, recursionCount = 0) {\n        const paramTypeStrings = type.details.parameters.map((param, index) => {\n            let paramString = '';\n            if (param.category === 1 /* VarArgList */) {\n                paramString += '*';\n            }\n            else if (param.category === 2 /* VarArgDictionary */) {\n                paramString += '**';\n            }\n            if (param.name) {\n                paramString += param.name;\n            }\n            let defaultValueAssignment = '=';\n            if (param.category === 0 /* Simple */) {\n                if (param.name) {\n                    // Avoid printing type types if parameter have unknown type.\n                    if (param.hasDeclaredType || param.isTypeInferred) {\n                        const paramType = types_1.FunctionType.getEffectiveParameterType(type, index);\n                        const paramTypeString = recursionCount < types_1.maxTypeRecursionCount\n                            ? printType(paramType, /* expandTypeAlias */ false, recursionCount + 1)\n                            : '';\n                        paramString += ': ' + paramTypeString;\n                        // PEP8 indicates that the \"=\" for the default value should have surrounding\n                        // spaces when used with a type annotation.\n                        defaultValueAssignment = ' = ';\n                    }\n                    else if ((printTypeFlags & 2 /* OmitTypeArgumentsIfAny */) === 0) {\n                        paramString += ': Unknown';\n                        defaultValueAssignment = ' = ';\n                    }\n                }\n                else {\n                    paramString += '/';\n                }\n            }\n            if (type.details.declaration) {\n                const adjustedIndex = type.ignoreFirstParamOfDeclaration ? index + 1 : index;\n                const paramNode = type.details.declaration.node.parameters[adjustedIndex];\n                if (paramNode.defaultValue) {\n                    paramString += defaultValueAssignment + ParseTreeUtils.printExpression(paramNode.defaultValue);\n                }\n            }\n            return paramString;\n        });\n        const returnType = getFunctionEffectiveReturnType(type);\n        let returnTypeString = recursionCount < types_1.maxTypeRecursionCount\n            ? printType(returnType, /* expandTypeAlias */ false, recursionCount + 1)\n            : '';\n        if (printTypeFlags & 8 /* PEP604 */ &&\n            returnType.category === 10 /* Union */ &&\n            recursionCount > 0) {\n            returnTypeString = `(${returnTypeString})`;\n        }\n        return [paramTypeStrings, returnTypeString];\n    }\n    function printType(type, expandTypeAlias = false, recursionCount = 0) {\n        if (recursionCount >= types_1.maxTypeRecursionCount) {\n            return '...';\n        }\n        // If this is a type alias, use its name rather than the type\n        // it represents.\n        if (type.typeAliasInfo && !expandTypeAlias) {\n            let aliasName = type.typeAliasInfo.aliasName;\n            // If there is a type arguments array, it's a specialized type alias.\n            if (type.typeAliasInfo.typeArguments) {\n                if ((printTypeFlags & 2 /* OmitTypeArgumentsIfAny */) === 0 ||\n                    type.typeAliasInfo.typeArguments.some((typeArg) => !types_1.isAnyOrUnknown(typeArg))) {\n                    aliasName +=\n                        '[' +\n                            type.typeAliasInfo.typeArguments\n                                .map((typeArg) => {\n                                return printType(typeArg, /* expandTypeAlias */ false, recursionCount + 1);\n                            })\n                                .join(', ') +\n                            ']';\n                }\n            }\n            else {\n                if (type.typeAliasInfo.typeParameters) {\n                    if ((printTypeFlags & 2 /* OmitTypeArgumentsIfAny */) === 0 ||\n                        type.typeAliasInfo.typeParameters.some((typeParam) => !types_1.isAnyOrUnknown(typeParam))) {\n                        aliasName +=\n                            '[' +\n                                type.typeAliasInfo.typeParameters\n                                    .map((typeParam) => {\n                                    return printType(typeParam, /* expandTypeAlias */ false, recursionCount + 1);\n                                })\n                                    .join(', ') +\n                                ']';\n                    }\n                }\n            }\n            return aliasName;\n        }\n        switch (type.category) {\n            case 0 /* Unbound */: {\n                return 'Unbound';\n            }\n            case 1 /* Unknown */: {\n                return (printTypeFlags & 1 /* PrintUnknownWithAny */) !== 0 ? 'Any' : 'Unknown';\n            }\n            case 9 /* Module */: {\n                return 'Module';\n            }\n            case 7 /* Class */: {\n                return 'Type[' + printObjectTypeForClass(type, recursionCount + 1) + ']';\n            }\n            case 8 /* Object */: {\n                const objType = type;\n                if (objType.classType.literalValue !== undefined) {\n                    return typeUtils_1.printLiteralType(objType);\n                }\n                if (typeUtils_1.isProperty(type)) {\n                    const getterInfo = typeUtils_1.lookUpObjectMember(type, 'fget');\n                    if (getterInfo) {\n                        const getter = getTypeOfMember(getterInfo);\n                        if (getter.category === 5 /* Function */) {\n                            const returnType = getFunctionEffectiveReturnType(getter);\n                            return printType(returnType, /* expandTypeAlias */ false, recursionCount + 1);\n                        }\n                    }\n                }\n                return printObjectTypeForClass(objType.classType, recursionCount + 1);\n            }\n            case 5 /* Function */: {\n                // If it's a Callable with a ParamSpec, use the\n                // Callable notation.\n                const parts = printFunctionParts(type, recursionCount);\n                if (type.details.paramSpec) {\n                    return `Callable[${type.details.paramSpec.name}, ${parts[1]}]`;\n                }\n                return `(${parts[0].join(', ')}) -> ${parts[1]}`;\n            }\n            case 6 /* OverloadedFunction */: {\n                const overloadedType = type;\n                const overloads = overloadedType.overloads.map((overload) => printType(overload, /* expandTypeAlias */ false, recursionCount + 1));\n                return `Overload[${overloads.join(', ')}]`;\n            }\n            case 10 /* Union */: {\n                const unionType = type;\n                let subtypes = unionType.subtypes;\n                if (subtypes.find((t) => t.category === 3 /* None */) !== undefined) {\n                    const optionalType = printType(types_1.removeNoneFromUnion(unionType), \n                    /* expandTypeAlias */ false, recursionCount + 1);\n                    if (printTypeFlags & 8 /* PEP604 */) {\n                        return optionalType + ' | None';\n                    }\n                    return 'Optional[' + optionalType + ']';\n                }\n                // Make a shallow copy of the array so we can manipulate it.\n                subtypes = [];\n                subtypes = subtypes.concat(...unionType.subtypes);\n                // If we're printing \"Unknown\" as \"Any\", remove redundant\n                // unknowns so we don't see two Any's appear in the union.\n                if ((printTypeFlags & 1 /* PrintUnknownWithAny */) !== 0) {\n                    if (subtypes.some((t) => t.category === 2 /* Any */)) {\n                        subtypes = subtypes.filter((t) => !types_1.isUnknown(t));\n                    }\n                }\n                // If one or more subtypes are pseudo-generic, remove any other pseudo-generics\n                // of the same type because we don't print type arguments for pseudo-generic\n                // types, and we'll end up displaying seemingly-duplicated types.\n                const isPseudoGeneric = (type) => (types_1.isClass(type) && types_1.ClassType.isPseudoGenericClass(type)) ||\n                    (types_1.isObject(type) && types_1.ClassType.isPseudoGenericClass(type.classType));\n                if (subtypes.some((t) => isPseudoGeneric(t))) {\n                    const filteredSubtypes = [];\n                    subtypes.forEach((type) => {\n                        if (!isPseudoGeneric(type)) {\n                            filteredSubtypes.push(type);\n                        }\n                        else if (types_1.isClass(type)) {\n                            if (!filteredSubtypes.some((t) => types_1.isClass(t) && types_1.ClassType.isSameGenericClass(t, type))) {\n                                filteredSubtypes.push(type);\n                            }\n                        }\n                        else if (types_1.isObject(type)) {\n                            if (!filteredSubtypes.some((t) => types_1.isObject(t) && types_1.ClassType.isSameGenericClass(t.classType, type.classType))) {\n                                filteredSubtypes.push(type);\n                            }\n                        }\n                    });\n                    subtypes = filteredSubtypes;\n                }\n                const isLiteral = (type) => types_1.isObject(type) && type.classType.literalValue !== undefined;\n                const subtypeStrings = [];\n                while (subtypes.length > 0) {\n                    const subtype = subtypes.shift();\n                    if (isLiteral(subtype)) {\n                        // Combine all literal values. Rather than printing Union[Literal[1],\n                        // Literal[2]], print Literal[1, 2].\n                        const literals = subtypes.filter((t) => isLiteral(t));\n                        literals.unshift(subtype);\n                        const literalValues = literals.map((t) => typeUtils_1.printLiteralValue(t));\n                        subtypeStrings.push(`Literal[${literalValues.join(', ')}]`);\n                        // Remove the items we've handled.\n                        if (literals.length > 1) {\n                            subtypes = subtypes.filter((t) => !isLiteral(t));\n                        }\n                    }\n                    else {\n                        subtypeStrings.push(printType(subtype, /* expandTypeAlias */ false, recursionCount + 1));\n                    }\n                }\n                if (subtypeStrings.length === 1) {\n                    return subtypeStrings[0];\n                }\n                if (printTypeFlags & 8 /* PEP604 */) {\n                    return subtypeStrings.join(' | ');\n                }\n                return `Union[${subtypeStrings.join(', ')}]`;\n            }\n            case 11 /* TypeVar */: {\n                // If it's synthesized, don't expose the internal name we generated.\n                // This will confuse users. The exception is if it's a bound synthesized\n                // type, in which case we'll print the bound type. This is used for\n                // \"self\" and \"cls\" parameters.\n                if (type.isSynthesized) {\n                    if (type.boundType) {\n                        return printType(type.boundType, /* expandTypeAlias */ false, recursionCount + 1);\n                    }\n                    return (printTypeFlags & 1 /* PrintUnknownWithAny */) !== 0 ? 'Any' : 'Unknown';\n                }\n                if (type.isParamSpec) {\n                    return `ParamSpec('${type.name}')`;\n                }\n                return `TypeVar('${type.name}')`;\n            }\n            case 3 /* None */: {\n                return types_1.TypeBase.isInstantiable(type) ? 'NoneType' : 'None';\n            }\n            case 4 /* Never */: {\n                return 'Never';\n            }\n            case 2 /* Any */: {\n                const anyType = type;\n                return anyType.isEllipsis ? '...' : 'Any';\n            }\n        }\n        return '';\n    }\n    // Calls back into the parser to parse the contents of a string literal.\n    // This is unfortunately needed in some cases — specifically where the\n    // parser couldn't determine that the string literal would be used in\n    // a context where it should be treated as a forward-declared type. This\n    // call produces an expression tree that is not attached to the main parse\n    // expression tree because we don't want to mutate the latter; the\n    // expression tree created by this function is therefore used only temporarily.\n    function parseStringAsTypeAnnotation(node) {\n        const fileInfo = getFileInfo(node);\n        const parser = new parser_1.Parser();\n        const textValue = node.strings[0].value;\n        // Determine the offset within the file where the string\n        // literal's contents begin.\n        const valueOffset = node.strings[0].start + node.strings[0].token.prefixLength + node.strings[0].token.quoteMarkLength;\n        const parseOptions = new parser_1.ParseOptions();\n        parseOptions.isStubFile = fileInfo.isStubFile;\n        parseOptions.pythonVersion = fileInfo.executionEnvironment.pythonVersion;\n        const parseResults = parser.parseTextExpression(fileInfo.fileContents, valueOffset, textValue.length, parseOptions, true);\n        if (parseResults.parseTree) {\n            parseResults.diagnostics.forEach((diag) => {\n                addError(diag.message, node);\n            });\n            parseResults.parseTree.parent = node;\n            return parseResults.parseTree;\n        }\n        return undefined;\n    }\n    return {\n        runWithCancellationToken,\n        getType,\n        getTypeOfClass,\n        getTypeOfFunction,\n        evaluateTypesForStatement,\n        getDeclaredTypeForExpression,\n        verifyDeleteExpression,\n        isAfterNodeReachable,\n        isNodeReachable,\n        suppressDiagnostics,\n        getDeclarationsForNameNode,\n        getTypeForDeclaration,\n        resolveAliasDeclaration,\n        getTypeFromIterable,\n        getTypedDictMembersForClass,\n        getEffectiveTypeOfSymbol,\n        getFunctionDeclaredReturnType,\n        getFunctionInferredReturnType,\n        getBuiltInType,\n        getTypeOfMember,\n        bindFunctionToClassOrObject,\n        getBoundMethod,\n        getCallSignatureInfo,\n        canAssignType,\n        canOverrideMethod,\n        addError,\n        addWarning,\n        addInformation,\n        addUnusedCode,\n        addDiagnostic,\n        addDiagnosticForTextRange,\n        printType,\n        printFunctionParts,\n        getTypeCacheSize,\n    };\n}\nexports.createTypeEvaluator = createTypeEvaluator;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/typeEvaluator.ts?");

/***/ }),

/***/ "./src/analyzer/typeStubWriter.ts":
/*!****************************************!*\
  !*** ./src/analyzer/typeStubWriter.ts ***!
  \****************************************/
/*! flagged exports */
/*! export TypeStubWriter [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * typeStubWriter.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic to emit a type stub file for a corresponding parsed\n * and analyzed python source file.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TypeStubWriter = void 0;\nconst AnalyzerNodeInfo = __webpack_require__(/*! ./analyzerNodeInfo */ \"./src/analyzer/analyzerNodeInfo.ts\");\nconst ParseTreeUtils = __webpack_require__(/*! ./parseTreeUtils */ \"./src/analyzer/parseTreeUtils.ts\");\nconst parseTreeWalker_1 = __webpack_require__(/*! ./parseTreeWalker */ \"./src/analyzer/parseTreeWalker.ts\");\nconst scopeUtils_1 = __webpack_require__(/*! ./scopeUtils */ \"./src/analyzer/scopeUtils.ts\");\nconst SymbolNameUtils = __webpack_require__(/*! ./symbolNameUtils */ \"./src/analyzer/symbolNameUtils.ts\");\nclass TrackedImport {\n    constructor(importName) {\n        this.importName = importName;\n        this.isAccessed = false;\n    }\n}\nclass TrackedImportAs extends TrackedImport {\n    constructor(importName, alias, symbol) {\n        super(importName);\n        this.alias = alias;\n        this.symbol = symbol;\n    }\n}\nclass TrackedImportFrom extends TrackedImport {\n    constructor(importName, isWildcardImport, node) {\n        super(importName);\n        this.isWildcardImport = isWildcardImport;\n        this.node = node;\n        this.symbols = [];\n    }\n    addSymbol(symbol, name, alias, isAccessed = false) {\n        if (!this.symbols.find((s) => s.name === name)) {\n            this.symbols.push({\n                symbol,\n                name,\n                alias,\n                isAccessed,\n            });\n        }\n    }\n}\nclass ImportSymbolWalker extends parseTreeWalker_1.ParseTreeWalker {\n    constructor(_accessedImportedSymbols, _treatStringsAsSymbols) {\n        super();\n        this._accessedImportedSymbols = _accessedImportedSymbols;\n        this._treatStringsAsSymbols = _treatStringsAsSymbols;\n    }\n    analyze(node) {\n        this.walk(node);\n    }\n    walk(node) {\n        if (!AnalyzerNodeInfo.isCodeUnreachable(node)) {\n            super.walk(node);\n        }\n    }\n    visitName(node) {\n        this._accessedImportedSymbols.set(node.value, true);\n        return true;\n    }\n    visitString(node) {\n        if (this._treatStringsAsSymbols) {\n            this._accessedImportedSymbols.set(node.value, true);\n        }\n        return true;\n    }\n}\nclass TypeStubWriter extends parseTreeWalker_1.ParseTreeWalker {\n    constructor(_stubPath, _sourceFile) {\n        super();\n        this._stubPath = _stubPath;\n        this._sourceFile = _sourceFile;\n        this._indentAmount = 0;\n        this._includeAllImports = false;\n        this._typeStubText = '';\n        this._lineEnd = '\\n';\n        this._tab = '    ';\n        this._classNestCount = 0;\n        this._functionNestCount = 0;\n        this._ifNestCount = 0;\n        this._emittedSuite = false;\n        this._emitDocString = true;\n        this._trackedImportAs = new Map();\n        this._trackedImportFrom = new Map();\n        this._accessedImportedSymbols = new Map();\n        // As a heuristic, we'll include all of the import statements\n        // in \"__init__.pyi\" files even if they're not locally referenced\n        // because these are often used as ways to re-export symbols.\n        if (this._stubPath.endsWith('__init__.pyi')) {\n            this._includeAllImports = true;\n        }\n    }\n    write() {\n        const parseResults = this._sourceFile.getParseResults();\n        this._lineEnd = parseResults.tokenizerOutput.predominantEndOfLineSequence;\n        this._tab = parseResults.tokenizerOutput.predominantTabSequence;\n        this.walk(parseResults.parseTree);\n        this._writeFile();\n    }\n    walk(node) {\n        if (!AnalyzerNodeInfo.isCodeUnreachable(node)) {\n            super.walk(node);\n        }\n    }\n    visitClass(node) {\n        const className = node.name.value;\n        this._emittedSuite = true;\n        this._emitDocString = true;\n        this._emitDecorators(node.decorators);\n        let line = `class ${className}`;\n        if (node.arguments.length > 0) {\n            line += `(${node.arguments\n                .map((arg) => {\n                let argString = '';\n                if (arg.name) {\n                    argString = arg.name.value + '=';\n                }\n                argString += this._printExpression(arg.valueExpression);\n                return argString;\n            })\n                .join(', ')})`;\n        }\n        line += ':';\n        this._emitLine(line);\n        this._emitSuite(() => {\n            this._classNestCount++;\n            this.walk(node.suite);\n            this._classNestCount--;\n        });\n        this._emitLine('');\n        this._emitLine('');\n        return false;\n    }\n    visitFunction(node) {\n        const functionName = node.name.value;\n        // Skip if we're already within a function or if the name is private/protected.\n        if (this._functionNestCount === 0 && !SymbolNameUtils.isPrivateOrProtectedName(functionName)) {\n            this._emittedSuite = true;\n            this._emitDocString = true;\n            this._emitDecorators(node.decorators);\n            let line = node.isAsync ? 'async ' : '';\n            line += `def ${functionName}`;\n            line += `(${node.parameters.map((param) => this._printParameter(param)).join(', ')})`;\n            let returnAnnotation;\n            if (node.returnTypeAnnotation) {\n                returnAnnotation = this._printExpression(node.returnTypeAnnotation, true);\n            }\n            else {\n                // Handle a few common cases where we always know the answer.\n                if (node.name.value === '__init__') {\n                    returnAnnotation = 'None';\n                }\n                else if (node.name.value === '__str__') {\n                    returnAnnotation = 'str';\n                }\n                else if (['__int__', '__hash__'].some((name) => name === node.name.value)) {\n                    returnAnnotation = 'int';\n                }\n                else if (['__eq__', '__ne__', '__gt__', '__lt__', '__ge__', '__le__'].some((name) => name === node.name.value)) {\n                    returnAnnotation = 'bool';\n                }\n            }\n            if (returnAnnotation) {\n                line += ' -> ' + returnAnnotation;\n            }\n            line += ':';\n            this._emitLine(line);\n            this._emitSuite(() => {\n                // Don't emit any nested functions.\n                this._functionNestCount++;\n                this.walk(node.suite);\n                this._functionNestCount--;\n            });\n            this._emitLine('');\n        }\n        return false;\n    }\n    visitWhile(node) {\n        // Don't emit a doc string after the first statement.\n        this._emitDocString = false;\n        return false;\n    }\n    visitFor(node) {\n        // Don't emit a doc string after the first statement.\n        this._emitDocString = false;\n        return false;\n    }\n    visitTry(node) {\n        // Don't emit a doc string after the first statement.\n        this._emitDocString = false;\n        return false;\n    }\n    visitWith(node) {\n        // Don't emit a doc string after the first statement.\n        this._emitDocString = false;\n        return false;\n    }\n    visitIf(node) {\n        // Don't emit a doc string after the first statement.\n        this._emitDocString = false;\n        // Include if statements if they are located\n        // at the global scope.\n        if (this._functionNestCount === 0 && this._ifNestCount === 0) {\n            this._ifNestCount++;\n            this._emittedSuite = true;\n            this._emitLine('if ' + this._printExpression(node.testExpression) + ':');\n            this._emitSuite(() => {\n                this.walkMultiple(node.ifSuite.statements);\n            });\n            const elseSuite = node.elseSuite;\n            if (elseSuite) {\n                this._emitLine('else:');\n                this._emitSuite(() => {\n                    if (elseSuite.nodeType === 19 /* If */) {\n                        this.walkMultiple([elseSuite.testExpression, elseSuite.ifSuite, elseSuite.elseSuite]);\n                    }\n                    else {\n                        this.walkMultiple(elseSuite.statements);\n                    }\n                });\n            }\n            this._ifNestCount--;\n        }\n        return false;\n    }\n    visitAssignment(node) {\n        let line = '';\n        if (node.leftExpression.nodeType === 39 /* Name */) {\n            // Handle \"__all__\" assignments specially.\n            if (node.leftExpression.value === '__all__') {\n                this._emitLine(this._printExpression(node, false, true));\n                return false;\n            }\n            if (this._functionNestCount === 0) {\n                line = this._printExpression(node.leftExpression);\n            }\n        }\n        else if (node.leftExpression.nodeType === 36 /* MemberAccess */) {\n            const baseExpression = node.leftExpression.leftExpression;\n            if (baseExpression.nodeType === 39 /* Name */) {\n                if (baseExpression.value === 'self') {\n                    const memberName = node.leftExpression.memberName.value;\n                    if (!SymbolNameUtils.isPrivateOrProtectedName(memberName)) {\n                        line = this._printExpression(node.leftExpression);\n                    }\n                }\n            }\n        }\n        if (line) {\n            const emitValue = this._functionNestCount === 0 && this._classNestCount === 0;\n            this._emittedSuite = true;\n            // Add the inferred type if it's known.\n            // TODO - need to implement\n            // line += ': ' + type.asString();\n            line += ' = ';\n            if (emitValue) {\n                line += this._printExpression(node.rightExpression);\n            }\n            else {\n                line += '...';\n            }\n            this._emitLine(line);\n        }\n        return false;\n    }\n    visitAugmentedAssignment(node) {\n        if (this._classNestCount === 0 && this._functionNestCount === 0) {\n            if (node.leftExpression.nodeType === 39 /* Name */) {\n                if (node.leftExpression.value === '__all__') {\n                    this._emitLine(this._printExpression(node, false, true));\n                }\n            }\n        }\n        return false;\n    }\n    visitTypeAnnotation(node) {\n        if (this._functionNestCount === 0) {\n            let line = '';\n            if (node.valueExpression.nodeType === 39 /* Name */) {\n                line = this._printExpression(node.valueExpression);\n            }\n            else if (node.valueExpression.nodeType === 36 /* MemberAccess */) {\n                const baseExpression = node.valueExpression.leftExpression;\n                if (baseExpression.nodeType === 39 /* Name */) {\n                    if (baseExpression.value === 'self') {\n                        const memberName = node.valueExpression.memberName.value;\n                        if (!SymbolNameUtils.isPrivateOrProtectedName(memberName)) {\n                            line = this._printExpression(node.valueExpression);\n                        }\n                    }\n                }\n            }\n            if (line) {\n                line += ': ' + this._printExpression(node.typeAnnotation, true);\n                this._emitLine(line);\n            }\n        }\n        return false;\n    }\n    visitImport(node) {\n        if (this._functionNestCount > 0 || this._classNestCount > 0) {\n            return false;\n        }\n        const currentScope = scopeUtils_1.getScopeForNode(node);\n        if (currentScope) {\n            // Record the input for later.\n            node.list.forEach((imp) => {\n                const moduleName = this._printModuleName(imp.module);\n                if (!this._trackedImportAs.has(moduleName)) {\n                    const symbolName = imp.alias\n                        ? imp.alias.value\n                        : imp.module.nameParts.length > 0\n                            ? imp.module.nameParts[0].value\n                            : '';\n                    const symbolInfo = currentScope.lookUpSymbolRecursive(symbolName);\n                    if (symbolInfo) {\n                        const trackedImportAs = new TrackedImportAs(moduleName, imp.alias ? imp.alias.value : undefined, symbolInfo.symbol);\n                        this._trackedImportAs.set(moduleName, trackedImportAs);\n                    }\n                }\n            });\n        }\n        return false;\n    }\n    visitImportFrom(node) {\n        if (this._functionNestCount > 0 || this._classNestCount > 0) {\n            return false;\n        }\n        const currentScope = scopeUtils_1.getScopeForNode(node);\n        if (currentScope) {\n            // Record the input for later.\n            const moduleName = this._printModuleName(node.module);\n            let trackedImportFrom = this._trackedImportFrom.get(moduleName);\n            if (!trackedImportFrom) {\n                trackedImportFrom = new TrackedImportFrom(moduleName, node.isWildcardImport, node);\n                this._trackedImportFrom.set(moduleName, trackedImportFrom);\n            }\n            node.imports.forEach((imp) => {\n                const symbolName = imp.alias ? imp.alias.value : imp.name.value;\n                const symbolInfo = currentScope.lookUpSymbolRecursive(symbolName);\n                if (symbolInfo) {\n                    trackedImportFrom.addSymbol(symbolInfo.symbol, imp.name.value, imp.alias ? imp.alias.value : undefined, false);\n                }\n            });\n        }\n        return false;\n    }\n    visitStatementList(node) {\n        if (node.statements.length > 0 && node.statements[0].nodeType === 49 /* StringList */) {\n            // Is this the first statement in a suite? If it's a string\n            // literal, assume it's a doc string and emit it.\n            if (!this._emittedSuite && this._emitDocString) {\n                this._emitLine(this._printExpression(node.statements[0]));\n            }\n        }\n        // Don't emit a doc string after the first statement.\n        this._emitDocString = false;\n        this.walkMultiple(node.statements);\n        return false;\n    }\n    _emitSuite(callback) {\n        this._increaseIndent(() => {\n            const prevEmittedSuite = this._emittedSuite;\n            this._emittedSuite = false;\n            callback();\n            if (!this._emittedSuite) {\n                this._emitLine('...');\n            }\n            this._emittedSuite = prevEmittedSuite;\n        });\n    }\n    _increaseIndent(callback) {\n        this._indentAmount++;\n        callback();\n        this._indentAmount--;\n    }\n    _emitDecorators(decorators) {\n        decorators.forEach((decorator) => {\n            let line = '@' + this._printExpression(decorator.leftExpression);\n            if (decorator.arguments) {\n                line += `(${decorator.arguments.map((arg) => this._printArgument(arg)).join(', ')})`;\n            }\n            this._emitLine(line);\n        });\n    }\n    _printHeaderDocString() {\n        return ('\"\"\"' +\n            this._lineEnd +\n            'This type stub file was generated by pyright.' +\n            this._lineEnd +\n            '\"\"\"' +\n            this._lineEnd +\n            this._lineEnd);\n    }\n    _emitLine(line) {\n        for (let i = 0; i < this._indentAmount; i++) {\n            this._typeStubText += this._tab;\n        }\n        this._typeStubText += line + this._lineEnd;\n    }\n    _printModuleName(node) {\n        let line = '';\n        for (let i = 0; i < node.leadingDots; i++) {\n            line += '.';\n        }\n        line += node.nameParts.map((part) => part.value).join('.');\n        return line;\n    }\n    _printParameter(node) {\n        let line = '';\n        if (node.category === 1 /* VarArgList */) {\n            line += '*';\n        }\n        else if (node.category === 2 /* VarArgDictionary */) {\n            line += '**';\n        }\n        if (node.name) {\n            line += node.name.value;\n        }\n        let paramType = '';\n        if (node.typeAnnotation) {\n            paramType = this._printExpression(node.typeAnnotation, true);\n        }\n        if (paramType) {\n            line += ': ' + paramType;\n        }\n        if (node.defaultValue) {\n            // Follow PEP8 spacing rules. Include spaces if type\n            // annotation is present, no space otherwise.\n            if (paramType) {\n                line += ' = ...';\n            }\n            else {\n                line += '=...';\n            }\n        }\n        return line;\n    }\n    _printArgument(node) {\n        let line = '';\n        if (node.argumentCategory === 1 /* UnpackedList */) {\n            line += '*';\n        }\n        else if (node.argumentCategory === 2 /* UnpackedDictionary */) {\n            line += '**';\n        }\n        if (node.name) {\n            line += node.name.value + '=';\n        }\n        return line + this._printExpression(node.valueExpression);\n    }\n    _printExpression(node, isType = false, treatStringsAsSymbols = false) {\n        const importSymbolWalker = new ImportSymbolWalker(this._accessedImportedSymbols, treatStringsAsSymbols);\n        importSymbolWalker.analyze(node);\n        return ParseTreeUtils.printExpression(node, isType ? 1 /* ForwardDeclarations */ : 0 /* None */);\n    }\n    _printTrackedImports() {\n        let importStr = '';\n        let lineEmitted = false;\n        // Emit the \"import\" statements.\n        this._trackedImportAs.forEach((imp) => {\n            if (this._accessedImportedSymbols.get(imp.alias || imp.importName)) {\n                imp.isAccessed = true;\n            }\n            if (imp.isAccessed || this._includeAllImports) {\n                importStr += `import ${imp.importName}`;\n                if (imp.alias) {\n                    importStr += ` as ${imp.alias}`;\n                }\n                importStr += this._lineEnd;\n                lineEmitted = true;\n            }\n        });\n        // Emit the \"import from\" statements.\n        this._trackedImportFrom.forEach((imp) => {\n            imp.symbols.forEach((s) => {\n                if (this._accessedImportedSymbols.get(s.alias || s.name)) {\n                    s.isAccessed = true;\n                }\n            });\n            if (imp.isWildcardImport) {\n                importStr += `from ${imp.importName} import *` + this._lineEnd;\n                lineEmitted = true;\n            }\n            const sortedSymbols = imp.symbols\n                .filter((s) => s.isAccessed || this._includeAllImports)\n                .sort((a, b) => {\n                if (a.name < b.name) {\n                    return -1;\n                }\n                else if (a.name > b.name) {\n                    return 1;\n                }\n                return 0;\n            });\n            if (sortedSymbols.length > 0) {\n                importStr += `from ${imp.importName} import `;\n                importStr += sortedSymbols\n                    .map((symbol) => {\n                    let symStr = symbol.name;\n                    if (symbol.alias) {\n                        symStr += ' as ' + symbol.alias;\n                    }\n                    return symStr;\n                })\n                    .join(', ');\n                importStr += this._lineEnd;\n                lineEmitted = true;\n            }\n        });\n        if (lineEmitted) {\n            importStr += this._lineEnd;\n        }\n        return importStr;\n    }\n    _writeFile() {\n        let finalText = this._printHeaderDocString();\n        finalText += this._printTrackedImports();\n        finalText += this._typeStubText;\n        this._sourceFile.fileSystem.writeFileSync(this._stubPath, finalText, 'utf8');\n    }\n}\nexports.TypeStubWriter = TypeStubWriter;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/typeStubWriter.ts?");

/***/ }),

/***/ "./src/analyzer/typeUtils.ts":
/*!***********************************!*\
  !*** ./src/analyzer/typeUtils.ts ***!
  \***********************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export addTypeVarsToListIfUnique [provided] [no usage info] [missing usage info prevents renaming] */
/*! export areTypesSame [provided] [no usage info] [missing usage info prevents renaming] */
/*! export buildTypeVarMap [provided] [no usage info] [missing usage info prevents renaming] */
/*! export buildTypeVarMapFromSpecializedClass [provided] [no usage info] [missing usage info prevents renaming] */
/*! export canBeFalsy [provided] [no usage info] [missing usage info prevents renaming] */
/*! export canBeTruthy [provided] [no usage info] [missing usage info prevents renaming] */
/*! export computeMroLinearization [provided] [no usage info] [missing usage info prevents renaming] */
/*! export convertToInstance [provided] [no usage info] [missing usage info prevents renaming] */
/*! export convertToInstantiable [provided] [no usage info] [missing usage info prevents renaming] */
/*! export derivesFromAnyOrUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*! export derivesFromClassRecursive [provided] [no usage info] [missing usage info prevents renaming] */
/*! export doForSubtypes [provided] [no usage info] [missing usage info prevents renaming] */
/*! export enumerateLiteralsForType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getConcreteTypeFromTypeVar [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getDeclaredGeneratorReturnType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getDeclaredGeneratorSendType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getDeclaredGeneratorYieldType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getMembersForClass [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getMembersForModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getMetaclass [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getSpecializedTupleType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getTypeVarArgumentsRecursive [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isEllipsisType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isNoReturnType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isOptionalType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isParamSpecType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isPartlyUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isProperty [provided] [no usage info] [missing usage info prevents renaming] */
/*! export lookUpClassMember [provided] [no usage info] [missing usage info prevents renaming] */
/*! export lookUpObjectMember [provided] [no usage info] [missing usage info prevents renaming] */
/*! export makeTypeVarsConcrete [provided] [no usage info] [missing usage info prevents renaming] */
/*! export partiallySpecializeType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export printLiteralType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export printLiteralValue [provided] [no usage info] [missing usage info prevents renaming] */
/*! export removeFalsinessFromType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export removeTruthinessFromType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export requiresSpecialization [provided] [no usage info] [missing usage info prevents renaming] */
/*! export selfSpecializeClassType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export setTypeArgumentsRecursive [provided] [no usage info] [missing usage info prevents renaming] */
/*! export specializeType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export stripFirstParameter [provided] [no usage info] [missing usage info prevents renaming] */
/*! export stripLiteralTypeArgsValue [provided] [no usage info] [missing usage info prevents renaming] */
/*! export stripLiteralValue [provided] [no usage info] [missing usage info prevents renaming] */
/*! export transformTypeObjectToClass [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * typeUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Collection of functions that operate on Type objects.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.printLiteralType = exports.printLiteralValue = exports.computeMroLinearization = exports.requiresSpecialization = exports.getConcreteTypeFromTypeVar = exports.isPartlyUnknown = exports.getMembersForModule = exports.getMembersForClass = exports.convertToInstantiable = exports.convertToInstance = exports.getDeclaredGeneratorReturnType = exports.getDeclaredGeneratorSendType = exports.getDeclaredGeneratorYieldType = exports.removeTruthinessFromType = exports.removeFalsinessFromType = exports.derivesFromClassRecursive = exports.buildTypeVarMap = exports.buildTypeVarMapFromSpecializedClass = exports.setTypeArgumentsRecursive = exports.stripFirstParameter = exports.selfSpecializeClassType = exports.getTypeVarArgumentsRecursive = exports.addTypeVarsToListIfUnique = exports.getMetaclass = exports.lookUpClassMember = exports.lookUpObjectMember = exports.specializeType = exports.makeTypeVarsConcrete = exports.partiallySpecializeType = exports.isProperty = exports.isParamSpecType = exports.isNoReturnType = exports.isEllipsisType = exports.getSpecializedTupleType = exports.canBeTruthy = exports.canBeFalsy = exports.transformTypeObjectToClass = exports.stripLiteralTypeArgsValue = exports.enumerateLiteralsForType = exports.stripLiteralValue = exports.derivesFromAnyOrUnknown = exports.areTypesSame = exports.doForSubtypes = exports.isOptionalType = void 0;\nconst symbol_1 = __webpack_require__(/*! ./symbol */ \"./src/analyzer/symbol.ts\");\nconst symbolUtils_1 = __webpack_require__(/*! ./symbolUtils */ \"./src/analyzer/symbolUtils.ts\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/analyzer/types.ts\");\nconst typeVarMap_1 = __webpack_require__(/*! ./typeVarMap */ \"./src/analyzer/typeVarMap.ts\");\nconst singleTickRegEx = /'/g;\nconst tripleTickRegEx = /'''/g;\nfunction isOptionalType(type) {\n    if (type.category === 10 /* Union */) {\n        return type.subtypes.some((t) => types_1.isNone(t));\n    }\n    return false;\n}\nexports.isOptionalType = isOptionalType;\n// Calls a callback for each subtype and combines the results\n// into a final type.\nfunction doForSubtypes(type, callback) {\n    if (type.category === 10 /* Union */) {\n        const newTypes = [];\n        type.subtypes.forEach((typeEntry) => {\n            const transformedType = callback(typeEntry);\n            if (transformedType) {\n                newTypes.push(transformedType);\n            }\n        });\n        return types_1.combineTypes(newTypes);\n    }\n    return callback(type) || types_1.NeverType.create();\n}\nexports.doForSubtypes = doForSubtypes;\n// Determines if all of the types in the array are the same.\nfunction areTypesSame(types) {\n    if (types.length < 2) {\n        return true;\n    }\n    for (let i = 1; i < types.length; i++) {\n        if (!types_1.isTypeSame(types[0], types[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.areTypesSame = areTypesSame;\nfunction derivesFromAnyOrUnknown(type) {\n    let anyOrUnknown = false;\n    doForSubtypes(type, (subtype) => {\n        if (types_1.isAnyOrUnknown(type)) {\n            anyOrUnknown = true;\n        }\n        else if (types_1.isClass(subtype)) {\n            if (types_1.ClassType.hasUnknownBaseClass(subtype)) {\n                anyOrUnknown = true;\n            }\n        }\n        else if (types_1.isObject(subtype)) {\n            if (types_1.ClassType.hasUnknownBaseClass(subtype.classType)) {\n                anyOrUnknown = true;\n            }\n        }\n        return undefined;\n    });\n    return anyOrUnknown;\n}\nexports.derivesFromAnyOrUnknown = derivesFromAnyOrUnknown;\nfunction stripLiteralValue(type) {\n    if (types_1.isObject(type)) {\n        if (type.classType.literalValue !== undefined) {\n            type = types_1.ObjectType.create(types_1.ClassType.cloneWithLiteral(type.classType, undefined));\n        }\n        return type;\n    }\n    if (types_1.isClass(type)) {\n        if (type.literalValue !== undefined) {\n            type = types_1.ClassType.cloneWithLiteral(type, undefined);\n        }\n        return type;\n    }\n    if (type.category === 10 /* Union */) {\n        return doForSubtypes(type, (subtype) => {\n            return stripLiteralValue(subtype);\n        });\n    }\n    return type;\n}\nexports.stripLiteralValue = stripLiteralValue;\nfunction enumerateLiteralsForType(type) {\n    if (types_1.ClassType.isBuiltIn(type.classType, 'bool')) {\n        // Booleans have only two types: True and False.\n        return [\n            types_1.ObjectType.create(types_1.ClassType.cloneWithLiteral(type.classType, true)),\n            types_1.ObjectType.create(types_1.ClassType.cloneWithLiteral(type.classType, false)),\n        ];\n    }\n    if (types_1.ClassType.isEnumClass(type.classType)) {\n        // Enumerate all of the values in this enumeration.\n        const enumList = [];\n        const fields = type.classType.details.fields;\n        fields.forEach((symbol, name) => {\n            if (!symbol.isIgnoredForProtocolMatch() && !symbol.isInstanceMember()) {\n                enumList.push(types_1.ObjectType.create(types_1.ClassType.cloneWithLiteral(type.classType, new types_1.EnumLiteral(type.classType.details.name, name))));\n            }\n        });\n        return enumList;\n    }\n    return undefined;\n}\nexports.enumerateLiteralsForType = enumerateLiteralsForType;\nfunction stripLiteralTypeArgsValue(type, recursionCount = 0) {\n    if (recursionCount > types_1.maxTypeRecursionCount) {\n        return type;\n    }\n    if (types_1.isClass(type)) {\n        if (type.typeArguments) {\n            const strippedTypeArgs = type.typeArguments.map((t) => stripLiteralTypeArgsValue(stripLiteralValue(t), recursionCount + 1));\n            return types_1.ClassType.cloneForSpecialization(type, strippedTypeArgs, !!type.isTypeArgumentExplicit, type.skipAbstractClassTest);\n        }\n    }\n    if (types_1.isObject(type)) {\n        if (type.classType.typeArguments) {\n            type = types_1.ObjectType.create(stripLiteralTypeArgsValue(type.classType, recursionCount + 1));\n        }\n        return type;\n    }\n    if (type.category === 10 /* Union */) {\n        return doForSubtypes(type, (subtype) => {\n            return stripLiteralTypeArgsValue(subtype, recursionCount + 1);\n        });\n    }\n    if (type.category === 5 /* Function */) {\n        if (type.specializedTypes) {\n            const strippedSpecializedTypes = {\n                parameterTypes: type.specializedTypes.parameterTypes.map((t) => stripLiteralTypeArgsValue(stripLiteralValue(t), recursionCount + 1)),\n                returnType: type.specializedTypes.returnType\n                    ? stripLiteralTypeArgsValue(stripLiteralValue(type.specializedTypes.returnType), recursionCount + 1)\n                    : undefined,\n            };\n            type = types_1.FunctionType.cloneForSpecialization(type, strippedSpecializedTypes, type.inferredReturnType);\n        }\n        return type;\n    }\n    if (type.category === 6 /* OverloadedFunction */) {\n        const strippedOverload = types_1.OverloadedFunctionType.create();\n        strippedOverload.overloads = type.overloads.map((t) => stripLiteralTypeArgsValue(t, recursionCount + 1));\n        return strippedOverload;\n    }\n    return type;\n}\nexports.stripLiteralTypeArgsValue = stripLiteralTypeArgsValue;\n// If the type is a concrete class X described by the object Type[X],\n// returns X. Otherwise returns the original type.\nfunction transformTypeObjectToClass(type) {\n    if (!types_1.isObject(type)) {\n        return type;\n    }\n    const classType = type.classType;\n    if (!types_1.ClassType.isBuiltIn(classType, 'Type')) {\n        return type;\n    }\n    // If it's a generic Type, we can't get the class.\n    if (!classType.typeArguments || classType.typeArguments.length < 1) {\n        return type;\n    }\n    const typeArg = classType.typeArguments[0];\n    if (!types_1.isObject(typeArg)) {\n        return type;\n    }\n    return typeArg.classType;\n}\nexports.transformTypeObjectToClass = transformTypeObjectToClass;\n// None is always falsy. All other types are generally truthy\n// unless they are objects that support the __bool__ or __len__\n// methods.\nfunction canBeFalsy(type, recursionLevel = 0) {\n    if (recursionLevel > types_1.maxTypeRecursionCount) {\n        return true;\n    }\n    switch (type.category) {\n        case 0 /* Unbound */:\n        case 1 /* Unknown */:\n        case 2 /* Any */:\n        case 4 /* Never */:\n        case 3 /* None */: {\n            return true;\n        }\n        case 10 /* Union */: {\n            return type.subtypes.some((t) => canBeFalsy(t, recursionLevel + 1));\n        }\n        case 5 /* Function */:\n        case 6 /* OverloadedFunction */:\n        case 7 /* Class */:\n        case 9 /* Module */:\n        case 11 /* TypeVar */: {\n            return false;\n        }\n        case 8 /* Object */: {\n            // Handle tuples specially.\n            if (types_1.ClassType.isBuiltIn(type.classType, 'Tuple') && type.classType.typeArguments) {\n                if (type.classType.typeArguments.length === 0) {\n                    return true;\n                }\n                const lastTypeArg = type.classType.typeArguments[type.classType.typeArguments.length - 1];\n                if (isEllipsisType(lastTypeArg)) {\n                    return true;\n                }\n                return false;\n            }\n            const lenMethod = lookUpObjectMember(type, '__len__');\n            if (lenMethod) {\n                return true;\n            }\n            const boolMethod = lookUpObjectMember(type, '__bool__');\n            if (boolMethod) {\n                return true;\n            }\n            // Check for Literal[False].\n            if (types_1.ClassType.isBuiltIn(type.classType, 'bool')) {\n                if (type.classType.literalValue === false) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}\nexports.canBeFalsy = canBeFalsy;\nfunction canBeTruthy(type, recursionLevel = 0) {\n    if (recursionLevel > types_1.maxTypeRecursionCount) {\n        return true;\n    }\n    switch (type.category) {\n        case 1 /* Unknown */:\n        case 5 /* Function */:\n        case 6 /* OverloadedFunction */:\n        case 7 /* Class */:\n        case 9 /* Module */:\n        case 11 /* TypeVar */:\n        case 4 /* Never */:\n        case 2 /* Any */: {\n            return true;\n        }\n        case 10 /* Union */: {\n            return type.subtypes.some((t) => canBeTruthy(t, recursionLevel + 1));\n        }\n        case 0 /* Unbound */:\n        case 3 /* None */: {\n            return false;\n        }\n        case 8 /* Object */: {\n            // Check for Tuple[()] (an empty tuple).\n            if (types_1.ClassType.isBuiltIn(type.classType, 'Tuple')) {\n                if (type.classType.typeArguments && type.classType.typeArguments.length === 0) {\n                    return false;\n                }\n            }\n            // Check for Literal[False].\n            if (types_1.ClassType.isBuiltIn(type.classType, 'bool')) {\n                if (type.classType.literalValue === false) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\nexports.canBeTruthy = canBeTruthy;\n// Determines whether the type is a Tuple class or object.\nfunction getSpecializedTupleType(type) {\n    let classType;\n    if (types_1.isClass(type)) {\n        classType = type;\n    }\n    else if (types_1.isObject(type)) {\n        classType = type.classType;\n    }\n    if (classType && types_1.ClassType.isBuiltIn(classType, 'Tuple')) {\n        return classType;\n    }\n    return undefined;\n}\nexports.getSpecializedTupleType = getSpecializedTupleType;\nfunction isEllipsisType(type) {\n    // Ellipses are translated into both a special form of \"Any\" or\n    // a distinct class depending on the context.\n    if (type.category === 2 /* Any */ && type.isEllipsis) {\n        return true;\n    }\n    return types_1.isClass(type) && types_1.ClassType.isBuiltIn(type, 'ellipsis');\n}\nexports.isEllipsisType = isEllipsisType;\nfunction isNoReturnType(type) {\n    if (types_1.isObject(type)) {\n        const classType = type.classType;\n        if (types_1.ClassType.isBuiltIn(classType, 'NoReturn')) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.isNoReturnType = isNoReturnType;\nfunction isParamSpecType(type) {\n    if (!types_1.isTypeVar(type)) {\n        return false;\n    }\n    return type.isParamSpec;\n}\nexports.isParamSpecType = isParamSpecType;\nfunction isProperty(type) {\n    return types_1.isObject(type) && types_1.ClassType.isPropertyClass(type.classType);\n}\nexports.isProperty = isProperty;\n// Partially specializes a type within the context of a specified\n// (presumably specialized) class.\nfunction partiallySpecializeType(type, contextClassType) {\n    // If the context class is not specialized (or doesn't need specialization),\n    // then there's no need to do any more work.\n    if (types_1.ClassType.isGeneric(contextClassType)) {\n        return type;\n    }\n    // Partially specialize the type using the specialized class type vars.\n    const typeVarMap = buildTypeVarMapFromSpecializedClass(contextClassType);\n    return specializeType(type, typeVarMap, false);\n}\nexports.partiallySpecializeType = partiallySpecializeType;\n// Replaces all of the top-level TypeVars (as opposed to TypeVars\n// used as type arguments in other types) with their concrete form.\nfunction makeTypeVarsConcrete(type) {\n    return doForSubtypes(type, (subtype) => {\n        if (types_1.isTypeVar(subtype)) {\n            if (subtype.boundType) {\n                return subtype.boundType;\n            }\n            // Normally, we would use UnknownType here, but we need\n            // to use Any because unknown types will generate diagnostics\n            // in strictly-typed files that cannot be suppressed in\n            // any reasonable manner.\n            return types_1.AnyType.create();\n        }\n        return subtype;\n    });\n}\nexports.makeTypeVarsConcrete = makeTypeVarsConcrete;\n// Specializes a (potentially generic) type by substituting\n// type variables with specified types. If typeVarMap is not\n// provided or makeConcrete is true, type variables are replaced\n// with a concrete type derived from the type variable if there\n// is no corresponding definition in the typeVarMap.\nfunction specializeType(type, typeVarMap, makeConcrete = false, recursionLevel = 0) {\n    if (recursionLevel > types_1.maxTypeRecursionCount) {\n        return type;\n    }\n    // Shortcut the operation if possible.\n    if (!requiresSpecialization(type)) {\n        return type;\n    }\n    // Shortcut if there are no type variables defined.\n    if (typeVarMap && !makeConcrete && typeVarMap.typeVarCount() === 0) {\n        return type;\n    }\n    if (types_1.isAnyOrUnknown(type)) {\n        return type;\n    }\n    if (types_1.isNone(type)) {\n        return type;\n    }\n    if (types_1.isTypeVar(type)) {\n        if (typeVarMap) {\n            const replacementType = typeVarMap.getTypeVar(type.name);\n            if (replacementType) {\n                // If we're replacing a TypeVar with another type and the\n                // original is not an instance, convert the replacement so it's also\n                // not an instance. This happens in the case where a type alias refers\n                // to a union that includes a TypeVar.\n                if (types_1.TypeBase.isInstantiable(type) && !types_1.TypeBase.isInstantiable(replacementType)) {\n                    return convertToInstantiable(replacementType);\n                }\n                return replacementType;\n            }\n        }\n        else {\n            if (type.boundType) {\n                return specializeType(type.boundType, undefined, /* makeConcrete */ false, recursionLevel + 1);\n            }\n            return makeConcrete ? types_1.UnknownType.create() : type;\n        }\n        return type;\n    }\n    if (type.category === 10 /* Union */) {\n        const subtypes = [];\n        type.subtypes.forEach((typeEntry) => {\n            subtypes.push(specializeType(typeEntry, typeVarMap, makeConcrete, recursionLevel + 1));\n        });\n        return types_1.combineTypes(subtypes);\n    }\n    if (types_1.isObject(type)) {\n        const classType = _specializeClassType(type.classType, typeVarMap, makeConcrete, recursionLevel + 1);\n        // Handle the \"Type\" special class.\n        if (types_1.ClassType.isBuiltIn(classType, 'Type')) {\n            const typeArgs = classType.typeArguments;\n            if (typeArgs && typeArgs.length >= 1) {\n                const firstTypeArg = typeArgs[0];\n                if (types_1.isObject(firstTypeArg)) {\n                    return specializeType(firstTypeArg.classType, typeVarMap, makeConcrete, recursionLevel + 1);\n                }\n                else if (types_1.isTypeVar(firstTypeArg)) {\n                    if (typeVarMap) {\n                        const replacementType = typeVarMap.getTypeVar(firstTypeArg.name);\n                        if (replacementType && types_1.isObject(replacementType)) {\n                            return replacementType.classType;\n                        }\n                    }\n                }\n            }\n        }\n        // Don't allocate a new ObjectType class if the class\n        // didn't need to be specialized.\n        if (classType === type.classType) {\n            return type;\n        }\n        return types_1.ObjectType.create(classType);\n    }\n    if (types_1.isClass(type)) {\n        return _specializeClassType(type, typeVarMap, makeConcrete, recursionLevel + 1);\n    }\n    if (type.category === 5 /* Function */) {\n        return _specializeFunctionType(type, typeVarMap, makeConcrete, recursionLevel + 1);\n    }\n    if (type.category === 6 /* OverloadedFunction */) {\n        return _specializeOverloadedFunctionType(type, typeVarMap, makeConcrete, recursionLevel + 1);\n    }\n    return type;\n}\nexports.specializeType = specializeType;\nfunction lookUpObjectMember(objectType, memberName, flags = 0 /* Default */) {\n    if (types_1.isObject(objectType)) {\n        return lookUpClassMember(objectType.classType, memberName, flags | 16 /* SkipIfInaccessibleToInstance */);\n    }\n    return undefined;\n}\nexports.lookUpObjectMember = lookUpObjectMember;\n// Looks up a member in a class using the multiple-inheritance rules\n// defined by Python. For more details, see this note on method resolution\n// order: https://www.python.org/download/releases/2.3/mro/.\n// As it traverses the inheritance tree, it applies partial specialization\n// to the the base class and member. For example, if ClassA inherits from\n// ClassB[str] which inherits from Dict[_T1, int], a search for '__iter__'\n// would return a class type of Dict[str, int] and a symbolType of\n// (self) -> Iterator[str].\nfunction lookUpClassMember(classType, memberName, flags = 0 /* Default */) {\n    const declaredTypesOnly = (flags & 32 /* DeclaredTypesOnly */) !== 0;\n    if (types_1.isClass(classType)) {\n        let foundUnknownBaseClass = false;\n        for (const mroClass of classType.details.mro) {\n            if (!types_1.isClass(mroClass)) {\n                foundUnknownBaseClass = true;\n                continue;\n            }\n            // If mroClass is an ancestor of classType, partially specialize\n            // it in the context of classType.\n            const specializedMroClass = partiallySpecializeType(mroClass, classType);\n            if (!types_1.isClass(specializedMroClass)) {\n                continue;\n            }\n            // Should we ignore members on the 'object' base class?\n            if (flags & 4 /* SkipObjectBaseClass */) {\n                if (types_1.ClassType.isBuiltIn(specializedMroClass, 'object')) {\n                    continue;\n                }\n            }\n            if ((flags & 1 /* SkipOriginalClass */) === 0 ||\n                specializedMroClass.details !== classType.details) {\n                const memberFields = specializedMroClass.details.fields;\n                // Look at instance members first if requested.\n                if ((flags & 8 /* SkipInstanceVariables */) === 0) {\n                    const symbol = memberFields.get(memberName);\n                    if (symbol && symbol.isInstanceMember()) {\n                        if (!declaredTypesOnly || symbol.hasTypedDeclarations()) {\n                            return {\n                                symbol,\n                                isInstanceMember: true,\n                                classType: specializedMroClass,\n                            };\n                        }\n                    }\n                }\n                // Next look at class members.\n                const symbol = memberFields.get(memberName);\n                if (symbol && symbol.isClassMember()) {\n                    if ((flags & 16 /* SkipIfInaccessibleToInstance */) === 0 ||\n                        !symbol.isInaccessibleToInstance()) {\n                        if (!declaredTypesOnly || symbol.hasTypedDeclarations()) {\n                            let isInstanceMember = false;\n                            // For data classes and typed dicts, variables that are declared\n                            // within the class are treated as instance variables. This distinction\n                            // is important in cases where a variable is a callable type because\n                            // we don't want to bind it to the instance like we would for a\n                            // class member.\n                            if (types_1.ClassType.isDataClass(specializedMroClass) ||\n                                types_1.ClassType.isTypedDictClass(specializedMroClass)) {\n                                const decls = symbol.getDeclarations();\n                                if (decls.length > 0 && decls[0].type === 1 /* Variable */) {\n                                    isInstanceMember = true;\n                                }\n                            }\n                            return {\n                                symbol,\n                                isInstanceMember,\n                                classType: specializedMroClass,\n                            };\n                        }\n                    }\n                }\n            }\n            if ((flags & 2 /* SkipBaseClasses */) !== 0) {\n                break;\n            }\n        }\n        if (foundUnknownBaseClass && !declaredTypesOnly) {\n            // The class derives from an unknown type, so all bets are off\n            // when trying to find a member. Return an unknown symbol.\n            return {\n                symbol: symbol_1.Symbol.createWithType(0 /* None */, types_1.UnknownType.create()),\n                isInstanceMember: false,\n                classType: types_1.UnknownType.create(),\n            };\n        }\n    }\n    else if (types_1.isAnyOrUnknown(classType)) {\n        // The class derives from an unknown type, so all bets are off\n        // when trying to find a member. Return an unknown symbol.\n        return {\n            symbol: symbol_1.Symbol.createWithType(0 /* None */, types_1.UnknownType.create()),\n            isInstanceMember: false,\n            classType: types_1.UnknownType.create(),\n        };\n    }\n    return undefined;\n}\nexports.lookUpClassMember = lookUpClassMember;\nfunction getMetaclass(type, recursionCount = 0) {\n    if (recursionCount > types_1.maxTypeRecursionCount) {\n        return undefined;\n    }\n    if (type.details.metaClass) {\n        if (types_1.isClass(type.details.metaClass)) {\n            return type.details.metaClass;\n        }\n        else {\n            return types_1.UnknownType.create();\n        }\n    }\n    for (const base of type.details.baseClasses) {\n        if (types_1.isClass(base)) {\n            const metaclass = getMetaclass(base, recursionCount + 1);\n            if (metaclass) {\n                return metaclass;\n            }\n        }\n    }\n    return undefined;\n}\nexports.getMetaclass = getMetaclass;\n// Combines two lists of type var types, maintaining the combined order\n// but removing any duplicates.\nfunction addTypeVarsToListIfUnique(list1, list2) {\n    for (const type2 of list2) {\n        if (!list1.find((type1) => types_1.isTypeSame(type1, type2))) {\n            list1.push(type2);\n        }\n    }\n}\nexports.addTypeVarsToListIfUnique = addTypeVarsToListIfUnique;\n// Walks the type recursively (in a depth-first manner), finds all\n// type variables that are referenced, and returns an ordered list\n// of unique type variables. For example, if the type is\n// Union[List[Dict[_T1, _T2]], _T1, _T3], the result would be\n// [_T1, _T2, _T3].\nfunction getTypeVarArgumentsRecursive(type, recursionCount = 0) {\n    if (recursionCount > types_1.maxTypeRecursionCount) {\n        return [];\n    }\n    const getTypeVarsFromClass = (classType) => {\n        const combinedList = [];\n        if (classType.typeArguments) {\n            classType.typeArguments.forEach((typeArg) => {\n                addTypeVarsToListIfUnique(combinedList, getTypeVarArgumentsRecursive(typeArg, recursionCount + 1));\n            });\n        }\n        return combinedList;\n    };\n    if (types_1.isTypeVar(type)) {\n        return [type];\n    }\n    else if (types_1.isClass(type)) {\n        return getTypeVarsFromClass(type);\n    }\n    else if (types_1.isObject(type)) {\n        return getTypeVarsFromClass(type.classType);\n    }\n    else if (type.category === 10 /* Union */) {\n        const combinedList = [];\n        for (const subtype of type.subtypes) {\n            addTypeVarsToListIfUnique(combinedList, getTypeVarArgumentsRecursive(subtype, recursionCount + 1));\n        }\n        return combinedList;\n    }\n    else if (type.category === 5 /* Function */) {\n        const combinedList = [];\n        type.details.parameters.forEach((param) => {\n            addTypeVarsToListIfUnique(combinedList, getTypeVarArgumentsRecursive(param.type, recursionCount + 1));\n        });\n        if (type.details.declaredReturnType) {\n            addTypeVarsToListIfUnique(combinedList, getTypeVarArgumentsRecursive(type.details.declaredReturnType, recursionCount + 1));\n        }\n        return combinedList;\n    }\n    return [];\n}\nexports.getTypeVarArgumentsRecursive = getTypeVarArgumentsRecursive;\n// If the class is generic, the type is cloned, and its own\n// type parameters are used as type arguments. This is useful\n// for typing \"self\" or \"cls\" within a class's implementation.\nfunction selfSpecializeClassType(type, setSkipAbstractClassTest = false) {\n    if (!types_1.ClassType.isGeneric(type) && !setSkipAbstractClassTest) {\n        return type;\n    }\n    const typeArgs = types_1.ClassType.getTypeParameters(type);\n    return types_1.ClassType.cloneForSpecialization(type, typeArgs, \n    /* isTypeArgumentExplicit */ false, setSkipAbstractClassTest);\n}\nexports.selfSpecializeClassType = selfSpecializeClassType;\n// Removes the first parameter of the function and returns a new function.\nfunction stripFirstParameter(type) {\n    if (type.details.parameters.length > 0 && type.details.parameters[0].category === 0 /* Simple */) {\n        return types_1.FunctionType.clone(type, true);\n    }\n    return type;\n}\nexports.stripFirstParameter = stripFirstParameter;\n// Recursively finds all of the type arguments and sets them\n// to the specified srcType.\nfunction setTypeArgumentsRecursive(destType, srcType, typeVarMap, recursionCount = 0) {\n    if (recursionCount > types_1.maxTypeRecursionCount) {\n        return;\n    }\n    if (typeVarMap.isLocked()) {\n        return;\n    }\n    switch (destType.category) {\n        case 10 /* Union */:\n            destType.subtypes.forEach((subtype) => {\n                setTypeArgumentsRecursive(subtype, srcType, typeVarMap, recursionCount + 1);\n            });\n            break;\n        case 7 /* Class */:\n            if (destType.typeArguments) {\n                destType.typeArguments.forEach((typeArg) => {\n                    setTypeArgumentsRecursive(typeArg, srcType, typeVarMap, recursionCount + 1);\n                });\n            }\n            break;\n        case 8 /* Object */:\n            setTypeArgumentsRecursive(destType.classType, srcType, typeVarMap, recursionCount + 1);\n            break;\n        case 5 /* Function */:\n            if (destType.specializedTypes) {\n                destType.specializedTypes.parameterTypes.forEach((paramType) => {\n                    setTypeArgumentsRecursive(paramType, srcType, typeVarMap, recursionCount + 1);\n                });\n                if (destType.specializedTypes.returnType) {\n                    setTypeArgumentsRecursive(destType.specializedTypes.returnType, srcType, typeVarMap, recursionCount + 1);\n                }\n            }\n            else {\n                destType.details.parameters.forEach((param) => {\n                    setTypeArgumentsRecursive(param.type, srcType, typeVarMap, recursionCount + 1);\n                });\n                if (destType.details.declaredReturnType) {\n                    setTypeArgumentsRecursive(destType.details.declaredReturnType, srcType, typeVarMap, recursionCount + 1);\n                }\n            }\n            break;\n        case 6 /* OverloadedFunction */:\n            destType.overloads.forEach((subtype) => {\n                setTypeArgumentsRecursive(subtype, srcType, typeVarMap, recursionCount + 1);\n            });\n            break;\n        case 11 /* TypeVar */:\n            if (!typeVarMap.hasTypeVar(destType.name)) {\n                typeVarMap.setTypeVar(destType.name, srcType, typeVarMap.isNarrowable(destType.name));\n            }\n            break;\n    }\n}\nexports.setTypeArgumentsRecursive = setTypeArgumentsRecursive;\n// Builds a mapping between type parameters and their specialized\n// types. For example, if the generic type is Dict[_T1, _T2] and the\n// specialized type is Dict[str, int], it returns a map that associates\n// _T1 with str and _T2 with int.\nfunction buildTypeVarMapFromSpecializedClass(classType, makeConcrete = true) {\n    const typeParameters = types_1.ClassType.getTypeParameters(classType);\n    let typeArguments = classType.typeArguments;\n    // If there are no type arguments, we can either use the type variables\n    // from the type parameters (keeping the type arguments generic) or\n    // fill in concrete types.\n    if (!typeArguments && !makeConcrete) {\n        typeArguments = typeParameters;\n    }\n    // Handle the special case where the source is a Tuple with heterogenous\n    // type arguments. In this case, we'll create a union out of the heterogeneous\n    // types.\n    if (types_1.ClassType.isBuiltIn(classType, 'Tuple') && classType.typeArguments) {\n        if (classType.typeArguments.length > 1) {\n            const lastTypeArg = classType.typeArguments[classType.typeArguments.length - 1];\n            if (!isEllipsisType(lastTypeArg)) {\n                typeArguments = [types_1.combineTypes(classType.typeArguments)];\n            }\n        }\n    }\n    return buildTypeVarMap(typeParameters, typeArguments);\n}\nexports.buildTypeVarMapFromSpecializedClass = buildTypeVarMapFromSpecializedClass;\nfunction buildTypeVarMap(typeParameters, typeArgs) {\n    const typeVarMap = new typeVarMap_1.TypeVarMap();\n    typeParameters.forEach((typeParam, index) => {\n        const typeVarName = typeParam.name;\n        let typeArgType;\n        if (typeArgs) {\n            if (index >= typeArgs.length) {\n                typeArgType = types_1.AnyType.create();\n            }\n            else {\n                typeArgType = typeArgs[index];\n            }\n        }\n        else {\n            typeArgType = getConcreteTypeFromTypeVar(typeParam);\n        }\n        typeVarMap.setTypeVar(typeVarName, typeArgType, false);\n    });\n    return typeVarMap;\n}\nexports.buildTypeVarMap = buildTypeVarMap;\n// If ignoreUnknown is true, an unknown base class is ignored when\n// checking for derivation. If ignoreUnknown is false, a return value\n// of true is assumed.\nfunction derivesFromClassRecursive(classType, baseClassToFind, ignoreUnknown) {\n    if (types_1.ClassType.isSameGenericClass(classType, baseClassToFind)) {\n        return true;\n    }\n    for (const baseClass of classType.details.baseClasses) {\n        if (types_1.isClass(baseClass)) {\n            if (derivesFromClassRecursive(baseClass, baseClassToFind, ignoreUnknown)) {\n                return true;\n            }\n        }\n        else if (!ignoreUnknown && types_1.isAnyOrUnknown(baseClass)) {\n            // If the base class is unknown, we have to make a conservative assumption.\n            return true;\n        }\n    }\n    return false;\n}\nexports.derivesFromClassRecursive = derivesFromClassRecursive;\n// Filters a type such that that no part of it is definitely\n// falsy. For example, if a type is a union of None\n// and an \"int\", this method would strip off the \"None\"\n// and return only the \"int\".\nfunction removeFalsinessFromType(type) {\n    return doForSubtypes(type, (subtype) => {\n        if (types_1.isObject(subtype)) {\n            if (subtype.classType.literalValue !== undefined) {\n                // If the object is already definitely truthy, it's fine to\n                // include, otherwise it should be removed.\n                return subtype.classType.literalValue ? subtype : undefined;\n            }\n            // If the object is a bool, make it \"true\", since\n            // \"false\" is a falsy value.\n            if (types_1.ClassType.isBuiltIn(subtype.classType, 'bool')) {\n                return types_1.ObjectType.create(types_1.ClassType.cloneWithLiteral(subtype.classType, true));\n            }\n        }\n        // If it's possible for the type to be truthy, include it.\n        if (canBeTruthy(subtype)) {\n            return subtype;\n        }\n        return undefined;\n    });\n}\nexports.removeFalsinessFromType = removeFalsinessFromType;\n// Filters a type such that that no part of it is definitely\n// truthy. For example, if a type is a union of None\n// and a custom class \"Foo\" that has no __len__ or __nonzero__\n// method, this method would strip off the \"Foo\"\n// and return only the \"None\".\nfunction removeTruthinessFromType(type) {\n    return doForSubtypes(type, (subtype) => {\n        if (types_1.isObject(subtype)) {\n            if (subtype.classType.literalValue !== undefined) {\n                // If the object is already definitely falsy, it's fine to\n                // include, otherwise it should be removed.\n                return !subtype.classType.literalValue ? subtype : undefined;\n            }\n            // If the object is a bool, make it \"false\", since\n            // \"true\" is a truthy value.\n            if (types_1.ClassType.isBuiltIn(subtype.classType, 'bool')) {\n                return types_1.ObjectType.create(types_1.ClassType.cloneWithLiteral(subtype.classType, false));\n            }\n        }\n        // If it's possible for the type to be falsy, include it.\n        if (canBeFalsy(subtype)) {\n            return subtype;\n        }\n        return undefined;\n    });\n}\nexports.removeTruthinessFromType = removeTruthinessFromType;\n// Returns the declared yield type if provided, or undefined otherwise.\nfunction getDeclaredGeneratorYieldType(functionType, iteratorType) {\n    const returnType = types_1.FunctionType.getSpecializedReturnType(functionType);\n    if (returnType) {\n        const generatorTypeArgs = _getGeneratorReturnTypeArgs(returnType);\n        if (generatorTypeArgs && generatorTypeArgs.length >= 1 && types_1.isClass(iteratorType)) {\n            // The yield type is the first type arg. Wrap it in an iterator.\n            return types_1.ObjectType.create(types_1.ClassType.cloneForSpecialization(iteratorType, [generatorTypeArgs[0]], \n            /* isTypeArgumentExplicit */ false));\n        }\n        // If the return type isn't a Generator, assume that it's the\n        // full return type.\n        return returnType;\n    }\n    return undefined;\n}\nexports.getDeclaredGeneratorYieldType = getDeclaredGeneratorYieldType;\n// Returns the declared \"send\" type (the type returned from the yield\n// statement) if it was declared, or undefined otherwise.\nfunction getDeclaredGeneratorSendType(functionType) {\n    const returnType = types_1.FunctionType.getSpecializedReturnType(functionType);\n    if (returnType) {\n        const generatorTypeArgs = _getGeneratorReturnTypeArgs(returnType);\n        if (generatorTypeArgs && generatorTypeArgs.length >= 2) {\n            // The send type is the second type arg.\n            return generatorTypeArgs[1];\n        }\n        return types_1.UnknownType.create();\n    }\n    return undefined;\n}\nexports.getDeclaredGeneratorSendType = getDeclaredGeneratorSendType;\n// Returns the declared \"return\" type (the type returned from a return statement)\n// if it was declared, or undefined otherwise.\nfunction getDeclaredGeneratorReturnType(functionType) {\n    const returnType = types_1.FunctionType.getSpecializedReturnType(functionType);\n    if (returnType) {\n        const generatorTypeArgs = _getGeneratorReturnTypeArgs(returnType);\n        if (generatorTypeArgs && generatorTypeArgs.length >= 3) {\n            // The send type is the third type arg.\n            return generatorTypeArgs[2];\n        }\n        return types_1.UnknownType.create();\n    }\n    return undefined;\n}\nexports.getDeclaredGeneratorReturnType = getDeclaredGeneratorReturnType;\nfunction convertToInstance(type) {\n    let result = doForSubtypes(type, (subtype) => {\n        subtype = transformTypeObjectToClass(subtype);\n        switch (subtype.category) {\n            case 7 /* Class */: {\n                return types_1.ObjectType.create(subtype);\n            }\n            case 3 /* None */: {\n                return types_1.NoneType.createInstance();\n            }\n            case 5 /* Function */: {\n                if (types_1.TypeBase.isInstantiable(subtype)) {\n                    return types_1.FunctionType.cloneAsInstance(subtype);\n                }\n                break;\n            }\n            case 11 /* TypeVar */: {\n                if (types_1.TypeBase.isInstantiable(subtype)) {\n                    return types_1.TypeVarType.cloneAsInstance(subtype);\n                }\n                break;\n            }\n        }\n        return subtype;\n    });\n    // Copy over any type alias information.\n    if (type.typeAliasInfo && type !== result) {\n        result = types_1.TypeBase.cloneForTypeAlias(result, type.typeAliasInfo.aliasName, type.typeAliasInfo.typeParameters, type.typeAliasInfo.typeArguments);\n    }\n    return result;\n}\nexports.convertToInstance = convertToInstance;\nfunction convertToInstantiable(type) {\n    let result = doForSubtypes(type, (subtype) => {\n        switch (subtype.category) {\n            case 8 /* Object */: {\n                return subtype.classType;\n            }\n            case 3 /* None */: {\n                return types_1.NoneType.createType();\n            }\n            case 5 /* Function */: {\n                if (types_1.TypeBase.isInstance(subtype)) {\n                    return types_1.FunctionType.cloneAsInstantiable(subtype);\n                }\n                break;\n            }\n            case 11 /* TypeVar */: {\n                if (types_1.TypeBase.isInstance(subtype)) {\n                    return types_1.TypeVarType.cloneAsInstantiable(subtype);\n                }\n                break;\n            }\n        }\n        return subtype;\n    });\n    // Copy over any type alias information.\n    if (type.typeAliasInfo && type !== result) {\n        result = types_1.TypeBase.cloneForTypeAlias(result, type.typeAliasInfo.aliasName, type.typeAliasInfo.typeParameters, type.typeAliasInfo.typeArguments);\n    }\n    return result;\n}\nexports.convertToInstantiable = convertToInstantiable;\nfunction getMembersForClass(classType, symbolTable, includeInstanceVars) {\n    for (let i = classType.details.mro.length - 1; i >= 0; i--) {\n        const mroClass = classType.details.mro[i];\n        if (types_1.isClass(mroClass)) {\n            // Add any new member variables from this class.\n            const isClassTypedDict = types_1.ClassType.isTypedDictClass(mroClass);\n            mroClass.details.fields.forEach((symbol, name) => {\n                if (symbol.isClassMember() || (includeInstanceVars && symbol.isInstanceMember())) {\n                    if (!isClassTypedDict || !symbolUtils_1.isTypedDictMemberAccessedThroughIndex(symbol)) {\n                        if (!symbolTable.get(name)) {\n                            symbolTable.set(name, symbol);\n                        }\n                    }\n                }\n            });\n        }\n    }\n    // If the class has a metaclass, add its members as well.\n    if (!includeInstanceVars) {\n        const metaclass = getMetaclass(classType);\n        if (metaclass && types_1.isClass(metaclass)) {\n            metaclass.details.fields.forEach((symbol, name) => {\n                if (!symbolTable.get(name)) {\n                    symbolTable.set(name, symbol);\n                }\n            });\n        }\n    }\n}\nexports.getMembersForClass = getMembersForClass;\nfunction getMembersForModule(moduleType, symbolTable) {\n    // Start with the loader fields. If there are any symbols of the\n    // same name defined within the module, they will overwrite the\n    // loader fields.\n    if (moduleType.loaderFields) {\n        moduleType.loaderFields.forEach((symbol, name) => {\n            symbolTable.set(name, symbol);\n        });\n    }\n    moduleType.fields.forEach((symbol, name) => {\n        symbolTable.set(name, symbol);\n    });\n}\nexports.getMembersForModule = getMembersForModule;\nfunction isPartlyUnknown(type, allowUnknownTypeArgsForClasses = false, recursionCount = 0) {\n    if (recursionCount > types_1.maxTypeRecursionCount) {\n        return false;\n    }\n    if (types_1.isUnknown(type)) {\n        return true;\n    }\n    // See if a union contains an unknown type.\n    if (type.category === 10 /* Union */) {\n        for (const subtype of type.subtypes) {\n            if (isPartlyUnknown(subtype, allowUnknownTypeArgsForClasses, recursionCount + 1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // See if an object or class has an unknown type argument.\n    if (types_1.isObject(type)) {\n        return isPartlyUnknown(type.classType, false, recursionCount + 1);\n    }\n    if (types_1.isClass(type)) {\n        if (type.typeArguments && !allowUnknownTypeArgsForClasses && !types_1.ClassType.isPseudoGenericClass(type)) {\n            for (const argType of type.typeArguments) {\n                if (isPartlyUnknown(argType, allowUnknownTypeArgsForClasses, recursionCount + 1)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    // See if a function has an unknown type.\n    if (type.category === 6 /* OverloadedFunction */) {\n        return type.overloads.some((overload) => {\n            return isPartlyUnknown(overload, false, recursionCount + 1);\n        });\n    }\n    if (type.category === 5 /* Function */) {\n        for (let i = 0; i < type.details.parameters.length; i++) {\n            // Ignore parameters such as \"*\" that have no name.\n            if (type.details.parameters[i].name) {\n                const paramType = types_1.FunctionType.getEffectiveParameterType(type, i);\n                if (isPartlyUnknown(paramType, false, recursionCount + 1)) {\n                    return true;\n                }\n            }\n        }\n        if (type.details.declaredReturnType &&\n            isPartlyUnknown(type.details.declaredReturnType, false, recursionCount + 1)) {\n            return true;\n        }\n        return false;\n    }\n    return false;\n}\nexports.isPartlyUnknown = isPartlyUnknown;\nfunction _specializeClassType(classType, typeVarMap, makeConcrete, recursionLevel) {\n    // Handle the common case where the class has no type parameters.\n    if (types_1.ClassType.getTypeParameters(classType).length === 0) {\n        return classType;\n    }\n    let newTypeArgs = [];\n    let specializationNeeded = false;\n    // If type args were previously provided, specialize them.\n    if (classType.typeArguments) {\n        newTypeArgs = classType.typeArguments.map((oldTypeArgType) => {\n            const newTypeArgType = specializeType(oldTypeArgType, typeVarMap, makeConcrete, recursionLevel + 1);\n            if (newTypeArgType !== oldTypeArgType) {\n                specializationNeeded = true;\n            }\n            return newTypeArgType;\n        });\n    }\n    else {\n        types_1.ClassType.getTypeParameters(classType).forEach((typeParam) => {\n            let typeArgType;\n            if (typeVarMap && typeVarMap.getTypeVar(typeParam.name)) {\n                // If the type var map already contains this type var, use\n                // the existing type.\n                typeArgType = typeVarMap.getTypeVar(typeParam.name);\n                specializationNeeded = true;\n            }\n            else {\n                // If the type var map wasn't provided or doesn't contain this\n                // type var, specialize the type var.\n                typeArgType = makeConcrete ? getConcreteTypeFromTypeVar(typeParam) : typeParam;\n                if (typeArgType !== typeParam) {\n                    specializationNeeded = true;\n                }\n            }\n            newTypeArgs.push(typeArgType);\n        });\n    }\n    // If specialization wasn't needed, don't allocate a new class.\n    if (!specializationNeeded) {\n        return classType;\n    }\n    return types_1.ClassType.cloneForSpecialization(classType, newTypeArgs, /* isTypeArgumentExplicit */ false);\n}\n// Converts a type var type into the most specific type\n// that fits the specified constraints.\nfunction getConcreteTypeFromTypeVar(type, recursionLevel = 0) {\n    if (type.boundType) {\n        return specializeType(type.boundType, undefined, false, recursionLevel + 1);\n    }\n    // Note that we can't use constraints for specialization because\n    // the union of constraints is not the same as individual constraints.\n    // In all other cases, treat as unknown.\n    return types_1.UnknownType.create();\n}\nexports.getConcreteTypeFromTypeVar = getConcreteTypeFromTypeVar;\nfunction _specializeOverloadedFunctionType(type, typeVarMap, makeConcrete, recursionLevel) {\n    // Specialize each of the functions in the overload.\n    const overloads = type.overloads.map((entry) => _specializeFunctionType(entry, typeVarMap, makeConcrete, recursionLevel));\n    // Construct a new overload with the specialized function types.\n    const newOverloadType = types_1.OverloadedFunctionType.create();\n    overloads.forEach((overload) => {\n        types_1.OverloadedFunctionType.addOverload(newOverloadType, overload);\n    });\n    return newOverloadType;\n}\nfunction _specializeFunctionType(sourceType, typeVarMap, makeConcrete, recursionLevel) {\n    let functionType = sourceType;\n    // Handle functions with a parameter specification in a special manner.\n    if (functionType.details.paramSpec) {\n        const paramSpec = typeVarMap === null || typeVarMap === void 0 ? void 0 : typeVarMap.getParamSpec(functionType.details.paramSpec.name);\n        functionType = types_1.FunctionType.cloneForParamSpec(functionType, paramSpec);\n    }\n    const declaredReturnType = functionType.specializedTypes && functionType.specializedTypes.returnType\n        ? functionType.specializedTypes.returnType\n        : functionType.details.declaredReturnType;\n    const specializedReturnType = declaredReturnType\n        ? specializeType(declaredReturnType, typeVarMap, makeConcrete, recursionLevel + 1)\n        : undefined;\n    let typesRequiredSpecialization = declaredReturnType !== specializedReturnType;\n    const specializedParameters = {\n        parameterTypes: [],\n        returnType: specializedReturnType,\n    };\n    for (let i = 0; i < functionType.details.parameters.length; i++) {\n        const paramType = types_1.FunctionType.getEffectiveParameterType(functionType, i);\n        const specializedType = specializeType(paramType, typeVarMap, makeConcrete, recursionLevel + 1);\n        specializedParameters.parameterTypes.push(specializedType);\n        if (paramType !== specializedType) {\n            typesRequiredSpecialization = true;\n        }\n    }\n    if (!typesRequiredSpecialization) {\n        return functionType;\n    }\n    let specializedInferredReturnType;\n    if (functionType.inferredReturnType) {\n        specializedInferredReturnType = specializeType(functionType.inferredReturnType, typeVarMap, makeConcrete, recursionLevel + 1);\n    }\n    return types_1.FunctionType.cloneForSpecialization(functionType, specializedParameters, specializedInferredReturnType);\n}\n// If the declared return type for the function is a Generator, AsyncGenerator,\n// Iterator, or AsyncIterator, returns the type arguments for the type.\nfunction _getGeneratorReturnTypeArgs(returnType) {\n    if (types_1.isObject(returnType)) {\n        const classType = returnType.classType;\n        if (types_1.ClassType.isBuiltIn(classType)) {\n            const className = classType.details.name;\n            if (className === 'Generator' || className === 'AsyncGenerator') {\n                return classType.typeArguments;\n            }\n            if (className === 'Iterator' || className === 'AsyncIterator' || className === 'AsyncIterable') {\n                return classType.typeArguments;\n            }\n        }\n    }\n    return undefined;\n}\nfunction requiresSpecialization(type, recursionCount = 0) {\n    switch (type.category) {\n        case 7 /* Class */: {\n            if (type.typeArguments) {\n                if (recursionCount > types_1.maxTypeRecursionCount) {\n                    return false;\n                }\n                return (type.typeArguments.find((typeArg) => requiresSpecialization(typeArg, recursionCount + 1)) !==\n                    undefined);\n            }\n            // If there are any type parameters, we need to specialize\n            // since there are no corresponding type arguments.\n            return types_1.ClassType.getTypeParameters(type).length > 0;\n        }\n        case 8 /* Object */: {\n            if (recursionCount > types_1.maxTypeRecursionCount) {\n                return false;\n            }\n            return requiresSpecialization(type.classType, recursionCount + 1);\n        }\n        case 5 /* Function */: {\n            if (recursionCount > types_1.maxTypeRecursionCount) {\n                return false;\n            }\n            for (let i = 0; i < type.details.parameters.length; i++) {\n                if (requiresSpecialization(types_1.FunctionType.getEffectiveParameterType(type, i), recursionCount + 1)) {\n                    return true;\n                }\n            }\n            const declaredReturnType = type.specializedTypes && type.specializedTypes.returnType\n                ? type.specializedTypes.returnType\n                : type.details.declaredReturnType;\n            if (declaredReturnType) {\n                if (requiresSpecialization(declaredReturnType, recursionCount + 1)) {\n                    return true;\n                }\n            }\n            else if (type.inferredReturnType) {\n                if (requiresSpecialization(type.inferredReturnType, recursionCount + 1)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        case 6 /* OverloadedFunction */: {\n            return (type.overloads.find((overload) => requiresSpecialization(overload, recursionCount + 1)) !== undefined);\n        }\n        case 10 /* Union */: {\n            return type.subtypes.find((type) => requiresSpecialization(type, recursionCount + 1)) !== undefined;\n        }\n        case 11 /* TypeVar */: {\n            return true;\n        }\n    }\n    return false;\n}\nexports.requiresSpecialization = requiresSpecialization;\n// Computes the method resolution ordering for a class whose base classes\n// have already been filled in. The algorithm for computing MRO is described\n// here: https://www.python.org/download/releases/2.3/mro/. It returns true\n// if an MRO was possible, false otherwise.\nfunction computeMroLinearization(classType) {\n    let isMroFound = true;\n    // Construct the list of class lists that need to be merged.\n    const classListsToMerge = [];\n    classType.details.baseClasses.forEach((baseClass) => {\n        if (types_1.isClass(baseClass)) {\n            const typeVarMap = buildTypeVarMapFromSpecializedClass(baseClass, false);\n            classListsToMerge.push(baseClass.details.mro.map((mroClass) => {\n                return specializeType(mroClass, typeVarMap);\n            }));\n        }\n        else {\n            classListsToMerge.push([baseClass]);\n        }\n    });\n    classListsToMerge.push(classType.details.baseClasses.map((baseClass) => {\n        const typeVarMap = buildTypeVarMapFromSpecializedClass(classType, false);\n        return specializeType(baseClass, typeVarMap);\n    }));\n    // The first class in the MRO is the class itself.\n    const typeVarMap = buildTypeVarMapFromSpecializedClass(classType, false);\n    classType.details.mro.push(specializeType(classType, typeVarMap));\n    // Helper function that returns true if the specified searchClass\n    // is found in the \"tail\" (i.e. in elements 1 through n) of any\n    // of the class lists.\n    const isInTail = (searchClass, classLists) => {\n        return classLists.some((classList) => {\n            return (classList.findIndex((value) => types_1.isClass(value) && types_1.ClassType.isSameGenericClass(value, searchClass, false)) > 0);\n        });\n    };\n    const filterClass = (classToFilter, classLists) => {\n        for (let i = 0; i < classLists.length; i++) {\n            classLists[i] = classLists[i].filter((value) => !types_1.isClass(value) || !types_1.ClassType.isSameGenericClass(value, classToFilter, false));\n        }\n    };\n    while (true) {\n        let foundValidHead = false;\n        let nonEmptyList = undefined;\n        for (let i = 0; i < classListsToMerge.length; i++) {\n            const classList = classListsToMerge[i];\n            if (classList.length > 0) {\n                if (nonEmptyList === undefined) {\n                    nonEmptyList = classList;\n                }\n                if (!types_1.isClass(classList[0])) {\n                    foundValidHead = true;\n                    classType.details.mro.push(classList[0]);\n                    classList.shift();\n                    break;\n                }\n                else if (!isInTail(classList[0], classListsToMerge)) {\n                    foundValidHead = true;\n                    classType.details.mro.push(classList[0]);\n                    filterClass(classList[0], classListsToMerge);\n                    break;\n                }\n            }\n        }\n        // If all lists are empty, we are done.\n        if (!nonEmptyList) {\n            break;\n        }\n        // We made it all the way through the list of class lists without\n        // finding a valid head, but there is at least one list that's not\n        // yet empty. This means there's no valid MRO order.\n        if (!foundValidHead) {\n            isMroFound = false;\n            // Handle the situation by pull the head off the first empty list.\n            // This allows us to make forward progress.\n            if (!types_1.isClass(nonEmptyList[0])) {\n                classType.details.mro.push(nonEmptyList[0]);\n                nonEmptyList.shift();\n            }\n            else {\n                classType.details.mro.push(nonEmptyList[0]);\n                filterClass(nonEmptyList[0], classListsToMerge);\n            }\n        }\n    }\n    return isMroFound;\n}\nexports.computeMroLinearization = computeMroLinearization;\nfunction printLiteralValue(type) {\n    const literalValue = type.classType.literalValue;\n    if (literalValue === undefined) {\n        return '';\n    }\n    let literalStr;\n    if (typeof literalValue === 'string') {\n        const prefix = type.classType.details.name === 'bytes' ? 'b' : '';\n        literalStr = literalValue.toString();\n        if (literalStr.indexOf('\\n') >= 0) {\n            literalStr = `${prefix}'''${literalStr.replace(tripleTickRegEx, \"\\\\'\\\\'\\\\'\")}'''`;\n        }\n        else {\n            literalStr = `${prefix}'${literalStr.replace(singleTickRegEx, \"\\\\'\")}'`;\n        }\n    }\n    else if (typeof literalValue === 'boolean') {\n        literalStr = literalValue ? 'True' : 'False';\n    }\n    else if (literalValue instanceof types_1.EnumLiteral) {\n        literalStr = `${literalValue.className}.${literalValue.itemName}`;\n    }\n    else {\n        literalStr = literalValue.toString();\n    }\n    return literalStr;\n}\nexports.printLiteralValue = printLiteralValue;\nfunction printLiteralType(type) {\n    const literalStr = printLiteralValue(type);\n    if (!literalStr) {\n        return '';\n    }\n    return `Literal[${literalStr}]`;\n}\nexports.printLiteralType = printLiteralType;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/typeUtils.ts?");

/***/ }),

/***/ "./src/analyzer/typeVarMap.ts":
/*!************************************!*\
  !*** ./src/analyzer/typeVarMap.ts ***!
  \************************************/
/*! flagged exports */
/*! export TypeVarMap [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * typeVarMap.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Module that records the relationship between named TypeVars\n * (type variables) and their types. It is used by the type\n * evaluator to \"solve\" for the type of each type variable.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TypeVarMap = void 0;\nconst debug_1 = __webpack_require__(/*! ../common/debug */ \"./src/common/debug.ts\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/analyzer/types.ts\");\nclass TypeVarMap {\n    constructor() {\n        this._isLocked = false;\n        this._typeVarMap = new Map();\n        this._paramSpecMap = new Map();\n        this._isNarrowableMap = new Map();\n    }\n    clone() {\n        const newTypeVarMap = new TypeVarMap();\n        this._typeVarMap.forEach((value, name) => {\n            newTypeVarMap.setTypeVar(name, value, this.isNarrowable(name));\n        });\n        this._paramSpecMap.forEach((value, name) => {\n            newTypeVarMap.setParamSpec(name, value);\n        });\n        newTypeVarMap._isLocked = this._isLocked;\n        return newTypeVarMap;\n    }\n    // Copies a cloned type var map back into this object.\n    copyFromClone(clone) {\n        this._typeVarMap = clone._typeVarMap;\n        this._paramSpecMap = clone._paramSpecMap;\n        this._isNarrowableMap = clone._isNarrowableMap;\n        this._isLocked = clone._isLocked;\n    }\n    // Provides a \"score\" - a value that values completeness (number\n    // of type variables that are assigned) and completeness.\n    getScore() {\n        let score = 0;\n        // Sum the scores for the defined type vars.\n        this._typeVarMap.forEach((value) => {\n            // Add 1 to the score for each type variable defined.\n            score += 1;\n            // Add a fractional amount based on the complexity of the definition.\n            // The more complex, the lower the score. In the spirit of Occam's\n            // Razor, we always want to favor simple answers.\n            score += this._getComplexityScoreForType(value);\n        });\n        // Do the same for the param spec map.\n        this._paramSpecMap.forEach((value) => {\n            score += 1;\n            score += this._getComplexityScoreForType(value);\n        });\n        return score;\n    }\n    hasTypeVar(name) {\n        return this._typeVarMap.has(name);\n    }\n    getTypeVar(name) {\n        return this._typeVarMap.get(name);\n    }\n    setTypeVar(name, type, isNarrowable) {\n        debug_1.assert(!this._isLocked);\n        this._typeVarMap.set(name, type);\n        this._isNarrowableMap.set(name, isNarrowable);\n    }\n    hasParamSpec(name) {\n        return this._paramSpecMap.has(name);\n    }\n    getParamSpec(name) {\n        return this._paramSpecMap.get(name);\n    }\n    setParamSpec(name, type) {\n        debug_1.assert(!this._isLocked);\n        this._paramSpecMap.set(name, type);\n    }\n    typeVarCount() {\n        return this._typeVarMap.size;\n    }\n    isNarrowable(name) {\n        const isNarrowable = this._isNarrowableMap.get(name);\n        // Unless told otherwise, assume type is narrowable.\n        return isNarrowable !== undefined ? isNarrowable : true;\n    }\n    lock() {\n        // Locks the type var map, preventing any further changes.\n        debug_1.assert(!this._isLocked);\n        this._isLocked = true;\n    }\n    isLocked() {\n        return this._isLocked;\n    }\n    // Returns a \"score\" for a type that captures the relative complexity\n    // of the type. Scores should all be between 0 and 1 where 0 means\n    // very complex and 1 means simple. This is a heuristic, so there's\n    // often no objectively correct answer.\n    _getComplexityScoreForType(type, recursionCount = 0) {\n        if (recursionCount > types_1.maxTypeRecursionCount) {\n            return 0;\n        }\n        switch (type.category) {\n            case 5 /* Function */:\n            case 6 /* OverloadedFunction */: {\n                // For now, return a constant for functions. We may want\n                // to make this heuristic in the future.\n                return 0.5;\n            }\n            case 10 /* Union */: {\n                let minScore = 1;\n                type.subtypes.forEach((subtype) => {\n                    const subtypeScore = this._getComplexityScoreForType(subtype, recursionCount + 1);\n                    if (subtypeScore < minScore) {\n                        minScore = subtypeScore;\n                    }\n                });\n                // Assume that a union is more complex than a non-union,\n                // and return half of the minimum score of the subtypes.\n                return minScore / 2;\n            }\n            case 7 /* Class */: {\n                // Score a class as 0.5 plus half of the average complexity\n                // score of its type arguments.\n                return this._getComplexityScoreForClass(type, recursionCount + 1);\n            }\n            case 8 /* Object */: {\n                return this._getComplexityScoreForClass(type.classType, recursionCount + 1);\n            }\n        }\n        // For all other types, return a score of 0.\n        return 0;\n    }\n    _getComplexityScoreForClass(classType, recursionCount) {\n        let typeArgScoreSum = 0;\n        let typeArgCount = 0;\n        if (classType.typeArguments) {\n            classType.typeArguments.forEach((type) => {\n                typeArgScoreSum += this._getComplexityScoreForType(type, recursionCount + 1);\n                typeArgCount++;\n            });\n        }\n        let score = 0.5;\n        if (typeArgCount > 0) {\n            score += (typeArgScoreSum / typeArgCount) * 0.5;\n        }\n        return score;\n    }\n}\nexports.TypeVarMap = TypeVarMap;\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/typeVarMap.ts?");

/***/ }),

/***/ "./src/analyzer/types.ts":
/*!*******************************!*\
  !*** ./src/analyzer/types.ts ***!
  \*******************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * types.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Representation of types used during type analysis within Python.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSameWithoutLiteralValue = exports.combineTypes = exports.isUnionableType = exports.removeFromUnion = exports.removeNoneFromUnion = exports.removeUnboundFromUnion = exports.removeUnknownFromUnion = exports.removeAnyFromUnion = exports.isTypeSame = exports.isTypeVar = exports.isModule = exports.isObject = exports.isClass = exports.isPossiblyUnbound = exports.isUnbound = exports.isAnyOrUnknown = exports.isUnknown = exports.isNone = exports.isNever = exports.TypeVarType = exports.UnionType = exports.AnyType = exports.NeverType = exports.NoneType = exports.OverloadedFunctionType = exports.FunctionType = exports.ObjectType = exports.ClassType = exports.ModuleType = exports.UnknownType = exports.UnboundType = exports.TypeBase = exports.maxTypeRecursionCount = exports.EnumLiteral = void 0;\nconst debug_1 = __webpack_require__(/*! ../common/debug */ \"./src/common/debug.ts\");\nclass EnumLiteral {\n    constructor(className, itemName) {\n        this.className = className;\n        this.itemName = itemName;\n    }\n}\nexports.EnumLiteral = EnumLiteral;\nexports.maxTypeRecursionCount = 16;\nvar TypeBase;\n(function (TypeBase) {\n    function isInstantiable(type) {\n        return (type.flags & 1 /* Instantiable */) !== 0;\n    }\n    TypeBase.isInstantiable = isInstantiable;\n    function isInstance(type) {\n        return (type.flags & 2 /* Instance */) !== 0;\n    }\n    TypeBase.isInstance = isInstance;\n    function cloneForTypeAlias(type, name, typeParams, typeArgs) {\n        const typeClone = Object.assign({}, type);\n        typeClone.typeAliasInfo = {\n            aliasName: name,\n            typeParameters: typeParams,\n            typeArguments: typeArgs,\n        };\n        return typeClone;\n    }\n    TypeBase.cloneForTypeAlias = cloneForTypeAlias;\n})(TypeBase = exports.TypeBase || (exports.TypeBase = {}));\nvar UnboundType;\n(function (UnboundType) {\n    const _instance = {\n        category: 0 /* Unbound */,\n        flags: 1 /* Instantiable */ | 2 /* Instance */,\n    };\n    function create() {\n        // All Unbound objects are the same, so use a shared instance.\n        return _instance;\n    }\n    UnboundType.create = create;\n})(UnboundType = exports.UnboundType || (exports.UnboundType = {}));\nvar UnknownType;\n(function (UnknownType) {\n    const _instance = {\n        category: 1 /* Unknown */,\n        flags: 1 /* Instantiable */ | 2 /* Instance */,\n    };\n    function create() {\n        // All Unknown objects are the same, so use a shared instance.\n        return _instance;\n    }\n    UnknownType.create = create;\n})(UnknownType = exports.UnknownType || (exports.UnknownType = {}));\nvar ModuleType;\n(function (ModuleType) {\n    function create(symbolTable) {\n        const newModuleType = {\n            category: 9 /* Module */,\n            fields: symbolTable || new Map(),\n            loaderFields: new Map(),\n            flags: 1 /* Instantiable */ | 1 /* Instantiable */,\n        };\n        return newModuleType;\n    }\n    ModuleType.create = create;\n    function getField(moduleType, name) {\n        // Always look for the symbol in the module's fields before consulting\n        // the loader fields. The loader runs before the module, so its values\n        // will be overwritten by the module.\n        let symbol = moduleType.fields.get(name);\n        if (!symbol && moduleType.loaderFields) {\n            symbol = moduleType.loaderFields.get(name);\n        }\n        return symbol;\n    }\n    ModuleType.getField = getField;\n})(ModuleType = exports.ModuleType || (exports.ModuleType = {}));\nvar ClassType;\n(function (ClassType) {\n    function create(name, flags, typeSourceId, docString) {\n        const newClass = {\n            category: 7 /* Class */,\n            details: {\n                name,\n                flags,\n                typeSourceId,\n                baseClasses: [],\n                mro: [],\n                fields: new Map(),\n                typeParameters: [],\n                docString,\n            },\n            skipAbstractClassTest: false,\n            flags: 1 /* Instantiable */,\n        };\n        return newClass;\n    }\n    ClassType.create = create;\n    function cloneForSpecialization(classType, typeArguments, isTypeArgumentExplicit, skipAbstractClassTest = false) {\n        const newClassType = create(classType.details.name, classType.details.flags, classType.details.typeSourceId);\n        newClassType.details = classType.details;\n        newClassType.typeArguments = typeArguments;\n        newClassType.isTypeArgumentExplicit = isTypeArgumentExplicit;\n        if (classType.literalValue !== undefined) {\n            newClassType.literalValue = classType.literalValue;\n        }\n        if (classType.typeAliasInfo !== undefined) {\n            newClassType.typeAliasInfo = classType.typeAliasInfo;\n        }\n        if (skipAbstractClassTest) {\n            newClassType.skipAbstractClassTest = true;\n        }\n        return newClassType;\n    }\n    ClassType.cloneForSpecialization = cloneForSpecialization;\n    function cloneWithLiteral(classType, value) {\n        const newClassType = create(classType.details.name, classType.details.flags, classType.details.typeSourceId);\n        newClassType.details = classType.details;\n        if (classType.typeArguments) {\n            newClassType.typeArguments = classType.typeArguments;\n        }\n        if (value !== undefined) {\n            newClassType.literalValue = value;\n        }\n        if (classType.typeAliasInfo !== undefined) {\n            newClassType.typeAliasInfo = classType.typeAliasInfo;\n        }\n        if (classType.skipAbstractClassTest) {\n            newClassType.skipAbstractClassTest = true;\n        }\n        return newClassType;\n    }\n    ClassType.cloneWithLiteral = cloneWithLiteral;\n    function isLiteralValueSame(type1, type2) {\n        if (type1.literalValue === undefined) {\n            return type2.literalValue === undefined;\n        }\n        else if (type2.literalValue === undefined) {\n            return false;\n        }\n        if (type1.literalValue instanceof EnumLiteral) {\n            if (type2.literalValue instanceof EnumLiteral) {\n                return type1.literalValue.itemName === type2.literalValue.itemName;\n            }\n            return false;\n        }\n        return type1.literalValue === type2.literalValue;\n    }\n    ClassType.isLiteralValueSame = isLiteralValueSame;\n    // Specifies whether the class type is generic (unspecialized)\n    // or specialized.\n    function isGeneric(classType) {\n        return classType.details.typeParameters.length > 0 && classType.typeArguments === undefined;\n    }\n    ClassType.isGeneric = isGeneric;\n    function isSpecialBuiltIn(classType, className) {\n        if (!(classType.details.flags & 2 /* SpecialBuiltIn */)) {\n            return false;\n        }\n        if (className !== undefined) {\n            return classType.details.name === className;\n        }\n        return true;\n    }\n    ClassType.isSpecialBuiltIn = isSpecialBuiltIn;\n    function isBuiltIn(classType, className) {\n        if (!(classType.details.flags & 1 /* BuiltInClass */)) {\n            return false;\n        }\n        if (className !== undefined) {\n            return classType.details.name === className;\n        }\n        return true;\n    }\n    ClassType.isBuiltIn = isBuiltIn;\n    function hasAbstractMethods(classType) {\n        return !!(classType.details.flags & 256 /* HasAbstractMethods */) && !classType.skipAbstractClassTest;\n    }\n    ClassType.hasAbstractMethods = hasAbstractMethods;\n    function supportsAbstractMethods(classType) {\n        return !!(classType.details.flags & 128 /* SupportsAbstractMethods */);\n    }\n    ClassType.supportsAbstractMethods = supportsAbstractMethods;\n    function isDataClass(classType) {\n        return !!(classType.details.flags & 4 /* DataClass */);\n    }\n    ClassType.isDataClass = isDataClass;\n    function isSkipSynthesizedInit(classType) {\n        return !!(classType.details.flags & 8 /* SkipSynthesizedInit */);\n    }\n    ClassType.isSkipSynthesizedInit = isSkipSynthesizedInit;\n    function isTypedDictClass(classType) {\n        return !!(classType.details.flags & 16 /* TypedDictClass */);\n    }\n    ClassType.isTypedDictClass = isTypedDictClass;\n    function isCanOmitDictValues(classType) {\n        return !!(classType.details.flags & 32 /* CanOmitDictValues */);\n    }\n    ClassType.isCanOmitDictValues = isCanOmitDictValues;\n    function isEnumClass(classType) {\n        return !!(classType.details.flags & 64 /* EnumClass */);\n    }\n    ClassType.isEnumClass = isEnumClass;\n    function isPropertyClass(classType) {\n        return !!(classType.details.flags & 512 /* PropertyClass */);\n    }\n    ClassType.isPropertyClass = isPropertyClass;\n    function isFinal(classType) {\n        return !!(classType.details.flags & 1024 /* Final */);\n    }\n    ClassType.isFinal = isFinal;\n    function isProtocolClass(classType) {\n        return !!(classType.details.flags & 2048 /* ProtocolClass */);\n    }\n    ClassType.isProtocolClass = isProtocolClass;\n    function isPseudoGenericClass(classType) {\n        return !!(classType.details.flags & 4096 /* PseudoGenericClass */);\n    }\n    ClassType.isPseudoGenericClass = isPseudoGenericClass;\n    function getDataClassEntries(classType) {\n        return classType.details.dataClassEntries || [];\n    }\n    ClassType.getDataClassEntries = getDataClassEntries;\n    function isRuntimeCheckable(classType) {\n        return !!(classType.details.flags & 8192 /* RuntimeCheckable */);\n    }\n    ClassType.isRuntimeCheckable = isRuntimeCheckable;\n    function isTypingExtensionClass(classType) {\n        return !!(classType.details.flags & 16384 /* TypingExtensionClass */);\n    }\n    ClassType.isTypingExtensionClass = isTypingExtensionClass;\n    function getTypeParameters(classType) {\n        // If this is a special class, use the alias class' type\n        // parameters instead.\n        if (classType.details.aliasClass) {\n            return classType.details.aliasClass.details.typeParameters;\n        }\n        return classType.details.typeParameters;\n    }\n    ClassType.getTypeParameters = getTypeParameters;\n    function hasUnknownBaseClass(classType) {\n        return classType.details.mro.some((baseClass) => isAnyOrUnknown(baseClass));\n    }\n    ClassType.hasUnknownBaseClass = hasUnknownBaseClass;\n    // Same as isSame except that it doesn't compare type arguments.\n    function isSameGenericClass(classType, type2, treatAliasAsSame = true, recursionCount = 0) {\n        if (recursionCount > exports.maxTypeRecursionCount) {\n            return true;\n        }\n        // If the class details match, it's definitely the same class.\n        if (classType.details === type2.details) {\n            return true;\n        }\n        // If either or both have aliases (e.g. List -> list), use the\n        // aliases for comparison purposes.\n        const class1Details = treatAliasAsSame && classType.details.aliasClass ? classType.details.aliasClass.details : classType.details;\n        const class2Details = treatAliasAsSame && type2.details.aliasClass ? type2.details.aliasClass.details : type2.details;\n        if (class1Details === class2Details) {\n            return true;\n        }\n        // Compare most of the details fields. We intentionally skip the isAbstractClass\n        // flag because it gets set dynamically.\n        if (class1Details.name !== class2Details.name ||\n            class1Details.flags !== class2Details.flags ||\n            class1Details.typeSourceId !== class2Details.typeSourceId ||\n            class1Details.baseClasses.length !== class2Details.baseClasses.length ||\n            class1Details.typeParameters.length !== class2Details.typeParameters.length) {\n            return false;\n        }\n        for (let i = 0; i < class1Details.baseClasses.length; i++) {\n            if (!isTypeSame(class1Details.baseClasses[i], class2Details.baseClasses[i], recursionCount + 1)) {\n                return false;\n            }\n        }\n        if (class1Details.metaClass || class2Details.metaClass) {\n            if (!class1Details.metaClass ||\n                !class2Details.metaClass ||\n                !isTypeSame(class1Details.metaClass, class2Details.metaClass)) {\n                return false;\n            }\n        }\n        for (let i = 0; i < class1Details.typeParameters.length; i++) {\n            if (!isTypeSame(class1Details.typeParameters[i], class2Details.typeParameters[i], recursionCount + 1)) {\n                return false;\n            }\n        }\n        const dataClassEntries1 = class1Details.dataClassEntries || [];\n        const dataClassEntries2 = class2Details.dataClassEntries || [];\n        if (dataClassEntries1.length !== dataClassEntries2.length) {\n            return false;\n        }\n        for (let i = 0; i < dataClassEntries1.length; i++) {\n            if (dataClassEntries1[i].name !== dataClassEntries2[i].name ||\n                dataClassEntries1[i].hasDefault !== dataClassEntries2[i].hasDefault ||\n                !isTypeSame(dataClassEntries1[i].type, dataClassEntries2[i].type, recursionCount + 1)) {\n                return false;\n            }\n        }\n        // If the two types don't have the same symbol table, they are probably\n        // using synthesized (undeclared) symbols. Make sure that they contain the\n        // same number of symbols and types.\n        if (class1Details.fields !== class2Details.fields) {\n            if (class1Details.fields.size !== class2Details.fields.size) {\n                return false;\n            }\n            let symbolsMatch = true;\n            class1Details.fields.forEach((symbol1, name) => {\n                const symbol2 = class2Details.fields.get(name);\n                if (!symbol2) {\n                    symbolsMatch = false;\n                }\n                else {\n                    const symbol1Type = symbol1.getSynthesizedType() || UnknownType.create();\n                    const symbol2Type = symbol2.getSynthesizedType() || UnknownType.create();\n                    if (!isTypeSame(symbol1Type, symbol2Type, recursionCount + 1)) {\n                        symbolsMatch = false;\n                    }\n                }\n            });\n            if (!symbolsMatch) {\n                return false;\n            }\n        }\n        return true;\n    }\n    ClassType.isSameGenericClass = isSameGenericClass;\n    // Determines whether this is a subclass (derived class)\n    // of the specified class. If the caller passes an empty\n    // array to inheritanceChain, it will be filled in by\n    // the call to include the chain of inherited classes starting\n    // with type2 and ending with this type.\n    function isDerivedFrom(subclassType, parentClassType, inheritanceChain) {\n        // Is it the exact same class?\n        if (isSameGenericClass(subclassType, parentClassType)) {\n            if (inheritanceChain) {\n                inheritanceChain.push(subclassType);\n            }\n            return true;\n        }\n        // Handle built-in types like 'dict' and 'list', which are all\n        // subclasses of object even though they are not explicitly declared\n        // that way.\n        if (isBuiltIn(subclassType) && isBuiltIn(parentClassType, 'object')) {\n            if (inheritanceChain) {\n                inheritanceChain.push(parentClassType);\n            }\n            return true;\n        }\n        const aliasedSubclass = subclassType.details.aliasClass || subclassType;\n        for (const baseClass of aliasedSubclass.details.baseClasses) {\n            if (isClass(baseClass)) {\n                if (isDerivedFrom(baseClass, parentClassType, inheritanceChain)) {\n                    if (inheritanceChain) {\n                        inheritanceChain.push(subclassType);\n                    }\n                    return true;\n                }\n            }\n            else if (isAnyOrUnknown(baseClass)) {\n                if (inheritanceChain) {\n                    inheritanceChain.push(UnknownType.create());\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    ClassType.isDerivedFrom = isDerivedFrom;\n})(ClassType = exports.ClassType || (exports.ClassType = {}));\nvar ObjectType;\n(function (ObjectType) {\n    function create(classType) {\n        const newObjectType = {\n            category: 8 /* Object */,\n            classType,\n            flags: 2 /* Instance */,\n        };\n        return newObjectType;\n    }\n    ObjectType.create = create;\n})(ObjectType = exports.ObjectType || (exports.ObjectType = {}));\nvar FunctionType;\n(function (FunctionType) {\n    function createInstance(name, functionFlags, docString) {\n        return create(name, functionFlags, 2 /* Instance */, docString);\n    }\n    FunctionType.createInstance = createInstance;\n    function createInstantiable(name, functionFlags, docString) {\n        return create(name, functionFlags, 1 /* Instantiable */, docString);\n    }\n    FunctionType.createInstantiable = createInstantiable;\n    function create(name, functionFlags, typeFlags, docString) {\n        const newFunctionType = {\n            category: 5 /* Function */,\n            details: {\n                name,\n                flags: functionFlags,\n                parameters: [],\n                docString,\n            },\n            flags: typeFlags,\n        };\n        return newFunctionType;\n    }\n    // Creates a deep copy of the function type, including a fresh\n    // version of _functionDetails.\n    function clone(type, deleteFirstParam = false) {\n        const newFunction = create(type.details.name, type.details.flags, type.flags, type.details.docString);\n        const startParam = deleteFirstParam ? 1 : 0;\n        newFunction.details = {\n            name: type.details.name,\n            flags: type.details.flags,\n            parameters: type.details.parameters.slice(startParam),\n            declaredReturnType: type.details.declaredReturnType,\n            declaration: type.details.declaration,\n            builtInName: type.details.builtInName,\n            docString: type.details.docString,\n        };\n        // If we strip off the first parameter, this is no longer an\n        // instance method or class method.\n        if (deleteFirstParam) {\n            newFunction.details.flags &= ~(1 /* ConstructorMethod */ | 2 /* ClassMethod */);\n            newFunction.details.flags |= 4 /* StaticMethod */;\n            newFunction.ignoreFirstParamOfDeclaration = true;\n        }\n        if (type.typeAliasInfo !== undefined) {\n            newFunction.typeAliasInfo = type.typeAliasInfo;\n        }\n        if (type.specializedTypes) {\n            newFunction.specializedTypes = {\n                parameterTypes: type.specializedTypes.parameterTypes.slice(startParam),\n                returnType: type.specializedTypes.returnType,\n            };\n        }\n        newFunction.inferredReturnType = type.inferredReturnType;\n        return newFunction;\n    }\n    FunctionType.clone = clone;\n    function cloneAsInstance(type) {\n        debug_1.assert(TypeBase.isInstantiable(type));\n        const newInstance = Object.assign({}, type);\n        newInstance.flags &= ~1 /* Instantiable */;\n        newInstance.flags |= 2 /* Instance */;\n        return newInstance;\n    }\n    FunctionType.cloneAsInstance = cloneAsInstance;\n    function cloneAsInstantiable(type) {\n        debug_1.assert(TypeBase.isInstance(type));\n        const newInstance = Object.assign({}, type);\n        newInstance.flags &= ~2 /* Instance */;\n        newInstance.flags |= 1 /* Instantiable */;\n        return newInstance;\n    }\n    FunctionType.cloneAsInstantiable = cloneAsInstantiable;\n    // Creates a shallow copy of the function type with new\n    // specialized types. The clone shares the _functionDetails\n    // with the object being cloned.\n    function cloneForSpecialization(type, specializedTypes, specializedInferredReturnType) {\n        const newFunction = create(type.details.name, type.details.flags, type.flags, type.details.docString);\n        newFunction.details = type.details;\n        debug_1.assert(specializedTypes.parameterTypes.length === type.details.parameters.length);\n        newFunction.specializedTypes = specializedTypes;\n        if (specializedInferredReturnType) {\n            newFunction.inferredReturnType = specializedInferredReturnType;\n        }\n        return newFunction;\n    }\n    FunctionType.cloneForSpecialization = cloneForSpecialization;\n    // Creates a new function based on the parameters of another function. If\n    // paramTemplate is undefined, use default (generic) parameters.\n    function cloneForParamSpec(type, paramTemplate) {\n        const newFunction = create(type.details.name, type.details.flags, type.flags, type.details.docString);\n        // Make a shallow clone of the details.\n        newFunction.details = Object.assign({}, type.details);\n        // The clone should no longer have a parameter specification\n        // since we're replacing it.\n        delete newFunction.details.paramSpec;\n        if (paramTemplate) {\n            newFunction.details.parameters = paramTemplate.details.parameters;\n        }\n        else {\n            FunctionType.addDefaultParameters(newFunction);\n        }\n        return newFunction;\n    }\n    FunctionType.cloneForParamSpec = cloneForParamSpec;\n    function addDefaultParameters(functionType, useUnknown = false) {\n        FunctionType.addParameter(functionType, {\n            category: 1 /* VarArgList */,\n            name: 'args',\n            type: useUnknown ? UnknownType.create() : AnyType.create(),\n        });\n        FunctionType.addParameter(functionType, {\n            category: 2 /* VarArgDictionary */,\n            name: 'kwargs',\n            type: useUnknown ? UnknownType.create() : AnyType.create(),\n        });\n    }\n    FunctionType.addDefaultParameters = addDefaultParameters;\n    function isInstanceMethod(type) {\n        return ((type.details.flags &\n            (1 /* ConstructorMethod */ |\n                4 /* StaticMethod */ |\n                2 /* ClassMethod */)) ===\n            0);\n    }\n    FunctionType.isInstanceMethod = isInstanceMethod;\n    function isConstructorMethod(type) {\n        return (type.details.flags & 1 /* ConstructorMethod */) !== 0;\n    }\n    FunctionType.isConstructorMethod = isConstructorMethod;\n    function isStaticMethod(type) {\n        return (type.details.flags & 4 /* StaticMethod */) !== 0;\n    }\n    FunctionType.isStaticMethod = isStaticMethod;\n    function isClassMethod(type) {\n        return (type.details.flags & 2 /* ClassMethod */) !== 0;\n    }\n    FunctionType.isClassMethod = isClassMethod;\n    function isAbstractMethod(type) {\n        return (type.details.flags & 8 /* AbstractMethod */) !== 0;\n    }\n    FunctionType.isAbstractMethod = isAbstractMethod;\n    function isGenerator(type) {\n        return (type.details.flags & 16 /* Generator */) !== 0;\n    }\n    FunctionType.isGenerator = isGenerator;\n    function isSynthesizedMethod(type) {\n        return (type.details.flags & 64 /* SynthesizedMethod */) !== 0;\n    }\n    FunctionType.isSynthesizedMethod = isSynthesizedMethod;\n    function isSkipConstructorCheck(type) {\n        return (type.details.flags & 128 /* SkipConstructorCheck */) !== 0;\n    }\n    FunctionType.isSkipConstructorCheck = isSkipConstructorCheck;\n    function isOverloaded(type) {\n        return (type.details.flags & 256 /* Overloaded */) !== 0;\n    }\n    FunctionType.isOverloaded = isOverloaded;\n    function isDefaultParameterCheckDisabled(type) {\n        return (type.details.flags & 32 /* DisableDefaultChecks */) !== 0;\n    }\n    FunctionType.isDefaultParameterCheckDisabled = isDefaultParameterCheckDisabled;\n    function isAsync(type) {\n        return (type.details.flags & 512 /* Async */) !== 0;\n    }\n    FunctionType.isAsync = isAsync;\n    function isWrapReturnTypeInAwait(type) {\n        return (type.details.flags & 1024 /* WrapReturnTypeInAwait */) !== 0;\n    }\n    FunctionType.isWrapReturnTypeInAwait = isWrapReturnTypeInAwait;\n    function isStubDefinition(type) {\n        return (type.details.flags & 2048 /* StubDefinition */) !== 0;\n    }\n    FunctionType.isStubDefinition = isStubDefinition;\n    function isFinal(type) {\n        return (type.details.flags & 4096 /* Final */) !== 0;\n    }\n    FunctionType.isFinal = isFinal;\n    function hasUnannotatedParams(type) {\n        return (type.details.flags & 8192 /* UnannotatedParams */) !== 0;\n    }\n    FunctionType.hasUnannotatedParams = hasUnannotatedParams;\n    function getEffectiveParameterType(type, index) {\n        debug_1.assert(index < type.details.parameters.length);\n        if (type.specializedTypes) {\n            return type.specializedTypes.parameterTypes[index];\n        }\n        return type.details.parameters[index].type;\n    }\n    FunctionType.getEffectiveParameterType = getEffectiveParameterType;\n    function addParameter(type, param) {\n        type.details.parameters.push(param);\n    }\n    FunctionType.addParameter = addParameter;\n    function getSpecializedReturnType(type) {\n        return type.specializedTypes && type.specializedTypes.returnType\n            ? type.specializedTypes.returnType\n            : type.details.declaredReturnType;\n    }\n    FunctionType.getSpecializedReturnType = getSpecializedReturnType;\n})(FunctionType = exports.FunctionType || (exports.FunctionType = {}));\nvar OverloadedFunctionType;\n(function (OverloadedFunctionType) {\n    function create(overloads = []) {\n        const newType = {\n            category: 6 /* OverloadedFunction */,\n            overloads,\n            flags: 2 /* Instance */,\n        };\n        return newType;\n    }\n    OverloadedFunctionType.create = create;\n    function addOverload(type, functionType) {\n        type.overloads.push(functionType);\n    }\n    OverloadedFunctionType.addOverload = addOverload;\n})(OverloadedFunctionType = exports.OverloadedFunctionType || (exports.OverloadedFunctionType = {}));\nvar NoneType;\n(function (NoneType) {\n    const _noneInstance = {\n        category: 3 /* None */,\n        flags: 2 /* Instance */,\n    };\n    const _noneType = {\n        category: 3 /* None */,\n        flags: 1 /* Instantiable */,\n    };\n    function createInstance() {\n        return _noneInstance;\n    }\n    NoneType.createInstance = createInstance;\n    function createType() {\n        return _noneType;\n    }\n    NoneType.createType = createType;\n})(NoneType = exports.NoneType || (exports.NoneType = {}));\nvar NeverType;\n(function (NeverType) {\n    const _neverInstance = {\n        category: 4 /* Never */,\n        flags: 2 /* Instance */ | 1 /* Instantiable */,\n    };\n    function create() {\n        return _neverInstance;\n    }\n    NeverType.create = create;\n})(NeverType = exports.NeverType || (exports.NeverType = {}));\nvar AnyType;\n(function (AnyType) {\n    const _anyInstance = {\n        category: 2 /* Any */,\n        isEllipsis: false,\n        flags: 2 /* Instance */ | 1 /* Instantiable */,\n    };\n    const _ellipsisInstance = {\n        category: 2 /* Any */,\n        isEllipsis: true,\n        flags: 2 /* Instance */ | 1 /* Instantiable */,\n    };\n    function create(isEllipsis = false) {\n        return isEllipsis ? _ellipsisInstance : _anyInstance;\n    }\n    AnyType.create = create;\n})(AnyType = exports.AnyType || (exports.AnyType = {}));\nvar UnionType;\n(function (UnionType) {\n    function create(subtypes = []) {\n        const newUnionType = {\n            category: 10 /* Union */,\n            subtypes: [],\n            flags: 2 /* Instance */ | 1 /* Instantiable */,\n        };\n        addTypes(newUnionType, subtypes);\n        return newUnionType;\n    }\n    UnionType.create = create;\n    function addTypes(unionType, subtypes) {\n        for (const newType of subtypes) {\n            debug_1.assert(newType.category !== 10 /* Union */);\n            debug_1.assert(newType.category !== 4 /* Never */);\n            unionType.flags &= newType.flags;\n            unionType.subtypes.push(newType);\n        }\n    }\n    UnionType.addTypes = addTypes;\n    function containsType(unionType, subtype, recursionCount = 0) {\n        return unionType.subtypes.find((t) => isTypeSame(t, subtype, recursionCount + 1)) !== undefined;\n    }\n    UnionType.containsType = containsType;\n})(UnionType = exports.UnionType || (exports.UnionType = {}));\nvar TypeVarType;\n(function (TypeVarType) {\n    function createInstance(name, isParamSpec, isSynthesized = false) {\n        return create(name, isParamSpec, isSynthesized, 2 /* Instance */);\n    }\n    TypeVarType.createInstance = createInstance;\n    function createInstantiable(name, isParamSpec, isSynthesized = false) {\n        return create(name, isParamSpec, isSynthesized, 1 /* Instantiable */);\n    }\n    TypeVarType.createInstantiable = createInstantiable;\n    function cloneAsInstance(type) {\n        debug_1.assert(TypeBase.isInstantiable(type));\n        const newInstance = Object.assign({}, type);\n        newInstance.flags &= ~1 /* Instantiable */;\n        newInstance.flags |= 2 /* Instance */;\n        return newInstance;\n    }\n    TypeVarType.cloneAsInstance = cloneAsInstance;\n    function cloneAsInstantiable(type) {\n        debug_1.assert(TypeBase.isInstance(type));\n        const newInstance = Object.assign({}, type);\n        newInstance.flags &= ~2 /* Instance */;\n        newInstance.flags |= 1 /* Instantiable */;\n        return newInstance;\n    }\n    TypeVarType.cloneAsInstantiable = cloneAsInstantiable;\n    function create(name, isParamSpec, isSynthesized, typeFlags) {\n        const newTypeVarType = {\n            category: 11 /* TypeVar */,\n            name,\n            constraints: [],\n            isCovariant: false,\n            isContravariant: false,\n            isParamSpec,\n            isSynthesized,\n            flags: typeFlags,\n        };\n        return newTypeVarType;\n    }\n    function addConstraint(typeVarType, constraintType) {\n        typeVarType.constraints.push(constraintType);\n    }\n    TypeVarType.addConstraint = addConstraint;\n})(TypeVarType = exports.TypeVarType || (exports.TypeVarType = {}));\nfunction isNever(type) {\n    return type.category === 4 /* Never */;\n}\nexports.isNever = isNever;\nfunction isNone(type) {\n    return type.category === 3 /* None */;\n}\nexports.isNone = isNone;\nfunction isUnknown(type) {\n    return type.category === 1 /* Unknown */;\n}\nexports.isUnknown = isUnknown;\nfunction isAnyOrUnknown(type) {\n    if (type.category === 2 /* Any */ || type.category === 1 /* Unknown */) {\n        return true;\n    }\n    if (type.category === 10 /* Union */) {\n        return type.subtypes.find((t) => !isAnyOrUnknown(t)) === undefined;\n    }\n    return false;\n}\nexports.isAnyOrUnknown = isAnyOrUnknown;\nfunction isUnbound(type) {\n    return type.category === 0 /* Unbound */;\n}\nexports.isUnbound = isUnbound;\nfunction isPossiblyUnbound(type) {\n    if (type.category === 0 /* Unbound */) {\n        return true;\n    }\n    if (type.category === 10 /* Union */) {\n        return type.subtypes.find((t) => isPossiblyUnbound(t)) !== undefined;\n    }\n    return false;\n}\nexports.isPossiblyUnbound = isPossiblyUnbound;\nfunction isClass(type) {\n    return type.category === 7 /* Class */;\n}\nexports.isClass = isClass;\nfunction isObject(type) {\n    return type.category === 8 /* Object */;\n}\nexports.isObject = isObject;\nfunction isModule(type) {\n    return type.category === 9 /* Module */;\n}\nexports.isModule = isModule;\nfunction isTypeVar(type) {\n    return type.category === 11 /* TypeVar */;\n}\nexports.isTypeVar = isTypeVar;\nfunction isTypeSame(type1, type2, recursionCount = 0) {\n    if (type1.category !== type2.category) {\n        return false;\n    }\n    if (recursionCount > exports.maxTypeRecursionCount) {\n        return true;\n    }\n    switch (type1.category) {\n        case 7 /* Class */: {\n            const classType2 = type2;\n            // If the details are not the same it's not the same class.\n            if (!ClassType.isSameGenericClass(type1, classType2, true, recursionCount + 1)) {\n                return false;\n            }\n            // Make sure the type args match.\n            const type1TypeArgs = type1.typeArguments || [];\n            const type2TypeArgs = classType2.typeArguments || [];\n            const typeArgCount = Math.max(type1TypeArgs.length, type2TypeArgs.length);\n            for (let i = 0; i < typeArgCount; i++) {\n                // Assume that missing type args are \"Any\".\n                const typeArg1 = i < type1TypeArgs.length ? type1TypeArgs[i] : AnyType.create();\n                const typeArg2 = i < type2TypeArgs.length ? type2TypeArgs[i] : AnyType.create();\n                if (!isTypeSame(typeArg1, typeArg2, recursionCount + 1)) {\n                    return false;\n                }\n            }\n            if (!ClassType.isLiteralValueSame(type1, classType2)) {\n                return false;\n            }\n            return true;\n        }\n        case 8 /* Object */: {\n            const objType2 = type2;\n            return isTypeSame(type1.classType, objType2.classType, recursionCount + 1);\n        }\n        case 5 /* Function */: {\n            // Make sure the parameter counts match.\n            const functionType2 = type2;\n            const params1 = type1.details.parameters;\n            const params2 = functionType2.details.parameters;\n            if (params1.length !== params2.length) {\n                return false;\n            }\n            // Make sure the parameter details match.\n            for (let i = 0; i < params1.length; i++) {\n                const param1 = params1[i];\n                const param2 = params2[i];\n                if (param1.category !== param2.category) {\n                    return false;\n                }\n                if (param1.name !== param2.name) {\n                    return false;\n                }\n                const param1Type = FunctionType.getEffectiveParameterType(type1, i);\n                const param2Type = FunctionType.getEffectiveParameterType(functionType2, i);\n                if (!isTypeSame(param1Type, param2Type, recursionCount + 1)) {\n                    return false;\n                }\n            }\n            // Make sure the return types match.\n            let return1Type = type1.details.declaredReturnType;\n            if (type1.specializedTypes && type1.specializedTypes.returnType) {\n                return1Type = type1.specializedTypes.returnType;\n            }\n            let return2Type = functionType2.details.declaredReturnType;\n            if (functionType2.specializedTypes && functionType2.specializedTypes.returnType) {\n                return2Type = functionType2.specializedTypes.returnType;\n            }\n            if (return1Type || return2Type) {\n                if (!return1Type || !return2Type || !isTypeSame(return1Type, return2Type, recursionCount + 1)) {\n                    return false;\n                }\n            }\n            if (type1.details.declaration !== functionType2.details.declaration) {\n                return false;\n            }\n            return true;\n        }\n        case 6 /* OverloadedFunction */: {\n            // Make sure the overload counts match.\n            const functionType2 = type2;\n            if (type1.overloads.length !== functionType2.overloads.length) {\n                return false;\n            }\n            // We assume here that overloaded functions always appear\n            // in the same order from one analysis pass to another.\n            for (let i = 0; i < type1.overloads.length; i++) {\n                if (!isTypeSame(type1.overloads[i], functionType2.overloads[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        case 10 /* Union */: {\n            const unionType2 = type2;\n            const subtypes1 = type1.subtypes;\n            const subtypes2 = unionType2.subtypes;\n            if (subtypes1.length !== subtypes2.length) {\n                return false;\n            }\n            // The types do not have a particular order, so we need to\n            // do the comparison in an order-independent manner.\n            return subtypes1.find((t) => !UnionType.containsType(unionType2, t, recursionCount + 1)) === undefined;\n        }\n        case 11 /* TypeVar */: {\n            const type2TypeVar = type2;\n            if (type1.name !== type2TypeVar.name) {\n                return false;\n            }\n            const boundType1 = type1.boundType;\n            const boundType2 = type2TypeVar.boundType;\n            if (boundType1) {\n                if (!boundType2 || !isTypeSame(boundType1, boundType2, recursionCount + 1)) {\n                    return false;\n                }\n            }\n            else {\n                if (boundType2) {\n                    return false;\n                }\n            }\n            if (type1.isContravariant !== type2TypeVar.isContravariant) {\n                return false;\n            }\n            if (type1.isCovariant !== type2TypeVar.isCovariant) {\n                return false;\n            }\n            const constraints1 = type1.constraints;\n            const constraints2 = type2TypeVar.constraints;\n            if (constraints1.length !== constraints2.length) {\n                return false;\n            }\n            for (let i = 0; i < constraints1.length; i++) {\n                if (!isTypeSame(constraints1[i], constraints2[i], recursionCount + 1)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        case 9 /* Module */: {\n            const type2Module = type2;\n            // Module types are the same if they share the same\n            // module symbol table.\n            if (type1.fields === type2Module.fields) {\n                return true;\n            }\n            // If both symbol tables are empty, we can also assume\n            // they're equal.\n            if (type1.fields.size === 0 && type2Module.fields.size === 0) {\n                return true;\n            }\n            return false;\n        }\n    }\n    return true;\n}\nexports.isTypeSame = isTypeSame;\n// If the type is a union, remove any \"unknown\" or \"any\" type\n// from the union, returning only the known types.\nfunction removeAnyFromUnion(type) {\n    return removeFromUnion(type, (t) => isAnyOrUnknown(t));\n}\nexports.removeAnyFromUnion = removeAnyFromUnion;\n// If the type is a union, remove an \"unknown\" type from the union,\n// returning only the known types.\nfunction removeUnknownFromUnion(type) {\n    return removeFromUnion(type, (t) => t.category === 1 /* Unknown */);\n}\nexports.removeUnknownFromUnion = removeUnknownFromUnion;\n// If the type is a union, remove an \"unbound\" type from the union,\n// returning only the known types.\nfunction removeUnboundFromUnion(type) {\n    return removeFromUnion(type, (t) => isUnbound(t));\n}\nexports.removeUnboundFromUnion = removeUnboundFromUnion;\n// If the type is a union, remove an \"None\" type from the union,\n// returning only the known types.\nfunction removeNoneFromUnion(type) {\n    return removeFromUnion(type, (t) => t.category === 3 /* None */);\n}\nexports.removeNoneFromUnion = removeNoneFromUnion;\nfunction removeFromUnion(type, removeFilter) {\n    if (type.category === 10 /* Union */) {\n        const remainingTypes = type.subtypes.filter((t) => !removeFilter(t));\n        if (remainingTypes.length < type.subtypes.length) {\n            return combineTypes(remainingTypes);\n        }\n    }\n    return type;\n}\nexports.removeFromUnion = removeFromUnion;\n// Determines whether the specified type is a type that can be\n// combined with other types for a union.\nfunction isUnionableType(subtypes) {\n    let typeFlags = 2 /* Instance */ | 1 /* Instantiable */;\n    for (const subtype of subtypes) {\n        typeFlags &= subtype.flags;\n    }\n    // All subtypes need to be instantiable. Some types (like Any\n    // and None) are both instances and instantiable. It's OK to\n    // include some of these, but at least one subtype needs to\n    // be definitively instantiable (not an instance).\n    return (typeFlags & 1 /* Instantiable */) !== 0 && (typeFlags & 2 /* Instance */) === 0;\n}\nexports.isUnionableType = isUnionableType;\n// Combines multiple types into a single type. If the types are\n// the same, only one is returned. If they differ, they\n// are combined into a UnionType. NeverTypes are filtered out.\n// If no types remain in the end, a NeverType is returned.\nfunction combineTypes(types) {\n    // Filter out any \"Never\" types.\n    types = types.filter((type) => type.category !== 4 /* Never */);\n    if (types.length === 0) {\n        return NeverType.create();\n    }\n    // Handle the common case where there is only one type.\n    if (types.length === 1) {\n        return types[0];\n    }\n    // Expand all union types.\n    let expandedTypes = [];\n    for (const type of types) {\n        if (type.category === 10 /* Union */) {\n            expandedTypes = expandedTypes.concat(type.subtypes);\n        }\n        else {\n            expandedTypes.push(type);\n        }\n    }\n    // Sort all of the literal types to the end.\n    expandedTypes = expandedTypes.sort((type1, type2) => {\n        if ((isObject(type1) && type1.classType.literalValue !== undefined) ||\n            (isClass(type1) && type1.literalValue !== undefined)) {\n            return 1;\n        }\n        else if ((isObject(type2) && type2.classType.literalValue !== undefined) ||\n            (isClass(type2) && type2.literalValue !== undefined)) {\n            return -1;\n        }\n        return 0;\n    });\n    // If the union contains a NoReturn, remove it. NoReturn should\n    // be used only when it's by itself.\n    const isNoReturn = (t) => isObject(t) && ClassType.isBuiltIn(t.classType, 'NoReturn');\n    if (expandedTypes.find((t) => isNoReturn(t))) {\n        expandedTypes = expandedTypes.filter((t) => !isNoReturn(t));\n    }\n    // If removing all NoReturn types results in no remaining types,\n    // convert it to an unknown.\n    if (expandedTypes.length === 0) {\n        return UnknownType.create();\n    }\n    const resultingTypes = [];\n    expandedTypes.forEach((t, index) => {\n        if (index === 0) {\n            resultingTypes.push(t);\n        }\n        else {\n            _addTypeIfUnique(resultingTypes, t);\n        }\n    });\n    // If only one type remains, convert it from a union to a simple type.\n    if (resultingTypes.length === 1) {\n        return resultingTypes[0];\n    }\n    return UnionType.create(resultingTypes);\n}\nexports.combineTypes = combineTypes;\n// Determines whether the dest type is the same as the source type with\n// the possible exception that the source type has a literal value when\n// the dest does not.\nfunction isSameWithoutLiteralValue(destType, srcType) {\n    // If it's the same with literals, great.\n    if (isTypeSame(destType, srcType)) {\n        return true;\n    }\n    if (isClass(srcType) && srcType.literalValue !== undefined) {\n        // Strip the literal.\n        srcType = ClassType.cloneWithLiteral(srcType, undefined);\n        return isTypeSame(destType, srcType);\n    }\n    if (isObject(srcType) && srcType.classType.literalValue !== undefined) {\n        // Strip the literal.\n        srcType = ObjectType.create(ClassType.cloneWithLiteral(srcType.classType, undefined));\n        return isTypeSame(destType, srcType);\n    }\n    return false;\n}\nexports.isSameWithoutLiteralValue = isSameWithoutLiteralValue;\nfunction _addTypeIfUnique(types, typeToAdd) {\n    for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        // Does this type already exist in the types array?\n        if (isTypeSame(type, typeToAdd)) {\n            return;\n        }\n        // If the typeToAdd is a literal value and there's already\n        // a non-literal type that matches, don't add the literal value.\n        if (isObject(type) && isObject(typeToAdd)) {\n            if (isSameWithoutLiteralValue(type, typeToAdd)) {\n                if (type.classType.literalValue === undefined) {\n                    return;\n                }\n            }\n            // If we're adding Literal[False] or Literal[True] to its\n            // opposite, combine them into a non-literal 'bool' type.\n            if (ClassType.isBuiltIn(type.classType, 'bool')) {\n                if (typeToAdd.classType.literalValue !== undefined &&\n                    !typeToAdd.classType.literalValue === type.classType.literalValue) {\n                    types[i] = ObjectType.create(ClassType.cloneWithLiteral(type.classType, undefined));\n                    return;\n                }\n            }\n        }\n    }\n    types.push(typeToAdd);\n}\n\n\n//# sourceURL=webpack://pyright-server/./src/analyzer/types.ts?");

/***/ }),

/***/ "./src/backgroundAnalysis.ts":
/*!***********************************!*\
  !*** ./src/backgroundAnalysis.ts ***!
  \***********************************/
/*! flagged exports */
/*! export BackgroundAnalysis [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * backgroundAnalysis.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * run analyzer from background thread\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BackgroundAnalysis = void 0;\nconst worker_threads_1 = __webpack_require__(/*! worker_threads */ \"worker_threads\");\nconst backgroundAnalysisBase_1 = __webpack_require__(/*! ./backgroundAnalysisBase */ \"./src/backgroundAnalysisBase.ts\");\nconst cancellationUtils_1 = __webpack_require__(/*! ./common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nclass BackgroundAnalysis extends backgroundAnalysisBase_1.BackgroundAnalysisBase {\n    constructor(console) {\n        super();\n        const initialData = {\n            rootDirectory: global.__rootDirectory,\n            cancellationFolderName: cancellationUtils_1.getCancellationFolderName(),\n        };\n        // this will load this same file in BG thread and start listener\n        const worker = new worker_threads_1.Worker(__filename, { workerData: initialData });\n        this.setup(worker, console);\n    }\n}\nexports.BackgroundAnalysis = BackgroundAnalysis;\nclass BackgroundAnalysisRunner extends backgroundAnalysisBase_1.BackgroundAnalysisRunnerBase {\n    constructor() {\n        super();\n    }\n}\n// this lets the runner start in the worker thread\nif (!worker_threads_1.isMainThread) {\n    const runner = new BackgroundAnalysisRunner();\n    runner.start();\n}\n\n\n//# sourceURL=webpack://pyright-server/./src/backgroundAnalysis.ts?");

/***/ }),

/***/ "./src/backgroundAnalysisBase.ts":
/*!***************************************!*\
  !*** ./src/backgroundAnalysisBase.ts ***!
  \***************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * backgroundAnalysisBase.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * run analyzer from background thread\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BackgroundAnalysisRunnerBase = exports.BackgroundAnalysisBase = void 0;\nconst worker_threads_1 = __webpack_require__(/*! worker_threads */ \"worker_threads\");\nconst analysis_1 = __webpack_require__(/*! ./analyzer/analysis */ \"./src/analyzer/analysis.ts\");\nconst importResolver_1 = __webpack_require__(/*! ./analyzer/importResolver */ \"./src/analyzer/importResolver.ts\");\nconst program_1 = __webpack_require__(/*! ./analyzer/program */ \"./src/analyzer/program.ts\");\nconst cancellationUtils_1 = __webpack_require__(/*! ./common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst configOptions_1 = __webpack_require__(/*! ./common/configOptions */ \"./src/common/configOptions.ts\");\nconst console_1 = __webpack_require__(/*! ./common/console */ \"./src/common/console.ts\");\nconst debug = __webpack_require__(/*! ./common/debug */ \"./src/common/debug.ts\");\nconst diagnostic_1 = __webpack_require__(/*! ./common/diagnostic */ \"./src/common/diagnostic.ts\");\nconst fileSystem_1 = __webpack_require__(/*! ./common/fileSystem */ \"./src/common/fileSystem.ts\");\nclass BackgroundAnalysisBase {\n    constructor() {\n        this._onAnalysisCompletion = analysis_1.nullCallback;\n        // Don't allow instantiation of this type directly.\n    }\n    setup(worker, console) {\n        this._worker = worker;\n        this._console = console;\n        // global channel to communicate from BG channel to main thread.\n        worker.on('message', (msg) => {\n            switch (msg.requestType) {\n                case 'log': {\n                    const logData = msg.data;\n                    this.log(logData.level, logData.message);\n                    break;\n                }\n                case 'analysisResult': {\n                    // Change in diagnostics due to host such as file closed rather than\n                    // analyzing files.\n                    this._onAnalysisCompletion(convertAnalysisResults(msg.data));\n                    break;\n                }\n                default:\n                    debug.fail(`${msg.requestType} is not expected`);\n            }\n        });\n        // this will catch any exception thrown from background thread,\n        // print log and ignore exception\n        worker.on('error', (msg) => {\n            this.log(console_1.LogLevel.Error, `Error occurred on background thread: ${JSON.stringify(msg)}`);\n        });\n    }\n    setCompletionCallback(callback) {\n        this._onAnalysisCompletion = callback !== null && callback !== void 0 ? callback : analysis_1.nullCallback;\n    }\n    setConfigOptions(configOptions) {\n        this._enqueueRequest({ requestType: 'setConfigOptions', data: configOptions });\n    }\n    setTrackedFiles(filePaths) {\n        this._enqueueRequest({ requestType: 'setTrackedFiles', data: filePaths });\n    }\n    setAllowedThirdPartyImports(importNames) {\n        this._enqueueRequest({ requestType: 'setAllowedThirdPartyImports', data: importNames });\n    }\n    setFileOpened(filePath, version, contents) {\n        this._enqueueRequest({ requestType: 'setFileOpened', data: { filePath, version, contents } });\n    }\n    setFileClosed(filePath) {\n        this._enqueueRequest({ requestType: 'setFileClosed', data: filePath });\n    }\n    markAllFilesDirty(evenIfContentsAreSame) {\n        this._enqueueRequest({ requestType: 'markAllFilesDirty', data: evenIfContentsAreSame });\n    }\n    markFilesDirty(filePaths, evenIfContentsAreSame) {\n        this._enqueueRequest({ requestType: 'markFilesDirty', data: { filePaths, evenIfContentsAreSame } });\n    }\n    startAnalysis(token) {\n        const { port1, port2 } = new worker_threads_1.MessageChannel();\n        // Handle response from background thread to main thread.\n        port1.on('message', (msg) => {\n            switch (msg.requestType) {\n                case 'analysisResult': {\n                    this._onAnalysisCompletion(convertAnalysisResults(msg.data));\n                    break;\n                }\n                case 'analysisDone': {\n                    cancellationUtils_1.disposeCancellationToken(token);\n                    port2.close();\n                    port1.close();\n                    break;\n                }\n                default:\n                    debug.fail(`${msg.requestType} is not expected`);\n            }\n        });\n        const cancellationId = cancellationUtils_1.getCancellationTokenId(token);\n        this._enqueueRequest({ requestType: 'analyze', data: cancellationId, port: port2 });\n    }\n    getDiagnosticsForRange(filePath, range, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            cancellationUtils_1.throwIfCancellationRequested(token);\n            const { port1, port2 } = new worker_threads_1.MessageChannel();\n            const waiter = getBackgroundWaiter(port1);\n            const cancellationId = cancellationUtils_1.getCancellationTokenId(token);\n            this._enqueueRequest({\n                requestType: 'getDiagnosticsForRange',\n                data: { filePath, range, cancellationId },\n                port: port2,\n            });\n            const result = yield waiter;\n            port2.close();\n            port1.close();\n            return convertDiagnostics(result);\n        });\n    }\n    writeTypeStub(targetImportPath, targetIsSingleFile, stubPath, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            cancellationUtils_1.throwIfCancellationRequested(token);\n            const { port1, port2 } = new worker_threads_1.MessageChannel();\n            const waiter = getBackgroundWaiter(port1);\n            const cancellationId = cancellationUtils_1.getCancellationTokenId(token);\n            this._enqueueRequest({\n                requestType: 'writeTypeStub',\n                data: { targetImportPath, targetIsSingleFile, stubPath, cancellationId },\n                port: port2,\n            });\n            yield waiter;\n            port2.close();\n            port1.close();\n        });\n    }\n    invalidateAndForceReanalysis() {\n        this._enqueueRequest({ requestType: 'invalidateAndForceReanalysis', data: null });\n    }\n    restart() {\n        this._enqueueRequest({ requestType: 'restart', data: null });\n    }\n    _enqueueRequest(request) {\n        this._worker.postMessage(request, request.port ? [request.port] : undefined);\n    }\n    log(level, msg) {\n        console_1.log(this._console, level, msg);\n    }\n}\nexports.BackgroundAnalysisBase = BackgroundAnalysisBase;\nclass BackgroundAnalysisRunnerBase {\n    constructor(_extension) {\n        this._extension = _extension;\n        const data = worker_threads_1.workerData;\n        cancellationUtils_1.setCancellationFolderName(data.cancellationFolderName);\n        // Stash the base directory into a global variable.\n        global.__rootDirectory = data.rootDirectory;\n        this.log(console_1.LogLevel.Info, `Background analysis root directory: ${data.rootDirectory}`);\n        this._fs = fileSystem_1.createFromRealFileSystem(this._getConsole());\n        this._configOptions = new configOptions_1.ConfigOptions(data.rootDirectory);\n        this._importResolver = this.createImportResolver(this._fs, this._configOptions);\n        this._program = new program_1.Program(this._importResolver, this._configOptions, this._getConsole(), this._extension, 'BG');\n    }\n    start() {\n        this.log(console_1.LogLevel.Info, `Background analysis started`);\n        // Get requests from main thread.\n        worker_threads_1.parentPort === null || worker_threads_1.parentPort === void 0 ? void 0 : worker_threads_1.parentPort.on('message', (msg) => {\n            switch (msg.requestType) {\n                case 'analyze': {\n                    const port = msg.port;\n                    const token = cancellationUtils_1.getCancellationTokenFromId(msg.data);\n                    // Report files to analyze first.\n                    const filesLeftToAnalyze = this._program.getFilesToAnalyzeCount();\n                    this._onAnalysisCompletion(port, {\n                        diagnostics: [],\n                        filesInProgram: this._program.getFileCount(),\n                        filesRequiringAnalysis: filesLeftToAnalyze,\n                        checkingOnlyOpenFiles: this._program.isCheckingOnlyOpenFiles(),\n                        fatalErrorOccurred: false,\n                        configParseErrorOccurred: false,\n                        elapsedTime: 0,\n                    });\n                    // Report results at the interval of the max analysis time.\n                    const maxTime = { openFilesTimeInMs: 50, noOpenFilesTimeInMs: 200 };\n                    let moreToAnalyze = true;\n                    while (moreToAnalyze) {\n                        moreToAnalyze = analysis_1.analyzeProgram(this._program, maxTime, this._configOptions, (result) => this._onAnalysisCompletion(port, result), this._getConsole(), token);\n                    }\n                    this._analysisDone(port, msg.data);\n                    break;\n                }\n                case 'getDiagnosticsForRange': {\n                    run(() => {\n                        const { filePath, range, cancellationId } = msg.data;\n                        const token = cancellationUtils_1.getCancellationTokenFromId(cancellationId);\n                        cancellationUtils_1.throwIfCancellationRequested(token);\n                        return this._program.getDiagnosticsForRange(filePath, range);\n                    }, msg.port);\n                    break;\n                }\n                case 'writeTypeStub': {\n                    run(() => {\n                        const { targetImportPath, targetIsSingleFile, stubPath, cancellationId } = msg.data;\n                        const token = cancellationUtils_1.getCancellationTokenFromId(cancellationId);\n                        analysis_1.analyzeProgram(this._program, undefined, this._configOptions, analysis_1.nullCallback, this._getConsole(), token);\n                        this._program.writeTypeStub(targetImportPath, targetIsSingleFile, stubPath, token);\n                    }, msg.port);\n                    break;\n                }\n                case 'setConfigOptions': {\n                    this._configOptions = createConfigOptionsFrom(msg.data);\n                    this._importResolver = this.createImportResolver(this._fs, this._configOptions);\n                    this._program.setConfigOptions(this._configOptions);\n                    this._program.setImportResolver(this._importResolver);\n                    break;\n                }\n                case 'setTrackedFiles': {\n                    const diagnostics = this._program.setTrackedFiles(msg.data);\n                    this._reportDiagnostics(diagnostics, this._program.getFilesToAnalyzeCount(), 0);\n                    break;\n                }\n                case 'setAllowedThirdPartyImports': {\n                    this._program.setAllowedThirdPartyImports(msg.data);\n                    break;\n                }\n                case 'setFileOpened': {\n                    const { filePath, version, contents } = msg.data;\n                    this._program.setFileOpened(filePath, version, contents);\n                    break;\n                }\n                case 'setFileClosed': {\n                    const diagnostics = this._program.setFileClosed(msg.data);\n                    this._reportDiagnostics(diagnostics, this._program.getFilesToAnalyzeCount(), 0);\n                    break;\n                }\n                case 'markAllFilesDirty': {\n                    this._program.markAllFilesDirty(msg.data);\n                    break;\n                }\n                case 'markFilesDirty': {\n                    const { filePaths, evenIfContentsAreSame } = msg.data;\n                    this._program.markFilesDirty(filePaths, evenIfContentsAreSame);\n                    break;\n                }\n                case 'invalidateAndForceReanalysis': {\n                    // Make sure the import resolver doesn't have invalid\n                    // cached entries.\n                    this._importResolver.invalidateCache();\n                    // Mark all files with one or more errors dirty.\n                    this._program.markAllFilesDirty(true);\n                    break;\n                }\n                case 'restart': {\n                    // recycle import resolver\n                    this._importResolver = this.createImportResolver(this._fs, this._configOptions);\n                    this._program.setImportResolver(this._importResolver);\n                    break;\n                }\n                default: {\n                    debug.fail(`${msg.requestType} is not expected`);\n                }\n            }\n        });\n        worker_threads_1.parentPort === null || worker_threads_1.parentPort === void 0 ? void 0 : worker_threads_1.parentPort.on('error', (msg) => debug.fail(`failed ${msg}`));\n        worker_threads_1.parentPort === null || worker_threads_1.parentPort === void 0 ? void 0 : worker_threads_1.parentPort.on('exit', (c) => {\n            if (c !== 0) {\n                debug.fail(`worker stopped with exit code ${c}`);\n            }\n        });\n    }\n    log(level, msg) {\n        worker_threads_1.parentPort === null || worker_threads_1.parentPort === void 0 ? void 0 : worker_threads_1.parentPort.postMessage({ requestType: 'log', data: { level: level, message: msg } });\n    }\n    createImportResolver(fs, options) {\n        return new importResolver_1.ImportResolver(fs, options);\n    }\n    _reportDiagnostics(diagnostics, filesLeftToAnalyze, elapsedTime) {\n        if (worker_threads_1.parentPort) {\n            this._onAnalysisCompletion(worker_threads_1.parentPort, {\n                diagnostics,\n                filesInProgram: this._program.getFileCount(),\n                filesRequiringAnalysis: filesLeftToAnalyze,\n                checkingOnlyOpenFiles: this._program.isCheckingOnlyOpenFiles(),\n                fatalErrorOccurred: false,\n                configParseErrorOccurred: false,\n                elapsedTime,\n            });\n        }\n    }\n    _onAnalysisCompletion(port, result) {\n        port.postMessage({ requestType: 'analysisResult', data: result });\n    }\n    _analysisDone(port, cancellationId) {\n        port.postMessage({ requestType: 'analysisDone', data: cancellationId });\n    }\n    _getConsole() {\n        return {\n            log: (msg) => {\n                this.log(console_1.LogLevel.Log, msg);\n            },\n            info: (msg) => {\n                this.log(console_1.LogLevel.Info, msg);\n            },\n            warn: (msg) => {\n                this.log(console_1.LogLevel.Warn, msg);\n            },\n            error: (msg) => {\n                this.log(console_1.LogLevel.Error, msg);\n            },\n            // We always generate logs in the background. For the foreground,\n            // we'll decide decide based on user setting whether.\n            level: console_1.LogLevel.Log,\n        };\n    }\n}\nexports.BackgroundAnalysisRunnerBase = BackgroundAnalysisRunnerBase;\nfunction createConfigOptionsFrom(jsonObject) {\n    const configOptions = new configOptions_1.ConfigOptions(jsonObject.projectRoot);\n    const getFileSpec = (fileSpec) => {\n        return { wildcardRoot: fileSpec.wildcardRoot, regExp: new RegExp(fileSpec.regExp.source) };\n    };\n    configOptions.pythonPath = jsonObject.pythonPath;\n    configOptions.typeshedPath = jsonObject.typeshedPath;\n    configOptions.stubPath = jsonObject.stubPath;\n    configOptions.autoExcludeVenv = jsonObject.autoExcludeVenv;\n    configOptions.verboseOutput = jsonObject.verboseOutput;\n    configOptions.checkOnlyOpenFiles = jsonObject.checkOnlyOpenFiles;\n    configOptions.useLibraryCodeForTypes = jsonObject.useLibraryCodeForTypes;\n    configOptions.internalTestMode = jsonObject.internalTestMode;\n    configOptions.venvPath = jsonObject.venvPath;\n    configOptions.defaultVenv = jsonObject.defaultVenv;\n    configOptions.defaultPythonVersion = jsonObject.defaultPythonVersion;\n    configOptions.defaultPythonPlatform = jsonObject.defaultPythonPlatform;\n    configOptions.diagnosticRuleSet = jsonObject.diagnosticRuleSet;\n    configOptions.executionEnvironments = jsonObject.executionEnvironments;\n    configOptions.autoImportCompletions = jsonObject.autoImportCompletions;\n    configOptions.include = jsonObject.include.map((f) => getFileSpec(f));\n    configOptions.exclude = jsonObject.exclude.map((f) => getFileSpec(f));\n    configOptions.ignore = jsonObject.ignore.map((f) => getFileSpec(f));\n    configOptions.strict = jsonObject.strict.map((f) => getFileSpec(f));\n    return configOptions;\n}\nfunction run(code, port) {\n    try {\n        const result = code();\n        port.postMessage({ kind: 'ok', data: result });\n    }\n    catch (e) {\n        if (cancellationUtils_1.OperationCanceledException.is(e)) {\n            port.postMessage({ kind: 'cancelled', data: e.message });\n            return;\n        }\n        port.postMessage({ kind: 'failed', data: `Exception: ${e.message} in ${e.stack}` });\n    }\n}\nfunction getBackgroundWaiter(port) {\n    return new Promise((resolve, reject) => {\n        port.on('message', (m) => {\n            switch (m.kind) {\n                case 'ok':\n                    resolve(m.data);\n                    break;\n                case 'cancelled':\n                    reject(new cancellationUtils_1.OperationCanceledException());\n                    break;\n                case 'failed':\n                    reject(m.data);\n                    break;\n                default:\n                    debug.fail(`unknown kind ${m.kind}`);\n            }\n        });\n    });\n}\nfunction convertAnalysisResults(result) {\n    result.diagnostics = result.diagnostics.map((f) => {\n        return {\n            filePath: f.filePath,\n            diagnostics: convertDiagnostics(f.diagnostics),\n        };\n    });\n    return result;\n}\nfunction convertDiagnostics(diagnostics) {\n    // Elements are typed as \"any\" since data crossing the process\n    // boundary loses type info.\n    return diagnostics.map((d) => {\n        const diag = new diagnostic_1.Diagnostic(d.category, d.message, d.range);\n        if (d._actions) {\n            for (const action of d._actions) {\n                diag.addAction(action);\n            }\n        }\n        if (d._rule) {\n            diag.setRule(d._rule);\n        }\n        if (d._relatedInfo) {\n            for (const info of d._relatedInfo) {\n                diag.addRelatedInfo(info.message, info.filePath, info.range);\n            }\n        }\n        return diag;\n    });\n}\n\n\n//# sourceURL=webpack://pyright-server/./src/backgroundAnalysisBase.ts?");

/***/ }),

/***/ "./src/commands/commandController.ts":
/*!*******************************************!*\
  !*** ./src/commands/commandController.ts ***!
  \*******************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * commandController.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Implements language server commands execution functionality.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CommandController = void 0;\nconst vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ \"./node_modules/vscode-languageserver/lib/node/main.js\");\nconst createTypeStub_1 = __webpack_require__(/*! ./createTypeStub */ \"./src/commands/createTypeStub.ts\");\nconst quickActionCommand_1 = __webpack_require__(/*! ./quickActionCommand */ \"./src/commands/quickActionCommand.ts\");\nconst restartServer_1 = __webpack_require__(/*! ./restartServer */ \"./src/commands/restartServer.ts\");\nclass CommandController {\n    constructor(ls) {\n        this._createStub = new createTypeStub_1.CreateTypeStubCommand(ls);\n        this._restartServer = new restartServer_1.RestartServerCommand(ls);\n        this._quickAction = new quickActionCommand_1.QuickActionCommand(ls);\n    }\n    execute(cmdParams, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            switch (cmdParams.command) {\n                case \"pyright.organizeimports\" /* orderImports */:\n                case \"pyright.addoptionalforparam\" /* addMissingOptionalToParam */: {\n                    return this._quickAction.execute(cmdParams, token);\n                }\n                case \"pyright.createtypestub\" /* createTypeStub */: {\n                    return this._createStub.execute(cmdParams, token);\n                }\n                case \"pyright.restartserver\" /* restartServer */: {\n                    return this._restartServer.execute(cmdParams);\n                }\n                default: {\n                    return new vscode_languageserver_1.ResponseError(1, 'Unsupported command');\n                }\n            }\n        });\n    }\n    isLongRunningCommand(command) {\n        switch (command) {\n            case \"pyright.createtypestub\" /* createTypeStub */:\n                return true;\n            default:\n                return false;\n        }\n    }\n}\nexports.CommandController = CommandController;\n\n\n//# sourceURL=webpack://pyright-server/./src/commands/commandController.ts?");

/***/ }),

/***/ "./src/commands/createTypeStub.ts":
/*!****************************************!*\
  !*** ./src/commands/createTypeStub.ts ***!
  \****************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * createTypeStub.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Implements 'create stub' command functionality.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CreateTypeStubCommand = void 0;\nconst service_1 = __webpack_require__(/*! ../analyzer/service */ \"./src/analyzer/service.ts\");\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst deferred_1 = __webpack_require__(/*! ../common/deferred */ \"./src/common/deferred.ts\");\nconst pathUtils_1 = __webpack_require__(/*! ../common/pathUtils */ \"./src/common/pathUtils.ts\");\nconst analyzerServiceExecutor_1 = __webpack_require__(/*! ../languageService/analyzerServiceExecutor */ \"./src/languageService/analyzerServiceExecutor.ts\");\nclass CreateTypeStubCommand {\n    constructor(_ls) {\n        this._ls = _ls;\n    }\n    execute(cmdParams, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (cmdParams.arguments && cmdParams.arguments.length >= 2) {\n                const workspaceRoot = cmdParams.arguments[0];\n                const importName = cmdParams.arguments[1];\n                const callingFile = cmdParams.arguments[2];\n                const service = yield this._createTypeStubService(callingFile);\n                // Allocate a temporary pseudo-workspace to perform this job.\n                const workspace = {\n                    workspaceName: `Create Type Stub ${importName}`,\n                    rootPath: workspaceRoot,\n                    rootUri: pathUtils_1.convertPathToUri(workspaceRoot),\n                    serviceInstance: service,\n                    disableLanguageServices: true,\n                    disableOrganizeImports: true,\n                    isInitialized: deferred_1.createDeferred(),\n                };\n                const serverSettings = yield this._ls.getSettings(workspace);\n                analyzerServiceExecutor_1.AnalyzerServiceExecutor.runWithOptions(this._ls.rootPath, workspace, serverSettings, importName, false);\n                try {\n                    yield service.writeTypeStubInBackground(token);\n                    service.dispose();\n                    const infoMessage = `Type stub was successfully created for '${importName}'.`;\n                    this._ls.window.showInformationMessage(infoMessage);\n                    this._handlePostCreateTypeStub();\n                }\n                catch (err) {\n                    const isCancellation = cancellationUtils_1.OperationCanceledException.is(err);\n                    if (isCancellation) {\n                        const errMessage = `Type stub creation for '${importName}' was canceled`;\n                        this._ls.console.error(errMessage);\n                    }\n                    else {\n                        let errMessage = '';\n                        if (err instanceof Error) {\n                            errMessage = ': ' + err.message;\n                        }\n                        errMessage = `An error occurred when creating type stub for '${importName}'` + errMessage;\n                        this._ls.console.error(errMessage);\n                        this._ls.window.showErrorMessage(errMessage);\n                    }\n                }\n            }\n        });\n    }\n    // Creates a service instance that's used for creating type\n    // stubs for a specified target library.\n    _createTypeStubService(callingFile) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (callingFile) {\n                // this should let us to inherit all execution env of the calling file\n                // if it is invoked from IDE through code action\n                const workspace = yield this._ls.getWorkspaceForFile(callingFile);\n                // new service has its own background analysis running on its own thread\n                // to not block main bg running background analysis\n                return workspace.serviceInstance.clone('Type stub', this._ls.createBackgroundAnalysis());\n            }\n            return new service_1.AnalyzerService('Type stub', this._ls.fs, this._ls.console);\n        });\n    }\n    _handlePostCreateTypeStub() {\n        this._ls.reanalyze();\n    }\n}\nexports.CreateTypeStubCommand = CreateTypeStubCommand;\n\n\n//# sourceURL=webpack://pyright-server/./src/commands/createTypeStub.ts?");

/***/ }),

/***/ "./src/commands/quickActionCommand.ts":
/*!********************************************!*\
  !*** ./src/commands/quickActionCommand.ts ***!
  \********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * quickActionCommand.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Implements command that maps to a quick action.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QuickActionCommand = void 0;\nconst pathUtils_1 = __webpack_require__(/*! ../common/pathUtils */ \"./src/common/pathUtils.ts\");\nconst textEditUtils_1 = __webpack_require__(/*! ../common/textEditUtils */ \"./src/common/textEditUtils.ts\");\nclass QuickActionCommand {\n    constructor(_ls) {\n        this._ls = _ls;\n    }\n    execute(params, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (params.arguments && params.arguments.length >= 1) {\n                const docUri = params.arguments[0];\n                const otherArgs = params.arguments.slice(1);\n                const filePath = pathUtils_1.convertUriToPath(docUri);\n                const workspace = yield this._ls.getWorkspaceForFile(filePath);\n                if (params.command === \"pyright.organizeimports\" /* orderImports */ && workspace.disableOrganizeImports) {\n                    return [];\n                }\n                const editActions = workspace.serviceInstance.performQuickAction(filePath, params.command, otherArgs, token);\n                return textEditUtils_1.convertTextEdits(docUri, editActions);\n            }\n        });\n    }\n}\nexports.QuickActionCommand = QuickActionCommand;\n\n\n//# sourceURL=webpack://pyright-server/./src/commands/quickActionCommand.ts?");

/***/ }),

/***/ "./src/commands/restartServer.ts":
/*!***************************************!*\
  !*** ./src/commands/restartServer.ts ***!
  \***************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__ */
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n/*\n * restartServer.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Implements 'restart server' command functionality.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RestartServerCommand = void 0;\nclass RestartServerCommand {\n    constructor(_ls) {\n        this._ls = _ls;\n    }\n    execute(cmdParams) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._ls.restart();\n        });\n    }\n}\nexports.RestartServerCommand = RestartServerCommand;\n\n\n//# sourceURL=webpack://pyright-server/./src/commands/restartServer.ts?");

/***/ }),

/***/ "./src/common/cancellationUtils.ts":
/*!*****************************************!*\
  !*** ./src/common/cancellationUtils.ts ***!
  \*****************************************/
/*! flagged exports */
/*! export CancelAfter [provided] [no usage info] [missing usage info prevents renaming] */
/*! export OperationCanceledException [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export createAnalysisCancellationTokenSource [provided] [no usage info] [missing usage info prevents renaming] */
/*! export disposeCancellationToken [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getCancellationFolderName [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getCancellationStrategyFromArgv [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getCancellationTokenFromId [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getCancellationTokenId [provided] [no usage info] [missing usage info prevents renaming] */
/*! export setCancellationFolderName [provided] [no usage info] [missing usage info prevents renaming] */
/*! export throwIfCancellationRequested [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * cancellationUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Helper methods relating to cancellation.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CancelAfter = exports.getCancellationTokenId = exports.getCancellationTokenFromId = exports.disposeCancellationToken = exports.createAnalysisCancellationTokenSource = exports.getCancellationStrategyFromArgv = exports.setCancellationFolderName = exports.getCancellationFolderName = exports.throwIfCancellationRequested = exports.OperationCanceledException = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/node/main.js\");\nconst vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ \"./node_modules/vscode-languageserver/lib/node/main.js\");\nclass CancellationThrottle {\n    static shouldCheck() {\n        // Throttle cancellation checks to one every 5ms. This value\n        // was selected through empirical testing. If we call the\n        // file system more often than this, type analysis performance\n        // is affected. If we call it less often, performance doesn't\n        // improve much, but responsiveness suffers.\n        const minTimeBetweenChecksInMs = 5;\n        const curTimestamp = Date.now().valueOf();\n        const timeSinceLastCheck = curTimestamp - this._lastCheckTimestamp;\n        if (timeSinceLastCheck >= minTimeBetweenChecksInMs) {\n            this._lastCheckTimestamp = curTimestamp;\n            return true;\n        }\n        return false;\n    }\n}\nCancellationThrottle._lastCheckTimestamp = 0;\nclass FileBasedToken {\n    constructor(cancellationFilePath) {\n        this.cancellationFilePath = cancellationFilePath;\n        this.isCancelled = false;\n    }\n    cancel() {\n        if (!this.isCancelled) {\n            this.isCancelled = true;\n            if (this._emitter) {\n                this._emitter.fire(undefined);\n                this._disposeEmitter();\n            }\n        }\n    }\n    get isCancellationRequested() {\n        if (this.isCancelled) {\n            return true;\n        }\n        if (CancellationThrottle.shouldCheck() && this._pipeExists()) {\n            // The first time it encounters the cancellation file, it will\n            // cancel itself and raise a cancellation event.\n            // In this mode, cancel() might not be called explicitly by\n            // jsonrpc layer.\n            this.cancel();\n        }\n        return this.isCancelled;\n    }\n    get onCancellationRequested() {\n        if (!this._emitter) {\n            this._emitter = new vscode_languageserver_1.Emitter();\n        }\n        return this._emitter.event;\n    }\n    dispose() {\n        this._disposeEmitter();\n    }\n    _disposeEmitter() {\n        if (this._emitter) {\n            this._emitter.dispose();\n            this._emitter = undefined;\n        }\n    }\n    _pipeExists() {\n        try {\n            fs.statSync(this.cancellationFilePath);\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n}\nclass OwningFileToken extends FileBasedToken {\n    constructor(cancellationFilePath) {\n        super(cancellationFilePath);\n        this._disposed = false;\n    }\n    cancel() {\n        if (!this._disposed && !this.isCancelled) {\n            this._createPipe();\n            super.cancel();\n        }\n    }\n    get isCancellationRequested() {\n        // Since this object owns the file and it gets created when the\n        // token is cancelled, there's no point in checking the pipe.\n        return this.isCancelled;\n    }\n    dispose() {\n        this._disposed = true;\n        super.dispose();\n        this._removePipe();\n    }\n    _createPipe() {\n        try {\n            fs.writeFileSync(this.cancellationFilePath, '', { flag: 'w' });\n        }\n        catch (_a) {\n            // Ignore the exception.\n        }\n    }\n    _removePipe() {\n        try {\n            fs.unlinkSync(this.cancellationFilePath);\n        }\n        catch (_a) {\n            // Ignore the exception.\n        }\n    }\n}\nclass FileBasedCancellationTokenSource {\n    constructor(_cancellationFilePath, _ownFile = false) {\n        this._cancellationFilePath = _cancellationFilePath;\n        this._ownFile = _ownFile;\n    }\n    get token() {\n        if (!this._token) {\n            // Be lazy and create the token only when actually needed.\n            this._token = this._ownFile\n                ? new OwningFileToken(this._cancellationFilePath)\n                : new FileBasedToken(this._cancellationFilePath);\n        }\n        return this._token;\n    }\n    cancel() {\n        if (!this._token) {\n            // Save an object by returning the default\n            // cancelled token when cancellation happens\n            // before someone asks for the token.\n            this._token = vscode_languageserver_1.CancellationToken.Cancelled;\n        }\n        else {\n            this._token.cancel();\n        }\n    }\n    dispose() {\n        if (!this._token) {\n            // Make sure to initialize with an empty token if we had none.\n            this._token = vscode_languageserver_1.CancellationToken.None;\n        }\n        else if (this._token instanceof FileBasedToken) {\n            // Actually dispose.\n            this._token.dispose();\n        }\n    }\n}\nfunction getCancellationFolderPath(folderName) {\n    return path.join(os.tmpdir(), 'python-languageserver-cancellation', folderName);\n}\nfunction getCancellationFilePath(folderName, id) {\n    return path.join(getCancellationFolderPath(folderName), `cancellation-${String(id)}.tmp`);\n}\nclass FileCancellationReceiverStrategy {\n    constructor(folderName) {\n        this.folderName = folderName;\n    }\n    createCancellationTokenSource(id) {\n        return new FileBasedCancellationTokenSource(getCancellationFilePath(this.folderName, id));\n    }\n}\nclass OperationCanceledException extends vscode_languageserver_1.ResponseError {\n    constructor() {\n        super(vscode_languageserver_1.ErrorCodes.RequestCancelled, 'request cancelled');\n    }\n    static is(e) {\n        return e.code === vscode_languageserver_1.ErrorCodes.RequestCancelled;\n    }\n}\nexports.OperationCanceledException = OperationCanceledException;\nfunction throwIfCancellationRequested(token) {\n    if (token.isCancellationRequested) {\n        throw new OperationCanceledException();\n    }\n}\nexports.throwIfCancellationRequested = throwIfCancellationRequested;\nlet cancellationFolderName;\nfunction getCancellationFolderName() {\n    return cancellationFolderName;\n}\nexports.getCancellationFolderName = getCancellationFolderName;\nfunction setCancellationFolderName(folderName) {\n    cancellationFolderName = folderName;\n}\nexports.setCancellationFolderName = setCancellationFolderName;\nfunction getCancellationStrategyFromArgv(argv) {\n    let receiver;\n    for (let i = 0; i < argv.length; i++) {\n        const arg = argv[i];\n        if (arg === '--cancellationReceive') {\n            receiver = createReceiverStrategyFromArgv(argv[i + 1]);\n        }\n        else {\n            const args = arg.split('=');\n            if (args[0] === '--cancellationReceive') {\n                receiver = createReceiverStrategyFromArgv(args[1]);\n            }\n        }\n    }\n    if (receiver && !cancellationFolderName) {\n        setCancellationFolderName(receiver.folderName);\n    }\n    receiver = receiver ? receiver : vscode_languageserver_1.CancellationReceiverStrategy.Message;\n    return { receiver, sender: vscode_languageserver_1.CancellationSenderStrategy.Message };\n    function createReceiverStrategyFromArgv(arg) {\n        const folderName = extractCancellationFolderName(arg);\n        return folderName ? new FileCancellationReceiverStrategy(folderName) : undefined;\n    }\n    function extractCancellationFolderName(arg) {\n        const fileRegex = /^file:(.+)$/;\n        const folderName = arg.match(fileRegex);\n        return folderName ? folderName[1] : undefined;\n    }\n}\nexports.getCancellationStrategyFromArgv = getCancellationStrategyFromArgv;\nlet analysisId = 0;\nfunction createAnalysisCancellationTokenSource() {\n    if (!cancellationFolderName) {\n        // File-based cancellation is not used.\n        // Return regular cancellation token source.\n        return new vscode_jsonrpc_1.CancellationTokenSource();\n    }\n    return new FileBasedCancellationTokenSource(getCancellationFilePath(cancellationFolderName, `analysis-${String(analysisId++)}`), true);\n}\nexports.createAnalysisCancellationTokenSource = createAnalysisCancellationTokenSource;\nfunction disposeCancellationToken(token) {\n    if (token instanceof FileBasedToken) {\n        token.dispose();\n    }\n}\nexports.disposeCancellationToken = disposeCancellationToken;\nfunction getCancellationTokenFromId(cancellationId) {\n    if (!cancellationId) {\n        return vscode_languageserver_1.CancellationToken.None;\n    }\n    return new FileBasedToken(cancellationId);\n}\nexports.getCancellationTokenFromId = getCancellationTokenFromId;\nfunction getCancellationTokenId(token) {\n    return token instanceof FileBasedToken ? token.cancellationFilePath : undefined;\n}\nexports.getCancellationTokenId = getCancellationTokenId;\nfunction CancelAfter(...tokens) {\n    const source = new vscode_jsonrpc_1.CancellationTokenSource();\n    const disposables = [];\n    for (const token of tokens) {\n        disposables.push(token.onCancellationRequested((_) => {\n            source.cancel();\n        }));\n    }\n    disposables.push(source.token.onCancellationRequested((_) => {\n        disposables.forEach((d) => d.dispose());\n    }));\n    return source;\n}\nexports.CancelAfter = CancelAfter;\n\n\n//# sourceURL=webpack://pyright-server/./src/common/cancellationUtils.ts?");

/***/ }),

/***/ "./src/common/collectionUtils.ts":
/*!***************************************!*\
  !*** ./src/common/collectionUtils.ts ***!
  \***************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export addRange [provided] [no usage info] [missing usage info prevents renaming] */
/*! export append [provided] [no usage info] [missing usage info prevents renaming] */
/*! export binarySearch [provided] [no usage info] [missing usage info prevents renaming] */
/*! export binarySearchKey [provided] [no usage info] [missing usage info prevents renaming] */
/*! export cloneAndSort [provided] [no usage info] [missing usage info prevents renaming] */
/*! export contains [provided] [no usage info] [missing usage info prevents renaming] */
/*! export emptyArray [provided] [no usage info] [missing usage info prevents renaming] */
/*! export every [provided] [no usage info] [missing usage info prevents renaming] */
/*! export find [provided] [no usage info] [missing usage info prevents renaming] */
/*! export flatten [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getNestedProperty [provided] [no usage info] [missing usage info prevents renaming] */
/*! export insertAt [provided] [no usage info] [missing usage info prevents renaming] */
/*! export map [provided] [no usage info] [missing usage info prevents renaming] */
/*! export some [provided] [no usage info] [missing usage info prevents renaming] */
/*! export stableSort [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * collectionUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Helper functions relating to collections and arrays.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getNestedProperty = exports.flatten = exports.binarySearchKey = exports.binarySearch = exports.every = exports.some = exports.map = exports.stableSort = exports.cloneAndSort = exports.insertAt = exports.addRange = exports.find = exports.append = exports.contains = exports.emptyArray = void 0;\nconst core_1 = __webpack_require__(/*! ./core */ \"./src/common/core.ts\");\nexports.emptyArray = [];\nfunction contains(array, value, equalityComparer = core_1.equateValues) {\n    if (array) {\n        for (const v of array) {\n            if (equalityComparer(v, value)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexports.contains = contains;\nfunction append(to, value) {\n    if (value === undefined) {\n        return to;\n    }\n    if (to === undefined) {\n        return [value];\n    }\n    to.push(value);\n    return to;\n}\nexports.append = append;\nfunction find(array, predicate) {\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        if (predicate(value, i)) {\n            return value;\n        }\n    }\n    return undefined;\n}\nexports.find = find;\n/**\n * Gets the actual offset into an array for a relative offset. Negative offsets indicate a\n * position offset from the end of the array.\n */\nfunction toOffset(array, offset) {\n    return offset < 0 ? array.length + offset : offset;\n}\nfunction addRange(to, from, start, end) {\n    if (from === undefined || from.length === 0) {\n        return to;\n    }\n    if (to === undefined) {\n        return from.slice(start, end);\n    }\n    start = start === undefined ? 0 : toOffset(from, start);\n    end = end === undefined ? from.length : toOffset(from, end);\n    for (let i = start; i < end && i < from.length; i++) {\n        if (from[i] !== undefined) {\n            to.push(from[i]);\n        }\n    }\n    return to;\n}\nexports.addRange = addRange;\nfunction insertAt(array, index, value) {\n    if (index === 0) {\n        array.unshift(value);\n    }\n    else if (index === array.length) {\n        array.push(value);\n    }\n    else {\n        for (let i = array.length; i > index; i--) {\n            array[i] = array[i - 1];\n        }\n        array[index] = value;\n    }\n    return array;\n}\nexports.insertAt = insertAt;\n/**\n * Returns a new sorted array.\n */\nfunction cloneAndSort(array, comparer) {\n    return (array.length === 0 ? array : array.slice().sort(comparer));\n}\nexports.cloneAndSort = cloneAndSort;\nfunction selectIndex(_, i) {\n    return i;\n}\nfunction indicesOf(array) {\n    return array.map(selectIndex);\n}\n/**\n * Stable sort of an array. Elements equal to each other maintain their relative position in the array.\n */\nfunction stableSort(array, comparer) {\n    const indices = indicesOf(array);\n    stableSortIndices(array, indices, comparer);\n    return indices.map((i) => array[i]);\n}\nexports.stableSort = stableSort;\nfunction stableSortIndices(array, indices, comparer) {\n    // sort indices by value then position\n    indices.sort((x, y) => comparer(array[x], array[y]) || core_1.compareValues(x, y));\n}\nfunction map(array, f) {\n    if (array) {\n        return array.map(f);\n    }\n    return undefined;\n}\nexports.map = map;\nfunction some(array, predicate) {\n    if (array) {\n        if (predicate) {\n            return array.some(predicate);\n        }\n        else {\n            return array.length > 0;\n        }\n    }\n    return false;\n}\nexports.some = some;\n/**\n * Iterates through `array` by index and performs the callback on each element of array until the callback\n * returns a falsey value, then returns false.\n * If no such value is found, the callback is applied to each element of array and `true` is returned.\n */\nfunction every(array, callback) {\n    if (array) {\n        return array.every(callback);\n    }\n    return true;\n}\nexports.every = every;\n/**\n * Performs a binary search, finding the index at which `value` occurs in `array`.\n * If no such index is found, returns the 2's-complement of first index at which\n * `array[index]` exceeds `value`.\n * @param array A sorted array whose first element must be no larger than number\n * @param value The value to be searched for in the array.\n * @param keySelector A callback used to select the search key from `value` and each element of\n * `array`.\n * @param keyComparer A callback used to compare two keys in a sorted array.\n * @param offset An offset into `array` at which to start the search.\n */\nfunction binarySearch(array, value, keySelector, keyComparer, offset) {\n    return binarySearchKey(array, keySelector(value), keySelector, keyComparer, offset);\n}\nexports.binarySearch = binarySearch;\n/**\n * Performs a binary search, finding the index at which an object with `key` occurs in `array`.\n * If no such index is found, returns the 2's-complement of first index at which\n * `array[index]` exceeds `key`.\n * @param array A sorted array whose first element must be no larger than number\n * @param key The key to be searched for in the array.\n * @param keySelector A callback used to select the search key from each element of `array`.\n * @param keyComparer A callback used to compare two keys in a sorted array.\n * @param offset An offset into `array` at which to start the search.\n */\nfunction binarySearchKey(array, key, keySelector, keyComparer, offset) {\n    if (!some(array)) {\n        return -1;\n    }\n    let low = offset || 0;\n    let high = array.length - 1;\n    while (low <= high) {\n        const middle = low + ((high - low) >> 1);\n        const midKey = keySelector(array[middle]);\n        switch (keyComparer(midKey, key)) {\n            case -1 /* LessThan */:\n                low = middle + 1;\n                break;\n            case 0 /* EqualTo */:\n                return middle;\n            case 1 /* GreaterThan */:\n                high = middle - 1;\n                break;\n        }\n    }\n    return ~low;\n}\nexports.binarySearchKey = binarySearchKey;\n/**\n * Flattens an array containing a mix of array or non-array elements.\n *\n * @param array The array to flatten.\n */\nfunction flatten(array) {\n    const result = [];\n    for (const v of array) {\n        if (v) {\n            if (core_1.isArray(v)) {\n                addRange(result, v);\n            }\n            else {\n                result.push(v);\n            }\n        }\n    }\n    return result;\n}\nexports.flatten = flatten;\n/**\n * Retrieves nested objects by parsing chained properties. ie. \"a.b.c\"\n * Returns undefined if not found\n * @param object The object to query\n * @param property The property to be searched for in the object ie. \"a.b.c\"\n */\nfunction getNestedProperty(object, property) {\n    const value = property.split('.').reduce((obj, prop) => {\n        return obj && obj[prop];\n    }, object);\n    return value;\n}\nexports.getNestedProperty = getNestedProperty;\n\n\n//# sourceURL=webpack://pyright-server/./src/common/collectionUtils.ts?");

/***/ }),

/***/ "./src/common/commandLineOptions.ts":
/*!******************************************!*\
  !*** ./src/common/commandLineOptions.ts ***!
  \******************************************/
/*! flagged exports */
/*! export CommandLineOptions [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getDiagnosticSeverityOverrides [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * commandLineOptions.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Class that holds the command-line options (those that can be\n * passed into the main entry point of the command-line version\n * of the analyzer).\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CommandLineOptions = exports.getDiagnosticSeverityOverrides = void 0;\nfunction getDiagnosticSeverityOverrides() {\n    return [\n        \"error\" /* Error */,\n        \"warning\" /* Warning */,\n        \"information\" /* Information */,\n        \"none\" /* None */,\n    ];\n}\nexports.getDiagnosticSeverityOverrides = getDiagnosticSeverityOverrides;\n// Some options can be specified from a source other than the pyright config file.\n// This can be from command-line parameters or some other settings mechanism, like\n// that provided through a language client like the VS Code editor. These options\n// are later combined with those from the config file to produce the final configuration.\nclass CommandLineOptions {\n    constructor(executionRoot, fromVsCodeExtension) {\n        // A list of file specs to include in the analysis. Can contain\n        // directories, in which case all \"*.py\" files within those directories\n        // are included.\n        this.fileSpecs = [];\n        this.executionRoot = executionRoot;\n        this.fromVsCodeExtension = fromVsCodeExtension;\n    }\n}\nexports.CommandLineOptions = CommandLineOptions;\n\n\n//# sourceURL=webpack://pyright-server/./src/common/commandLineOptions.ts?");

/***/ }),

/***/ "./src/common/configOptions.ts":
/*!*************************************!*\
  !*** ./src/common/configOptions.ts ***!
  \*************************************/
/*! flagged exports */
/*! export ConfigOptions [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ExecutionEnvironment [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export cloneDiagnosticRuleSet [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getBasicDiagnosticRuleSet [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getBooleanDiagnosticRules [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getDiagLevelDiagnosticRules [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getOffDiagnosticRuleSet [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getStrictDiagnosticRuleSet [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getStrictModeNotOverriddenRules [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * configOptions.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Class that holds the configuration options for the analyzer.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConfigOptions = exports.getStrictDiagnosticRuleSet = exports.getBasicDiagnosticRuleSet = exports.getOffDiagnosticRuleSet = exports.getStrictModeNotOverriddenRules = exports.getDiagLevelDiagnosticRules = exports.getBooleanDiagnosticRules = exports.cloneDiagnosticRuleSet = exports.ExecutionEnvironment = void 0;\nconst child_process = __webpack_require__(/*! child_process */ \"child_process\");\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst pathConsts = __webpack_require__(/*! ../common/pathConsts */ \"./src/common/pathConsts.ts\");\nconst pathUtils_1 = __webpack_require__(/*! ./pathUtils */ \"./src/common/pathUtils.ts\");\nconst pythonVersion_1 = __webpack_require__(/*! ./pythonVersion */ \"./src/common/pythonVersion.ts\");\nclass ExecutionEnvironment {\n    // Default to \".\" which indicates every file in the project.\n    constructor(root, defaultPythonVersion, defaultPythonPlatform) {\n        // Default to no extra paths.\n        this.extraPaths = [];\n        this.root = root;\n        this.pythonVersion = defaultPythonVersion || pythonVersion_1.latestStablePythonVersion;\n        this.pythonPlatform = defaultPythonPlatform;\n    }\n}\nexports.ExecutionEnvironment = ExecutionEnvironment;\nfunction cloneDiagnosticRuleSet(diagSettings) {\n    // Create a shallow copy of the existing object.\n    return Object.assign({}, diagSettings);\n}\nexports.cloneDiagnosticRuleSet = cloneDiagnosticRuleSet;\nfunction getBooleanDiagnosticRules() {\n    return [\n        \"strictListInference\" /* strictListInference */,\n        \"strictDictionaryInference\" /* strictDictionaryInference */,\n        \"strictParameterNoneValue\" /* strictParameterNoneValue */,\n    ];\n}\nexports.getBooleanDiagnosticRules = getBooleanDiagnosticRules;\nfunction getDiagLevelDiagnosticRules() {\n    return [\n        \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */,\n        \"reportMissingImports\" /* reportMissingImports */,\n        \"reportMissingModuleSource\" /* reportMissingModuleSource */,\n        \"reportMissingTypeStubs\" /* reportMissingTypeStubs */,\n        \"reportImportCycles\" /* reportImportCycles */,\n        \"reportUnusedImport\" /* reportUnusedImport */,\n        \"reportUnusedClass\" /* reportUnusedClass */,\n        \"reportUnusedFunction\" /* reportUnusedFunction */,\n        \"reportUnusedVariable\" /* reportUnusedVariable */,\n        \"reportDuplicateImport\" /* reportDuplicateImport */,\n        \"reportOptionalSubscript\" /* reportOptionalSubscript */,\n        \"reportOptionalMemberAccess\" /* reportOptionalMemberAccess */,\n        \"reportOptionalCall\" /* reportOptionalCall */,\n        \"reportOptionalIterable\" /* reportOptionalIterable */,\n        \"reportOptionalContextManager\" /* reportOptionalContextManager */,\n        \"reportOptionalOperand\" /* reportOptionalOperand */,\n        \"reportUntypedFunctionDecorator\" /* reportUntypedFunctionDecorator */,\n        \"reportUntypedClassDecorator\" /* reportUntypedClassDecorator */,\n        \"reportUntypedBaseClass\" /* reportUntypedBaseClass */,\n        \"reportUntypedNamedTuple\" /* reportUntypedNamedTuple */,\n        \"reportPrivateUsage\" /* reportPrivateUsage */,\n        \"reportConstantRedefinition\" /* reportConstantRedefinition */,\n        \"reportIncompatibleMethodOverride\" /* reportIncompatibleMethodOverride */,\n        \"reportIncompatibleVariableOverride\" /* reportIncompatibleVariableOverride */,\n        \"reportInvalidStringEscapeSequence\" /* reportInvalidStringEscapeSequence */,\n        \"reportUnknownParameterType\" /* reportUnknownParameterType */,\n        \"reportUnknownArgumentType\" /* reportUnknownArgumentType */,\n        \"reportUnknownLambdaType\" /* reportUnknownLambdaType */,\n        \"reportUnknownVariableType\" /* reportUnknownVariableType */,\n        \"reportUnknownMemberType\" /* reportUnknownMemberType */,\n        \"reportCallInDefaultInitializer\" /* reportCallInDefaultInitializer */,\n        \"reportUnnecessaryIsInstance\" /* reportUnnecessaryIsInstance */,\n        \"reportUnnecessaryCast\" /* reportUnnecessaryCast */,\n        \"reportAssertAlwaysTrue\" /* reportAssertAlwaysTrue */,\n        \"reportSelfClsParameterName\" /* reportSelfClsParameterName */,\n        \"reportImplicitStringConcatenation\" /* reportImplicitStringConcatenation */,\n        \"reportUndefinedVariable\" /* reportUndefinedVariable */,\n        \"reportUnboundVariable\" /* reportUnboundVariable */,\n        \"reportInvalidStubStatement\" /* reportInvalidStubStatement */,\n    ];\n}\nexports.getDiagLevelDiagnosticRules = getDiagLevelDiagnosticRules;\nfunction getStrictModeNotOverriddenRules() {\n    // In strict mode, the value in the user config file should be honored and\n    // not overwritten by the value from the strict rule set.\n    return [\"reportMissingModuleSource\" /* reportMissingModuleSource */];\n}\nexports.getStrictModeNotOverriddenRules = getStrictModeNotOverriddenRules;\nfunction getOffDiagnosticRuleSet() {\n    const diagSettings = {\n        printUnknownAsAny: true,\n        omitTypeArgsIfAny: true,\n        omitUnannotatedParamType: true,\n        pep604Printing: true,\n        strictListInference: false,\n        strictDictionaryInference: false,\n        strictParameterNoneValue: false,\n        enableTypeIgnoreComments: true,\n        reportGeneralTypeIssues: 'none',\n        reportMissingImports: 'warning',\n        reportMissingModuleSource: 'warning',\n        reportMissingTypeStubs: 'none',\n        reportImportCycles: 'none',\n        reportUnusedImport: 'none',\n        reportUnusedClass: 'none',\n        reportUnusedFunction: 'none',\n        reportUnusedVariable: 'none',\n        reportDuplicateImport: 'none',\n        reportOptionalSubscript: 'none',\n        reportOptionalMemberAccess: 'none',\n        reportOptionalCall: 'none',\n        reportOptionalIterable: 'none',\n        reportOptionalContextManager: 'none',\n        reportOptionalOperand: 'none',\n        reportUntypedFunctionDecorator: 'none',\n        reportUntypedClassDecorator: 'none',\n        reportUntypedBaseClass: 'none',\n        reportUntypedNamedTuple: 'none',\n        reportPrivateUsage: 'none',\n        reportConstantRedefinition: 'none',\n        reportIncompatibleMethodOverride: 'none',\n        reportIncompatibleVariableOverride: 'none',\n        reportInvalidStringEscapeSequence: 'none',\n        reportUnknownParameterType: 'none',\n        reportUnknownArgumentType: 'none',\n        reportUnknownLambdaType: 'none',\n        reportUnknownVariableType: 'none',\n        reportUnknownMemberType: 'none',\n        reportCallInDefaultInitializer: 'none',\n        reportUnnecessaryIsInstance: 'none',\n        reportUnnecessaryCast: 'none',\n        reportAssertAlwaysTrue: 'none',\n        reportSelfClsParameterName: 'none',\n        reportImplicitStringConcatenation: 'none',\n        reportUnboundVariable: 'warning',\n        reportUndefinedVariable: 'warning',\n        reportInvalidStubStatement: 'none',\n    };\n    return diagSettings;\n}\nexports.getOffDiagnosticRuleSet = getOffDiagnosticRuleSet;\nfunction getBasicDiagnosticRuleSet() {\n    const diagSettings = {\n        printUnknownAsAny: false,\n        omitTypeArgsIfAny: false,\n        omitUnannotatedParamType: true,\n        pep604Printing: true,\n        strictListInference: false,\n        strictDictionaryInference: false,\n        strictParameterNoneValue: false,\n        enableTypeIgnoreComments: true,\n        reportGeneralTypeIssues: 'error',\n        reportMissingImports: 'error',\n        reportMissingModuleSource: 'warning',\n        reportMissingTypeStubs: 'none',\n        reportImportCycles: 'none',\n        reportUnusedImport: 'none',\n        reportUnusedClass: 'none',\n        reportUnusedFunction: 'none',\n        reportUnusedVariable: 'none',\n        reportDuplicateImport: 'none',\n        reportOptionalSubscript: 'none',\n        reportOptionalMemberAccess: 'none',\n        reportOptionalCall: 'none',\n        reportOptionalIterable: 'none',\n        reportOptionalContextManager: 'none',\n        reportOptionalOperand: 'none',\n        reportUntypedFunctionDecorator: 'none',\n        reportUntypedClassDecorator: 'none',\n        reportUntypedBaseClass: 'none',\n        reportUntypedNamedTuple: 'none',\n        reportPrivateUsage: 'none',\n        reportConstantRedefinition: 'none',\n        reportIncompatibleMethodOverride: 'none',\n        reportIncompatibleVariableOverride: 'none',\n        reportInvalidStringEscapeSequence: 'warning',\n        reportUnknownParameterType: 'none',\n        reportUnknownArgumentType: 'none',\n        reportUnknownLambdaType: 'none',\n        reportUnknownVariableType: 'none',\n        reportUnknownMemberType: 'none',\n        reportCallInDefaultInitializer: 'none',\n        reportUnnecessaryIsInstance: 'none',\n        reportUnnecessaryCast: 'none',\n        reportAssertAlwaysTrue: 'warning',\n        reportSelfClsParameterName: 'warning',\n        reportImplicitStringConcatenation: 'none',\n        reportUnboundVariable: 'error',\n        reportUndefinedVariable: 'error',\n        reportInvalidStubStatement: 'none',\n    };\n    return diagSettings;\n}\nexports.getBasicDiagnosticRuleSet = getBasicDiagnosticRuleSet;\nfunction getStrictDiagnosticRuleSet() {\n    const diagSettings = {\n        printUnknownAsAny: false,\n        omitTypeArgsIfAny: false,\n        omitUnannotatedParamType: false,\n        pep604Printing: true,\n        strictListInference: true,\n        strictDictionaryInference: true,\n        strictParameterNoneValue: true,\n        enableTypeIgnoreComments: true,\n        reportGeneralTypeIssues: 'error',\n        reportMissingImports: 'error',\n        reportMissingModuleSource: 'warning',\n        reportMissingTypeStubs: 'error',\n        reportImportCycles: 'error',\n        reportUnusedImport: 'error',\n        reportUnusedClass: 'error',\n        reportUnusedFunction: 'error',\n        reportUnusedVariable: 'error',\n        reportDuplicateImport: 'error',\n        reportOptionalSubscript: 'error',\n        reportOptionalMemberAccess: 'error',\n        reportOptionalCall: 'error',\n        reportOptionalIterable: 'error',\n        reportOptionalContextManager: 'error',\n        reportOptionalOperand: 'error',\n        reportUntypedFunctionDecorator: 'error',\n        reportUntypedClassDecorator: 'error',\n        reportUntypedBaseClass: 'error',\n        reportUntypedNamedTuple: 'error',\n        reportPrivateUsage: 'error',\n        reportConstantRedefinition: 'error',\n        reportIncompatibleMethodOverride: 'error',\n        reportIncompatibleVariableOverride: 'error',\n        reportInvalidStringEscapeSequence: 'error',\n        reportUnknownParameterType: 'error',\n        reportUnknownArgumentType: 'error',\n        reportUnknownLambdaType: 'error',\n        reportUnknownVariableType: 'error',\n        reportUnknownMemberType: 'error',\n        reportCallInDefaultInitializer: 'none',\n        reportUnnecessaryIsInstance: 'error',\n        reportUnnecessaryCast: 'error',\n        reportAssertAlwaysTrue: 'error',\n        reportSelfClsParameterName: 'error',\n        reportImplicitStringConcatenation: 'none',\n        reportUnboundVariable: 'error',\n        reportUndefinedVariable: 'error',\n        reportInvalidStubStatement: 'error',\n    };\n    return diagSettings;\n}\nexports.getStrictDiagnosticRuleSet = getStrictDiagnosticRuleSet;\n// Internal configuration options. These are derived from a combination\n// of the command line and from a JSON-based config file.\nclass ConfigOptions {\n    constructor(projectRoot, typeCheckingMode) {\n        // A list of file specs to include in the analysis. Can contain\n        // directories, in which case all \"*.py\" files within those directories\n        // are included.\n        this.include = [];\n        // A list of file specs to exclude from the analysis (overriding include\n        // if necessary). Can contain directories, in which case all \"*.py\" files\n        // within those directories are included.\n        this.exclude = [];\n        // A list of file specs whose errors and warnings should be ignored even\n        // if they are included in the transitive closure of included files.\n        this.ignore = [];\n        // A list of file specs that should be analyzed using \"strict\" mode.\n        this.strict = [];\n        // Offer auto-import completions.\n        this.autoImportCompletions = true;\n        //---------------------------------------------------------------\n        // Parsing and Import Resolution Settings\n        // Parameters that specify the execution environment for\n        // the files being analyzed.\n        this.executionEnvironments = [];\n        this.projectRoot = projectRoot;\n        this.diagnosticRuleSet = ConfigOptions.getDiagnosticRuleSet(typeCheckingMode);\n    }\n    static getDiagnosticRuleSet(typeCheckingMode) {\n        if (typeCheckingMode === 'strict') {\n            return getStrictDiagnosticRuleSet();\n        }\n        if (typeCheckingMode === 'off') {\n            return getOffDiagnosticRuleSet();\n        }\n        return getBasicDiagnosticRuleSet();\n    }\n    // Finds the best execution environment for a given file path. The\n    // specified file path should be absolute.\n    // If no matching execution environment can be found, a default\n    // execution environment is used.\n    findExecEnvironment(filePath) {\n        let execEnv = this.executionEnvironments.find((env) => {\n            const envRoot = pathUtils_1.ensureTrailingDirectorySeparator(pathUtils_1.normalizePath(pathUtils_1.combinePaths(this.projectRoot, env.root)));\n            return filePath.startsWith(envRoot);\n        });\n        if (!execEnv) {\n            execEnv = new ExecutionEnvironment(this.projectRoot, this.defaultPythonVersion, this.defaultPythonPlatform);\n        }\n        return execEnv;\n    }\n    addExecEnvironmentForExtraPaths(fs, autoSearchPaths, extraPaths) {\n        const paths = [];\n        if (autoSearchPaths) {\n            // Auto-detect the common scenario where the sources are under the src folder\n            const srcPath = pathUtils_1.normalizePath(pathUtils_1.combinePaths(this.projectRoot, pathConsts.src));\n            if (fs.existsSync(srcPath) && !fs.existsSync(pathUtils_1.combinePaths(srcPath, '__init__.py'))) {\n                paths.push(srcPath);\n            }\n        }\n        if (extraPaths.length > 0) {\n            for (const p of extraPaths) {\n                paths.push(pathUtils_1.normalizePath(pathUtils_1.combinePaths(this.projectRoot, p)));\n            }\n        }\n        if (paths.length > 0) {\n            const execEnv = new ExecutionEnvironment(this.projectRoot, this.defaultPythonVersion, this.defaultPythonPlatform);\n            execEnv.extraPaths.push(...paths);\n            this.executionEnvironments.push(execEnv);\n        }\n    }\n    // Initialize the structure from a JSON object.\n    initializeFromJson(configObj, typeCheckingMode, console, diagnosticOverrides, pythonPath) {\n        // Read the \"include\" entry.\n        this.include = [];\n        if (configObj.include !== undefined) {\n            if (!Array.isArray(configObj.include)) {\n                console.info(`Config \"include\" entry must must contain an array.`);\n            }\n            else {\n                const filesList = configObj.include;\n                filesList.forEach((fileSpec, index) => {\n                    if (typeof fileSpec !== 'string') {\n                        console.info(`Index ${index} of \"include\" array should be a string.`);\n                    }\n                    else if (path_1.isAbsolute(fileSpec)) {\n                        console.info(`Ignoring path \"${fileSpec}\" in \"include\" array because it is not relative.`);\n                    }\n                    else {\n                        this.include.push(pathUtils_1.getFileSpec(this.projectRoot, fileSpec));\n                    }\n                });\n            }\n        }\n        // Read the \"exclude\" entry.\n        this.exclude = [];\n        if (configObj.exclude !== undefined) {\n            if (!Array.isArray(configObj.exclude)) {\n                console.info(`Config \"exclude\" entry must contain an array.`);\n            }\n            else {\n                const filesList = configObj.exclude;\n                filesList.forEach((fileSpec, index) => {\n                    if (typeof fileSpec !== 'string') {\n                        console.info(`Index ${index} of \"exclude\" array should be a string.`);\n                    }\n                    else if (path_1.isAbsolute(fileSpec)) {\n                        console.info(`Ignoring path \"${fileSpec}\" in \"exclude\" array because it is not relative.`);\n                    }\n                    else {\n                        this.exclude.push(pathUtils_1.getFileSpec(this.projectRoot, fileSpec));\n                    }\n                });\n            }\n        }\n        // Read the \"ignore\" entry.\n        this.ignore = [];\n        if (configObj.ignore !== undefined) {\n            if (!Array.isArray(configObj.ignore)) {\n                console.info(`Config \"ignore\" entry must contain an array.`);\n            }\n            else {\n                const filesList = configObj.ignore;\n                filesList.forEach((fileSpec, index) => {\n                    if (typeof fileSpec !== 'string') {\n                        console.info(`Index ${index} of \"ignore\" array should be a string.`);\n                    }\n                    else if (path_1.isAbsolute(fileSpec)) {\n                        console.info(`Ignoring path \"${fileSpec}\" in \"ignore\" array because it is not relative.`);\n                    }\n                    else {\n                        this.ignore.push(pathUtils_1.getFileSpec(this.projectRoot, fileSpec));\n                    }\n                });\n            }\n        }\n        // Read the \"strict\" entry.\n        this.strict = [];\n        if (configObj.strict !== undefined) {\n            if (!Array.isArray(configObj.strict)) {\n                console.info(`Config \"strict\" entry must contain an array.`);\n            }\n            else {\n                const filesList = configObj.strict;\n                filesList.forEach((fileSpec, index) => {\n                    if (typeof fileSpec !== 'string') {\n                        console.info(`Index ${index} of \"strict\" array should be a string.`);\n                    }\n                    else if (path_1.isAbsolute(fileSpec)) {\n                        console.info(`Ignoring path \"${fileSpec}\" in \"strict\" array because it is not relative.`);\n                    }\n                    else {\n                        this.strict.push(pathUtils_1.getFileSpec(this.projectRoot, fileSpec));\n                    }\n                });\n            }\n        }\n        // If there is a \"typeCheckingMode\", it can override the provided setting.\n        let configTypeCheckingMode;\n        if (configObj.typeCheckingMode !== undefined) {\n            if (configObj.typeCheckingMode === 'off' ||\n                configObj.typeCheckingMode === 'basic' ||\n                configObj.typeCheckingMode === 'strict') {\n                configTypeCheckingMode = configObj.typeCheckingMode;\n            }\n            else {\n                console.info(`Config \"typeCheckingMode\" entry must contain \"off\", \"basic\", or \"strict\".`);\n            }\n        }\n        const defaultSettings = ConfigOptions.getDiagnosticRuleSet(configTypeCheckingMode || typeCheckingMode);\n        // Apply host provided overrides first and then overrides from the config file\n        this.applyDiagnosticOverrides(diagnosticOverrides);\n        this.diagnosticRuleSet = {\n            printUnknownAsAny: defaultSettings.printUnknownAsAny,\n            omitTypeArgsIfAny: defaultSettings.omitTypeArgsIfAny,\n            omitUnannotatedParamType: defaultSettings.omitUnannotatedParamType,\n            pep604Printing: defaultSettings.pep604Printing,\n            // Use strict inference rules for list expressions?\n            strictListInference: this._convertBoolean(configObj.strictListInference, \"strictListInference\" /* strictListInference */, defaultSettings.strictListInference),\n            // Use strict inference rules for dictionary expressions?\n            strictDictionaryInference: this._convertBoolean(configObj.strictDictionaryInference, \"strictDictionaryInference\" /* strictDictionaryInference */, defaultSettings.strictDictionaryInference),\n            // Should a None default value imply that the parameter type\n            // is Optional?\n            strictParameterNoneValue: this._convertBoolean(configObj.strictParameterNoneValue, \"strictParameterNoneValue\" /* strictParameterNoneValue */, defaultSettings.strictParameterNoneValue),\n            // Should \"# type: ignore\" be honored?\n            enableTypeIgnoreComments: this._convertBoolean(configObj.enableTypeIgnoreComments, \"enableTypeIgnoreComments\" /* enableTypeIgnoreComments */, defaultSettings.enableTypeIgnoreComments),\n            // Read the \"reportGeneralTypeIssues\" entry.\n            reportGeneralTypeIssues: this._convertDiagnosticLevel(configObj.reportGeneralTypeIssues, \"reportGeneralTypeIssues\" /* reportGeneralTypeIssues */, defaultSettings.reportGeneralTypeIssues),\n            // Read the \"reportMissingImports\" entry.\n            reportMissingImports: this._convertDiagnosticLevel(configObj.reportMissingImports, \"reportMissingImports\" /* reportMissingImports */, defaultSettings.reportMissingImports),\n            // Read the \"reportUnusedImport\" entry.\n            reportUnusedImport: this._convertDiagnosticLevel(configObj.reportUnusedImport, \"reportUnusedImport\" /* reportUnusedImport */, defaultSettings.reportUnusedImport),\n            // Read the \"reportUnusedClass\" entry.\n            reportUnusedClass: this._convertDiagnosticLevel(configObj.reportUnusedClass, \"reportUnusedClass\" /* reportUnusedClass */, defaultSettings.reportUnusedClass),\n            // Read the \"reportUnusedFunction\" entry.\n            reportUnusedFunction: this._convertDiagnosticLevel(configObj.reportUnusedFunction, \"reportUnusedFunction\" /* reportUnusedFunction */, defaultSettings.reportUnusedFunction),\n            // Read the \"reportUnusedVariable\" entry.\n            reportUnusedVariable: this._convertDiagnosticLevel(configObj.reportUnusedVariable, \"reportUnusedVariable\" /* reportUnusedVariable */, defaultSettings.reportUnusedVariable),\n            // Read the \"reportDuplicateImport\" entry.\n            reportDuplicateImport: this._convertDiagnosticLevel(configObj.reportDuplicateImport, \"reportDuplicateImport\" /* reportDuplicateImport */, defaultSettings.reportDuplicateImport),\n            // Read the \"reportMissingModuleSource\" entry.\n            reportMissingModuleSource: this._convertDiagnosticLevel(configObj.reportMissingModuleSource, \"reportMissingModuleSource\" /* reportMissingModuleSource */, defaultSettings.reportMissingModuleSource),\n            // Read the \"reportMissingTypeStubs\" entry.\n            reportMissingTypeStubs: this._convertDiagnosticLevel(configObj.reportMissingTypeStubs, \"reportMissingTypeStubs\" /* reportMissingTypeStubs */, defaultSettings.reportMissingTypeStubs),\n            // Read the \"reportImportCycles\" entry.\n            reportImportCycles: this._convertDiagnosticLevel(configObj.reportImportCycles, \"reportImportCycles\" /* reportImportCycles */, defaultSettings.reportImportCycles),\n            // Read the \"reportOptionalSubscript\" entry.\n            reportOptionalSubscript: this._convertDiagnosticLevel(configObj.reportOptionalSubscript, \"reportOptionalSubscript\" /* reportOptionalSubscript */, defaultSettings.reportOptionalSubscript),\n            // Read the \"reportOptionalMemberAccess\" entry.\n            reportOptionalMemberAccess: this._convertDiagnosticLevel(configObj.reportOptionalMemberAccess, \"reportOptionalMemberAccess\" /* reportOptionalMemberAccess */, defaultSettings.reportOptionalMemberAccess),\n            // Read the \"reportOptionalCall\" entry.\n            reportOptionalCall: this._convertDiagnosticLevel(configObj.reportOptionalCall, \"reportOptionalCall\" /* reportOptionalCall */, defaultSettings.reportOptionalCall),\n            // Read the \"reportOptionalIterable\" entry.\n            reportOptionalIterable: this._convertDiagnosticLevel(configObj.reportOptionalIterable, \"reportOptionalIterable\" /* reportOptionalIterable */, defaultSettings.reportOptionalIterable),\n            // Read the \"reportOptionalContextManager\" entry.\n            reportOptionalContextManager: this._convertDiagnosticLevel(configObj.reportOptionalContextManager, \"reportOptionalContextManager\" /* reportOptionalContextManager */, defaultSettings.reportOptionalContextManager),\n            // Read the \"reportOptionalOperand\" entry.\n            reportOptionalOperand: this._convertDiagnosticLevel(configObj.reportOptionalOperand, \"reportOptionalOperand\" /* reportOptionalOperand */, defaultSettings.reportOptionalOperand),\n            // Read the \"reportUntypedFunctionDecorator\" entry.\n            reportUntypedFunctionDecorator: this._convertDiagnosticLevel(configObj.reportUntypedFunctionDecorator, \"reportUntypedFunctionDecorator\" /* reportUntypedFunctionDecorator */, defaultSettings.reportUntypedFunctionDecorator),\n            // Read the \"reportUntypedClassDecorator\" entry.\n            reportUntypedClassDecorator: this._convertDiagnosticLevel(configObj.reportUntypedClassDecorator, \"reportUntypedClassDecorator\" /* reportUntypedClassDecorator */, defaultSettings.reportUntypedClassDecorator),\n            // Read the \"reportUntypedBaseClass\" entry.\n            reportUntypedBaseClass: this._convertDiagnosticLevel(configObj.reportUntypedBaseClass, \"reportUntypedBaseClass\" /* reportUntypedBaseClass */, defaultSettings.reportUntypedBaseClass),\n            // Read the \"reportUntypedNamedTuple\" entry.\n            reportUntypedNamedTuple: this._convertDiagnosticLevel(configObj.reportUntypedNamedTuple, \"reportUntypedNamedTuple\" /* reportUntypedNamedTuple */, defaultSettings.reportUntypedNamedTuple),\n            // Read the \"reportPrivateUsage\" entry.\n            reportPrivateUsage: this._convertDiagnosticLevel(configObj.reportPrivateUsage, \"reportPrivateUsage\" /* reportPrivateUsage */, defaultSettings.reportPrivateUsage),\n            // Read the \"reportConstantRedefinition\" entry.\n            reportConstantRedefinition: this._convertDiagnosticLevel(configObj.reportConstantRedefinition, \"reportConstantRedefinition\" /* reportConstantRedefinition */, defaultSettings.reportConstantRedefinition),\n            // Read the \"reportIncompatibleMethodOverride\" entry.\n            reportIncompatibleMethodOverride: this._convertDiagnosticLevel(configObj.reportIncompatibleMethodOverride, \"reportIncompatibleMethodOverride\" /* reportIncompatibleMethodOverride */, defaultSettings.reportIncompatibleMethodOverride),\n            // Read the \"reportIncompatibleVariableOverride\" entry.\n            reportIncompatibleVariableOverride: this._convertDiagnosticLevel(configObj.reportIncompatibleVariableOverride, \"reportIncompatibleVariableOverride\" /* reportIncompatibleVariableOverride */, defaultSettings.reportIncompatibleVariableOverride),\n            // Read the \"reportInvalidStringEscapeSequence\" entry.\n            reportInvalidStringEscapeSequence: this._convertDiagnosticLevel(configObj.reportInvalidStringEscapeSequence, \"reportInvalidStringEscapeSequence\" /* reportInvalidStringEscapeSequence */, defaultSettings.reportInvalidStringEscapeSequence),\n            // Read the \"reportUnknownParameterType\" entry.\n            reportUnknownParameterType: this._convertDiagnosticLevel(configObj.reportUnknownParameterType, \"reportUnknownParameterType\" /* reportUnknownParameterType */, defaultSettings.reportUnknownParameterType),\n            // Read the \"reportUnknownArgumentType\" entry.\n            reportUnknownArgumentType: this._convertDiagnosticLevel(configObj.reportUnknownArgumentType, \"reportUnknownArgumentType\" /* reportUnknownArgumentType */, defaultSettings.reportUnknownArgumentType),\n            // Read the \"reportUnknownLambdaType\" entry.\n            reportUnknownLambdaType: this._convertDiagnosticLevel(configObj.reportUnknownLambdaType, \"reportUnknownLambdaType\" /* reportUnknownLambdaType */, defaultSettings.reportUnknownLambdaType),\n            // Read the \"reportUnknownVariableType\" entry.\n            reportUnknownVariableType: this._convertDiagnosticLevel(configObj.reportUnknownVariableType, \"reportUnknownVariableType\" /* reportUnknownVariableType */, defaultSettings.reportUnknownVariableType),\n            // Read the \"reportUnknownMemberType\" entry.\n            reportUnknownMemberType: this._convertDiagnosticLevel(configObj.reportUnknownMemberType, \"reportUnknownMemberType\" /* reportUnknownMemberType */, defaultSettings.reportUnknownMemberType),\n            // Read the \"reportCallInDefaultInitializer\" entry.\n            reportCallInDefaultInitializer: this._convertDiagnosticLevel(configObj.reportCallInDefaultInitializer, \"reportCallInDefaultInitializer\" /* reportCallInDefaultInitializer */, defaultSettings.reportCallInDefaultInitializer),\n            // Read the \"reportUnnecessaryIsInstance\" entry.\n            reportUnnecessaryIsInstance: this._convertDiagnosticLevel(configObj.reportUnnecessaryIsInstance, \"reportUnnecessaryIsInstance\" /* reportUnnecessaryIsInstance */, defaultSettings.reportUnnecessaryIsInstance),\n            // Read the \"reportUnnecessaryCast\" entry.\n            reportUnnecessaryCast: this._convertDiagnosticLevel(configObj.reportUnnecessaryCast, \"reportUnnecessaryCast\" /* reportUnnecessaryCast */, defaultSettings.reportUnnecessaryCast),\n            // Read the \"reportAssertAlwaysTrue\" entry.\n            reportAssertAlwaysTrue: this._convertDiagnosticLevel(configObj.reportAssertAlwaysTrue, \"reportAssertAlwaysTrue\" /* reportAssertAlwaysTrue */, defaultSettings.reportAssertAlwaysTrue),\n            // Read the \"reportSelfClsParameterName\" entry.\n            reportSelfClsParameterName: this._convertDiagnosticLevel(configObj.reportSelfClsParameterName, \"reportSelfClsParameterName\" /* reportSelfClsParameterName */, defaultSettings.reportSelfClsParameterName),\n            // Read the \"reportImplicitStringConcatenation\" entry.\n            reportImplicitStringConcatenation: this._convertDiagnosticLevel(configObj.reportImplicitStringConcatenation, \"reportImplicitStringConcatenation\" /* reportImplicitStringConcatenation */, defaultSettings.reportImplicitStringConcatenation),\n            // Read the \"reportUndefinedVariable\" entry.\n            reportUndefinedVariable: this._convertDiagnosticLevel(configObj.reportUndefinedVariable, \"reportUndefinedVariable\" /* reportUndefinedVariable */, defaultSettings.reportUndefinedVariable),\n            // Read the \"reportUnboundVariable\" entry.\n            reportUnboundVariable: this._convertDiagnosticLevel(configObj.reportUnboundVariable, \"reportUnboundVariable\" /* reportUnboundVariable */, defaultSettings.reportUnboundVariable),\n            // Read the \"reportInvalidStubStatement\" entry.\n            reportInvalidStubStatement: this._convertDiagnosticLevel(configObj.reportInvalidStubStatement, \"reportInvalidStubStatement\" /* reportInvalidStubStatement */, defaultSettings.reportInvalidStubStatement),\n        };\n        // Read the \"venvPath\".\n        this.venvPath = undefined;\n        if (configObj.venvPath !== undefined) {\n            if (typeof configObj.venvPath !== 'string') {\n                console.info(`Config \"venvPath\" field must contain a string.`);\n            }\n            else {\n                this.venvPath = pathUtils_1.normalizePath(pathUtils_1.combinePaths(this.projectRoot, configObj.venvPath));\n            }\n        }\n        // Read the default \"venv\".\n        this.defaultVenv = undefined;\n        if (configObj.venv !== undefined) {\n            if (typeof configObj.venv !== 'string') {\n                console.info(`Config \"venv\" field must contain a string.`);\n            }\n            else {\n                this.defaultVenv = configObj.venv;\n            }\n        }\n        // Read the default \"pythonVersion\".\n        this.defaultPythonVersion = undefined;\n        if (configObj.pythonVersion !== undefined) {\n            if (typeof configObj.pythonVersion === 'string') {\n                const version = pythonVersion_1.versionFromString(configObj.pythonVersion);\n                if (version) {\n                    this.defaultPythonVersion = version;\n                }\n                else {\n                    console.info(`Config \"pythonVersion\" field contains unsupported version.`);\n                }\n            }\n            else {\n                console.info(`Config \"pythonVersion\" field must contain a string.`);\n            }\n        }\n        this.ensureDefaultPythonVersion(pythonPath, console);\n        // Read the default \"pythonPlatform\".\n        this.defaultPythonPlatform = undefined;\n        if (configObj.pythonPlatform !== undefined) {\n            if (typeof configObj.pythonPlatform !== 'string') {\n                console.info(`Config \"pythonPlatform\" field must contain a string.`);\n            }\n            else {\n                this.defaultPythonPlatform = configObj.pythonPlatform;\n            }\n        }\n        this.ensureDefaultPythonPlatform(console);\n        // Read the \"typeshedPath\" setting.\n        this.typeshedPath = undefined;\n        if (configObj.typeshedPath !== undefined) {\n            if (typeof configObj.typeshedPath !== 'string') {\n                console.info(`Config \"typeshedPath\" field must contain a string.`);\n            }\n            else {\n                this.typeshedPath = configObj.typeshedPath\n                    ? pathUtils_1.normalizePath(pathUtils_1.combinePaths(this.projectRoot, configObj.typeshedPath))\n                    : '';\n            }\n        }\n        // Read the \"stubPath\" setting.\n        this.stubPath = undefined;\n        // Keep this for backward compatibility\n        if (configObj.typingsPath !== undefined) {\n            if (typeof configObj.typingsPath !== 'string') {\n                console.info(`Config \"typingsPath\" field must contain a string.`);\n            }\n            else {\n                console.info(`Config \"typingsPath\" is now deprecated. Please, use stubPath instead.`);\n                this.stubPath = pathUtils_1.normalizePath(pathUtils_1.combinePaths(this.projectRoot, configObj.typingsPath));\n            }\n        }\n        if (configObj.stubPath !== undefined) {\n            if (typeof configObj.stubPath !== 'string') {\n                console.info(`Config \"stubPath\" field must contain a string.`);\n            }\n            else {\n                this.stubPath = pathUtils_1.normalizePath(pathUtils_1.combinePaths(this.projectRoot, configObj.stubPath));\n            }\n        }\n        // Read the \"verboseOutput\" setting.\n        // Don't initialize to a default value because we want the command-line \"verbose\"\n        // switch to apply if this setting isn't specified in the config file.\n        if (configObj.verboseOutput !== undefined) {\n            if (typeof configObj.verboseOutput !== 'boolean') {\n                console.info(`Config \"verboseOutput\" field must be true or false.`);\n            }\n            else {\n                this.verboseOutput = configObj.verboseOutput;\n            }\n        }\n        // Read the \"useLibraryCodeForTypes\" setting.\n        if (configObj.useLibraryCodeForTypes !== undefined) {\n            if (typeof configObj.useLibraryCodeForTypes !== 'boolean') {\n                console.info(`Config \"useLibraryCodeForTypes\" field must be true or false.`);\n            }\n            else {\n                this.useLibraryCodeForTypes = configObj.useLibraryCodeForTypes;\n            }\n        }\n        // Read the \"executionEnvironments\" array. This should be done at the end\n        // after we've established default values.\n        this.executionEnvironments = [];\n        if (configObj.executionEnvironments !== undefined) {\n            if (!Array.isArray(configObj.executionEnvironments)) {\n                console.info(`Config \"executionEnvironments\" field must contain an array.`);\n            }\n            else {\n                const execEnvironments = configObj.executionEnvironments;\n                execEnvironments.forEach((env, index) => {\n                    const execEnv = this._initExecutionEnvironmentFromJson(env, index, console);\n                    if (execEnv) {\n                        this.executionEnvironments.push(execEnv);\n                    }\n                });\n            }\n        }\n        // Read the \"autoImportCompletions\" setting.\n        if (configObj.autoImportCompletions !== undefined) {\n            if (typeof configObj.autoImportCompletions !== 'boolean') {\n                console.info(`Config \"autoImportCompletions\" field must be true or false.`);\n            }\n            else {\n                this.autoImportCompletions = configObj.autoImportCompletions;\n            }\n        }\n    }\n    ensureDefaultPythonPlatform(console) {\n        // If no default python platform was specified, assume that the\n        // user wants to use the current platform.\n        if (this.defaultPythonPlatform !== undefined) {\n            return;\n        }\n        if (process.platform === 'darwin') {\n            this.defaultPythonPlatform = 'Darwin';\n        }\n        else if (process.platform === 'linux') {\n            this.defaultPythonPlatform = 'Linux';\n        }\n        else if (process.platform === 'win32') {\n            this.defaultPythonPlatform = 'Windows';\n        }\n        if (this.defaultPythonPlatform !== undefined) {\n            console.info(`Assuming Python platform ${this.defaultPythonPlatform}`);\n        }\n    }\n    ensureDefaultPythonVersion(pythonPath, console) {\n        // If no default python version was specified, retrieve the version\n        // from the currently-selected python interpreter.\n        if (this.defaultPythonVersion !== undefined) {\n            return;\n        }\n        this.defaultPythonVersion = this._getPythonVersionFromPythonInterpreter(pythonPath, console);\n        if (this.defaultPythonVersion !== undefined) {\n            console.info(`Assuming Python version ${pythonVersion_1.versionToString(this.defaultPythonVersion)}`);\n        }\n    }\n    applyDiagnosticOverrides(diagnosticSeverityOverrides) {\n        if (!diagnosticSeverityOverrides) {\n            return;\n        }\n        for (const [ruleName, severity] of Object.entries(diagnosticSeverityOverrides)) {\n            this.diagnosticRuleSet[ruleName] = severity;\n        }\n    }\n    _convertBoolean(value, fieldName, defaultValue) {\n        if (value === undefined) {\n            return defaultValue;\n        }\n        else if (typeof value === 'boolean') {\n            return value ? true : false;\n        }\n        console.log(`Config \"${fieldName}\" entry must be true or false.`);\n        return defaultValue;\n    }\n    _convertDiagnosticLevel(value, fieldName, defaultValue) {\n        if (value === undefined) {\n            return defaultValue;\n        }\n        else if (typeof value === 'boolean') {\n            return value ? 'error' : 'none';\n        }\n        else if (typeof value === 'string') {\n            if (value === 'error' || value === 'warning' || value === 'information' || value === 'none') {\n                return value;\n            }\n        }\n        console.log(`Config \"${fieldName}\" entry must be true, false, \"error\", \"warning\", \"information\" or \"none\".`);\n        return defaultValue;\n    }\n    _initExecutionEnvironmentFromJson(envObj, index, console) {\n        try {\n            const newExecEnv = new ExecutionEnvironment(this.projectRoot, this.defaultPythonVersion, this.defaultPythonPlatform);\n            // Validate the root.\n            if (envObj.root && typeof envObj.root === 'string') {\n                newExecEnv.root = pathUtils_1.normalizePath(pathUtils_1.combinePaths(this.projectRoot, envObj.root));\n            }\n            else {\n                console.info(`Config executionEnvironments index ${index}: missing root value.`);\n            }\n            // Validate the extraPaths.\n            if (envObj.extraPaths) {\n                if (!Array.isArray(envObj.extraPaths)) {\n                    console.info(`Config executionEnvironments index ${index}: extraPaths field must contain an array.`);\n                }\n                else {\n                    const pathList = envObj.extraPaths;\n                    pathList.forEach((path, pathIndex) => {\n                        if (typeof path !== 'string') {\n                            console.info(`Config executionEnvironments index ${index}:` +\n                                ` extraPaths field ${pathIndex} must be a string.`);\n                        }\n                        else {\n                            newExecEnv.extraPaths.push(pathUtils_1.normalizePath(pathUtils_1.combinePaths(this.projectRoot, path)));\n                        }\n                    });\n                }\n            }\n            // Validate the pythonVersion.\n            if (envObj.pythonVersion) {\n                if (typeof envObj.pythonVersion === 'string') {\n                    const version = pythonVersion_1.versionFromString(envObj.pythonVersion);\n                    if (version) {\n                        newExecEnv.pythonVersion = version;\n                    }\n                    else {\n                        console.info(`Config executionEnvironments index ${index} contains unsupported pythonVersion.`);\n                    }\n                }\n                else {\n                    console.info(`Config executionEnvironments index ${index} pythonVersion must be a string.`);\n                }\n            }\n            // Validate the pythonPlatform.\n            if (envObj.pythonPlatform) {\n                if (typeof envObj.pythonPlatform === 'string') {\n                    newExecEnv.pythonPlatform = envObj.pythonPlatform;\n                }\n                else {\n                    console.info(`Config executionEnvironments index ${index} pythonPlatform must be a string.`);\n                }\n            }\n            // Validate the venv.\n            if (envObj.venv) {\n                if (typeof envObj.venv === 'string') {\n                    newExecEnv.venv = envObj.venv;\n                }\n                else {\n                    console.info(`Config executionEnvironments index ${index} venv must be a string.`);\n                }\n            }\n            return newExecEnv;\n        }\n        catch (_a) {\n            console.info(`Config executionEnvironments index ${index} is not accessible.`);\n        }\n        return undefined;\n    }\n    _getPythonVersionFromPythonInterpreter(interpreterPath, console) {\n        try {\n            const commandLineArgs = [\n                '-c',\n                'import sys, json; json.dump(dict(major=sys.version_info[0], minor=sys.version_info[1]), sys.stdout)',\n            ];\n            let execOutput;\n            if (interpreterPath) {\n                execOutput = child_process.execFileSync(interpreterPath, commandLineArgs, { encoding: 'utf8' });\n            }\n            else {\n                execOutput = child_process.execFileSync('python', commandLineArgs, { encoding: 'utf8' });\n            }\n            const versionJson = JSON.parse(execOutput);\n            const version = pythonVersion_1.versionFromMajorMinor(versionJson.major, versionJson.minor);\n            if (version === undefined) {\n                console.info(`Python version ${versionJson.major}.${versionJson.minor} from interpreter is unsupported`);\n                return undefined;\n            }\n            return version;\n        }\n        catch (_a) {\n            console.info('Unable to get Python version from interpreter');\n            return undefined;\n        }\n    }\n}\nexports.ConfigOptions = ConfigOptions;\n\n\n//# sourceURL=webpack://pyright-server/./src/common/configOptions.ts?");

/***/ }),

/***/ "./src/common/console.ts":
/*!*******************************!*\
  !*** ./src/common/console.ts ***!
  \*******************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * console.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Provides an abstraction for console logging and error-reporting\n * methods.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.log = exports.ConsoleWithLogLevel = exports.StandardConsole = exports.NullConsole = exports.LogLevel = void 0;\nconst debug = __webpack_require__(/*! ./debug */ \"./src/common/debug.ts\");\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[\"Error\"] = \"error\";\n    LogLevel[\"Warn\"] = \"warn\";\n    LogLevel[\"Info\"] = \"info\";\n    LogLevel[\"Log\"] = \"log\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\n// Avoids outputting errors to the console but counts\n// the number of logs and errors, which can be useful\n// for unit tests.\nclass NullConsole {\n    constructor() {\n        this.logCount = 0;\n        this.infoCount = 0;\n        this.warnCount = 0;\n        this.errorCount = 0;\n    }\n    log(message) {\n        this.logCount++;\n    }\n    info(message) {\n        this.infoCount++;\n    }\n    warn(message) {\n        this.warnCount++;\n    }\n    error(message) {\n        this.errorCount++;\n    }\n}\nexports.NullConsole = NullConsole;\nclass StandardConsole {\n    log(message) {\n        console.info(message);\n    }\n    info(message) {\n        console.info(message);\n    }\n    warn(message) {\n        console.warn(message);\n    }\n    error(message) {\n        console.error(message);\n    }\n}\nexports.StandardConsole = StandardConsole;\nclass ConsoleWithLogLevel {\n    constructor(_console) {\n        this._console = _console;\n        this._levelMap = new Map([\n            [LogLevel.Error, 0],\n            [LogLevel.Warn, 1],\n            [LogLevel.Info, 2],\n            [LogLevel.Log, 3],\n        ]);\n        this._maxLevel = 2;\n    }\n    get level() {\n        switch (this._maxLevel) {\n            case 0:\n                return LogLevel.Error;\n            case 1:\n                return LogLevel.Warn;\n            case 2:\n                return LogLevel.Info;\n        }\n        return LogLevel.Log;\n    }\n    set level(value) {\n        let maxLevel = this._levelMap.get(value);\n        if (maxLevel === undefined) {\n            maxLevel = this._levelMap.get(LogLevel.Info);\n        }\n        this._maxLevel = maxLevel;\n    }\n    error(message) {\n        this._log(LogLevel.Error, message);\n    }\n    warn(message) {\n        this._log(LogLevel.Warn, message);\n    }\n    info(message) {\n        this._log(LogLevel.Info, message);\n    }\n    log(message) {\n        this._log(LogLevel.Log, message);\n    }\n    _log(level, message) {\n        if (this._getNumericalLevel(level) > this._maxLevel) {\n            return;\n        }\n        log(this._console, level, message);\n    }\n    _getNumericalLevel(level) {\n        const numericLevel = this._levelMap.get(level);\n        debug.assert(numericLevel !== undefined, 'Logger: unknown log level.');\n        return numericLevel !== undefined ? numericLevel : 2;\n    }\n}\nexports.ConsoleWithLogLevel = ConsoleWithLogLevel;\nfunction log(console, logType, msg) {\n    switch (logType) {\n        case LogLevel.Log:\n            console.log(msg);\n            break;\n        case LogLevel.Info:\n            console.info(msg);\n            break;\n        case LogLevel.Warn:\n            console.warn(msg);\n            break;\n        case LogLevel.Error:\n            console.error(msg);\n            break;\n        default:\n            debug.fail(`${logType} is not expected`);\n    }\n}\nexports.log = log;\n\n\n//# sourceURL=webpack://pyright-server/./src/common/console.ts?");

/***/ }),

/***/ "./src/common/core.ts":
/*!****************************!*\
  !*** ./src/common/core.ts ***!
  \****************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export compareComparableValues [provided] [no usage info] [missing usage info prevents renaming] */
/*! export compareValues [provided] [no usage info] [missing usage info prevents renaming] */
/*! export equateValues [provided] [no usage info] [missing usage info prevents renaming] */
/*! export hasProperty [provided] [no usage info] [missing usage info prevents renaming] */
/*! export identity [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isArray [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isDebugMode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isNumber [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isString [provided] [no usage info] [missing usage info prevents renaming] */
/*! export returnFalse [provided] [no usage info] [missing usage info prevents renaming] */
/*! export returnTrue [provided] [no usage info] [missing usage info prevents renaming] */
/*! export returnUndefined [provided] [no usage info] [missing usage info prevents renaming] */
/*! export toBoolean [provided] [no usage info] [missing usage info prevents renaming] */
/*! export toLowerCase [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * core.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Various helpers that don't have a dependency on other code files.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isDebugMode = exports.toBoolean = exports.hasProperty = exports.isNumber = exports.isString = exports.isArray = exports.compareValues = exports.compareComparableValues = exports.equateValues = exports.toLowerCase = exports.identity = exports.returnUndefined = exports.returnTrue = exports.returnFalse = void 0;\n/** Do nothing and return false */\nfunction returnFalse() {\n    return false;\n}\nexports.returnFalse = returnFalse;\n/** Do nothing and return true */\nfunction returnTrue() {\n    return true;\n}\nexports.returnTrue = returnTrue;\n/** Do nothing and return undefined */\nfunction returnUndefined() {\n    return undefined;\n}\nexports.returnUndefined = returnUndefined;\n/** Returns its argument. */\nfunction identity(x) {\n    return x;\n}\nexports.identity = identity;\n/** Returns lower case string */\nfunction toLowerCase(x) {\n    return x.toLowerCase();\n}\nexports.toLowerCase = toLowerCase;\nfunction equateValues(a, b) {\n    return a === b;\n}\nexports.equateValues = equateValues;\nfunction compareComparableValues(a, b) {\n    return a === b\n        ? 0 /* EqualTo */\n        : a === undefined\n            ? -1 /* LessThan */\n            : b === undefined\n                ? 1 /* GreaterThan */\n                : a < b\n                    ? -1 /* LessThan */\n                    : 1 /* GreaterThan */;\n}\nexports.compareComparableValues = compareComparableValues;\n/**\n * Compare two numeric values for their order relative to each other.\n * To compare strings, use any of the `compareStrings` functions.\n */\nfunction compareValues(a, b) {\n    return compareComparableValues(a, b);\n}\nexports.compareValues = compareValues;\n/**\n * Tests whether a value is an array.\n */\nfunction isArray(value) {\n    return Array.isArray ? Array.isArray(value) : value instanceof Array;\n}\nexports.isArray = isArray;\n/**\n * Tests whether a value is string\n */\nfunction isString(text) {\n    return typeof text === 'string';\n}\nexports.isString = isString;\nfunction isNumber(x) {\n    return typeof x === 'number';\n}\nexports.isNumber = isNumber;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Indicates whether a map-like contains an own property with the specified key.\n *\n * @param map A map-like.\n * @param key A property key.\n */\nfunction hasProperty(map, key) {\n    return hasOwnProperty.call(map, key);\n}\nexports.hasProperty = hasProperty;\n/**\n * Convert the given value to boolean\n * @param trueOrFalse string value 'true' or 'false'\n */\nfunction toBoolean(trueOrFalse) {\n    const normalized = trueOrFalse === null || trueOrFalse === void 0 ? void 0 : trueOrFalse.trim().toUpperCase();\n    if (normalized === 'TRUE') {\n        return true;\n    }\n    return false;\n}\nexports.toBoolean = toBoolean;\nfunction isDebugMode() {\n    const argv = process.execArgv.join();\n    return argv.includes('inspect') || argv.includes('debug');\n}\nexports.isDebugMode = isDebugMode;\n\n\n//# sourceURL=webpack://pyright-server/./src/common/core.ts?");

/***/ }),

/***/ "./src/common/debug.ts":
/*!*****************************!*\
  !*** ./src/common/debug.ts ***!
  \*****************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export assert [provided] [no usage info] [missing usage info prevents renaming] */
/*! export assertDefined [provided] [no usage info] [missing usage info prevents renaming] */
/*! export assertEachDefined [provided] [no usage info] [missing usage info prevents renaming] */
/*! export assertNever [provided] [no usage info] [missing usage info prevents renaming] */
/*! export fail [provided] [no usage info] [missing usage info prevents renaming] */
/*! export formatEnum [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getFunctionName [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * debug.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Helper functions that display user friendly debugging info.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.formatEnum = exports.getFunctionName = exports.assertNever = exports.assertEachDefined = exports.assertDefined = exports.fail = exports.assert = void 0;\nconst collectionUtils_1 = __webpack_require__(/*! ./collectionUtils */ \"./src/common/collectionUtils.ts\");\nconst core_1 = __webpack_require__(/*! ./core */ \"./src/common/core.ts\");\nfunction assert(expression, message, verboseDebugInfo, stackCrawlMark) {\n    if (!expression) {\n        if (verboseDebugInfo) {\n            message +=\n                '\\r\\nVerbose Debug Information: ' +\n                    (typeof verboseDebugInfo === 'string' ? verboseDebugInfo : verboseDebugInfo());\n        }\n        fail(message ? 'False expression: ' + message : 'False expression.', stackCrawlMark || assert);\n    }\n}\nexports.assert = assert;\nfunction fail(message, stackCrawlMark) {\n    // debugger;\n    const e = new Error(message ? `Debug Failure. ${message}` : 'Debug Failure.');\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(e, stackCrawlMark || fail);\n    }\n    throw e;\n}\nexports.fail = fail;\nfunction assertDefined(value, message) {\n    if (value === undefined || value === null) {\n        return fail(message);\n    }\n    return value;\n}\nexports.assertDefined = assertDefined;\nfunction assertEachDefined(value, message) {\n    for (const v of value) {\n        assertDefined(v, message);\n    }\n    return value;\n}\nexports.assertEachDefined = assertEachDefined;\nfunction assertNever(member, message = 'Illegal value:', stackCrawlMark) {\n    const detail = JSON.stringify(member);\n    return fail(`${message} ${detail}`, stackCrawlMark || assertNever);\n}\nexports.assertNever = assertNever;\nfunction getFunctionName(func) {\n    if (typeof func !== 'function') {\n        return '';\n    }\n    else if (core_1.hasProperty(func, 'name')) {\n        return func.name;\n    }\n    else {\n        const text = Function.prototype.toString.call(func);\n        const match = /^function\\s+([\\w$]+)\\s*\\(/.exec(text);\n        return match ? match[1] : '';\n    }\n}\nexports.getFunctionName = getFunctionName;\n/**\n * Formats an enum value as a string for debugging and debug assertions.\n */\nfunction formatEnum(value = 0, enumObject, isFlags) {\n    const members = getEnumMembers(enumObject);\n    if (value === 0) {\n        return members.length > 0 && members[0][0] === 0 ? members[0][1] : '0';\n    }\n    if (isFlags) {\n        let result = '';\n        let remainingFlags = value;\n        for (const [enumValue, enumName] of members) {\n            if (enumValue > value) {\n                break;\n            }\n            if (enumValue !== 0 && enumValue & value) {\n                result = `${result}${result ? '|' : ''}${enumName}`;\n                remainingFlags &= ~enumValue;\n            }\n        }\n        if (remainingFlags === 0) {\n            return result;\n        }\n    }\n    else {\n        for (const [enumValue, enumName] of members) {\n            if (enumValue === value) {\n                return enumName;\n            }\n        }\n    }\n    return value.toString();\n}\nexports.formatEnum = formatEnum;\nfunction getEnumMembers(enumObject) {\n    const result = [];\n    for (const name of Object.keys(enumObject)) {\n        const value = enumObject[name];\n        if (typeof value === 'number') {\n            result.push([value, name]);\n        }\n    }\n    return collectionUtils_1.stableSort(result, (x, y) => core_1.compareValues(x[0], y[0]));\n}\n\n\n//# sourceURL=webpack://pyright-server/./src/common/debug.ts?");

/***/ }),

/***/ "./src/common/deferred.ts":
/*!********************************!*\
  !*** ./src/common/deferred.ts ***!
  \********************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export createDeferred [provided] [no usage info] [missing usage info prevents renaming] */
/*! export createDeferredFrom [provided] [no usage info] [missing usage info prevents renaming] */
/*! export createDeferredFromPromise [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * deferred.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Promise utilities for async operations.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createDeferredFromPromise = exports.createDeferredFrom = exports.createDeferred = void 0;\nclass DeferredImpl {\n    constructor(scope = null) {\n        this.scope = scope;\n        this._resolved = false;\n        this._rejected = false;\n        this._promise = new Promise((res, rej) => {\n            this._resolve = res;\n            this._reject = rej;\n        });\n    }\n    resolve(_value) {\n        // eslint-disable-next-line prefer-rest-params\n        this._resolve.apply(this.scope ? this.scope : this, arguments);\n        this._resolved = true;\n    }\n    reject(_reason) {\n        // eslint-disable-next-line prefer-rest-params\n        this._reject.apply(this.scope ? this.scope : this, arguments);\n        this._rejected = true;\n    }\n    get promise() {\n        return this._promise;\n    }\n    get resolved() {\n        return this._resolved;\n    }\n    get rejected() {\n        return this._rejected;\n    }\n    get completed() {\n        return this._rejected || this._resolved;\n    }\n}\nfunction createDeferred(scope = null) {\n    return new DeferredImpl(scope);\n}\nexports.createDeferred = createDeferred;\nfunction createDeferredFrom(...promises) {\n    const deferred = createDeferred();\n    Promise.all(promises)\n        .then(deferred.resolve.bind(deferred))\n        .catch(deferred.reject.bind(deferred));\n    return deferred;\n}\nexports.createDeferredFrom = createDeferredFrom;\nfunction createDeferredFromPromise(promise) {\n    const deferred = createDeferred();\n    promise.then(deferred.resolve.bind(deferred)).catch(deferred.reject.bind(deferred));\n    return deferred;\n}\nexports.createDeferredFromPromise = createDeferredFromPromise;\n\n\n//# sourceURL=webpack://pyright-server/./src/common/deferred.ts?");

/***/ }),

/***/ "./src/common/diagnostic.ts":
/*!**********************************!*\
  !*** ./src/common/diagnostic.ts ***!
  \**********************************/
/*! flagged exports */
/*! export Diagnostic [provided] [no usage info] [missing usage info prevents renaming] */
/*! export DiagnosticAddendum [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export convertLevelToCategory [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * diagnostics.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Class that represents errors and warnings.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DiagnosticAddendum = exports.Diagnostic = exports.convertLevelToCategory = void 0;\nfunction convertLevelToCategory(level) {\n    switch (level) {\n        case 'error':\n            return 0 /* Error */;\n        case 'warning':\n            return 1 /* Warning */;\n        case 'information':\n            return 2 /* Information */;\n        default:\n            throw new Error(`${level} is not expected`);\n    }\n}\nexports.convertLevelToCategory = convertLevelToCategory;\n// Represents a single error or warning.\nclass Diagnostic {\n    constructor(category, message, range) {\n        this.category = category;\n        this.message = message;\n        this.range = range;\n        this._relatedInfo = [];\n    }\n    addAction(action) {\n        if (this._actions === undefined) {\n            this._actions = [action];\n        }\n        else {\n            this._actions.push(action);\n        }\n    }\n    getActions() {\n        return this._actions;\n    }\n    setRule(rule) {\n        this._rule = rule;\n    }\n    getRule() {\n        return this._rule;\n    }\n    addRelatedInfo(message, filePath, range) {\n        this._relatedInfo.push({ filePath, message, range });\n    }\n    getRelatedInfo() {\n        return this._relatedInfo;\n    }\n}\nexports.Diagnostic = Diagnostic;\n// Helps to build additional information that can be appended to a diagnostic\n// message. It supports hierarchical information and flexible formatting.\nclass DiagnosticAddendum {\n    constructor() {\n        this._messages = [];\n        this._childAddenda = [];\n    }\n    addMessage(message) {\n        this._messages.push(message);\n    }\n    // Create a new (nested) addendum to which messages can be added.\n    createAddendum() {\n        const newAddendum = new DiagnosticAddendum();\n        this.addAddendum(newAddendum);\n        return newAddendum;\n    }\n    getString(maxDepth = 5, maxLineCount = 5) {\n        let lines = this._getLinesRecursive(maxDepth);\n        if (lines.length > maxLineCount) {\n            lines = lines.slice(0, maxLineCount);\n            lines.push('...');\n        }\n        const text = lines.join('\\n');\n        if (text.length > 0) {\n            return '\\n' + text;\n        }\n        return '';\n    }\n    isEmpty() {\n        return this._getMessageCount() === 0;\n    }\n    addAddendum(addendum) {\n        this._childAddenda.push(addendum);\n    }\n    _getMessageCount() {\n        // Get the nested message count.\n        let messageCount = this._messages.length;\n        for (const diag of this._childAddenda) {\n            messageCount += diag._getMessageCount();\n        }\n        return messageCount;\n    }\n    _getLinesRecursive(maxDepth) {\n        if (maxDepth <= 0) {\n            return [];\n        }\n        const childLines = [];\n        for (const addendum of this._childAddenda) {\n            childLines.push(...addendum._getLinesRecursive(maxDepth - 1));\n        }\n        // Prepend indentation for readability. Skip if there are no\n        // messages at this level.\n        const extraSpace = this._messages.length > 0 ? '  ' : '';\n        return this._messages.concat(childLines).map((line) => extraSpace + line);\n    }\n}\nexports.DiagnosticAddendum = DiagnosticAddendum;\n\n\n//# sourceURL=webpack://pyright-server/./src/common/diagnostic.ts?");

/***/ }),

/***/ "./src/common/diagnosticSink.ts":
/*!**************************************!*\
  !*** ./src/common/diagnosticSink.ts ***!
  \**************************************/
/*! flagged exports */
/*! export DiagnosticSink [provided] [no usage info] [missing usage info prevents renaming] */
/*! export TextRangeDiagnosticSink [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * diagnostics.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Class that represents errors and warnings.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextRangeDiagnosticSink = exports.DiagnosticSink = void 0;\nconst diagnostic_1 = __webpack_require__(/*! ./diagnostic */ \"./src/common/diagnostic.ts\");\nconst positionUtils_1 = __webpack_require__(/*! ./positionUtils */ \"./src/common/positionUtils.ts\");\n// Creates and tracks a list of diagnostics.\nclass DiagnosticSink {\n    constructor(diagnostics) {\n        this._diagnosticList = diagnostics || [];\n        this._diagnosticMap = new Map();\n    }\n    fetchAndClear() {\n        const prevDiagnostics = this._diagnosticList;\n        this._diagnosticList = [];\n        this._diagnosticMap.clear();\n        return prevDiagnostics;\n    }\n    addError(message, range) {\n        return this.addDiagnostic(new diagnostic_1.Diagnostic(0 /* Error */, message, range));\n    }\n    addWarning(message, range) {\n        return this.addDiagnostic(new diagnostic_1.Diagnostic(1 /* Warning */, message, range));\n    }\n    addInformation(message, range) {\n        return this.addDiagnostic(new diagnostic_1.Diagnostic(2 /* Information */, message, range));\n    }\n    addUnusedCode(message, range, action) {\n        const diag = new diagnostic_1.Diagnostic(3 /* UnusedCode */, message, range);\n        if (action) {\n            diag.addAction(action);\n        }\n        return this.addDiagnostic(diag);\n    }\n    addDiagnostic(diag) {\n        // Create a unique key for the diagnostic to prevent\n        // adding duplicates.\n        const key = `${diag.range.start.line},${diag.range.start.character}-` +\n            `${diag.range.end.line}-${diag.range.end.character}:${diag.message.substr(0, 25)}}`;\n        if (!this._diagnosticMap.has(key)) {\n            this._diagnosticList.push(diag);\n            this._diagnosticMap.set(key, diag);\n        }\n        return diag;\n    }\n    addDiagnostics(diagsToAdd) {\n        this._diagnosticList.push(...diagsToAdd);\n    }\n    getErrors() {\n        return this._diagnosticList.filter((diag) => diag.category === 0 /* Error */);\n    }\n    getWarnings() {\n        return this._diagnosticList.filter((diag) => diag.category === 1 /* Warning */);\n    }\n}\nexports.DiagnosticSink = DiagnosticSink;\n// Specialized version of DiagnosticSink that works with TextRange objects\n// and converts text ranges to line and column numbers.\nclass TextRangeDiagnosticSink extends DiagnosticSink {\n    constructor(lines, diagnostics) {\n        super(diagnostics);\n        this._lines = lines;\n    }\n    addDiagnosticWithTextRange(level, message, range) {\n        const positionRange = positionUtils_1.convertOffsetsToRange(range.start, range.start + range.length, this._lines);\n        switch (level) {\n            case 'error':\n                return this.addError(message, positionRange);\n            case 'warning':\n                return this.addWarning(message, positionRange);\n            case 'information':\n                return this.addInformation(message, positionRange);\n            default:\n                throw new Error(`${level} is not expected value`);\n        }\n    }\n    addUnusedCodeWithTextRange(message, range, action) {\n        return this.addUnusedCode(message, positionUtils_1.convertOffsetsToRange(range.start, range.start + range.length, this._lines), action);\n    }\n}\nexports.TextRangeDiagnosticSink = TextRangeDiagnosticSink;\n\n\n//# sourceURL=webpack://pyright-server/./src/common/diagnosticSink.ts?");

/***/ }),

/***/ "./src/common/extensions.ts":
/*!**********************************!*\
  !*** ./src/common/extensions.ts ***!
  \**********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements:  */
/***/ (() => {

eval("/*\n * extensions.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Extension methods to various types.\n */\n/* eslint-disable @typescript-eslint/no-empty-function */\n// Explicitly tells that promise should be run asynchronously.\nPromise.prototype.ignoreErrors = function () {\n    this.catch(() => { });\n};\n\n\n//# sourceURL=webpack://pyright-server/./src/common/extensions.ts?");

/***/ }),

/***/ "./src/common/fileSystem.ts":
/*!**********************************!*\
  !*** ./src/common/fileSystem.ts ***!
  \**********************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export createFromRealFileSystem [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * fileSystem.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * A \"file system provider\" abstraction that allows us to swap out a\n * real file system implementation for a virtual (mocked) implementation\n * for testing.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createFromRealFileSystem = void 0;\n/* eslint-disable no-dupe-class-members */\n// * NOTE * except tests, this should be only file that import \"fs\"\nconst chokidar = __webpack_require__(/*! chokidar */ \"./node_modules/chokidar/index.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst console_1 = __webpack_require__(/*! ./console */ \"./src/common/console.ts\");\nconst deferred_1 = __webpack_require__(/*! ./deferred */ \"./src/common/deferred.ts\");\n// Callers can specify a different file watcher provider if desired.\n// By default, we'll use the file watcher based on chokidar.\nfunction createFromRealFileSystem(console, fileWatcherProvider) {\n    return new RealFileSystem(fileWatcherProvider !== null && fileWatcherProvider !== void 0 ? fileWatcherProvider : new ChokidarFileWatcherProvider(console !== null && console !== void 0 ? console : new console_1.NullConsole()));\n}\nexports.createFromRealFileSystem = createFromRealFileSystem;\nconst _isMacintosh = process.platform === 'darwin';\nconst _isLinux = process.platform === 'linux';\nclass RealFileSystem {\n    constructor(fileWatcherProvider) {\n        this._fileWatcherProvider = fileWatcherProvider;\n    }\n    existsSync(path) {\n        return fs.existsSync(path);\n    }\n    mkdirSync(path, options) {\n        fs.mkdirSync(path, options);\n    }\n    chdir(path) {\n        process.chdir(path);\n    }\n    readdirSync(path) {\n        return fs.readdirSync(path);\n    }\n    readdirEntriesSync(path) {\n        return fs.readdirSync(path, { withFileTypes: true });\n    }\n    readFileSync(path, encoding = null) {\n        return fs.readFileSync(path, { encoding });\n    }\n    writeFileSync(path, data, encoding) {\n        fs.writeFileSync(path, data, { encoding });\n    }\n    statSync(path) {\n        return fs.statSync(path);\n    }\n    unlinkSync(path) {\n        fs.unlinkSync(path);\n    }\n    realpathSync(path) {\n        return fs.realpathSync(path);\n    }\n    getModulePath() {\n        // The entry point to the tool should have set the __rootDirectory\n        // global variable to point to the directory that contains the\n        // typeshed-fallback directory.\n        return global.__rootDirectory;\n    }\n    createFileSystemWatcher(paths, listener) {\n        return this._fileWatcherProvider.createFileWatcher(paths, listener);\n    }\n    createReadStream(path) {\n        return fs.createReadStream(path);\n    }\n    createWriteStream(path) {\n        return fs.createWriteStream(path);\n    }\n    copyFileSync(src, dst) {\n        fs.copyFileSync(src, dst);\n    }\n    readFile(path) {\n        const d = deferred_1.createDeferred();\n        fs.readFile(path, (e, b) => {\n            if (e) {\n                d.reject(e);\n            }\n            else {\n                d.resolve(b);\n            }\n        });\n        return d.promise;\n    }\n    readFileText(path, encoding) {\n        const d = deferred_1.createDeferred();\n        fs.readFile(path, { encoding }, (e, s) => {\n            if (e) {\n                d.reject(e);\n            }\n            else {\n                d.resolve(s);\n            }\n        });\n        return d.promise;\n    }\n    tmpdir() {\n        return os.tmpdir();\n    }\n}\nclass ChokidarFileWatcherProvider {\n    constructor(_console) {\n        this._console = _console;\n    }\n    createFileWatcher(paths, listener) {\n        return this._createFileSystemWatcher(paths).on('all', listener);\n    }\n    createReadStream(path) {\n        return fs.createReadStream(path);\n    }\n    createWriteStream(path) {\n        return fs.createWriteStream(path);\n    }\n    _createFileSystemWatcher(paths) {\n        // The following options are copied from VS Code source base. It also\n        // uses chokidar for its file watching.\n        const watcherOptions = {\n            ignoreInitial: true,\n            ignorePermissionErrors: true,\n            followSymlinks: true,\n            interval: 1000,\n            binaryInterval: 1000,\n            disableGlobbing: true,\n        };\n        if (_isMacintosh) {\n            // Explicitly disable on MacOS because it uses up large amounts of memory\n            // and CPU for large file hierarchies, resulting in instability and crashes.\n            watcherOptions.usePolling = false;\n        }\n        const excludes = [];\n        if (_isMacintosh || _isLinux) {\n            if (paths.some((path) => path === '' || path === '/')) {\n                excludes.push('/dev/**');\n                if (_isLinux) {\n                    excludes.push('/proc/**', '/sys/**');\n                }\n            }\n        }\n        watcherOptions.ignored = excludes;\n        const watcher = chokidar.watch(paths, watcherOptions);\n        watcher.on('error', (_) => {\n            this._console.error('Error returned from file system watcher.');\n        });\n        // Detect if for some reason the native watcher library fails to load\n        if (_isMacintosh && !watcher.options.useFsEvents) {\n            this._console.info('Watcher could not use native fsevents library. File system watcher disabled.');\n        }\n        return watcher;\n    }\n    readFile(path) {\n        const d = deferred_1.createDeferred();\n        fs.readFile(path, (e, b) => {\n            if (e) {\n                d.reject(e);\n            }\n            else {\n                d.resolve(b);\n            }\n        });\n        return d.promise;\n    }\n    readFileText(path, encoding) {\n        const d = deferred_1.createDeferred();\n        fs.readFile(path, { encoding }, (e, s) => {\n            if (e) {\n                d.reject(e);\n            }\n            else {\n                d.resolve(s);\n            }\n        });\n        return d.promise;\n    }\n}\n\n\n//# sourceURL=webpack://pyright-server/./src/common/fileSystem.ts?");

/***/ }),

/***/ "./src/common/logTracker.ts":
/*!**********************************!*\
  !*** ./src/common/logTracker.ts ***!
  \**********************************/
/*! flagged exports */
/*! export LogTracker [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * logTracker.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * A simple logging class that can be used to track nested loggings.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogTracker = void 0;\nconst console_1 = __webpack_require__(/*! ./console */ \"./src/common/console.ts\");\nconst timing_1 = __webpack_require__(/*! ./timing */ \"./src/common/timing.ts\");\nclass LogTracker {\n    constructor(_console, _prefix) {\n        this._console = _console;\n        this._prefix = _prefix;\n        this._dummyState = new State();\n        this._indentation = '';\n        this._previousTitles = [];\n    }\n    log(title, callback) {\n        // If no console is given, don't do anything.\n        if (this._console === undefined) {\n            return callback(this._dummyState);\n        }\n        // This is enabled only when level is LogLevel.Log or does not exist.\n        const level = this._console.level;\n        if (level === undefined || level !== console_1.LogLevel.Log) {\n            return callback(this._dummyState);\n        }\n        // Since this is only used when LogLevel.Log is set or BG, we don't care much\n        // on extra logging cost.\n        const duration = new timing_1.Duration();\n        const current = this._indentation;\n        this._previousTitles.push(`${current}${title} ...`);\n        this._indentation += '  ';\n        const state = new State();\n        try {\n            return callback(state);\n        }\n        finally {\n            this._printPreviousTitles();\n            this._indentation = current;\n            this._console.log(`[${this._prefix}] ${this._indentation}${title}${state.get()} (${duration.getDurationInMilliseconds()}ms)`);\n        }\n    }\n    _printPreviousTitles() {\n        // Get rid of myself\n        this._previousTitles.pop();\n        if (this._previousTitles.length <= 0) {\n            return;\n        }\n        for (const previousTitle of this._previousTitles) {\n            this._console.log(`[${this._prefix}] ${previousTitle}`);\n        }\n        this._previousTitles.length = 0;\n    }\n}\nexports.LogTracker = LogTracker;\nclass State {\n    add(_addendum) {\n        this._addendum = _addendum;\n    }\n    get() {\n        if (this._addendum) {\n            return ` [${this._addendum}]`;\n        }\n        return '';\n    }\n}\n\n\n//# sourceURL=webpack://pyright-server/./src/common/logTracker.ts?");

/***/ }),

/***/ "./src/common/pathConsts.ts":
/*!**********************************!*\
  !*** ./src/common/pathConsts.ts ***!
  \**********************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export lib [provided] [no usage info] [missing usage info prevents renaming] */
/*! export sitePackages [provided] [no usage info] [missing usage info prevents renaming] */
/*! export src [provided] [no usage info] [missing usage info prevents renaming] */
/*! export typeshedFallback [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * pathConsts.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Path-related constants.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.src = exports.sitePackages = exports.lib = exports.typeshedFallback = void 0;\nexports.typeshedFallback = 'typeshed-fallback';\nexports.lib = 'lib';\nexports.sitePackages = 'site-packages';\nexports.src = 'src';\n\n\n//# sourceURL=webpack://pyright-server/./src/common/pathConsts.ts?");

/***/ }),

/***/ "./src/common/pathUtils.ts":
/*!*********************************!*\
  !*** ./src/common/pathUtils.ts ***!
  \*********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * pathUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Pathname utility functions.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isFileSystemCaseSensitiveInternal = exports.isFileSystemCaseSensitive = exports.convertPathToUri = exports.convertUriToPath = exports.isDiskPathRoot = exports.isRootedDiskPath = exports.getRegexEscapedSeparator = exports.getFileSpec = exports.getWildcardRoot = exports.getWildcardRegexPattern = exports.getFileSystemEntries = exports.isFile = exports.isDirectory = exports.normalizePath = exports.stripFileExtension = exports.getFileName = exports.getFileExtension = exports.stripTrailingDirectorySeparator = exports.hasTrailingDirectorySeparator = exports.ensureTrailingDirectorySeparator = exports.comparePathsCaseInsensitive = exports.comparePathsCaseSensitive = exports.getRelativePathComponentsFromDirectory = exports.getRelativePathFromDirectory = exports.getBaseFileName = exports.getAnyExtensionFromPath = exports.changeAnyExtension = exports.containsPath = exports.comparePaths = exports.combinePaths = exports.resolvePaths = exports.normalizeSlashes = exports.directoryExists = exports.fileExists = exports.getFileSize = exports.makeDirectories = exports.getRelativePath = exports.combinePathComponents = exports.reducePathComponents = exports.getPathComponents = exports.getRootLength = exports.getDirectoryPath = exports.forEachAncestorDirectory = exports.FileSpec = void 0;\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst collectionUtils_1 = __webpack_require__(/*! ./collectionUtils */ \"./src/common/collectionUtils.ts\");\nconst core_1 = __webpack_require__(/*! ./core */ \"./src/common/core.ts\");\nconst debug = __webpack_require__(/*! ./debug */ \"./src/common/debug.ts\");\nconst stringUtils_1 = __webpack_require__(/*! ./stringUtils */ \"./src/common/stringUtils.ts\");\nvar FileSpec;\n(function (FileSpec) {\n    function is(value) {\n        const candidate = value;\n        return candidate && !!candidate.wildcardRoot && !!candidate.regExp;\n    }\n    FileSpec.is = is;\n})(FileSpec = exports.FileSpec || (exports.FileSpec = {}));\nfunction forEachAncestorDirectory(directory, callback) {\n    while (true) {\n        const result = callback(directory);\n        if (result !== undefined) {\n            return result;\n        }\n        const parentPath = getDirectoryPath(directory);\n        if (parentPath === directory) {\n            return undefined;\n        }\n        directory = parentPath;\n    }\n}\nexports.forEachAncestorDirectory = forEachAncestorDirectory;\nfunction getDirectoryPath(pathString) {\n    return pathString.substr(0, Math.max(getRootLength(pathString), pathString.lastIndexOf(path.sep)));\n}\nexports.getDirectoryPath = getDirectoryPath;\nfunction getRootLength(pathString) {\n    if (pathString.charAt(0) === path.sep) {\n        if (pathString.charAt(1) !== path.sep) {\n            return 1;\n        }\n        const p1 = pathString.indexOf(path.sep, 2);\n        if (p1 < 0) {\n            return 2;\n        }\n        const p2 = pathString.indexOf(path.sep, p1 + 1);\n        if (p2 < 0) {\n            return p1 + 1;\n        }\n        return p2 + 1;\n    }\n    if (pathString.charAt(1) === ':') {\n        if (pathString.charAt(2) === path.sep) {\n            return 3;\n        }\n    }\n    return 0;\n}\nexports.getRootLength = getRootLength;\nfunction getPathComponents(pathString) {\n    const normalizedPath = normalizeSlashes(pathString);\n    const rootLength = getRootLength(normalizedPath);\n    const root = normalizedPath.substring(0, rootLength);\n    const rest = normalizedPath.substring(rootLength).split(path.sep);\n    if (rest.length > 0 && !rest[rest.length - 1]) {\n        rest.pop();\n    }\n    return reducePathComponents([root, ...rest]);\n}\nexports.getPathComponents = getPathComponents;\nfunction reducePathComponents(components) {\n    if (!collectionUtils_1.some(components)) {\n        return [];\n    }\n    // Reduce the path components by eliminating\n    // any '.' or '..'.\n    const reduced = [components[0]];\n    for (let i = 1; i < components.length; i++) {\n        const component = components[i];\n        if (!component || component === '.') {\n            continue;\n        }\n        if (component === '..') {\n            if (reduced.length > 1) {\n                if (reduced[reduced.length - 1] !== '..') {\n                    reduced.pop();\n                    continue;\n                }\n            }\n            else if (reduced[0]) {\n                continue;\n            }\n        }\n        reduced.push(component);\n    }\n    return reduced;\n}\nexports.reducePathComponents = reducePathComponents;\nfunction combinePathComponents(components) {\n    if (components.length === 0) {\n        return '';\n    }\n    const root = components[0] && ensureTrailingDirectorySeparator(components[0]);\n    return normalizeSlashes(root + components.slice(1).join(path.sep));\n}\nexports.combinePathComponents = combinePathComponents;\nfunction getRelativePath(dirPath, relativeTo) {\n    if (!dirPath.startsWith(ensureTrailingDirectorySeparator(relativeTo))) {\n        return undefined;\n    }\n    const pathComponents = getPathComponents(dirPath);\n    const relativeToComponents = getPathComponents(relativeTo);\n    let relativePath = '.';\n    for (let i = relativeToComponents.length; i < pathComponents.length; i++) {\n        relativePath += path.sep + pathComponents[i];\n    }\n    return relativePath;\n}\nexports.getRelativePath = getRelativePath;\n// Creates a directory hierarchy for a path, starting from some ancestor path.\nfunction makeDirectories(fs, dirPath, startingFromDirPath) {\n    if (!dirPath.startsWith(startingFromDirPath)) {\n        return;\n    }\n    const pathComponents = getPathComponents(dirPath);\n    const relativeToComponents = getPathComponents(startingFromDirPath);\n    let curPath = startingFromDirPath;\n    for (let i = relativeToComponents.length; i < pathComponents.length; i++) {\n        curPath = combinePaths(curPath, pathComponents[i]);\n        if (!fs.existsSync(curPath)) {\n            fs.mkdirSync(curPath);\n        }\n    }\n}\nexports.makeDirectories = makeDirectories;\nfunction getFileSize(fs, path) {\n    try {\n        const stat = fs.statSync(path);\n        if (stat.isFile()) {\n            return stat.size;\n        }\n    }\n    catch (_a) {\n        // Ignore the exception.\n    }\n    return 0;\n}\nexports.getFileSize = getFileSize;\nfunction fileExists(fs, path) {\n    return fileSystemEntryExists(fs, path, 0 /* File */);\n}\nexports.fileExists = fileExists;\nfunction directoryExists(fs, path) {\n    return fileSystemEntryExists(fs, path, 1 /* Directory */);\n}\nexports.directoryExists = directoryExists;\nfunction normalizeSlashes(pathString) {\n    const separatorRegExp = /[\\\\/]/g;\n    return pathString.replace(separatorRegExp, path.sep);\n}\nexports.normalizeSlashes = normalizeSlashes;\n/**\n * Combines and resolves paths. If a path is absolute, it replaces any previous path. Any\n * `.` and `..` path components are resolved. Trailing directory separators are preserved.\n *\n * ```ts\n * resolvePath(\"/path\", \"to\", \"file.ext\") === \"path/to/file.ext\"\n * resolvePath(\"/path\", \"to\", \"file.ext/\") === \"path/to/file.ext/\"\n * resolvePath(\"/path\", \"dir\", \"..\", \"to\", \"file.ext\") === \"path/to/file.ext\"\n * ```\n */\nfunction resolvePaths(path, ...paths) {\n    return normalizePath(collectionUtils_1.some(paths) ? combinePaths(path, ...paths) : normalizeSlashes(path));\n}\nexports.resolvePaths = resolvePaths;\nfunction combinePaths(pathString, ...paths) {\n    if (pathString) {\n        pathString = normalizeSlashes(pathString);\n    }\n    for (let relativePath of paths) {\n        if (!relativePath) {\n            continue;\n        }\n        relativePath = normalizeSlashes(relativePath);\n        if (!pathString || getRootLength(relativePath) !== 0) {\n            pathString = relativePath;\n        }\n        else {\n            pathString = ensureTrailingDirectorySeparator(pathString) + relativePath;\n        }\n    }\n    return pathString;\n}\nexports.combinePaths = combinePaths;\nfunction comparePaths(a, b, currentDirectory, ignoreCase) {\n    a = normalizePath(a);\n    b = normalizePath(b);\n    if (typeof currentDirectory === 'string') {\n        a = combinePaths(currentDirectory, a);\n        b = combinePaths(currentDirectory, b);\n    }\n    else if (typeof currentDirectory === 'boolean') {\n        ignoreCase = currentDirectory;\n    }\n    return comparePathsWorker(a, b, stringUtils_1.getStringComparer(ignoreCase));\n}\nexports.comparePaths = comparePaths;\nfunction containsPath(parent, child, currentDirectory, ignoreCase) {\n    if (typeof currentDirectory === 'string') {\n        parent = combinePaths(currentDirectory, parent);\n        child = combinePaths(currentDirectory, child);\n    }\n    else if (typeof currentDirectory === 'boolean') {\n        ignoreCase = currentDirectory;\n    }\n    if (parent === undefined || child === undefined) {\n        return false;\n    }\n    if (parent === child) {\n        return true;\n    }\n    const parentComponents = getPathComponents(parent);\n    const childComponents = getPathComponents(child);\n    if (childComponents.length < parentComponents.length) {\n        return false;\n    }\n    const componentEqualityComparer = ignoreCase ? stringUtils_1.equateStringsCaseInsensitive : stringUtils_1.equateStringsCaseSensitive;\n    for (let i = 0; i < parentComponents.length; i++) {\n        const equalityComparer = i === 0 ? stringUtils_1.equateStringsCaseInsensitive : componentEqualityComparer;\n        if (!equalityComparer(parentComponents[i], childComponents[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.containsPath = containsPath;\nfunction changeAnyExtension(path, ext, extensions, ignoreCase) {\n    const pathExt = extensions !== undefined && ignoreCase !== undefined\n        ? getAnyExtensionFromPath(path, extensions, ignoreCase)\n        : getAnyExtensionFromPath(path);\n    return pathExt ? path.slice(0, path.length - pathExt.length) + (ext.startsWith('.') ? ext : '.' + ext) : path;\n}\nexports.changeAnyExtension = changeAnyExtension;\nfunction getAnyExtensionFromPath(path, extensions, ignoreCase) {\n    // Retrieves any string from the final \".\" onwards from a base file name.\n    // Unlike extensionFromPath, which throws an exception on unrecognized extensions.\n    if (extensions) {\n        return getAnyExtensionFromPathWorker(stripTrailingDirectorySeparator(path), extensions, ignoreCase ? stringUtils_1.equateStringsCaseInsensitive : stringUtils_1.equateStringsCaseSensitive);\n    }\n    const baseFileName = getBaseFileName(path);\n    const extensionIndex = baseFileName.lastIndexOf('.');\n    if (extensionIndex >= 0) {\n        return baseFileName.substring(extensionIndex);\n    }\n    return '';\n}\nexports.getAnyExtensionFromPath = getAnyExtensionFromPath;\nfunction getBaseFileName(pathString, extensions, ignoreCase) {\n    pathString = normalizeSlashes(pathString);\n    // if the path provided is itself the root, then it has not file name.\n    const rootLength = getRootLength(pathString);\n    if (rootLength === pathString.length) {\n        return '';\n    }\n    // return the trailing portion of the path starting after the last (non-terminal) directory\n    // separator but not including any trailing directory separator.\n    pathString = stripTrailingDirectorySeparator(pathString);\n    const name = pathString.slice(Math.max(getRootLength(pathString), pathString.lastIndexOf(path.sep) + 1));\n    const extension = extensions !== undefined && ignoreCase !== undefined\n        ? getAnyExtensionFromPath(name, extensions, ignoreCase)\n        : undefined;\n    return extension ? name.slice(0, name.length - extension.length) : name;\n}\nexports.getBaseFileName = getBaseFileName;\nfunction getRelativePathFromDirectory(fromDirectory, to, getCanonicalFileNameOrIgnoreCase) {\n    const pathComponents = getRelativePathComponentsFromDirectory(fromDirectory, to, getCanonicalFileNameOrIgnoreCase);\n    return combinePathComponents(pathComponents);\n}\nexports.getRelativePathFromDirectory = getRelativePathFromDirectory;\nfunction getRelativePathComponentsFromDirectory(fromDirectory, to, getCanonicalFileNameOrIgnoreCase) {\n    debug.assert(getRootLength(fromDirectory) > 0 === getRootLength(to) > 0, 'Paths must either both be absolute or both be relative');\n    const getCanonicalFileName = typeof getCanonicalFileNameOrIgnoreCase === 'function' ? getCanonicalFileNameOrIgnoreCase : core_1.identity;\n    const ignoreCase = typeof getCanonicalFileNameOrIgnoreCase === 'boolean' ? getCanonicalFileNameOrIgnoreCase : false;\n    const pathComponents = getPathComponentsRelativeTo(fromDirectory, to, ignoreCase ? stringUtils_1.equateStringsCaseInsensitive : stringUtils_1.equateStringsCaseSensitive, getCanonicalFileName);\n    return pathComponents;\n}\nexports.getRelativePathComponentsFromDirectory = getRelativePathComponentsFromDirectory;\n/**\n * Performs a case-sensitive comparison of two paths. Path roots are always compared case-insensitively.\n */\nfunction comparePathsCaseSensitive(a, b) {\n    return comparePathsWorker(a, b, stringUtils_1.compareStringsCaseSensitive);\n}\nexports.comparePathsCaseSensitive = comparePathsCaseSensitive;\n/**\n * Performs a case-insensitive comparison of two paths.\n */\nfunction comparePathsCaseInsensitive(a, b) {\n    return comparePathsWorker(a, b, stringUtils_1.compareStringsCaseInsensitive);\n}\nexports.comparePathsCaseInsensitive = comparePathsCaseInsensitive;\nfunction ensureTrailingDirectorySeparator(pathString) {\n    if (!hasTrailingDirectorySeparator(pathString)) {\n        return pathString + path.sep;\n    }\n    return pathString;\n}\nexports.ensureTrailingDirectorySeparator = ensureTrailingDirectorySeparator;\nfunction hasTrailingDirectorySeparator(pathString) {\n    if (pathString.length === 0) {\n        return false;\n    }\n    const ch = pathString.charCodeAt(pathString.length - 1);\n    return ch === 47 /* Slash */ || ch === 92 /* Backslash */;\n}\nexports.hasTrailingDirectorySeparator = hasTrailingDirectorySeparator;\nfunction stripTrailingDirectorySeparator(pathString) {\n    if (!hasTrailingDirectorySeparator(pathString)) {\n        return pathString;\n    }\n    return pathString.substr(0, pathString.length - 1);\n}\nexports.stripTrailingDirectorySeparator = stripTrailingDirectorySeparator;\nfunction getFileExtension(fileName, multiDotExtension = false) {\n    if (!multiDotExtension) {\n        return path.extname(fileName);\n    }\n    fileName = getFileName(fileName);\n    const firstDotIndex = fileName.indexOf('.');\n    return fileName.substr(firstDotIndex);\n}\nexports.getFileExtension = getFileExtension;\nfunction getFileName(pathString) {\n    return path.basename(pathString);\n}\nexports.getFileName = getFileName;\nfunction stripFileExtension(fileName, multiDotExtension = false) {\n    const ext = getFileExtension(fileName, multiDotExtension);\n    return fileName.substr(0, fileName.length - ext.length);\n}\nexports.stripFileExtension = stripFileExtension;\nfunction normalizePath(pathString) {\n    return normalizeSlashes(path.normalize(pathString));\n}\nexports.normalizePath = normalizePath;\nfunction isDirectory(fs, path) {\n    let stat;\n    try {\n        stat = fs.statSync(path);\n    }\n    catch (e) {\n        return false;\n    }\n    return stat.isDirectory();\n}\nexports.isDirectory = isDirectory;\nfunction isFile(fs, path) {\n    let stat;\n    try {\n        stat = fs.statSync(path);\n    }\n    catch (e) {\n        return false;\n    }\n    return stat.isFile();\n}\nexports.isFile = isFile;\nfunction getFileSystemEntries(fs, path) {\n    try {\n        const entries = fs.readdirEntriesSync(path || '.').sort((a, b) => {\n            if (a.name < b.name) {\n                return -1;\n            }\n            else if (a.name > b.name) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        });\n        const files = [];\n        const directories = [];\n        for (const entry of entries) {\n            // This is necessary because on some file system node fails to exclude\n            // \".\" and \"..\". See https://github.com/nodejs/node/issues/4002\n            if (entry.name === '.' || entry.name === '..') {\n                continue;\n            }\n            if (entry.isFile()) {\n                files.push(entry.name);\n            }\n            else if (entry.isDirectory()) {\n                // Don't traverse symbolic links. They can lead to cycles.\n                if (!entry.isSymbolicLink()) {\n                    directories.push(entry.name);\n                }\n            }\n        }\n        return { files, directories };\n    }\n    catch (e) {\n        return { files: [], directories: [] };\n    }\n}\nexports.getFileSystemEntries = getFileSystemEntries;\n// Transforms a relative file spec (one that potentially contains\n// escape characters **, * or ?) and returns a regular expression\n// that can be used for matching against.\nfunction getWildcardRegexPattern(rootPath, fileSpec) {\n    let absolutePath = normalizePath(combinePaths(rootPath, fileSpec));\n    if (!absolutePath.endsWith('.py') && !absolutePath.endsWith('.pyi')) {\n        absolutePath = ensureTrailingDirectorySeparator(absolutePath);\n    }\n    const pathComponents = getPathComponents(absolutePath);\n    const escapedSeparator = getRegexEscapedSeparator();\n    const doubleAsteriskRegexFragment = `(${escapedSeparator}[^${escapedSeparator}.][^${escapedSeparator}]*)*?`;\n    const reservedCharacterPattern = new RegExp(`[^\\\\w\\\\s${escapedSeparator}]`, 'g');\n    // Strip the directory separator from the root component.\n    if (pathComponents.length > 0) {\n        pathComponents[0] = stripTrailingDirectorySeparator(pathComponents[0]);\n    }\n    let regExPattern = '';\n    let firstComponent = true;\n    for (let component of pathComponents) {\n        if (component === '**') {\n            regExPattern += doubleAsteriskRegexFragment;\n        }\n        else {\n            if (!firstComponent) {\n                component = escapedSeparator + component;\n            }\n            regExPattern += component.replace(reservedCharacterPattern, (match) => {\n                if (match === '*') {\n                    return `[^${escapedSeparator}]*`;\n                }\n                else if (match === '?') {\n                    return `[^${escapedSeparator}]`;\n                }\n                else {\n                    // escaping anything that is not reserved characters - word/space/separator\n                    return '\\\\' + match;\n                }\n            });\n            firstComponent = false;\n        }\n    }\n    return regExPattern;\n}\nexports.getWildcardRegexPattern = getWildcardRegexPattern;\n// Returns the topmost path that contains no wildcard characters.\nfunction getWildcardRoot(rootPath, fileSpec) {\n    let absolutePath = normalizePath(combinePaths(rootPath, fileSpec));\n    if (!absolutePath.endsWith('.py') && !absolutePath.endsWith('.pyi')) {\n        absolutePath = ensureTrailingDirectorySeparator(absolutePath);\n    }\n    const pathComponents = getPathComponents(absolutePath);\n    // Strip the directory separator from the root component.\n    if (pathComponents.length > 0) {\n        pathComponents[0] = stripTrailingDirectorySeparator(pathComponents[0]);\n    }\n    let wildcardRoot = '';\n    let firstComponent = true;\n    for (let component of pathComponents) {\n        if (component === '**') {\n            break;\n        }\n        else {\n            if (component.match(/[*?]/)) {\n                break;\n            }\n            if (!firstComponent) {\n                component = path.sep + component;\n            }\n            wildcardRoot += component;\n            firstComponent = false;\n        }\n    }\n    return wildcardRoot;\n}\nexports.getWildcardRoot = getWildcardRoot;\nfunction getFileSpec(rootPath, fileSpec) {\n    let regExPattern = getWildcardRegexPattern(rootPath, fileSpec);\n    const escapedSeparator = getRegexEscapedSeparator();\n    regExPattern = `^(${regExPattern})($|${escapedSeparator})`;\n    const regExp = new RegExp(regExPattern);\n    const wildcardRoot = getWildcardRoot(rootPath, fileSpec);\n    return {\n        wildcardRoot,\n        regExp,\n    };\n}\nexports.getFileSpec = getFileSpec;\nfunction getRegexEscapedSeparator() {\n    // we don't need to escape \"/\" in typescript regular expression\n    return path.sep === '/' ? '/' : '\\\\\\\\';\n}\nexports.getRegexEscapedSeparator = getRegexEscapedSeparator;\n/**\n * Determines whether a path is an absolute disk path (e.g. starts with `/`, or a dos path\n * like `c:`, `c:\\` or `c:/`).\n */\nfunction isRootedDiskPath(path) {\n    return getRootLength(path) > 0;\n}\nexports.isRootedDiskPath = isRootedDiskPath;\n/**\n * Determines whether a path consists only of a path root.\n */\nfunction isDiskPathRoot(path) {\n    const rootLength = getRootLength(path);\n    return rootLength > 0 && rootLength === path.length;\n}\nexports.isDiskPathRoot = isDiskPathRoot;\n//// Path Comparisons\nfunction comparePathsWorker(a, b, componentComparer) {\n    if (a === b) {\n        return 0 /* EqualTo */;\n    }\n    if (a === undefined) {\n        return -1 /* LessThan */;\n    }\n    if (b === undefined) {\n        return 1 /* GreaterThan */;\n    }\n    // NOTE: Performance optimization - shortcut if the root segments differ as there would be no\n    //       need to perform path reduction.\n    const aRoot = a.substring(0, getRootLength(a));\n    const bRoot = b.substring(0, getRootLength(b));\n    const result = stringUtils_1.compareStringsCaseInsensitive(aRoot, bRoot);\n    if (result !== 0 /* EqualTo */) {\n        return result;\n    }\n    // check path for these segments: '', '.'. '..'\n    const escapedSeparator = getRegexEscapedSeparator();\n    const relativePathSegmentRegExp = new RegExp(`(^|${escapedSeparator}).{0,2}($|${escapedSeparator})`);\n    // NOTE: Performance optimization - shortcut if there are no relative path segments in\n    //       the non-root portion of the path\n    const aRest = a.substring(aRoot.length);\n    const bRest = b.substring(bRoot.length);\n    if (!relativePathSegmentRegExp.test(aRest) && !relativePathSegmentRegExp.test(bRest)) {\n        return componentComparer(aRest, bRest);\n    }\n    // The path contains a relative path segment. Normalize the paths and perform a slower component\n    // by component comparison.\n    const aComponents = getPathComponents(a);\n    const bComponents = getPathComponents(b);\n    const sharedLength = Math.min(aComponents.length, bComponents.length);\n    for (let i = 1; i < sharedLength; i++) {\n        const result = componentComparer(aComponents[i], bComponents[i]);\n        if (result !== 0 /* EqualTo */) {\n            return result;\n        }\n    }\n    return core_1.compareValues(aComponents.length, bComponents.length);\n}\nfunction getAnyExtensionFromPathWorker(path, extensions, stringEqualityComparer) {\n    if (typeof extensions === 'string') {\n        return tryGetExtensionFromPath(path, extensions, stringEqualityComparer) || '';\n    }\n    for (const extension of extensions) {\n        const result = tryGetExtensionFromPath(path, extension, stringEqualityComparer);\n        if (result) {\n            return result;\n        }\n    }\n    return '';\n}\nfunction tryGetExtensionFromPath(path, extension, stringEqualityComparer) {\n    if (!extension.startsWith('.')) {\n        extension = '.' + extension;\n    }\n    if (path.length >= extension.length && path.charCodeAt(path.length - extension.length) === 46 /* Period */) {\n        const pathExtension = path.slice(path.length - extension.length);\n        if (stringEqualityComparer(pathExtension, extension)) {\n            return pathExtension;\n        }\n    }\n    return undefined;\n}\nfunction getPathComponentsRelativeTo(from, to, stringEqualityComparer, getCanonicalFileName) {\n    const fromComponents = getPathComponents(from);\n    const toComponents = getPathComponents(to);\n    let start;\n    for (start = 0; start < fromComponents.length && start < toComponents.length; start++) {\n        const fromComponent = getCanonicalFileName(fromComponents[start]);\n        const toComponent = getCanonicalFileName(toComponents[start]);\n        const comparer = start === 0 ? stringUtils_1.equateStringsCaseInsensitive : stringEqualityComparer;\n        if (!comparer(fromComponent, toComponent)) {\n            break;\n        }\n    }\n    if (start === 0) {\n        return toComponents;\n    }\n    const components = toComponents.slice(start);\n    const relative = [];\n    for (; start < fromComponents.length; start++) {\n        relative.push('..');\n    }\n    return ['', ...relative, ...components];\n}\nfunction fileSystemEntryExists(fs, path, entryKind) {\n    try {\n        const stat = fs.statSync(path);\n        switch (entryKind) {\n            case 0 /* File */:\n                return stat.isFile();\n            case 1 /* Directory */:\n                return stat.isDirectory();\n            default:\n                return false;\n        }\n    }\n    catch (e) {\n        return false;\n    }\n}\nfunction convertUriToPath(uriString) {\n    const uri = vscode_uri_1.URI.parse(uriString);\n    let convertedPath = normalizePath(uri.path);\n    // If this is a DOS-style path with a drive letter, remove\n    // the leading slash.\n    if (convertedPath.match(/^\\\\[a-zA-Z]:\\\\/)) {\n        convertedPath = convertedPath.substr(1);\n    }\n    return convertedPath;\n}\nexports.convertUriToPath = convertUriToPath;\nfunction convertPathToUri(path) {\n    return vscode_uri_1.URI.file(path).toString();\n}\nexports.convertPathToUri = convertPathToUri;\nlet _fsCaseSensitivity = undefined;\nfunction isFileSystemCaseSensitive(fs) {\n    if (_fsCaseSensitivity !== undefined) {\n        return _fsCaseSensitivity;\n    }\n    _fsCaseSensitivity = isFileSystemCaseSensitiveInternal(fs);\n    return _fsCaseSensitivity;\n}\nexports.isFileSystemCaseSensitive = isFileSystemCaseSensitive;\nfunction isFileSystemCaseSensitiveInternal(fs) {\n    let filePath = undefined;\n    try {\n        // Make sure tmp dir exists.\n        if (!fs.existsSync(fs.tmpdir())) {\n            fs.mkdirSync(fs.tmpdir(), { recursive: true });\n        }\n        // Make unique file name.\n        let name;\n        let mangledFilePath;\n        do {\n            name = `${crypto_1.randomBytes(21).toString('hex')}-a`;\n            filePath = path.join(fs.tmpdir(), name);\n            mangledFilePath = path.join(fs.tmpdir(), name.toUpperCase());\n        } while (fs.existsSync(filePath) || fs.existsSync(mangledFilePath));\n        fs.writeFileSync(filePath, '', 'utf8');\n        // If file exists, then it is insensitive.\n        return !fs.existsSync(mangledFilePath);\n    }\n    catch (e) {\n        return false;\n    }\n    finally {\n        if (filePath) {\n            // remove temp file created\n            fs.unlinkSync(filePath);\n        }\n    }\n}\nexports.isFileSystemCaseSensitiveInternal = isFileSystemCaseSensitiveInternal;\n\n\n//# sourceURL=webpack://pyright-server/./src/common/pathUtils.ts?");

/***/ }),

/***/ "./src/common/positionUtils.ts":
/*!*************************************!*\
  !*** ./src/common/positionUtils.ts ***!
  \*************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export convertOffsetToPosition [provided] [no usage info] [missing usage info prevents renaming] */
/*! export convertOffsetsToRange [provided] [no usage info] [missing usage info prevents renaming] */
/*! export convertPositionToOffset [provided] [no usage info] [missing usage info prevents renaming] */
/*! export convertRangeToTextRange [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * positionUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Utility routines for converting between file offsets and\n * line/column positions.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertRangeToTextRange = exports.convertPositionToOffset = exports.convertOffsetsToRange = exports.convertOffsetToPosition = void 0;\nconst debug_1 = __webpack_require__(/*! ./debug */ \"./src/common/debug.ts\");\nconst textRange_1 = __webpack_require__(/*! ./textRange */ \"./src/common/textRange.ts\");\n// Translates a file offset into a line/column pair.\nfunction convertOffsetToPosition(offset, lines) {\n    // Handle the case where the file is empty.\n    if (lines.end === 0) {\n        return {\n            line: 0,\n            character: 0,\n        };\n    }\n    // Handle the case where we're pointing to the last line of the file.\n    let offsetAdjustment = 0;\n    if (offset >= lines.end) {\n        offset = lines.end - 1;\n        offsetAdjustment = 1;\n    }\n    const itemIndex = lines.getItemContaining(offset);\n    debug_1.assert(itemIndex >= 0 && itemIndex <= lines.length);\n    const lineRange = lines.getItemAt(itemIndex);\n    debug_1.assert(lineRange !== undefined);\n    return {\n        line: itemIndex,\n        character: offset - lineRange.start + offsetAdjustment,\n    };\n}\nexports.convertOffsetToPosition = convertOffsetToPosition;\n// Translates a start/end file offset into a pair of line/column positions.\nfunction convertOffsetsToRange(startOffset, endOffset, lines) {\n    const start = convertOffsetToPosition(startOffset, lines);\n    const end = convertOffsetToPosition(endOffset, lines);\n    return { start, end };\n}\nexports.convertOffsetsToRange = convertOffsetsToRange;\n// Translates a position (line and col) into a file offset.\nfunction convertPositionToOffset(position, lines) {\n    if (position.line >= lines.count) {\n        return undefined;\n    }\n    return lines.getItemAt(position.line).start + position.character;\n}\nexports.convertPositionToOffset = convertPositionToOffset;\nfunction convertRangeToTextRange(range, lines) {\n    const start = convertPositionToOffset(range.start, lines);\n    if (start === undefined) {\n        return undefined;\n    }\n    const end = convertPositionToOffset(range.end, lines);\n    if (end === undefined) {\n        return undefined;\n    }\n    return textRange_1.TextRange.fromBounds(start, end);\n}\nexports.convertRangeToTextRange = convertRangeToTextRange;\n\n\n//# sourceURL=webpack://pyright-server/./src/common/positionUtils.ts?");

/***/ }),

/***/ "./src/common/progressReporter.ts":
/*!****************************************!*\
  !*** ./src/common/progressReporter.ts ***!
  \****************************************/
/*! flagged exports */
/*! export ProgressReportTracker [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * progressReporter.ts\n *\n * Implements progress reporter.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ProgressReportTracker = void 0;\nclass ProgressReportTracker {\n    constructor(_reporter) {\n        this._reporter = _reporter;\n        // Tracks whether we're currently displaying progress.\n        this._isDisplayingProgress = false;\n    }\n    isEnabled(data) {\n        var _a, _b;\n        if (this._isDisplayingProgress) {\n            return true;\n        }\n        return (_b = (_a = this._reporter) === null || _a === void 0 ? void 0 : _a.isEnabled(data)) !== null && _b !== void 0 ? _b : false;\n    }\n    begin() {\n        var _a;\n        if (this._isDisplayingProgress) {\n            return;\n        }\n        this._isDisplayingProgress = true;\n        (_a = this._reporter) === null || _a === void 0 ? void 0 : _a.begin();\n    }\n    report(message) {\n        var _a;\n        if (!this._isDisplayingProgress) {\n            return;\n        }\n        (_a = this._reporter) === null || _a === void 0 ? void 0 : _a.report(message);\n    }\n    end() {\n        var _a;\n        if (!this._isDisplayingProgress) {\n            return;\n        }\n        this._isDisplayingProgress = false;\n        (_a = this._reporter) === null || _a === void 0 ? void 0 : _a.end();\n    }\n}\nexports.ProgressReportTracker = ProgressReportTracker;\n\n\n//# sourceURL=webpack://pyright-server/./src/common/progressReporter.ts?");

/***/ }),

/***/ "./src/common/pythonVersion.ts":
/*!*************************************!*\
  !*** ./src/common/pythonVersion.ts ***!
  \*************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * pythonLanguageVersion.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Types and functions that relate to the Python language version\n * and features within them.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.is3x = exports.versionFromMajorMinor = exports.versionFromString = exports.versionToString = exports.latestPythonVersion = exports.latestStablePythonVersion = exports.PythonVersion = void 0;\nvar PythonVersion;\n(function (PythonVersion) {\n    // The order of this enumeration is significant. We assume\n    // that we can use comparison operators to check for older\n    // or newer versions.\n    PythonVersion[PythonVersion[\"V3_0\"] = 768] = \"V3_0\";\n    PythonVersion[PythonVersion[\"V3_1\"] = 769] = \"V3_1\";\n    PythonVersion[PythonVersion[\"V3_2\"] = 770] = \"V3_2\";\n    PythonVersion[PythonVersion[\"V3_3\"] = 771] = \"V3_3\";\n    PythonVersion[PythonVersion[\"V3_4\"] = 772] = \"V3_4\";\n    PythonVersion[PythonVersion[\"V3_5\"] = 773] = \"V3_5\";\n    PythonVersion[PythonVersion[\"V3_6\"] = 774] = \"V3_6\";\n    PythonVersion[PythonVersion[\"V3_7\"] = 775] = \"V3_7\";\n    PythonVersion[PythonVersion[\"V3_8\"] = 776] = \"V3_8\";\n    PythonVersion[PythonVersion[\"V3_9\"] = 777] = \"V3_9\";\n    PythonVersion[PythonVersion[\"V3_10\"] = 778] = \"V3_10\";\n})(PythonVersion = exports.PythonVersion || (exports.PythonVersion = {}));\nexports.latestStablePythonVersion = PythonVersion.V3_8;\nexports.latestPythonVersion = PythonVersion.V3_8;\nfunction versionToString(version) {\n    const majorVersion = (version >> 8) & 0xff;\n    const minorVersion = version & 0xff;\n    return `${majorVersion}.${minorVersion}`;\n}\nexports.versionToString = versionToString;\nfunction versionFromString(verString) {\n    const split = verString.split('.');\n    if (split.length < 2) {\n        return undefined;\n    }\n    const majorVersion = parseInt(split[0], 10);\n    const minorVersion = parseInt(split[1], 10);\n    return versionFromMajorMinor(majorVersion, minorVersion);\n}\nexports.versionFromString = versionFromString;\nfunction versionFromMajorMinor(major, minor) {\n    if (isNaN(major) || isNaN(minor)) {\n        return undefined;\n    }\n    if (major > 255 || minor > 255) {\n        return undefined;\n    }\n    const value = major * 256 + minor;\n    if (PythonVersion[value] === undefined) {\n        return undefined;\n    }\n    // Pyright currently supports only 3.x.\n    if (!is3x(value)) {\n        return undefined;\n    }\n    return value;\n}\nexports.versionFromMajorMinor = versionFromMajorMinor;\nfunction is3x(version) {\n    return version >> 8 === 3;\n}\nexports.is3x = is3x;\n\n\n//# sourceURL=webpack://pyright-server/./src/common/pythonVersion.ts?");

/***/ }),

/***/ "./src/common/stringUtils.ts":
/*!***********************************!*\
  !*** ./src/common/stringUtils.ts ***!
  \***********************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export compareStringsCaseInsensitive [provided] [no usage info] [missing usage info prevents renaming] */
/*! export compareStringsCaseSensitive [provided] [no usage info] [missing usage info prevents renaming] */
/*! export computeCompletionSimilarity [provided] [no usage info] [missing usage info prevents renaming] */
/*! export equateStringsCaseInsensitive [provided] [no usage info] [missing usage info prevents renaming] */
/*! export equateStringsCaseSensitive [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getStringComparer [provided] [no usage info] [missing usage info prevents renaming] */
/*! export hashString [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * stringUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Utility methods for manipulating and comparing strings.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.equateStringsCaseSensitive = exports.equateStringsCaseInsensitive = exports.getStringComparer = exports.compareStringsCaseSensitive = exports.compareStringsCaseInsensitive = exports.hashString = exports.computeCompletionSimilarity = void 0;\nconst leven_1 = __webpack_require__(/*! leven */ \"./node_modules/leven/index.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"./src/common/core.ts\");\n// Determines how closely a typed string matches a symbol\n// name. An exact match returns 1. A match that differs\n// only in case returns a slightly lower number. A match\n// that involves a few missing or added characters returns\n// an even lower number.\nfunction computeCompletionSimilarity(typedValue, symbolName) {\n    if (symbolName.startsWith(typedValue)) {\n        return 1;\n    }\n    const symbolLower = symbolName.toLocaleLowerCase();\n    const typedLower = typedValue.toLocaleLowerCase();\n    if (symbolLower.startsWith(typedLower)) {\n        return 0.75;\n    }\n    // How far apart are the two strings? Find the smallest edit\n    // distance for each of the substrings taken from the start of\n    // symbolName.\n    let symbolSubstrLength = symbolLower.length;\n    let smallestEditDistance = Number.MAX_VALUE;\n    while (symbolSubstrLength > 0) {\n        const editDistance = leven_1.default(symbolLower.substr(0, symbolSubstrLength), typedLower);\n        if (editDistance < smallestEditDistance) {\n            smallestEditDistance = editDistance;\n        }\n        symbolSubstrLength--;\n    }\n    // We'll take into account the length of the typed value. If the user\n    // has typed more characters, and they largely match the symbol name,\n    // it is considered more similar. If the the edit distance is similar\n    // to the number of characters the user has typed, then there's almost\n    // no similarity.\n    if (smallestEditDistance >= typedValue.length) {\n        return 0;\n    }\n    const similarity = (typedValue.length - smallestEditDistance) / typedValue.length;\n    return 0.5 * similarity;\n}\nexports.computeCompletionSimilarity = computeCompletionSimilarity;\n// This is a simple, non-cryptographic hash function for text.\nfunction hashString(contents) {\n    let hash = 0;\n    for (let i = 0; i < contents.length; i++) {\n        hash = ((hash << 5) - hash + contents.charCodeAt(i)) | 0;\n    }\n    return hash;\n}\nexports.hashString = hashString;\n/**\n * Compare two strings using a case-insensitive ordinal comparison.\n *\n * Ordinal comparisons are based on the difference between the unicode code points of both\n * strings. Characters with multiple unicode representations are considered unequal. Ordinal\n * comparisons provide predictable ordering, but place \"a\" after \"B\".\n *\n * Case-insensitive comparisons compare both strings one code-point at a time using the integer\n * value of each code-point after applying `toUpperCase` to each string. We always map both\n * strings to their upper-case form as some unicode characters do not properly round-trip to\n * lowercase (such as `áºž` (German sharp capital s)).\n */\nfunction compareStringsCaseInsensitive(a, b) {\n    return a === b\n        ? 0 /* EqualTo */\n        : a === undefined\n            ? -1 /* LessThan */\n            : b === undefined\n                ? 1 /* GreaterThan */\n                : core_1.compareComparableValues(a.toUpperCase(), b.toUpperCase());\n}\nexports.compareStringsCaseInsensitive = compareStringsCaseInsensitive;\n/**\n * Compare two strings using a case-sensitive ordinal comparison.\n *\n * Ordinal comparisons are based on the difference between the unicode code points of both\n * strings. Characters with multiple unicode representations are considered unequal. Ordinal\n * comparisons provide predictable ordering, but place \"a\" after \"B\".\n *\n * Case-sensitive comparisons compare both strings one code-point at a time using the integer\n * value of each code-point.\n */\nfunction compareStringsCaseSensitive(a, b) {\n    return core_1.compareComparableValues(a, b);\n}\nexports.compareStringsCaseSensitive = compareStringsCaseSensitive;\nfunction getStringComparer(ignoreCase) {\n    return ignoreCase ? compareStringsCaseInsensitive : compareStringsCaseSensitive;\n}\nexports.getStringComparer = getStringComparer;\n/**\n * Compare the equality of two strings using a case-insensitive ordinal comparison.\n *\n * Case-insensitive comparisons compare both strings one code-point at a time using the integer\n * value of each code-point after applying `toUpperCase` to each string. We always map both\n * strings to their upper-case form as some unicode characters do not properly round-trip to\n * lowercase (such as `ẞ` (German sharp capital s)).\n */\nfunction equateStringsCaseInsensitive(a, b) {\n    return compareStringsCaseInsensitive(a, b) === 0 /* EqualTo */;\n}\nexports.equateStringsCaseInsensitive = equateStringsCaseInsensitive;\n/**\n * Compare the equality of two strings using a case-sensitive ordinal comparison.\n *\n * Case-sensitive comparisons compare both strings one code-point at a time using the\n * integer value of each code-point.\n */\nfunction equateStringsCaseSensitive(a, b) {\n    return compareStringsCaseSensitive(a, b) === 0 /* EqualTo */;\n}\nexports.equateStringsCaseSensitive = equateStringsCaseSensitive;\n\n\n//# sourceURL=webpack://pyright-server/./src/common/stringUtils.ts?");

/***/ }),

/***/ "./src/common/textEditUtils.ts":
/*!*************************************!*\
  !*** ./src/common/textEditUtils.ts ***!
  \*************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export convertTextEdits [provided] [no usage info] [missing usage info prevents renaming] */
/*! export convertWorkspaceEdits [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * textEditUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Language server command execution functionality.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertWorkspaceEdits = exports.convertTextEdits = void 0;\nconst pathUtils_1 = __webpack_require__(/*! ../common/pathUtils */ \"./src/common/pathUtils.ts\");\nfunction convertTextEdits(uri, editActions) {\n    if (!editActions) {\n        return {};\n    }\n    const edits = [];\n    editActions.forEach((editAction) => {\n        edits.push({\n            range: editAction.range,\n            newText: editAction.replacementText,\n        });\n    });\n    return {\n        changes: {\n            [uri]: edits,\n        },\n    };\n}\nexports.convertTextEdits = convertTextEdits;\nfunction convertWorkspaceEdits(edits) {\n    const workspaceEdits = {\n        changes: {},\n    };\n    edits.forEach((edit) => {\n        const uri = pathUtils_1.convertPathToUri(edit.filePath);\n        workspaceEdits.changes[uri] = workspaceEdits.changes[uri] || [];\n        workspaceEdits.changes[uri].push({ range: edit.range, newText: edit.replacementText });\n    });\n    return workspaceEdits;\n}\nexports.convertWorkspaceEdits = convertWorkspaceEdits;\n\n\n//# sourceURL=webpack://pyright-server/./src/common/textEditUtils.ts?");

/***/ }),

/***/ "./src/common/textRange.ts":
/*!*********************************!*\
  !*** ./src/common/textRange.ts ***!
  \*********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * textRange.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Specifies the range of text within a larger string.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getEmptyRange = exports.rangesAreEqual = exports.doesRangeContain = exports.doRangesIntersect = exports.doRangesOverlap = exports.getEmptyPosition = exports.comparePositions = exports.TextRange = void 0;\nvar TextRange;\n(function (TextRange) {\n    function create(start, length) {\n        if (start < 0) {\n            throw new Error('start must be non-negative');\n        }\n        if (length < 0) {\n            throw new Error('length must be non-negative');\n        }\n        return { start, length };\n    }\n    TextRange.create = create;\n    function fromBounds(start, end) {\n        if (start < 0) {\n            throw new Error('start must be non-negative');\n        }\n        if (start > end) {\n            throw new Error('end must be greater than or equal to start');\n        }\n        return create(start, end - start);\n    }\n    TextRange.fromBounds = fromBounds;\n    function getEnd(range) {\n        return range.start + range.length;\n    }\n    TextRange.getEnd = getEnd;\n    function contains(range, position) {\n        return position >= range.start && position < getEnd(range);\n    }\n    TextRange.contains = contains;\n    function extend(range, extension) {\n        if (extension) {\n            if (Array.isArray(extension)) {\n                extension.forEach((r) => {\n                    extend(range, r);\n                });\n            }\n            else {\n                if (extension.start < range.start) {\n                    range.length += range.start - extension.start;\n                    range.start = extension.start;\n                }\n                if (getEnd(extension) > getEnd(range)) {\n                    range.length += getEnd(extension) - getEnd(range);\n                }\n            }\n        }\n    }\n    TextRange.extend = extend;\n})(TextRange = exports.TextRange || (exports.TextRange = {}));\nvar Position;\n(function (Position) {\n    function is(value) {\n        const candidate = value;\n        return candidate && candidate.line !== void 0 && candidate.character !== void 0;\n    }\n    Position.is = is;\n})(Position || (Position = {}));\nvar Range;\n(function (Range) {\n    function is(value) {\n        const candidate = value;\n        return candidate && candidate.start !== void 0 && candidate.end !== void 0;\n    }\n    Range.is = is;\n})(Range || (Range = {}));\nfunction comparePositions(a, b) {\n    if (a.line < b.line) {\n        return -1;\n    }\n    else if (a.line > b.line) {\n        return 1;\n    }\n    else if (a.character < b.character) {\n        return -1;\n    }\n    else if (a.character > b.character) {\n        return 1;\n    }\n    return 0;\n}\nexports.comparePositions = comparePositions;\nfunction getEmptyPosition() {\n    return {\n        line: 0,\n        character: 0,\n    };\n}\nexports.getEmptyPosition = getEmptyPosition;\nfunction doRangesOverlap(a, b) {\n    if (comparePositions(b.start, a.end) >= 0) {\n        return false;\n    }\n    else if (comparePositions(a.start, b.end) >= 0) {\n        return false;\n    }\n    return true;\n}\nexports.doRangesOverlap = doRangesOverlap;\nfunction doRangesIntersect(a, b) {\n    if (comparePositions(b.start, a.end) > 0) {\n        return false;\n    }\n    else if (comparePositions(a.start, b.end) > 0) {\n        return false;\n    }\n    return true;\n}\nexports.doRangesIntersect = doRangesIntersect;\nfunction doesRangeContain(range, positionOrRange) {\n    if (Position.is(positionOrRange)) {\n        return comparePositions(range.start, positionOrRange) <= 0 && comparePositions(range.end, positionOrRange) >= 0;\n    }\n    return doesRangeContain(range, positionOrRange.start) && doesRangeContain(range, positionOrRange.end);\n}\nexports.doesRangeContain = doesRangeContain;\nfunction rangesAreEqual(a, b) {\n    return comparePositions(a.start, b.start) === 0 && comparePositions(a.end, b.end) === 0;\n}\nexports.rangesAreEqual = rangesAreEqual;\nfunction getEmptyRange() {\n    return {\n        start: getEmptyPosition(),\n        end: getEmptyPosition(),\n    };\n}\nexports.getEmptyRange = getEmptyRange;\n\n\n//# sourceURL=webpack://pyright-server/./src/common/textRange.ts?");

/***/ }),

/***/ "./src/common/textRangeCollection.ts":
/*!*******************************************!*\
  !*** ./src/common/textRangeCollection.ts ***!
  \*******************************************/
/*! flagged exports */
/*! export TextRangeCollection [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * textRangeCollection.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Based on code from vscode-python repository:\n *  https://github.com/Microsoft/vscode-python\n *\n * Class that maintains an ordered list of text ranges and allows\n * for indexing and fast lookups within this list.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextRangeCollection = void 0;\nconst textRange_1 = __webpack_require__(/*! ./textRange */ \"./src/common/textRange.ts\");\nclass TextRangeCollection {\n    constructor(items) {\n        this._items = items;\n    }\n    get start() {\n        return this._items.length > 0 ? this._items[0].start : 0;\n    }\n    get end() {\n        const lastItem = this._items[this._items.length - 1];\n        return this._items.length > 0 ? lastItem.start + lastItem.length : 0;\n    }\n    get length() {\n        return this.end - this.start;\n    }\n    get count() {\n        return this._items.length;\n    }\n    contains(position) {\n        return position >= this.start && position < this.end;\n    }\n    getItemAt(index) {\n        if (index < 0 || index >= this._items.length) {\n            throw new Error('index is out of range');\n        }\n        return this._items[index];\n    }\n    // Returns the nearest item prior to the position.\n    // The position may not be contained within the item.\n    getItemAtPosition(position) {\n        if (this.count === 0) {\n            return -1;\n        }\n        if (position < this.start) {\n            return -1;\n        }\n        if (position > this.end) {\n            return -1;\n        }\n        let min = 0;\n        let max = this.count - 1;\n        while (min < max) {\n            const mid = Math.floor(min + (max - min) / 2);\n            const item = this._items[mid];\n            // Is the position past the start of this item but before\n            // the start of the next item? If so, we found our item.\n            if (position >= item.start) {\n                if (mid >= this.count - 1 || position < this._items[mid + 1].start) {\n                    return mid;\n                }\n            }\n            if (position < item.start) {\n                max = mid - 1;\n            }\n            else {\n                min = mid + 1;\n            }\n        }\n        return min;\n    }\n    getItemContaining(position) {\n        if (this.count === 0) {\n            return -1;\n        }\n        if (position < this.start) {\n            return -1;\n        }\n        if (position > this.end) {\n            return -1;\n        }\n        let min = 0;\n        let max = this.count - 1;\n        while (min <= max) {\n            const mid = Math.floor(min + (max - min) / 2);\n            const item = this._items[mid];\n            if (textRange_1.TextRange.contains(item, position)) {\n                return mid;\n            }\n            if (mid < this.count - 1 && textRange_1.TextRange.getEnd(item) <= position && position < this._items[mid + 1].start) {\n                return -1;\n            }\n            if (position < item.start) {\n                max = mid - 1;\n            }\n            else {\n                min = mid + 1;\n            }\n        }\n        return -1;\n    }\n}\nexports.TextRangeCollection = TextRangeCollection;\n\n\n//# sourceURL=webpack://pyright-server/./src/common/textRangeCollection.ts?");

/***/ }),

/***/ "./src/common/timing.ts":
/*!******************************!*\
  !*** ./src/common/timing.ts ***!
  \******************************/
/*! flagged exports */
/*! export Duration [provided] [no usage info] [missing usage info prevents renaming] */
/*! export TimingStat [provided] [no usage info] [missing usage info prevents renaming] */
/*! export TimingStats [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export timingStats [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * timing.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * A simple duration class that can be used to record and report\n * durations at the millisecond level of resolution.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.timingStats = exports.TimingStats = exports.TimingStat = exports.Duration = void 0;\nclass Duration {\n    constructor() {\n        this._startTime = Date.now();\n    }\n    getDurationInMilliseconds() {\n        const curTime = Date.now();\n        return curTime - this._startTime;\n    }\n    getDurationInSeconds() {\n        return this.getDurationInMilliseconds() / 1000;\n    }\n}\nexports.Duration = Duration;\nclass TimingStat {\n    constructor() {\n        this.totalTime = 0;\n        this.isTiming = false;\n    }\n    timeOperation(callback) {\n        // Handle reentrancy.\n        if (this.isTiming) {\n            callback();\n        }\n        else {\n            this.isTiming = true;\n            const duration = new Duration();\n            callback();\n            this.totalTime += duration.getDurationInMilliseconds();\n            this.isTiming = false;\n        }\n    }\n    subtractFromTime(callback) {\n        if (this.isTiming) {\n            this.isTiming = false;\n            const duration = new Duration();\n            callback();\n            this.totalTime -= duration.getDurationInMilliseconds();\n            this.isTiming = true;\n        }\n        else {\n            callback();\n        }\n    }\n    printTime() {\n        const totalTimeInSec = this.totalTime / 1000;\n        const roundedTime = Math.round(totalTimeInSec * 100) / 100;\n        return roundedTime.toString() + 'sec';\n    }\n}\nexports.TimingStat = TimingStat;\nclass TimingStats {\n    constructor() {\n        this.totalDuration = new Duration();\n        this.findFilesTime = new TimingStat();\n        this.readFileTime = new TimingStat();\n        this.tokenizeFileTime = new TimingStat();\n        this.parseFileTime = new TimingStat();\n        this.resolveImportsTime = new TimingStat();\n        this.cycleDetectionTime = new TimingStat();\n        this.bindTime = new TimingStat();\n        this.typeCheckerTime = new TimingStat();\n    }\n    printSummary(console) {\n        console.info(`Completed in ${this.totalDuration.getDurationInSeconds()}sec`);\n    }\n    printDetails(console) {\n        console.info('');\n        console.info('Timing stats');\n        console.info('Find Source Files:    ' + this.findFilesTime.printTime());\n        console.info('Read Source Files:    ' + this.readFileTime.printTime());\n        console.info('Tokenize:             ' + this.tokenizeFileTime.printTime());\n        console.info('Parse:                ' + this.parseFileTime.printTime());\n        console.info('Resolve Imports:      ' + this.resolveImportsTime.printTime());\n        console.info('Bind:                 ' + this.bindTime.printTime());\n        console.info('Check:                ' + this.typeCheckerTime.printTime());\n        console.info('Detect Cycles:        ' + this.cycleDetectionTime.printTime());\n    }\n}\nexports.TimingStats = TimingStats;\nexports.timingStats = new TimingStats();\n\n\n//# sourceURL=webpack://pyright-server/./src/common/timing.ts?");

/***/ }),

/***/ "./src/languageServerBase.ts":
/*!***********************************!*\
  !*** ./src/languageServerBase.ts ***!
  \***********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * languageServerBase.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Implements common language server functionality.\n * This is split out as a base class to allow for\n * different language server variants to be created\n * from the same core functionality.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LanguageServerBase = void 0;\n__webpack_require__(/*! ./common/extensions */ \"./src/common/extensions.ts\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst node_1 = __webpack_require__(/*! vscode-languageserver/node */ \"./node_modules/vscode-languageserver/node.js\");\nconst importResolver_1 = __webpack_require__(/*! ./analyzer/importResolver */ \"./src/analyzer/importResolver.ts\");\nconst service_1 = __webpack_require__(/*! ./analyzer/service */ \"./src/analyzer/service.ts\");\nconst cancellationUtils_1 = __webpack_require__(/*! ./common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst collectionUtils_1 = __webpack_require__(/*! ./common/collectionUtils */ \"./src/common/collectionUtils.ts\");\nconst commandLineOptions_1 = __webpack_require__(/*! ./common/commandLineOptions */ \"./src/common/commandLineOptions.ts\");\nconst configOptions_1 = __webpack_require__(/*! ./common/configOptions */ \"./src/common/configOptions.ts\");\nconst console_1 = __webpack_require__(/*! ./common/console */ \"./src/common/console.ts\");\nconst deferred_1 = __webpack_require__(/*! ./common/deferred */ \"./src/common/deferred.ts\");\nconst fileSystem_1 = __webpack_require__(/*! ./common/fileSystem */ \"./src/common/fileSystem.ts\");\nconst pathUtils_1 = __webpack_require__(/*! ./common/pathUtils */ \"./src/common/pathUtils.ts\");\nconst progressReporter_1 = __webpack_require__(/*! ./common/progressReporter */ \"./src/common/progressReporter.ts\");\nconst textEditUtils_1 = __webpack_require__(/*! ./common/textEditUtils */ \"./src/common/textEditUtils.ts\");\nconst analyzerServiceExecutor_1 = __webpack_require__(/*! ./languageService/analyzerServiceExecutor */ \"./src/languageService/analyzerServiceExecutor.ts\");\nconst hoverProvider_1 = __webpack_require__(/*! ./languageService/hoverProvider */ \"./src/languageService/hoverProvider.ts\");\nconst localize_1 = __webpack_require__(/*! ./localization/localize */ \"./src/localization/localize.ts\");\nconst workspaceMap_1 = __webpack_require__(/*! ./workspaceMap */ \"./src/workspaceMap.ts\");\nclass LanguageServerBase {\n    constructor(_serverOptions) {\n        var _a, _b;\n        this._serverOptions = _serverOptions;\n        // Create a connection for the server. The connection type can be changed by the process's arguments\n        this._connection = node_1.createConnection(this._GetConnectionOptions());\n        this._hasConfigurationCapability = false;\n        this._hasVisualStudioExtensionsCapability = false;\n        this._hasWorkspaceFoldersCapability = false;\n        this._hasWatchFileCapability = false;\n        this._hasActiveParameterCapability = false;\n        // Tracks active file system watchers.\n        this._fileWatchers = [];\n        // Global root path - the basis for all global settings.\n        this.rootPath = '';\n        this.console = new console_1.ConsoleWithLogLevel(this._connection.console);\n        this.console.info(`${_serverOptions.productName} language server ${_serverOptions.version && _serverOptions.version + ' '}starting`);\n        this.fs = fileSystem_1.createFromRealFileSystem(this.console, this);\n        // Set the working directory to a known location within\n        // the extension directory. Otherwise the execution of\n        // python can have unintended and surprising results.\n        const moduleDirectory = this.fs.getModulePath();\n        if (moduleDirectory) {\n            this.fs.chdir(moduleDirectory);\n        }\n        // Stash the base directory into a global variable.\n        global.__rootDirectory = _serverOptions.rootDirectory;\n        this.console.info(`Server root directory: ${_serverOptions.rootDirectory}`);\n        // Create workspace map.\n        this._workspaceMap = new workspaceMap_1.WorkspaceMap(this);\n        // Set up callbacks.\n        this._setupConnection((_a = _serverOptions.supportedCommands) !== null && _a !== void 0 ? _a : [], (_b = _serverOptions.supportedCodeActions) !== null && _b !== void 0 ? _b : []);\n        this._progressReporter = new progressReporter_1.ProgressReportTracker(this._serverOptions.progressReporterFactory\n            ? this._serverOptions.progressReporterFactory(this._connection)\n            : undefined);\n        // Listen on the connection.\n        this._connection.listen();\n    }\n    isLongRunningCommand(command) {\n        // By default, all commands are considered \"long-running\" and should\n        // display a cancelable progress dialog. Servers can override this\n        // to avoid showing the progress dialog for commands that are\n        // guaranteed to be quick.\n        return true;\n    }\n    getConfiguration(workspace, section) {\n        if (this._hasConfigurationCapability) {\n            const scopeUri = workspace.rootUri ? workspace.rootUri : undefined;\n            const item = {\n                scopeUri,\n                section,\n            };\n            return this._connection.workspace.getConfiguration(item);\n        }\n        if (this._defaultClientConfig) {\n            return collectionUtils_1.getNestedProperty(this._defaultClientConfig, section);\n        }\n        return undefined;\n    }\n    isOpenFilesOnly(diagnosticMode) {\n        return diagnosticMode !== 'workspace';\n    }\n    getSeverityOverrides(value) {\n        const enumValue = value;\n        if (commandLineOptions_1.getDiagnosticSeverityOverrides().includes(enumValue)) {\n            return enumValue;\n        }\n        return undefined;\n    }\n    getDiagnosticRuleName(value) {\n        const enumValue = value;\n        if (configOptions_1.getDiagLevelDiagnosticRules().includes(enumValue)) {\n            return enumValue;\n        }\n        return undefined;\n    }\n    createImportResolver(fs, options) {\n        return new importResolver_1.ImportResolver(fs, options);\n    }\n    setExtension(extension) {\n        this._serverOptions.extension = extension;\n    }\n    // Provides access to the client's window.\n    get window() {\n        return this._connection.window;\n    }\n    // Creates a service instance that's used for analyzing a\n    // program within a workspace.\n    createAnalyzerService(name) {\n        this.console.log(`Starting service instance \"${name}\"`);\n        const service = new service_1.AnalyzerService(name, this.fs, this.console, this.createImportResolver.bind(this), undefined, this._serverOptions.extension, this.createBackgroundAnalysis(), this._serverOptions.maxAnalysisTimeInForeground);\n        service.setCompletionCallback((results) => this.onAnalysisCompletedHandler(results));\n        return service;\n    }\n    getWorkspaceForFile(filePath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const workspace = this._workspaceMap.getWorkspaceForFile(filePath);\n            yield workspace.isInitialized.promise;\n            return workspace;\n        });\n    }\n    reanalyze() {\n        this._workspaceMap.forEach((workspace) => {\n            workspace.serviceInstance.invalidateAndForceReanalysis();\n        });\n    }\n    restart() {\n        this._workspaceMap.forEach((workspace) => {\n            workspace.serviceInstance.restart();\n        });\n    }\n    createFileWatcher(paths, listener) {\n        // Capture \"this\" so we can reference it within the \"close\" method below.\n        const lsBase = this;\n        // Determine which paths are located within one or more workspaces.\n        // Those are already covered by existing file watchers handled by\n        // the client.\n        const workspacePaths = [];\n        const nonWorkspacePaths = [];\n        const workspaces = this._workspaceMap.getNonDefaultWorkspaces();\n        paths.forEach((path) => {\n            if (workspaces.some((workspace) => pathUtils_1.containsPath(workspace.rootPath, path))) {\n                workspacePaths.push(path);\n            }\n            else {\n                nonWorkspacePaths.push(path);\n            }\n        });\n        // For any non-workspace paths, use the node file watcher.\n        const nodeWatchers = nonWorkspacePaths.map((path) => {\n            return fs.watch(path, { recursive: true }, listener);\n        });\n        const fileWatcher = {\n            close() {\n                // Stop listening for workspace paths.\n                lsBase._fileWatchers = lsBase._fileWatchers.filter((watcher) => watcher !== fileWatcher);\n                // Close the node watchers.\n                nodeWatchers.forEach((watcher) => {\n                    watcher.close();\n                });\n            },\n            workspacePaths,\n            eventHandler: listener,\n        };\n        // Record the file watcher.\n        this._fileWatchers.push(fileWatcher);\n        return fileWatcher;\n    }\n    _setupConnection(supportedCommands, supportedCodeActions) {\n        // After the server has started the client sends an initialize request. The server receives\n        // in the passed params the rootPath of the workspace plus the client capabilities.\n        this._connection.onInitialize((params) => this.initialize(params, supportedCommands, supportedCodeActions));\n        this._connection.onDidChangeConfiguration((params) => {\n            this.console.log(`Received updated settings`);\n            if (params === null || params === void 0 ? void 0 : params.settings) {\n                this._defaultClientConfig = params === null || params === void 0 ? void 0 : params.settings;\n            }\n            this.updateSettingsForAllWorkspaces();\n        });\n        this._connection.onCodeAction((params, token) => this.executeCodeAction(params, token));\n        this._connection.onDefinition((params, token) => __awaiter(this, void 0, void 0, function* () {\n            this.recordUserInteractionTime();\n            const filePath = pathUtils_1.convertUriToPath(params.textDocument.uri);\n            const position = {\n                line: params.position.line,\n                character: params.position.character,\n            };\n            const workspace = yield this.getWorkspaceForFile(filePath);\n            if (workspace.disableLanguageServices) {\n                return;\n            }\n            const locations = workspace.serviceInstance.getDefinitionForPosition(filePath, position, token);\n            if (!locations) {\n                return undefined;\n            }\n            return locations.map((loc) => node_1.Location.create(pathUtils_1.convertPathToUri(loc.path), loc.range));\n        }));\n        this._connection.onReferences((params, token, reporter) => __awaiter(this, void 0, void 0, function* () {\n            if (this._pendingFindAllRefsCancellationSource) {\n                this._pendingFindAllRefsCancellationSource.cancel();\n                this._pendingFindAllRefsCancellationSource = undefined;\n            }\n            // VS Code doesn't support cancellation of \"final all references\".\n            // We provide a progress bar a cancellation button so the user can cancel\n            // any long-running actions.\n            const progress = yield this._getProgressReporter(params.workDoneToken, reporter, localize_1.Localizer.CodeAction.findingReferences());\n            const source = cancellationUtils_1.CancelAfter(token, progress.token);\n            this._pendingFindAllRefsCancellationSource = source;\n            try {\n                const filePath = pathUtils_1.convertUriToPath(params.textDocument.uri);\n                const position = {\n                    line: params.position.line,\n                    character: params.position.character,\n                };\n                const workspace = yield this.getWorkspaceForFile(filePath);\n                if (workspace.disableLanguageServices) {\n                    return;\n                }\n                const locations = workspace.serviceInstance.getReferencesForPosition(filePath, position, params.context.includeDeclaration, source.token);\n                if (!locations) {\n                    return undefined;\n                }\n                return locations.map((loc) => node_1.Location.create(pathUtils_1.convertPathToUri(loc.path), loc.range));\n            }\n            finally {\n                progress.reporter.done();\n                source.dispose();\n            }\n        }));\n        this._connection.onDocumentSymbol((params, token) => __awaiter(this, void 0, void 0, function* () {\n            this.recordUserInteractionTime();\n            const filePath = pathUtils_1.convertUriToPath(params.textDocument.uri);\n            const workspace = yield this.getWorkspaceForFile(filePath);\n            if (workspace.disableLanguageServices) {\n                return undefined;\n            }\n            const symbolList = [];\n            workspace.serviceInstance.addSymbolsForDocument(filePath, symbolList, token);\n            return symbolList;\n        }));\n        this._connection.onWorkspaceSymbol((params, token) => __awaiter(this, void 0, void 0, function* () {\n            const symbolList = [];\n            this._workspaceMap.forEach((workspace) => __awaiter(this, void 0, void 0, function* () {\n                yield workspace.isInitialized.promise;\n                if (!workspace.disableLanguageServices) {\n                    workspace.serviceInstance.addSymbolsForWorkspace(symbolList, params.query, token);\n                }\n            }));\n            return symbolList;\n        }));\n        this._connection.onHover((params, token) => __awaiter(this, void 0, void 0, function* () {\n            const filePath = pathUtils_1.convertUriToPath(params.textDocument.uri);\n            const position = {\n                line: params.position.line,\n                character: params.position.character,\n            };\n            const workspace = yield this.getWorkspaceForFile(filePath);\n            const hoverResults = workspace.serviceInstance.getHoverForPosition(filePath, position, token);\n            return hoverProvider_1.convertHoverResults(hoverResults);\n        }));\n        this._connection.onDocumentHighlight((params, token) => __awaiter(this, void 0, void 0, function* () {\n            const filePath = pathUtils_1.convertUriToPath(params.textDocument.uri);\n            const position = {\n                line: params.position.line,\n                character: params.position.character,\n            };\n            const workspace = yield this.getWorkspaceForFile(filePath);\n            return workspace.serviceInstance.getDocumentHighlight(filePath, position, token);\n        }));\n        this._connection.onSignatureHelp((params, token) => __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            const filePath = pathUtils_1.convertUriToPath(params.textDocument.uri);\n            const position = {\n                line: params.position.line,\n                character: params.position.character,\n            };\n            const workspace = yield this.getWorkspaceForFile(filePath);\n            if (workspace.disableLanguageServices) {\n                return;\n            }\n            const signatureHelpResults = workspace.serviceInstance.getSignatureHelpForPosition(filePath, position, token);\n            if (!signatureHelpResults) {\n                return undefined;\n            }\n            const signatures = signatureHelpResults.signatures.map((sig) => {\n                let paramInfo = [];\n                if (sig.parameters) {\n                    paramInfo = sig.parameters.map((param) => node_1.ParameterInformation.create([param.startOffset, param.endOffset], param.documentation));\n                }\n                const sigInfo = node_1.SignatureInformation.create(sig.label, sig.documentation, ...paramInfo);\n                sigInfo.activeParameter = sig.activeParameter;\n                return sigInfo;\n            });\n            let activeSignature = signatures.findIndex((sig) => sig.activeParameter !== undefined);\n            if (activeSignature === -1) {\n                activeSignature = null;\n            }\n            let activeParameter = activeSignature !== null ? signatures[activeSignature].activeParameter : null;\n            // Check if we should reuse the user's signature selection. If the retrigger was not \"invoked\"\n            // (i.e., the signature help call was automatically generated by the client due to some navigation\n            // or text change), check to see if the previous signature is still \"active\". If so, we mark it as\n            // active in our response.\n            //\n            // This isn't a perfect method. For nested calls, we can't tell when we are moving between them.\n            // Ideally, we would include a token in the signature help responses to compare later, allowing us\n            // to know when the user's navigated to a nested call (and therefore the old signature's info does\n            // not apply), but for now manually retriggering the signature help will work around the issue.\n            if (((_a = params.context) === null || _a === void 0 ? void 0 : _a.isRetrigger) && params.context.triggerKind !== node_1.SignatureHelpTriggerKind.Invoked) {\n                const prevActiveSignature = (_c = (_b = params.context.activeSignatureHelp) === null || _b === void 0 ? void 0 : _b.activeSignature) !== null && _c !== void 0 ? _c : null;\n                if (prevActiveSignature !== null && prevActiveSignature < signatures.length) {\n                    const sig = signatures[prevActiveSignature];\n                    if (sig.activeParameter !== undefined) {\n                        activeSignature = prevActiveSignature;\n                        activeParameter = sig.activeParameter;\n                    }\n                }\n            }\n            if (this._hasActiveParameterCapability || activeSignature === null) {\n                // A value of -1 is out of bounds but is legal within the LSP (should be treated\n                // as undefined). It produces a better result in VS Code by preventing it from\n                // highlighting the first parameter when no parameter works, since the LSP client\n                // converts null into zero.\n                activeParameter = -1;\n            }\n            return { signatures, activeSignature, activeParameter };\n        }));\n        let lastTriggerKind = node_1.CompletionTriggerKind.Invoked;\n        this._connection.onCompletion((params, token) => __awaiter(this, void 0, void 0, function* () {\n            var _d, _e;\n            // We set completion incomplete for the first invocation and next consecutive call,\n            // but after that we mark it as completed so the client doesn't repeatedly call back.\n            // We mark the first one as incomplete because completion could be invoked without\n            // any meaningful character provided, such as an explicit completion invocation (ctrl+space)\n            // or a period. That might cause us to not include some items (e.g., auto-imports).\n            // The next consecutive call provides some characters to help us to pick\n            // better completion items. After that, we are not going to introduce new items,\n            // so we can let the client to do the filtering and caching.\n            const completionIncomplete = lastTriggerKind !== node_1.CompletionTriggerKind.TriggerForIncompleteCompletions ||\n                ((_d = params.context) === null || _d === void 0 ? void 0 : _d.triggerKind) !== node_1.CompletionTriggerKind.TriggerForIncompleteCompletions;\n            lastTriggerKind = (_e = params.context) === null || _e === void 0 ? void 0 : _e.triggerKind;\n            const filePath = pathUtils_1.convertUriToPath(params.textDocument.uri);\n            const position = {\n                line: params.position.line,\n                character: params.position.character,\n            };\n            const workspace = yield this.getWorkspaceForFile(filePath);\n            if (workspace.disableLanguageServices) {\n                return;\n            }\n            const completions = yield workspace.serviceInstance.getCompletionsForPosition(filePath, position, workspace.rootPath, token);\n            if (completions) {\n                completions.isIncomplete = completionIncomplete;\n            }\n            return completions;\n        }));\n        this._connection.onCompletionResolve((params, token) => __awaiter(this, void 0, void 0, function* () {\n            // Cancellation bugs in vscode and LSP:\n            // https://github.com/microsoft/vscode-languageserver-node/issues/615\n            // https://github.com/microsoft/vscode/issues/95485\n            //\n            // If resolver throws cancellation exception, LSP and VSCode\n            // cache that result and never call us back.\n            const completionItemData = params.data;\n            if (completionItemData && completionItemData.filePath) {\n                const workspace = yield this.getWorkspaceForFile(completionItemData.workspacePath);\n                workspace.serviceInstance.resolveCompletionItem(completionItemData.filePath, params, token);\n            }\n            return params;\n        }));\n        this._connection.onRenameRequest((params, token) => __awaiter(this, void 0, void 0, function* () {\n            const filePath = pathUtils_1.convertUriToPath(params.textDocument.uri);\n            const position = {\n                line: params.position.line,\n                character: params.position.character,\n            };\n            const workspace = yield this.getWorkspaceForFile(filePath);\n            if (workspace.disableLanguageServices) {\n                return;\n            }\n            const editActions = workspace.serviceInstance.renameSymbolAtPosition(filePath, position, params.newName, token);\n            if (!editActions) {\n                return undefined;\n            }\n            return textEditUtils_1.convertWorkspaceEdits(editActions);\n        }));\n        this._connection.languages.callHierarchy.onPrepare((params, token) => __awaiter(this, void 0, void 0, function* () {\n            const filePath = pathUtils_1.convertUriToPath(params.textDocument.uri);\n            const position = {\n                line: params.position.line,\n                character: params.position.character,\n            };\n            const workspace = yield this.getWorkspaceForFile(filePath);\n            if (workspace.disableLanguageServices) {\n                return null;\n            }\n            const callItem = workspace.serviceInstance.getCallForPosition(filePath, position, token) || null;\n            if (!callItem) {\n                return null;\n            }\n            // Convert the file path in the item to proper URI.\n            callItem.uri = pathUtils_1.convertPathToUri(callItem.uri);\n            return [callItem];\n        }));\n        this._connection.languages.callHierarchy.onIncomingCalls((params, token) => __awaiter(this, void 0, void 0, function* () {\n            const filePath = pathUtils_1.convertUriToPath(params.item.uri);\n            const position = {\n                line: params.item.range.start.line,\n                character: params.item.range.start.character,\n            };\n            const workspace = yield this.getWorkspaceForFile(filePath);\n            if (workspace.disableLanguageServices) {\n                return null;\n            }\n            const callItems = workspace.serviceInstance.getIncomingCallsForPosition(filePath, position, token) || null;\n            if (!callItems || callItems.length === 0) {\n                return null;\n            }\n            // Convert the file paths in the items to proper URIs.\n            callItems.forEach((item) => {\n                item.from.uri = pathUtils_1.convertPathToUri(item.from.uri);\n            });\n            return callItems;\n        }));\n        this._connection.languages.callHierarchy.onOutgoingCalls((params, token) => __awaiter(this, void 0, void 0, function* () {\n            const filePath = pathUtils_1.convertUriToPath(params.item.uri);\n            const position = {\n                line: params.item.range.start.line,\n                character: params.item.range.start.character,\n            };\n            const workspace = yield this.getWorkspaceForFile(filePath);\n            if (workspace.disableLanguageServices) {\n                return null;\n            }\n            const callItems = workspace.serviceInstance.getOutgoingCallsForPosition(filePath, position, token) || null;\n            if (!callItems || callItems.length === 0) {\n                return null;\n            }\n            // Convert the file paths in the items to proper URIs.\n            callItems.forEach((item) => {\n                item.to.uri = pathUtils_1.convertPathToUri(item.to.uri);\n            });\n            return callItems;\n        }));\n        this._connection.onDidOpenTextDocument((params) => __awaiter(this, void 0, void 0, function* () {\n            const filePath = pathUtils_1.convertUriToPath(params.textDocument.uri);\n            const workspace = yield this.getWorkspaceForFile(filePath);\n            workspace.serviceInstance.setFileOpened(filePath, params.textDocument.version, params.textDocument.text);\n        }));\n        this._connection.onDidChangeTextDocument((params) => __awaiter(this, void 0, void 0, function* () {\n            this.recordUserInteractionTime();\n            const filePath = pathUtils_1.convertUriToPath(params.textDocument.uri);\n            const workspace = yield this.getWorkspaceForFile(filePath);\n            workspace.serviceInstance.updateOpenFileContents(filePath, params.textDocument.version, params.contentChanges[0].text);\n        }));\n        this._connection.onDidCloseTextDocument((params) => __awaiter(this, void 0, void 0, function* () {\n            const filePath = pathUtils_1.convertUriToPath(params.textDocument.uri);\n            const workspace = yield this.getWorkspaceForFile(filePath);\n            workspace.serviceInstance.setFileClosed(filePath);\n        }));\n        this._connection.onDidChangeWatchedFiles((params) => {\n            params.changes.forEach((change) => {\n                const filePath = pathUtils_1.convertUriToPath(change.uri);\n                const eventType = change.type === 1 ? 'add' : 'change';\n                this._fileWatchers.forEach((watcher) => {\n                    if (watcher.workspacePaths.some((dirPath) => pathUtils_1.containsPath(dirPath, filePath))) {\n                        watcher.eventHandler(eventType, filePath);\n                    }\n                });\n            });\n        });\n        this._connection.onInitialized(() => {\n            if (this._hasWorkspaceFoldersCapability) {\n                this._connection.workspace.onDidChangeWorkspaceFolders((event) => {\n                    event.removed.forEach((workspace) => {\n                        const rootPath = pathUtils_1.convertUriToPath(workspace.uri);\n                        this._workspaceMap.delete(rootPath);\n                    });\n                    event.added.forEach((workspace) => __awaiter(this, void 0, void 0, function* () {\n                        const rootPath = pathUtils_1.convertUriToPath(workspace.uri);\n                        const newWorkspace = {\n                            workspaceName: workspace.name,\n                            rootPath,\n                            rootUri: workspace.uri,\n                            serviceInstance: this.createAnalyzerService(workspace.name),\n                            disableLanguageServices: false,\n                            disableOrganizeImports: false,\n                            isInitialized: deferred_1.createDeferred(),\n                        };\n                        this._workspaceMap.set(rootPath, newWorkspace);\n                        yield this.updateSettingsForWorkspace(newWorkspace);\n                    }));\n                });\n            }\n            // Set up our file watchers.\n            if (this._hasWatchFileCapability) {\n                this._connection.client.register(node_1.DidChangeWatchedFilesNotification.type, {\n                    watchers: [\n                        ...service_1.configFileNames.map((fileName) => {\n                            return {\n                                globPattern: `**/${fileName}`,\n                                kind: node_1.WatchKind.Create | node_1.WatchKind.Change | node_1.WatchKind.Delete,\n                            };\n                        }),\n                        {\n                            globPattern: '**/*.{py,pyi}',\n                            kind: node_1.WatchKind.Create | node_1.WatchKind.Change | node_1.WatchKind.Delete,\n                        },\n                    ],\n                });\n            }\n        });\n        this._connection.onExecuteCommand((params, token, reporter) => __awaiter(this, void 0, void 0, function* () {\n            // Cancel running command if there is one.\n            if (this._pendingCommandCancellationSource) {\n                this._pendingCommandCancellationSource.cancel();\n                this._pendingCommandCancellationSource = undefined;\n            }\n            const executeCommand = (token) => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.executeCommand(params, token);\n                if (node_1.WorkspaceEdit.is(result)) {\n                    // Tell client to apply edits.\n                    this._connection.workspace.applyEdit(result);\n                }\n            });\n            if (this.isLongRunningCommand(params.command)) {\n                // Create a progress dialog for long-running commands.\n                const progress = yield this._getProgressReporter(params.workDoneToken, reporter, localize_1.Localizer.CodeAction.executingCommand());\n                const source = cancellationUtils_1.CancelAfter(token, progress.token);\n                this._pendingCommandCancellationSource = source;\n                try {\n                    executeCommand(source.token);\n                }\n                finally {\n                    progress.reporter.done();\n                    source.dispose();\n                }\n            }\n            else {\n                executeCommand(token);\n            }\n        }));\n    }\n    updateSettingsForAllWorkspaces() {\n        this._workspaceMap.forEach((workspace) => {\n            this.updateSettingsForWorkspace(workspace).ignoreErrors();\n        });\n    }\n    initialize(params, supportedCommands, supportedCodeActions) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        this.rootPath = params.rootPath || '';\n        const capabilities = params.capabilities;\n        this._hasConfigurationCapability = !!((_a = capabilities.workspace) === null || _a === void 0 ? void 0 : _a.configuration);\n        this._hasWatchFileCapability = !!((_c = (_b = capabilities.workspace) === null || _b === void 0 ? void 0 : _b.didChangeWatchedFiles) === null || _c === void 0 ? void 0 : _c.dynamicRegistration);\n        this._hasWorkspaceFoldersCapability = !!((_d = capabilities.workspace) === null || _d === void 0 ? void 0 : _d.workspaceFolders);\n        this._hasVisualStudioExtensionsCapability = !!capabilities.supportsVisualStudioExtensions;\n        this._hasActiveParameterCapability = !!((_g = (_f = (_e = capabilities.textDocument) === null || _e === void 0 ? void 0 : _e.signatureHelp) === null || _f === void 0 ? void 0 : _f.signatureInformation) === null || _g === void 0 ? void 0 : _g.activeParameterSupport);\n        // Create a service instance for each of the workspace folders.\n        if (params.workspaceFolders) {\n            params.workspaceFolders.forEach((folder) => {\n                const path = pathUtils_1.convertUriToPath(folder.uri);\n                this._workspaceMap.set(path, {\n                    workspaceName: folder.name,\n                    rootPath: path,\n                    rootUri: folder.uri,\n                    serviceInstance: this.createAnalyzerService(folder.name),\n                    disableLanguageServices: false,\n                    disableOrganizeImports: false,\n                    isInitialized: deferred_1.createDeferred(),\n                });\n            });\n        }\n        else if (params.rootPath) {\n            this._workspaceMap.set(params.rootPath, {\n                workspaceName: '',\n                rootPath: params.rootPath,\n                rootUri: '',\n                serviceInstance: this.createAnalyzerService(params.rootPath),\n                disableLanguageServices: false,\n                disableOrganizeImports: false,\n                isInitialized: deferred_1.createDeferred(),\n            });\n        }\n        const result = {\n            capabilities: {\n                // Tell the client that the server works in FULL text document\n                // sync mode (as opposed to incremental).\n                textDocumentSync: node_1.TextDocumentSyncKind.Full,\n                definitionProvider: { workDoneProgress: true },\n                referencesProvider: { workDoneProgress: true },\n                documentSymbolProvider: { workDoneProgress: true },\n                workspaceSymbolProvider: { workDoneProgress: true },\n                hoverProvider: { workDoneProgress: true },\n                documentHighlightProvider: { workDoneProgress: true },\n                renameProvider: { workDoneProgress: true },\n                completionProvider: {\n                    triggerCharacters: ['.', '['],\n                    resolveProvider: true,\n                    workDoneProgress: true,\n                },\n                signatureHelpProvider: {\n                    triggerCharacters: ['(', ',', ')'],\n                    workDoneProgress: true,\n                },\n                codeActionProvider: {\n                    codeActionKinds: supportedCodeActions,\n                    workDoneProgress: true,\n                },\n                executeCommandProvider: {\n                    commands: supportedCommands,\n                    workDoneProgress: true,\n                },\n                callHierarchyProvider: true,\n            },\n        };\n        return result;\n    }\n    onAnalysisCompletedHandler(results) {\n        // Send the computed diagnostics to the client.\n        results.diagnostics.forEach((fileDiag) => {\n            this._connection.sendDiagnostics({\n                uri: pathUtils_1.convertPathToUri(fileDiag.filePath),\n                diagnostics: this._convertDiagnostics(fileDiag.diagnostics),\n            });\n        });\n        if (!this._progressReporter.isEnabled(results)) {\n            // Make sure to disable progress bar if it is currently active.\n            // This can happen if a user changes typeCheckingMode in the middle\n            // of analysis.\n            // end() is noop if there is no active progress bar.\n            this._progressReporter.end();\n            return;\n        }\n        // Update progress.\n        if (results.filesRequiringAnalysis > 0) {\n            this._progressReporter.begin();\n            const progressMessage = results.filesRequiringAnalysis === 1\n                ? localize_1.Localizer.CodeAction.filesToAnalyzeOne()\n                : localize_1.Localizer.CodeAction.filesToAnalyzeCount().format({\n                    count: results.filesRequiringAnalysis,\n                });\n            this._progressReporter.report(progressMessage);\n        }\n        else {\n            this._progressReporter.end();\n        }\n    }\n    updateSettingsForWorkspace(workspace) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const serverSettings = yield this.getSettings(workspace);\n            // Set logging level first.\n            this.console.level = (_a = serverSettings.logLevel) !== null && _a !== void 0 ? _a : console_1.LogLevel.Info;\n            this.updateOptionsAndRestartService(workspace, serverSettings);\n            workspace.disableLanguageServices = !!serverSettings.disableLanguageServices;\n            workspace.disableOrganizeImports = !!serverSettings.disableOrganizeImports;\n            // The workspace is now open for business.\n            workspace.isInitialized.resolve(true);\n        });\n    }\n    updateOptionsAndRestartService(workspace, serverSettings, typeStubTargetImportName) {\n        analyzerServiceExecutor_1.AnalyzerServiceExecutor.runWithOptions(this.rootPath, workspace, serverSettings, typeStubTargetImportName);\n    }\n    convertLogLevel(logLevel) {\n        if (!logLevel) {\n            return console_1.LogLevel.Info;\n        }\n        switch (logLevel.toLowerCase()) {\n            case 'error':\n                return console_1.LogLevel.Error;\n            case 'warning':\n                return console_1.LogLevel.Warn;\n            case 'info':\n                return console_1.LogLevel.Info;\n            case 'trace':\n                return console_1.LogLevel.Log;\n            default:\n                return console_1.LogLevel.Info;\n        }\n    }\n    _getProgressReporter(workDoneToken, clientReporter, title) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (workDoneToken) {\n                return { reporter: clientReporter, token: node_1.CancellationToken.None };\n            }\n            const serverInitiatedReporter = yield this._connection.window.createWorkDoneProgress();\n            serverInitiatedReporter.begin(title, undefined, undefined, true);\n            return {\n                reporter: serverInitiatedReporter,\n                token: serverInitiatedReporter.token,\n            };\n        });\n    }\n    _GetConnectionOptions() {\n        return { cancellationStrategy: cancellationUtils_1.getCancellationStrategyFromArgv(process.argv) };\n    }\n    _convertDiagnostics(diags) {\n        return diags.map((diag) => {\n            const severity = convertCategoryToSeverity(diag.category);\n            let source = this._serverOptions.productName;\n            const rule = diag.getRule();\n            if (rule) {\n                source = `${source} (${rule})`;\n            }\n            const vsDiag = node_1.Diagnostic.create(diag.range, diag.message, severity, undefined, source);\n            if (diag.category === 3 /* UnusedCode */) {\n                vsDiag.tags = [node_1.DiagnosticTag.Unnecessary];\n                vsDiag.severity = node_1.DiagnosticSeverity.Hint;\n            }\n            const relatedInfo = diag.getRelatedInfo();\n            if (relatedInfo.length > 0) {\n                vsDiag.relatedInformation = relatedInfo.map((info) => {\n                    return node_1.DiagnosticRelatedInformation.create(node_1.Location.create(pathUtils_1.convertPathToUri(info.filePath), info.range), info.message);\n                });\n            }\n            return vsDiag;\n        });\n        function convertCategoryToSeverity(category) {\n            switch (category) {\n                case 0 /* Error */:\n                    return node_1.DiagnosticSeverity.Error;\n                case 1 /* Warning */:\n                    return node_1.DiagnosticSeverity.Warning;\n                case 2 /* Information */:\n                    return node_1.DiagnosticSeverity.Information;\n                case 3 /* UnusedCode */:\n                    return node_1.DiagnosticSeverity.Hint;\n            }\n        }\n    }\n    recordUserInteractionTime() {\n        // Tell all of the services that the user is actively\n        // interacting with one or more editors, so they should\n        // back off from performing any work.\n        this._workspaceMap.forEach((workspace) => {\n            workspace.serviceInstance.recordUserInteractionTime();\n        });\n    }\n}\nexports.LanguageServerBase = LanguageServerBase;\n\n\n//# sourceURL=webpack://pyright-server/./src/languageServerBase.ts?");

/***/ }),

/***/ "./src/languageService/analyzerServiceExecutor.ts":
/*!********************************************************!*\
  !*** ./src/languageService/analyzerServiceExecutor.ts ***!
  \********************************************************/
/*! flagged exports */
/*! export AnalyzerServiceExecutor [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * analyzerServiceExecutor.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Runs the analyzer service of a given workspace service instance\n * with a specified set of options.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AnalyzerServiceExecutor = void 0;\nconst commandLineOptions_1 = __webpack_require__(/*! ../common/commandLineOptions */ \"./src/common/commandLineOptions.ts\");\nconst pathUtils_1 = __webpack_require__(/*! ../common/pathUtils */ \"./src/common/pathUtils.ts\");\nclass AnalyzerServiceExecutor {\n    static runWithOptions(languageServiceRootPath, workspace, serverSettings, typeStubTargetImportName, trackFiles = true) {\n        const commandLineOptions = getEffectiveCommandLineOptions(languageServiceRootPath, workspace.rootPath, serverSettings, trackFiles, typeStubTargetImportName);\n        // Setting options causes the analyzer service to re-analyze everything.\n        workspace.serviceInstance.setOptions(commandLineOptions, trackFiles);\n    }\n}\nexports.AnalyzerServiceExecutor = AnalyzerServiceExecutor;\nfunction getEffectiveCommandLineOptions(languageServiceRootPath, workspaceRootPath, serverSettings, trackFiles, typeStubTargetImportName) {\n    const commandLineOptions = new commandLineOptions_1.CommandLineOptions(workspaceRootPath, true);\n    commandLineOptions.checkOnlyOpenFiles = serverSettings.openFilesOnly;\n    commandLineOptions.useLibraryCodeForTypes = serverSettings.useLibraryCodeForTypes;\n    commandLineOptions.typeCheckingMode = serverSettings.typeCheckingMode;\n    commandLineOptions.autoImportCompletions = serverSettings.autoImportCompletions;\n    if (!trackFiles) {\n        commandLineOptions.watchForSourceChanges = false;\n        commandLineOptions.watchForLibraryChanges = false;\n    }\n    else {\n        commandLineOptions.watchForSourceChanges = serverSettings.watchForSourceChanges;\n        commandLineOptions.watchForLibraryChanges = serverSettings.watchForLibraryChanges;\n    }\n    if (serverSettings.venvPath) {\n        commandLineOptions.venvPath = pathUtils_1.combinePaths(workspaceRootPath || languageServiceRootPath, pathUtils_1.normalizePath(_expandPathVariables(languageServiceRootPath, serverSettings.venvPath)));\n    }\n    if (serverSettings.pythonPath) {\n        // The Python VS Code extension treats the value \"python\" specially. This means\n        // the local python interpreter should be used rather than interpreting the\n        // setting value as a path to the interpreter. We'll simply ignore it in this case.\n        if (serverSettings.pythonPath.trim() !== 'python') {\n            commandLineOptions.pythonPath = pathUtils_1.combinePaths(workspaceRootPath || languageServiceRootPath, pathUtils_1.normalizePath(_expandPathVariables(languageServiceRootPath, serverSettings.pythonPath)));\n        }\n    }\n    if (serverSettings.typeshedPath) {\n        // Pyright supports only one typeshed path currently, whereas the\n        // official VS Code Python extension supports multiple typeshed paths.\n        // We'll use the first one specified and ignore the rest.\n        commandLineOptions.typeshedPath = pathUtils_1.normalizePath(_expandPathVariables(languageServiceRootPath, serverSettings.typeshedPath));\n    }\n    if (serverSettings.stubPath) {\n        commandLineOptions.stubPath = pathUtils_1.normalizePath(_expandPathVariables(languageServiceRootPath, serverSettings.stubPath));\n    }\n    if (typeStubTargetImportName) {\n        commandLineOptions.typeStubTargetImportName = typeStubTargetImportName;\n    }\n    commandLineOptions.autoSearchPaths = serverSettings.autoSearchPaths;\n    commandLineOptions.extraPaths = serverSettings.extraPaths;\n    commandLineOptions.diagnosticSeverityOverrides = serverSettings.diagnosticSeverityOverrides;\n    return commandLineOptions;\n}\n// Expands certain predefined variables supported within VS Code settings.\n// Ideally, VS Code would provide an API for doing this expansion, but\n// it doesn't. We'll handle the most common variables here as a convenience.\nfunction _expandPathVariables(rootPath, value) {\n    const regexp = /\\$\\{(.*?)\\}/g;\n    return value.replace(regexp, (match, name) => {\n        const trimmedName = name.trim();\n        if (trimmedName === 'workspaceFolder') {\n            return rootPath;\n        }\n        return match;\n    });\n}\n\n\n//# sourceURL=webpack://pyright-server/./src/languageService/analyzerServiceExecutor.ts?");

/***/ }),

/***/ "./src/languageService/autoImporter.ts":
/*!*********************************************!*\
  !*** ./src/languageService/autoImporter.ts ***!
  \*********************************************/
/*! flagged exports */
/*! export AutoImporter [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export buildModuleSymbolsMap [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * autoImporter.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AutoImporter = exports.buildModuleSymbolsMap = void 0;\nconst importStatementUtils_1 = __webpack_require__(/*! ../analyzer/importStatementUtils */ \"./src/analyzer/importStatementUtils.ts\");\nconst SymbolNameUtils = __webpack_require__(/*! ../analyzer/symbolNameUtils */ \"./src/analyzer/symbolNameUtils.ts\");\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst pathUtils_1 = __webpack_require__(/*! ../common/pathUtils */ \"./src/common/pathUtils.ts\");\nconst StringUtils = __webpack_require__(/*! ../common/stringUtils */ \"./src/common/stringUtils.ts\");\n// Build a map of all modules within this program and the module-\n// level scope that contains the symbol table for the module.\nfunction buildModuleSymbolsMap(files, token) {\n    const moduleSymbolMap = new Map();\n    files.forEach((file) => {\n        cancellationUtils_1.throwIfCancellationRequested(token);\n        if (file.shadows.length > 0) {\n            // There is corresponding stub file. Don't add\n            // duplicated files in the map.\n            return;\n        }\n        const symbolTable = file.sourceFile.getModuleSymbolTable();\n        if (symbolTable) {\n            moduleSymbolMap.set(file.sourceFile.getFilePath(), symbolTable);\n        }\n    });\n    return moduleSymbolMap;\n}\nexports.buildModuleSymbolsMap = buildModuleSymbolsMap;\nclass AutoImporter {\n    constructor(_configOptions, _filePath, _importResolver, _parseResults, _moduleSymbolMap, _packageMap) {\n        this._configOptions = _configOptions;\n        this._filePath = _filePath;\n        this._importResolver = _importResolver;\n        this._parseResults = _parseResults;\n        this._moduleSymbolMap = _moduleSymbolMap;\n        this._packageMap = _packageMap;\n    }\n    getAutoImportCandidates(word, similarityLimit, excludes, aliasName, token) {\n        const results = [];\n        const importStatements = importStatementUtils_1.getTopLevelImports(this._parseResults.parseTree);\n        this._addImportsFromModuleMap(word, similarityLimit, excludes, aliasName, importStatements, results, token);\n        this._addImportsFromPackages(word, similarityLimit, excludes, aliasName, importStatements, results, token);\n        return results;\n    }\n    _addImportsFromPackages(word, similarityLimit, excludes, aliasName, importStatements, results, token) {\n        if (!this._packageMap) {\n            return;\n        }\n        this._packageMap.forEach((imports, name) => {\n            cancellationUtils_1.throwIfCancellationRequested(token);\n            // Don't offer imports from files that are named with private\n            // naming semantics like \"_ast.py\".\n            if (SymbolNameUtils.isPrivateOrProtectedName(name)) {\n                return;\n            }\n            const isSimilar = this._isSimilar(word, name, similarityLimit);\n            if (!isSimilar) {\n                return;\n            }\n            imports.forEach((filePath, fullImport) => {\n                cancellationUtils_1.throwIfCancellationRequested(token);\n                const importParts = this._getImportParts(filePath);\n                if (!importParts) {\n                    return;\n                }\n                this._addAutoImports(importParts, excludes, importStatements, aliasName, results);\n            });\n        });\n    }\n    _addImportsFromModuleMap(word, similarityLimit, excludes, aliasName, importStatements, results, token) {\n        this._moduleSymbolMap.forEach((symbolTable, filePath) => {\n            cancellationUtils_1.throwIfCancellationRequested(token);\n            const fileName = pathUtils_1.stripFileExtension(pathUtils_1.getFileName(filePath));\n            // Don't offer imports from files that are named with private\n            // naming semantics like \"_ast.py\".\n            if (SymbolNameUtils.isPrivateOrProtectedName(fileName)) {\n                return;\n            }\n            symbolTable.forEach((symbol, name) => {\n                cancellationUtils_1.throwIfCancellationRequested(token);\n                // For very short matching strings, we will require an exact match. Otherwise\n                // we will tend to return a list that's too long. Once we get beyond two\n                // characters, we can do a fuzzy match.\n                const isSimilar = this._isSimilar(word, name, similarityLimit);\n                if (!isSimilar || symbol.isExternallyHidden()) {\n                    return;\n                }\n                const alreadyIncluded = this._containsName(name, undefined, excludes, results);\n                if (alreadyIncluded) {\n                    return;\n                }\n                const declarations = symbol.getDeclarations();\n                if (!declarations || declarations.length === 0) {\n                    return;\n                }\n                // Don't include imported symbols, only those that\n                // are declared within this file.\n                if (declarations[0].path !== filePath) {\n                    return;\n                }\n                let importSource;\n                let importGroup = 2 /* Local */;\n                let moduleNameAndType;\n                const localImport = importStatements.mapByFilePath.get(filePath);\n                if (localImport) {\n                    importSource = localImport.moduleName;\n                    importGroup = importStatementUtils_1.getImportGroup(localImport);\n                }\n                else {\n                    moduleNameAndType = this._getModuleNameAndTypeFromFilePath(filePath);\n                    importSource = moduleNameAndType.moduleName;\n                    if (!importSource) {\n                        return;\n                    }\n                    importGroup = this._getImportGroupFromModuleNameAndType(moduleNameAndType);\n                }\n                const autoImportTextEdits = this._getTextEditsForAutoImportByFilePath(name, importStatements, filePath, importSource, importGroup, aliasName);\n                results.push({\n                    name,\n                    symbol,\n                    source: importSource,\n                    edits: autoImportTextEdits,\n                    isImportFrom: true,\n                    alias: aliasName,\n                });\n            });\n            // See if this file should be offered as an implicit import.\n            const fileDir = pathUtils_1.getDirectoryPath(filePath);\n            const initPathPy = pathUtils_1.combinePaths(fileDir, '__init__.py');\n            const initPathPyi = initPathPy + 'i';\n            const isStubFile = filePath.endsWith('.pyi');\n            const hasInit = this._moduleSymbolMap.has(initPathPy) || this._moduleSymbolMap.has(initPathPyi);\n            // If the current file is in a directory that also contains an \"__init__.py[i]\"\n            // file, we can use that directory name as an implicit import target.\n            // Or if the file is a stub file, we can use it as import target.\n            if (!isStubFile && !hasInit) {\n                return;\n            }\n            const importParts = this._getImportParts(filePath);\n            if (!importParts) {\n                return;\n            }\n            const isSimilar = this._isSimilar(word, importParts.importName, similarityLimit);\n            if (!isSimilar) {\n                return;\n            }\n            this._addAutoImports(importParts, excludes, importStatements, aliasName, results);\n        });\n    }\n    _addAutoImports(importParts, excludes, importStatements, aliasName, results) {\n        const alreadyIncluded = this._containsName(importParts.importName, importParts.importSource, excludes, results);\n        if (alreadyIncluded) {\n            return;\n        }\n        const importGroup = this._getImportGroupFromModuleNameAndType(importParts.moduleAndType);\n        const autoImportTextEdits = this._getTextEditsForAutoImportByFilePath(importParts.namePart, importStatements, importParts.filePath, importParts.importSource, importGroup, aliasName);\n        results.push({\n            name: importParts.importName,\n            alias: aliasName,\n            symbol: undefined,\n            source: importParts.importSource,\n            edits: autoImportTextEdits,\n            isImportFrom: !!importParts.namePart,\n        });\n    }\n    _getImportParts(filePath) {\n        const name = pathUtils_1.stripFileExtension(pathUtils_1.getFileName(filePath));\n        // See if we can import module as \"import xxx\"\n        if (name === '__init__') {\n            return createImportParts(this._getModuleNameAndTypeFromFilePath(pathUtils_1.getDirectoryPath(filePath)));\n        }\n        return createImportParts(this._getModuleNameAndTypeFromFilePath(filePath));\n        function createImportParts(module) {\n            const importSource = module.moduleName;\n            if (!importSource) {\n                return;\n            }\n            const index = importSource.lastIndexOf('.');\n            const importNamePart = index > 0 ? importSource.substring(index + 1) : undefined;\n            return {\n                namePart: importNamePart,\n                importName: index > 0 ? importNamePart : importSource,\n                importSource: index > 0 ? importSource.substring(0, index) : importSource,\n                filePath,\n                moduleAndType: module,\n            };\n        }\n    }\n    _isSimilar(word, name, similarityLimit) {\n        if (similarityLimit === 1) {\n            return word === name;\n        }\n        return word.length > 2\n            ? StringUtils.computeCompletionSimilarity(word, name) > similarityLimit\n            : word.length > 0 && name.startsWith(word);\n    }\n    _containsName(name, source, excludes, results) {\n        if (excludes.find((e) => e === name)) {\n            return true;\n        }\n        if (results.find((r) => r.name === name && r.source === source)) {\n            return true;\n        }\n        return false;\n    }\n    // Given the file path of a module that we want to import,\n    // convert to a module name that can be used in an\n    // 'import from' statement.\n    _getModuleNameAndTypeFromFilePath(filePath) {\n        const execEnvironment = this._configOptions.findExecEnvironment(this._filePath);\n        return this._importResolver.getModuleNameForImport(filePath, execEnvironment);\n    }\n    _getImportGroupFromModuleNameAndType(moduleNameAndType) {\n        let importGroup = 2 /* Local */;\n        if (moduleNameAndType.isLocalTypingsFile || moduleNameAndType.importType === 1 /* ThirdParty */) {\n            importGroup = 1 /* ThirdParty */;\n        }\n        else if (moduleNameAndType.importType === 0 /* BuiltIn */) {\n            importGroup = 0 /* BuiltIn */;\n        }\n        return importGroup;\n    }\n    _getTextEditsForAutoImportByFilePath(symbolName, importStatements, filePath, moduleName, importGroup, aliasName) {\n        if (symbolName) {\n            // Does an 'import from' statement already exist? If so, we'll reuse it.\n            const importStatement = importStatements.mapByFilePath.get(filePath);\n            if (importStatement && importStatement.node.nodeType === 22 /* ImportFrom */) {\n                return importStatementUtils_1.getTextEditsForAutoImportSymbolAddition(symbolName, importStatement, this._parseResults, aliasName);\n            }\n        }\n        return importStatementUtils_1.getTextEditsForAutoImportInsertion(symbolName, importStatements, moduleName, importGroup, this._parseResults, aliasName);\n    }\n}\nexports.AutoImporter = AutoImporter;\n\n\n//# sourceURL=webpack://pyright-server/./src/languageService/autoImporter.ts?");

/***/ }),

/***/ "./src/languageService/callHierarchyProvider.ts":
/*!******************************************************!*\
  !*** ./src/languageService/callHierarchyProvider.ts ***!
  \******************************************************/
/*! flagged exports */
/*! export CallHierarchyProvider [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * callHierarchyProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic that provides a list of callers or callees associated with\n * a position.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CallHierarchyProvider = void 0;\nconst vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ \"./node_modules/vscode-languageserver/lib/node/main.js\");\nconst DeclarationUtils = __webpack_require__(/*! ../analyzer/declarationUtils */ \"./src/analyzer/declarationUtils.ts\");\nconst ParseTreeUtils = __webpack_require__(/*! ../analyzer/parseTreeUtils */ \"./src/analyzer/parseTreeUtils.ts\");\nconst parseTreeWalker_1 = __webpack_require__(/*! ../analyzer/parseTreeWalker */ \"./src/analyzer/parseTreeWalker.ts\");\nconst types_1 = __webpack_require__(/*! ../analyzer/types */ \"./src/analyzer/types.ts\");\nconst typeUtils_1 = __webpack_require__(/*! ../analyzer/typeUtils */ \"./src/analyzer/typeUtils.ts\");\nconst typeUtils_2 = __webpack_require__(/*! ../analyzer/typeUtils */ \"./src/analyzer/typeUtils.ts\");\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst pathUtils_1 = __webpack_require__(/*! ../common/pathUtils */ \"./src/common/pathUtils.ts\");\nconst positionUtils_1 = __webpack_require__(/*! ../common/positionUtils */ \"./src/common/positionUtils.ts\");\nconst textRange_1 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\nclass CallHierarchyProvider {\n    static getCallForDeclaration(symbolName, declaration, evaluator, token) {\n        cancellationUtils_1.throwIfCancellationRequested(token);\n        if (declaration.type === 3 /* Function */ || declaration.type === 4 /* Class */) {\n            const callItem = {\n                name: symbolName,\n                kind: getSymbolKind(declaration, evaluator),\n                uri: declaration.path,\n                range: declaration.range,\n                selectionRange: declaration.range,\n            };\n            return callItem;\n        }\n        return undefined;\n    }\n    static getIncomingCallsForDeclaration(filePath, symbolName, declaration, parseResults, evaluator, token) {\n        cancellationUtils_1.throwIfCancellationRequested(token);\n        const callFinder = new FindIncomingCallTreeWalker(filePath, symbolName, declaration, parseResults, evaluator, token);\n        const incomingCalls = callFinder.findCalls();\n        return incomingCalls.length > 0 ? incomingCalls : undefined;\n    }\n    static getOutgoingCallsForDeclaration(declaration, parseResults, evaluator, token) {\n        cancellationUtils_1.throwIfCancellationRequested(token);\n        // Find the parse node root corresponding to the function or class.\n        let parseRoot;\n        if (declaration.type === 3 /* Function */) {\n            parseRoot = declaration.node;\n        }\n        else if (declaration.type === 4 /* Class */) {\n            // Look up the __init__ method for this class.\n            const classType = evaluator.getTypeForDeclaration(declaration);\n            if (classType && types_1.isClass(classType)) {\n                // Don't perform a recursive search of parent classes in this\n                // case because we don't want to find an inherited __init__\n                // method defined in a different module.\n                const initMethodMember = typeUtils_2.lookUpClassMember(classType, '__init__', 8 /* SkipInstanceVariables */ |\n                    4 /* SkipObjectBaseClass */ |\n                    2 /* SkipBaseClasses */);\n                if (initMethodMember) {\n                    const initMethodType = evaluator.getTypeOfMember(initMethodMember);\n                    if (initMethodType && initMethodType.category === 5 /* Function */) {\n                        const initDecls = initMethodMember.symbol.getDeclarations();\n                        if (initDecls && initDecls.length > 0) {\n                            const primaryInitDecl = initDecls[0];\n                            if (primaryInitDecl.type === 3 /* Function */) {\n                                parseRoot = primaryInitDecl.node;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (!parseRoot) {\n            return undefined;\n        }\n        const callFinder = new FindOutgoingCallTreeWalker(parseRoot, parseResults, evaluator, token);\n        const outgoingCalls = callFinder.findCalls();\n        return outgoingCalls.length > 0 ? outgoingCalls : undefined;\n    }\n    static getTargetDeclaration(declarations, node) {\n        // If there's more than one declaration, pick the target one.\n        // We'll always prefer one with a declared type, and we'll always\n        // prefer later declarations.\n        let targetDecl = declarations[0];\n        for (const decl of declarations) {\n            if (DeclarationUtils.hasTypeForDeclaration(decl) || !DeclarationUtils.hasTypeForDeclaration(targetDecl)) {\n                if (decl.type === 3 /* Function */ || decl.type === 4 /* Class */) {\n                    targetDecl = decl;\n                    // If the specified node is an exact match, use this declaration\n                    // as the primary even if it's not the last.\n                    if (decl.node === node) {\n                        break;\n                    }\n                }\n            }\n        }\n        return targetDecl;\n    }\n}\nexports.CallHierarchyProvider = CallHierarchyProvider;\nclass FindOutgoingCallTreeWalker extends parseTreeWalker_1.ParseTreeWalker {\n    constructor(_parseRoot, _parseResults, _evaluator, _cancellationToken) {\n        super();\n        this._parseRoot = _parseRoot;\n        this._parseResults = _parseResults;\n        this._evaluator = _evaluator;\n        this._cancellationToken = _cancellationToken;\n        this._outgoingCalls = [];\n    }\n    findCalls() {\n        this.walk(this._parseRoot);\n        return this._outgoingCalls;\n    }\n    visitCall(node) {\n        cancellationUtils_1.throwIfCancellationRequested(this._cancellationToken);\n        let nameNode;\n        if (node.leftExpression.nodeType === 39 /* Name */) {\n            nameNode = node.leftExpression;\n        }\n        else if (node.leftExpression.nodeType === 36 /* MemberAccess */) {\n            nameNode = node.leftExpression.memberName;\n        }\n        if (nameNode) {\n            const declarations = this._evaluator.getDeclarationsForNameNode(nameNode);\n            if (declarations) {\n                // TODO - it would be better if we could match the call to the\n                // specific declaration (e.g. a specific overload of a property\n                // setter vs getter). For now, add callees for all declarations.\n                declarations.forEach((decl) => {\n                    this._addOutgoingCallForDeclaration(nameNode, decl);\n                });\n            }\n        }\n        return true;\n    }\n    visitMemberAccess(node) {\n        cancellationUtils_1.throwIfCancellationRequested(this._cancellationToken);\n        // Determine whether the member corresponds to a property.\n        // If so, we'll treat it as a function call for purposes of\n        // finding outgoing calls.\n        const leftHandType = this._evaluator.getType(node.leftExpression);\n        if (leftHandType) {\n            typeUtils_2.doForSubtypes(leftHandType, (subtype) => {\n                let baseType = subtype;\n                // This could be a bound TypeVar (e.g. used for \"self\" and \"cls\").\n                if (types_1.isTypeVar(baseType)) {\n                    baseType = typeUtils_1.specializeType(baseType, /* typeVarMap */ undefined, /* makeConcrete */ true);\n                }\n                if (!types_1.isObject(baseType)) {\n                    return undefined;\n                }\n                const memberInfo = typeUtils_2.lookUpObjectMember(baseType, node.memberName.value);\n                if (!memberInfo) {\n                    return undefined;\n                }\n                const memberType = this._evaluator.getTypeOfMember(memberInfo);\n                const propertyDecls = memberInfo.symbol.getDeclarations();\n                if (!memberType) {\n                    return undefined;\n                }\n                if (types_1.isObject(memberType) && types_1.ClassType.isPropertyClass(memberType.classType)) {\n                    propertyDecls.forEach((decl) => {\n                        this._addOutgoingCallForDeclaration(node.memberName, decl);\n                    });\n                }\n                return undefined;\n            });\n        }\n        return true;\n    }\n    _addOutgoingCallForDeclaration(nameNode, declaration) {\n        const resolvedDecl = this._evaluator.resolveAliasDeclaration(declaration, /* resolveLocalNames */ true);\n        if (!resolvedDecl) {\n            return;\n        }\n        if (resolvedDecl.type !== 3 /* Function */ && resolvedDecl.type !== 4 /* Class */) {\n            return;\n        }\n        const callDest = {\n            name: nameNode.value,\n            kind: getSymbolKind(resolvedDecl, this._evaluator),\n            uri: resolvedDecl.path,\n            range: resolvedDecl.range,\n            selectionRange: resolvedDecl.range,\n        };\n        // Is there already a call recorded for this destination? If so,\n        // we'll simply add a new range. Otherwise, we'll create a new entry.\n        let outgoingCall = this._outgoingCalls.find((outgoing) => outgoing.to.uri === callDest.uri && textRange_1.rangesAreEqual(outgoing.to.range, callDest.range));\n        if (!outgoingCall) {\n            outgoingCall = {\n                to: callDest,\n                fromRanges: [],\n            };\n            this._outgoingCalls.push(outgoingCall);\n        }\n        const fromRange = positionUtils_1.convertOffsetsToRange(nameNode.start, nameNode.start + nameNode.length, this._parseResults.tokenizerOutput.lines);\n        outgoingCall.fromRanges.push(fromRange);\n    }\n}\nclass FindIncomingCallTreeWalker extends parseTreeWalker_1.ParseTreeWalker {\n    constructor(_filePath, _symbolName, _declaration, _parseResults, _evaluator, _cancellationToken) {\n        super();\n        this._filePath = _filePath;\n        this._symbolName = _symbolName;\n        this._declaration = _declaration;\n        this._parseResults = _parseResults;\n        this._evaluator = _evaluator;\n        this._cancellationToken = _cancellationToken;\n        this._incomingCalls = [];\n    }\n    findCalls() {\n        this.walk(this._parseResults.parseTree);\n        return this._incomingCalls;\n    }\n    visitCall(node) {\n        cancellationUtils_1.throwIfCancellationRequested(this._cancellationToken);\n        let nameNode;\n        if (node.leftExpression.nodeType === 39 /* Name */) {\n            nameNode = node.leftExpression;\n        }\n        else if (node.leftExpression.nodeType === 36 /* MemberAccess */) {\n            nameNode = node.leftExpression.memberName;\n        }\n        // Don't bother doing any more work if the name doesn't match.\n        if (nameNode && nameNode.value === this._symbolName) {\n            const declarations = this._evaluator.getDeclarationsForNameNode(nameNode);\n            if (declarations) {\n                const resolvedDecls = declarations\n                    .map((decl) => {\n                    return this._evaluator.resolveAliasDeclaration(decl, /* resolveLocalNames */ true);\n                })\n                    .filter((decl) => decl !== undefined);\n                if (resolvedDecls.some((decl) => DeclarationUtils.areDeclarationsSame(decl, this._declaration))) {\n                    this._addIncomingCallForDeclaration(nameNode);\n                }\n            }\n        }\n        return true;\n    }\n    visitMemberAccess(node) {\n        cancellationUtils_1.throwIfCancellationRequested(this._cancellationToken);\n        if (node.memberName.value === this._symbolName) {\n            // Determine whether the member corresponds to a property.\n            // If so, we'll treat it as a function call for purposes of\n            // finding outgoing calls.\n            const leftHandType = this._evaluator.getType(node.leftExpression);\n            if (leftHandType) {\n                typeUtils_2.doForSubtypes(leftHandType, (subtype) => {\n                    let baseType = subtype;\n                    // This could be a bound TypeVar (e.g. used for \"self\" and \"cls\").\n                    if (types_1.isTypeVar(baseType)) {\n                        baseType = typeUtils_1.specializeType(baseType, /* typeVarMap */ undefined, /* makeConcrete */ true);\n                    }\n                    if (!types_1.isObject(baseType)) {\n                        return undefined;\n                    }\n                    const memberInfo = typeUtils_2.lookUpObjectMember(baseType, node.memberName.value);\n                    if (!memberInfo) {\n                        return undefined;\n                    }\n                    const memberType = this._evaluator.getTypeOfMember(memberInfo);\n                    const propertyDecls = memberInfo.symbol.getDeclarations();\n                    if (!memberType) {\n                        return undefined;\n                    }\n                    if (propertyDecls.some((decl) => DeclarationUtils.areDeclarationsSame(decl, this._declaration))) {\n                        this._addIncomingCallForDeclaration(node.memberName);\n                    }\n                    return undefined;\n                });\n            }\n        }\n        return true;\n    }\n    _addIncomingCallForDeclaration(nameNode) {\n        const executionNode = ParseTreeUtils.getExecutionScopeNode(nameNode);\n        if (!executionNode) {\n            return;\n        }\n        let callSource;\n        if (executionNode.nodeType === 37 /* Module */) {\n            const moduleRange = positionUtils_1.convertOffsetsToRange(0, 0, this._parseResults.tokenizerOutput.lines);\n            const fileName = pathUtils_1.getFileName(this._filePath);\n            callSource = {\n                name: `(module) ${fileName}`,\n                kind: vscode_languageserver_1.SymbolKind.Module,\n                uri: this._filePath,\n                range: moduleRange,\n                selectionRange: moduleRange,\n            };\n        }\n        else if (executionNode.nodeType === 31 /* Lambda */) {\n            const lambdaRange = positionUtils_1.convertOffsetsToRange(executionNode.start, executionNode.start + executionNode.length, this._parseResults.tokenizerOutput.lines);\n            callSource = {\n                name: '(lambda)',\n                kind: vscode_languageserver_1.SymbolKind.Function,\n                uri: this._filePath,\n                range: lambdaRange,\n                selectionRange: lambdaRange,\n            };\n        }\n        else {\n            const functionRange = positionUtils_1.convertOffsetsToRange(executionNode.name.start, executionNode.name.start + executionNode.name.length, this._parseResults.tokenizerOutput.lines);\n            callSource = {\n                name: executionNode.name.value,\n                kind: vscode_languageserver_1.SymbolKind.Function,\n                uri: this._filePath,\n                range: functionRange,\n                selectionRange: functionRange,\n            };\n        }\n        // Is there already a call recorded for this caller? If so,\n        // we'll simply add a new range. Otherwise, we'll create a new entry.\n        let incomingCall = this._incomingCalls.find((incoming) => incoming.from.uri === callSource.uri && textRange_1.rangesAreEqual(incoming.from.range, callSource.range));\n        if (!incomingCall) {\n            incomingCall = {\n                from: callSource,\n                fromRanges: [],\n            };\n            this._incomingCalls.push(incomingCall);\n        }\n        const fromRange = positionUtils_1.convertOffsetsToRange(nameNode.start, nameNode.start + nameNode.length, this._parseResults.tokenizerOutput.lines);\n        incomingCall.fromRanges.push(fromRange);\n    }\n}\nfunction getSymbolKind(declaration, evaluator) {\n    let symbolKind;\n    switch (declaration.type) {\n        case 4 /* Class */:\n        case 5 /* SpecialBuiltInClass */:\n            symbolKind = vscode_languageserver_1.SymbolKind.Class;\n            break;\n        case 3 /* Function */:\n            if (declaration.isMethod) {\n                const declType = evaluator.getTypeForDeclaration(declaration);\n                if (declType && typeUtils_2.isProperty(declType)) {\n                    symbolKind = vscode_languageserver_1.SymbolKind.Property;\n                }\n                else {\n                    symbolKind = vscode_languageserver_1.SymbolKind.Method;\n                }\n            }\n            else {\n                symbolKind = vscode_languageserver_1.SymbolKind.Function;\n            }\n            break;\n        default:\n            symbolKind = vscode_languageserver_1.SymbolKind.Function;\n            break;\n    }\n    return symbolKind;\n}\n\n\n//# sourceURL=webpack://pyright-server/./src/languageService/callHierarchyProvider.ts?");

/***/ }),

/***/ "./src/languageService/codeActionProvider.ts":
/*!***************************************************!*\
  !*** ./src/languageService/codeActionProvider.ts ***!
  \***************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * codeActionProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Handles 'code actions' requests from the client.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CodeActionProvider = void 0;\nconst vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ \"./node_modules/vscode-languageserver/lib/node/main.js\");\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst localize_1 = __webpack_require__(/*! ../localization/localize */ \"./src/localization/localize.ts\");\nclass CodeActionProvider {\n    static getCodeActionsForPosition(workspace, filePath, range, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            cancellationUtils_1.throwIfCancellationRequested(token);\n            const codeActions = [];\n            if (!workspace.disableLanguageServices) {\n                const diags = yield workspace.serviceInstance.getDiagnosticsForRange(filePath, range, token);\n                const typeStubDiag = diags.find((d) => {\n                    const actions = d.getActions();\n                    return actions && actions.find((a) => a.action === \"pyright.createtypestub\" /* createTypeStub */);\n                });\n                if (typeStubDiag) {\n                    const action = typeStubDiag\n                        .getActions()\n                        .find((a) => a.action === \"pyright.createtypestub\" /* createTypeStub */);\n                    if (action) {\n                        const createTypeStubAction = vscode_languageserver_1.CodeAction.create(localize_1.Localizer.CodeAction.createTypeStubFor().format({ moduleName: action.moduleName }), vscode_languageserver_1.Command.create(localize_1.Localizer.CodeAction.createTypeStub(), \"pyright.createtypestub\" /* createTypeStub */, workspace.rootPath, action.moduleName, filePath), vscode_languageserver_1.CodeActionKind.QuickFix);\n                        codeActions.push(createTypeStubAction);\n                    }\n                }\n                const addOptionalDiag = diags.find((d) => {\n                    const actions = d.getActions();\n                    return actions && actions.find((a) => a.action === \"pyright.addoptionalforparam\" /* addMissingOptionalToParam */);\n                });\n                if (addOptionalDiag) {\n                    const action = addOptionalDiag\n                        .getActions()\n                        .find((a) => a.action === \"pyright.addoptionalforparam\" /* addMissingOptionalToParam */);\n                    if (action) {\n                        const addMissingOptionalAction = vscode_languageserver_1.CodeAction.create(localize_1.Localizer.CodeAction.addOptionalToAnnotation(), vscode_languageserver_1.Command.create(localize_1.Localizer.CodeAction.addOptionalToAnnotation(), \"pyright.addoptionalforparam\" /* addMissingOptionalToParam */, action.offsetOfTypeNode), vscode_languageserver_1.CodeActionKind.QuickFix);\n                        codeActions.push(addMissingOptionalAction);\n                    }\n                }\n            }\n            return codeActions;\n        });\n    }\n}\nexports.CodeActionProvider = CodeActionProvider;\n\n\n//# sourceURL=webpack://pyright-server/./src/languageService/codeActionProvider.ts?");

/***/ }),

/***/ "./src/languageService/completionProvider.ts":
/*!***************************************************!*\
  !*** ./src/languageService/completionProvider.ts ***!
  \***************************************************/
/*! flagged exports */
/*! export CompletionProvider [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * completionProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic that maps a position within a Python program file into\n * a list of zero or more text completions that apply in the context.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CompletionProvider = void 0;\nconst vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ \"./node_modules/vscode-languageserver/lib/node/main.js\");\nconst AnalyzerNodeInfo = __webpack_require__(/*! ../analyzer/analyzerNodeInfo */ \"./src/analyzer/analyzerNodeInfo.ts\");\nconst docStringToMarkdown_1 = __webpack_require__(/*! ../analyzer/docStringToMarkdown */ \"./src/analyzer/docStringToMarkdown.ts\");\nconst ParseTreeUtils = __webpack_require__(/*! ../analyzer/parseTreeUtils */ \"./src/analyzer/parseTreeUtils.ts\");\nconst SymbolNameUtils = __webpack_require__(/*! ../analyzer/symbolNameUtils */ \"./src/analyzer/symbolNameUtils.ts\");\nconst symbolUtils_1 = __webpack_require__(/*! ../analyzer/symbolUtils */ \"./src/analyzer/symbolUtils.ts\");\nconst typeDocStringUtils_1 = __webpack_require__(/*! ../analyzer/typeDocStringUtils */ \"./src/analyzer/typeDocStringUtils.ts\");\nconst types_1 = __webpack_require__(/*! ../analyzer/types */ \"./src/analyzer/types.ts\");\nconst typeUtils_1 = __webpack_require__(/*! ../analyzer/typeUtils */ \"./src/analyzer/typeUtils.ts\");\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst positionUtils_1 = __webpack_require__(/*! ../common/positionUtils */ \"./src/common/positionUtils.ts\");\nconst StringUtils = __webpack_require__(/*! ../common/stringUtils */ \"./src/common/stringUtils.ts\");\nconst textRange_1 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\nconst textRange_2 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\nconst parseNodes_1 = __webpack_require__(/*! ../parser/parseNodes */ \"./src/parser/parseNodes.ts\");\nconst autoImporter_1 = __webpack_require__(/*! ./autoImporter */ \"./src/languageService/autoImporter.ts\");\nconst _keywords = [\n    // Expression keywords\n    'True',\n    'False',\n    'None',\n    'and',\n    'or',\n    'await',\n    'not',\n    'is',\n    'lambda',\n    'yield',\n    // Statement keywords\n    'assert',\n    'async',\n    'break',\n    'class',\n    'continue',\n    'def',\n    'del',\n    'elif',\n    'else',\n    'except',\n    'finally',\n    'for',\n    'from',\n    'global',\n    'if',\n    'import',\n    'in',\n    'nonlocal',\n    'pass',\n    'raise',\n    'return',\n    'try',\n    'while',\n    'yield',\n];\nvar SortCategory;\n(function (SortCategory) {\n    // The order of the following is important. We use\n    // this to order the completion suggestions.\n    // A keyword that must be entered for the syntax to be correct.\n    SortCategory[SortCategory[\"LikelyKeyword\"] = 0] = \"LikelyKeyword\";\n    // A module name recently used in an import statement.\n    SortCategory[SortCategory[\"RecentImportModuleName\"] = 1] = \"RecentImportModuleName\";\n    // A module name used in an import statement.\n    SortCategory[SortCategory[\"ImportModuleName\"] = 2] = \"ImportModuleName\";\n    // A literal string.\n    SortCategory[SortCategory[\"LiteralValue\"] = 3] = \"LiteralValue\";\n    // A named parameter in a call expression.\n    SortCategory[SortCategory[\"NamedParameter\"] = 4] = \"NamedParameter\";\n    // A keyword or symbol that was recently used for completion.\n    SortCategory[SortCategory[\"RecentKeywordOrSymbol\"] = 5] = \"RecentKeywordOrSymbol\";\n    // An auto-import symbol that was recently used for completion.\n    SortCategory[SortCategory[\"RecentAutoImport\"] = 6] = \"RecentAutoImport\";\n    // A keyword in the python syntax.\n    SortCategory[SortCategory[\"Keyword\"] = 7] = \"Keyword\";\n    // A normal symbol.\n    SortCategory[SortCategory[\"NormalSymbol\"] = 8] = \"NormalSymbol\";\n    // A symbol that starts with _ or __ (used only when there is\n    // no matching filter).\n    SortCategory[SortCategory[\"PrivateSymbol\"] = 9] = \"PrivateSymbol\";\n    // A symbol with a dunder name (e.g. __init__).\n    SortCategory[SortCategory[\"DunderSymbol\"] = 10] = \"DunderSymbol\";\n    // An auto-import symbol.\n    SortCategory[SortCategory[\"AutoImport\"] = 11] = \"AutoImport\";\n})(SortCategory || (SortCategory = {}));\n// We'll use a somewhat-arbitrary cutoff value here to determine\n// whether it's sufficiently similar.\nconst similarityLimit = 0.25;\n// We'll remember this many completions in the MRU list.\nconst maxRecentCompletions = 128;\nclass CompletionProvider {\n    constructor(_workspacePath, _parseResults, _fileContents, _importResolver, _position, _filePath, _configOptions, _importLookup, _evaluator, _sourceMapper, _moduleSymbolsCallback, _cancellationToken) {\n        this._workspacePath = _workspacePath;\n        this._parseResults = _parseResults;\n        this._fileContents = _fileContents;\n        this._importResolver = _importResolver;\n        this._position = _position;\n        this._filePath = _filePath;\n        this._configOptions = _configOptions;\n        this._importLookup = _importLookup;\n        this._evaluator = _evaluator;\n        this._sourceMapper = _sourceMapper;\n        this._moduleSymbolsCallback = _moduleSymbolsCallback;\n        this._cancellationToken = _cancellationToken;\n    }\n    getCompletionsForPosition() {\n        const offset = positionUtils_1.convertPositionToOffset(this._position, this._parseResults.tokenizerOutput.lines);\n        if (offset === undefined) {\n            return undefined;\n        }\n        let node = ParseTreeUtils.findNodeByOffset(this._parseResults.parseTree, offset);\n        // See if we can get to a \"better\" node by backing up a few columns.\n        // A \"better\" node is defined as one that's deeper than the current\n        // node.\n        const initialNode = node;\n        const initialDepth = node ? ParseTreeUtils.getNodeDepth(node) : 0;\n        if (!initialNode || initialNode.nodeType !== 39 /* Name */) {\n            let curOffset = offset;\n            while (curOffset >= 0) {\n                curOffset--;\n                // Stop scanning backward if we hit certain stop characters.\n                const curChar = this._fileContents.substr(curOffset, 1);\n                if (curChar === '(' || curChar === '\\n') {\n                    break;\n                }\n                const curNode = ParseTreeUtils.findNodeByOffset(this._parseResults.parseTree, curOffset);\n                if (curNode && curNode !== initialNode) {\n                    if (ParseTreeUtils.getNodeDepth(curNode) > initialDepth) {\n                        node = curNode;\n                    }\n                    break;\n                }\n            }\n        }\n        if (node === undefined) {\n            return undefined;\n        }\n        // Get the text on that line prior to the insertion point.\n        const lineTextRange = this._parseResults.tokenizerOutput.lines.getItemAt(this._position.line);\n        const textOnLine = this._fileContents.substr(lineTextRange.start, lineTextRange.length);\n        const priorText = textOnLine.substr(0, this._position.character);\n        const postText = textOnLine.substr(this._position.character);\n        const priorWordIndex = priorText.search(/\\w+$/);\n        const priorWord = priorWordIndex >= 0 ? priorText.substr(priorWordIndex) : '';\n        // Don't offer completions if we're within a comment.\n        if (this._isWithinComment(offset, priorText)) {\n            return undefined;\n        }\n        // See if the node is part of an error node. If so, that takes\n        // precedence.\n        let errorNode = node;\n        while (errorNode) {\n            if (errorNode.nodeType === 0 /* Error */) {\n                break;\n            }\n            errorNode = errorNode.parent;\n        }\n        // Determine the context based on the parse node's type and\n        // that of its ancestors.\n        let curNode = errorNode || node;\n        while (true) {\n            cancellationUtils_1.throwIfCancellationRequested(this._cancellationToken);\n            if (curNode.nodeType === 50 /* String */) {\n                return this._getStringLiteralCompletions(curNode, priorWord, priorText, postText);\n            }\n            if (curNode.nodeType === 49 /* StringList */) {\n                return undefined;\n            }\n            if (curNode.nodeType === 38 /* ModuleName */) {\n                return this._getImportModuleCompletions(curNode);\n            }\n            if (curNode.nodeType === 0 /* Error */) {\n                return this._getExpressionErrorCompletions(curNode, priorWord, priorText, postText);\n            }\n            if (curNode.nodeType === 36 /* MemberAccess */) {\n                return this._getMemberAccessCompletions(curNode.leftExpression, priorWord);\n            }\n            if (curNode.nodeType === 39 /* Name */) {\n                // Are we within a \"from X import Y as Z\" statement and\n                // more specifically within the \"Y\"?\n                if (curNode.parent && curNode.parent.nodeType === 38 /* ModuleName */) {\n                    return this._getImportModuleCompletions(curNode.parent);\n                }\n                else if (curNode.parent && curNode.parent.nodeType === 23 /* ImportFromAs */) {\n                    const parentNode = curNode.parent.parent;\n                    if (parentNode && parentNode.nodeType === 22 /* ImportFrom */) {\n                        if (curNode.parent.name === curNode) {\n                            return this._getImportFromCompletions(parentNode, priorWord);\n                        }\n                        else {\n                            return this._getImportFromCompletions(parentNode, '');\n                        }\n                    }\n                }\n                else if (curNode.parent &&\n                    curNode.parent.nodeType === 36 /* MemberAccess */ &&\n                    curNode === curNode.parent.memberName) {\n                    return this._getMemberAccessCompletions(curNode.parent.leftExpression, priorWord);\n                }\n            }\n            if (curNode.nodeType === 22 /* ImportFrom */) {\n                return this._getImportFromCompletions(curNode, priorWord);\n            }\n            if (parseNodes_1.isExpressionNode(curNode)) {\n                return this._getExpressionCompletions(curNode, priorWord, priorText, postText);\n            }\n            if (curNode.nodeType === 51 /* Suite */ || curNode.nodeType === 37 /* Module */) {\n                return this._getStatementCompletions(curNode, priorWord, priorText, postText);\n            }\n            if (!curNode.parent) {\n                break;\n            }\n            curNode = curNode.parent;\n        }\n        return undefined;\n    }\n    // When the user selects a completion, this callback is invoked,\n    // allowing us to record what was selected. This allows us to\n    // build our MRU cache so we can better predict entries.\n    resolveCompletionItem(completionItem) {\n        cancellationUtils_1.throwIfCancellationRequested(this._cancellationToken);\n        const completionItemData = completionItem.data;\n        const label = completionItem.label;\n        let autoImportText = '';\n        if (completionItemData.autoImportText) {\n            autoImportText = completionItemData.autoImportText;\n        }\n        const curIndex = CompletionProvider._mostRecentCompletions.findIndex((item) => item.label === label && item.autoImportText === autoImportText);\n        if (curIndex > 0) {\n            // If there's an existing entry with the same name that's not at the\n            // beginning of the array, remove it.\n            CompletionProvider._mostRecentCompletions = CompletionProvider._mostRecentCompletions.splice(curIndex, 1);\n        }\n        if (curIndex !== 0) {\n            // Add to the start of the array.\n            CompletionProvider._mostRecentCompletions.unshift({ label, autoImportText });\n        }\n        if (CompletionProvider._mostRecentCompletions.length > maxRecentCompletions) {\n            // Prevent the MRU list from growing indefinitely.\n            CompletionProvider._mostRecentCompletions.pop();\n        }\n        if (completionItemData.symbolId) {\n            this._itemToResolve = completionItem;\n            // Rerun the completion lookup. It will fill in additional information\n            // about the item to be resolved. We'll ignore the rest of the returned\n            // list. This is a bit wasteful, but all of that information should be\n            // cached, so it's not as bad as it might seem.\n            this.getCompletionsForPosition();\n        }\n    }\n    _isWithinComment(offset, priorText) {\n        const tokenIndex = this._parseResults.tokenizerOutput.tokens.getItemAtPosition(offset);\n        if (tokenIndex < 0) {\n            return false;\n        }\n        const token = this._parseResults.tokenizerOutput.tokens.getItemAt(tokenIndex);\n        // If we're in the middle of a token, we're not in a comment.\n        if (offset > token.start && offset < textRange_2.TextRange.getEnd(token)) {\n            return false;\n        }\n        // See if the text that precedes the current position contains\n        // a '#' character.\n        return !!priorText.match(/#/);\n    }\n    _getExpressionErrorCompletions(node, priorWord, priorText, postText) {\n        // Is the error due to a missing member access name? If so,\n        // we can evaluate the left side of the member access expression\n        // to determine its type and offer suggestions based on it.\n        switch (node.category) {\n            case 0 /* MissingIn */: {\n                return this._createSingleKeywordCompletionList('in');\n            }\n            case 1 /* MissingElse */: {\n                return this._createSingleKeywordCompletionList('else');\n            }\n            case 2 /* MissingExpression */:\n            case 3 /* MissingIndexOrSlice */:\n            case 4 /* MissingDecoratorCallName */: {\n                return this._getExpressionCompletions(node, priorWord, priorText, postText);\n            }\n            case 7 /* MissingMemberAccessName */: {\n                if (node.child && parseNodes_1.isExpressionNode(node.child)) {\n                    return this._getMemberAccessCompletions(node.child, priorWord);\n                }\n                break;\n            }\n            case 10 /* MissingFunctionParameterList */: {\n                if (node.child && node.child.nodeType === 39 /* Name */) {\n                    // Determine if the partial name is a method that's overriding\n                    // a method in a base class.\n                    return this._getMethodOverrideCompletions(node.child);\n                }\n                break;\n            }\n        }\n        return undefined;\n    }\n    _createSingleKeywordCompletionList(keyword) {\n        const completionItem = vscode_languageserver_1.CompletionItem.create(keyword);\n        completionItem.kind = vscode_languageserver_1.CompletionItemKind.Keyword;\n        completionItem.sortText = this._makeSortText(SortCategory.LikelyKeyword, keyword);\n        return vscode_languageserver_1.CompletionList.create([completionItem]);\n    }\n    _getMethodOverrideCompletions(partialName) {\n        const enclosingClass = ParseTreeUtils.getEnclosingClass(partialName, true);\n        if (!enclosingClass) {\n            return undefined;\n        }\n        const classResults = this._evaluator.getTypeOfClass(enclosingClass);\n        if (!classResults) {\n            return undefined;\n        }\n        // Get symbols in reverse-MRO, but leave omit the class itself.\n        const symbolTable = new Map();\n        for (let i = classResults.classType.details.mro.length - 1; i > 0; i--) {\n            const mroClass = classResults.classType.details.mro[i];\n            if (types_1.isClass(mroClass)) {\n                typeUtils_1.getMembersForClass(mroClass, symbolTable, false);\n            }\n        }\n        const completionList = vscode_languageserver_1.CompletionList.create();\n        symbolTable.forEach((symbol, name) => {\n            const decl = symbolUtils_1.getLastTypedDeclaredForSymbol(symbol);\n            if (decl && decl.type === 3 /* Function */) {\n                const isSimilar = StringUtils.computeCompletionSimilarity(partialName.value, name) > similarityLimit;\n                if (isSimilar) {\n                    const range = {\n                        start: { line: this._position.line, character: this._position.character - partialName.length },\n                        end: { line: this._position.line, character: this._position.character },\n                    };\n                    const methodSignature = this._printMethodSignature(decl.node) + ':';\n                    const textEdit = vscode_languageserver_1.TextEdit.replace(range, methodSignature);\n                    this._addSymbol(name, symbol, partialName.value, completionList, undefined, textEdit);\n                }\n            }\n        });\n        return completionList;\n    }\n    _printMethodSignature(node) {\n        const paramList = node.parameters\n            .map((param) => {\n            let paramString = '';\n            if (param.category === 1 /* VarArgList */) {\n                paramString += '*';\n            }\n            else if (param.category === 2 /* VarArgDictionary */) {\n                paramString += '**';\n            }\n            if (param.name) {\n                paramString += param.name.value;\n            }\n            if (param.typeAnnotation) {\n                paramString += ': ' + ParseTreeUtils.printExpression(param.typeAnnotation);\n            }\n            return paramString;\n        })\n            .join(', ');\n        let methodSignature = node.name.value + '(' + paramList + ')';\n        if (node.returnTypeAnnotation) {\n            methodSignature += ' -> ' + ParseTreeUtils.printExpression(node.returnTypeAnnotation);\n        }\n        return methodSignature;\n    }\n    _getMemberAccessCompletions(leftExprNode, priorWord) {\n        const leftType = this._evaluator.getType(leftExprNode);\n        const symbolTable = new Map();\n        if (leftType) {\n            typeUtils_1.doForSubtypes(leftType, (subtype) => {\n                let specializedSubtype = subtype;\n                if (types_1.isTypeVar(subtype)) {\n                    specializedSubtype = typeUtils_1.specializeType(subtype, /* typeVarMap */ undefined, /* makeConcrete */ true);\n                }\n                if (types_1.isObject(specializedSubtype)) {\n                    typeUtils_1.getMembersForClass(specializedSubtype.classType, symbolTable, true);\n                }\n                else if (types_1.isClass(specializedSubtype)) {\n                    typeUtils_1.getMembersForClass(specializedSubtype, symbolTable, false);\n                }\n                else if (types_1.isModule(specializedSubtype)) {\n                    typeUtils_1.getMembersForModule(specializedSubtype, symbolTable);\n                }\n                return undefined;\n            });\n        }\n        const completionList = vscode_languageserver_1.CompletionList.create();\n        const objectThrough = leftType && types_1.isObject(leftType) ? leftType : undefined;\n        this._addSymbolsForSymbolTable(symbolTable, (_) => true, priorWord, objectThrough, completionList);\n        return completionList;\n    }\n    _getStatementCompletions(parseNode, priorWord, priorText, postText) {\n        // For now, use the same logic for expressions and statements.\n        return this._getExpressionCompletions(parseNode, priorWord, priorText, postText);\n    }\n    _getExpressionCompletions(parseNode, priorWord, priorText, postText) {\n        // If the user typed a \".\" as part of a number, don't present\n        // any completion options.\n        if (parseNode.nodeType === 41 /* Number */) {\n            return undefined;\n        }\n        const completionList = vscode_languageserver_1.CompletionList.create();\n        // Add call argument completions.\n        this._addCallArgumentCompletions(parseNode, priorWord, priorText, postText, completionList);\n        // Add symbols that are in scope.\n        this._addSymbols(parseNode, priorWord, completionList);\n        // Add keywords.\n        this._findMatchingKeywords(_keywords, priorWord).map((keyword) => {\n            const completionItem = vscode_languageserver_1.CompletionItem.create(keyword);\n            completionItem.kind = vscode_languageserver_1.CompletionItemKind.Keyword;\n            completionList.items.push(completionItem);\n            completionItem.sortText = this._makeSortText(SortCategory.Keyword, keyword);\n        });\n        // Add auto-import suggestions from other modules.\n        // Ignore this check for privates, since they are not imported.\n        if (this._configOptions.autoImportCompletions && !priorWord.startsWith('_') && !this._itemToResolve) {\n            this._getAutoImportCompletions(priorWord, completionList);\n        }\n        // Add literal values if appropriate.\n        if (parseNode.nodeType === 0 /* Error */) {\n            if (parseNode.category === 3 /* MissingIndexOrSlice */) {\n                this._getIndexStringLiteral(parseNode, completionList);\n            }\n            else if (parseNode.category === 2 /* MissingExpression */) {\n                if (parseNode.parent && parseNode.parent.nodeType === 3 /* Assignment */) {\n                    const declaredTypeOfTarget = this._evaluator.getDeclaredTypeForExpression(parseNode.parent.leftExpression);\n                    if (declaredTypeOfTarget) {\n                        this._addLiteralValuesForTargetType(declaredTypeOfTarget, priorText, postText, completionList);\n                    }\n                }\n            }\n        }\n        return completionList;\n    }\n    _addCallArgumentCompletions(parseNode, priorWord, priorText, postText, completionList) {\n        // If we're within the argument list of a call, add parameter names.\n        const offset = positionUtils_1.convertPositionToOffset(this._position, this._parseResults.tokenizerOutput.lines);\n        const signatureInfo = this._evaluator.getCallSignatureInfo(parseNode, offset, this._parseResults.tokenizerOutput.tokens);\n        if (signatureInfo) {\n            // Are we past the call expression and within the argument list?\n            const callNameEnd = positionUtils_1.convertOffsetToPosition(signatureInfo.callNode.leftExpression.start + signatureInfo.callNode.leftExpression.length, this._parseResults.tokenizerOutput.lines);\n            if (textRange_1.comparePositions(this._position, callNameEnd) > 0) {\n                this._addNamedParameters(signatureInfo, priorWord, completionList);\n                // Add literals that apply to this parameter.\n                this._addLiteralValuesForArgument(signatureInfo, priorText, postText, completionList);\n            }\n        }\n    }\n    _addLiteralValuesForArgument(signatureInfo, priorText, postText, completionList) {\n        signatureInfo.signatures.forEach((signature) => {\n            if (!signature.activeParam) {\n                return undefined;\n            }\n            const type = signature.type;\n            const paramIndex = type.details.parameters.indexOf(signature.activeParam);\n            if (paramIndex < 0) {\n                return undefined;\n            }\n            const paramType = type.details.parameters[paramIndex].type;\n            this._addLiteralValuesForTargetType(paramType, priorText, postText, completionList);\n            return undefined;\n        });\n    }\n    _addLiteralValuesForTargetType(type, priorText, postText, completionList) {\n        const quoteValue = this._getQuoteValueFromPriorText(priorText);\n        typeUtils_1.doForSubtypes(type, (subtype) => {\n            if (types_1.isObject(subtype)) {\n                if (types_1.ClassType.isBuiltIn(subtype.classType, 'str')) {\n                    if (subtype.classType.literalValue !== undefined) {\n                        this._addStringLiteralToCompletionList(subtype.classType.literalValue, quoteValue.stringValue, postText, quoteValue.quoteCharacter, completionList);\n                    }\n                }\n            }\n            return undefined;\n        });\n    }\n    _getStringLiteralCompletions(parseNode, priorWord, priorText, postText) {\n        let parentNode = parseNode.parent;\n        if (!parentNode || parentNode.nodeType !== 49 /* StringList */ || parentNode.strings.length > 1) {\n            return undefined;\n        }\n        parentNode = parentNode.parent;\n        if (!parentNode) {\n            return undefined;\n        }\n        const completionList = vscode_languageserver_1.CompletionList.create();\n        if (parentNode.nodeType === 25 /* IndexItems */) {\n            parentNode = parentNode.parent;\n            if (!parentNode || parentNode.nodeType !== 24 /* Index */) {\n                return undefined;\n            }\n            const baseType = this._evaluator.getType(parentNode.baseExpression);\n            if (!baseType || !types_1.isObject(baseType)) {\n                return undefined;\n            }\n            // We currently handle only TypedDict objects.\n            const classType = baseType.classType;\n            if (!types_1.ClassType.isTypedDictClass(classType)) {\n                return;\n            }\n            const entries = this._evaluator.getTypedDictMembersForClass(classType);\n            const quoteValue = this._getQuoteValueFromPriorText(priorText);\n            entries.forEach((_, key) => {\n                this._addStringLiteralToCompletionList(key, quoteValue.stringValue, postText, quoteValue.quoteCharacter, completionList);\n            });\n        }\n        else if (parentNode.nodeType === 3 /* Assignment */) {\n            const declaredTypeOfTarget = this._evaluator.getDeclaredTypeForExpression(parentNode.leftExpression);\n            if (declaredTypeOfTarget) {\n                this._addLiteralValuesForTargetType(declaredTypeOfTarget, priorText, postText, completionList);\n            }\n        }\n        else {\n            this._addCallArgumentCompletions(parseNode, priorWord, priorText, postText, completionList);\n        }\n        return completionList;\n    }\n    // Given a string of text that precedes the current insertion point,\n    // determines which portion of it is the first part of a string literal\n    // (either starting with a single or double quote). Returns the quote\n    // type and the string literal value after the starting quote.\n    _getQuoteValueFromPriorText(priorText) {\n        const lastSingleQuote = priorText.lastIndexOf(\"'\");\n        const lastDoubleQuote = priorText.lastIndexOf('\"');\n        let quoteCharacter = this._parseResults.tokenizerOutput.predominantSingleQuoteCharacter;\n        let stringValue = undefined;\n        if (lastSingleQuote > lastDoubleQuote) {\n            quoteCharacter = \"'\";\n            stringValue = priorText.substr(lastSingleQuote + 1);\n        }\n        else if (lastDoubleQuote > lastSingleQuote) {\n            quoteCharacter = '\"';\n            stringValue = priorText.substr(lastDoubleQuote + 1);\n        }\n        return { stringValue, quoteCharacter };\n    }\n    _getIndexStringLiteral(parseNode, completionList) {\n        if (!parseNode.parent || parseNode.parent.nodeType !== 25 /* IndexItems */) {\n            return;\n        }\n        const parentNode = parseNode.parent;\n        if (!parentNode.parent || parentNode.parent.nodeType !== 24 /* Index */) {\n            return;\n        }\n        const baseType = this._evaluator.getType(parentNode.parent.baseExpression);\n        if (!baseType || !types_1.isObject(baseType)) {\n            return;\n        }\n        // We currently handle only TypedDict objects.\n        const classType = baseType.classType;\n        if (!types_1.ClassType.isTypedDictClass(classType)) {\n            return;\n        }\n        const entries = this._evaluator.getTypedDictMembersForClass(classType);\n        entries.forEach((_, key) => {\n            this._addStringLiteralToCompletionList(key, undefined, undefined, this._parseResults.tokenizerOutput.predominantSingleQuoteCharacter, completionList);\n        });\n    }\n    _addStringLiteralToCompletionList(value, priorString, postText, quoteCharacter, completionList) {\n        const isSimilar = StringUtils.computeCompletionSimilarity(priorString || '', value) > similarityLimit;\n        if (isSimilar) {\n            const valueWithQuotes = `${quoteCharacter}${value}${quoteCharacter}`;\n            const completionItem = vscode_languageserver_1.CompletionItem.create(valueWithQuotes);\n            completionItem.kind = vscode_languageserver_1.CompletionItemKind.Text;\n            completionItem.sortText = this._makeSortText(SortCategory.LiteralValue, valueWithQuotes);\n            let rangeStartCol = this._position.character;\n            if (priorString !== undefined) {\n                rangeStartCol -= priorString.length + 1;\n            }\n            // If the text after the insertion point is the closing quote,\n            // replace it.\n            let rangeEndCol = this._position.character;\n            if (postText !== undefined) {\n                if (postText.startsWith(quoteCharacter)) {\n                    rangeEndCol++;\n                }\n            }\n            const range = {\n                start: { line: this._position.line, character: rangeStartCol },\n                end: { line: this._position.line, character: rangeEndCol },\n            };\n            completionItem.textEdit = vscode_languageserver_1.TextEdit.replace(range, valueWithQuotes);\n            completionList.items.push(completionItem);\n        }\n    }\n    _getAutoImportCompletions(priorWord, completionList) {\n        const moduleSymbolMap = this._moduleSymbolsCallback();\n        const autoImporter = new autoImporter_1.AutoImporter(this._configOptions, this._filePath, this._importResolver, this._parseResults, moduleSymbolMap);\n        for (const result of autoImporter.getAutoImportCandidates(priorWord, similarityLimit, completionList.items.filter((i) => { var _a; return !((_a = i.data) === null || _a === void 0 ? void 0 : _a.autoImport); }).map((i) => i.label), undefined, this._cancellationToken)) {\n            if (result.symbol) {\n                this._addSymbol(result.name, result.symbol, priorWord, completionList, result.source, undefined, result.edits);\n            }\n            else {\n                this._addNameToCompletionList(result.name, vscode_languageserver_1.CompletionItemKind.Module, priorWord, completionList, result.name, '', result.isImportFrom ? `Auto-import from ${result.source}` : `Auto-import ${result.source}`, undefined, result.edits);\n            }\n        }\n    }\n    _getImportFromCompletions(importFromNode, priorWord) {\n        // Don't attempt to provide completions for \"from X import *\".\n        if (importFromNode.isWildcardImport) {\n            return undefined;\n        }\n        // Access the imported module information, which is hanging\n        // off the ImportFromNode.\n        const importInfo = AnalyzerNodeInfo.getImportInfo(importFromNode.module);\n        if (!importInfo) {\n            return undefined;\n        }\n        const completionList = vscode_languageserver_1.CompletionList.create();\n        const resolvedPath = importInfo.resolvedPaths.length > 0 ? importInfo.resolvedPaths[importInfo.resolvedPaths.length - 1] : '';\n        const lookupResults = this._importLookup(resolvedPath);\n        if (lookupResults) {\n            this._addSymbolsForSymbolTable(lookupResults.symbolTable, (name) => {\n                // Don't suggest symbols that have already been imported.\n                return !importFromNode.imports.find((imp) => imp.name.value === name);\n            }, priorWord, undefined, completionList);\n        }\n        // Add the implicit imports.\n        importInfo.implicitImports.forEach((implImport) => {\n            if (!importFromNode.imports.find((imp) => imp.name.value === implImport.name)) {\n                this._addNameToCompletionList(implImport.name, vscode_languageserver_1.CompletionItemKind.Module, priorWord, completionList);\n            }\n        });\n        return completionList;\n    }\n    _findMatchingKeywords(keywordList, partialMatch) {\n        return keywordList.filter((keyword) => {\n            if (partialMatch) {\n                return StringUtils.computeCompletionSimilarity(partialMatch, keyword) > similarityLimit;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _addNamedParameters(signatureInfo, priorWord, completionList) {\n        const argNameMap = new Map();\n        signatureInfo.signatures.forEach((signature) => {\n            this._addNamedParametersToMap(signature.type, argNameMap);\n        });\n        // Remove any named parameters that are already provided.\n        signatureInfo.callNode.arguments.forEach((arg) => {\n            if (arg.name) {\n                argNameMap.delete(arg.name.value);\n            }\n        });\n        // Add the remaining unique parameter names to the completion list.\n        argNameMap.forEach((argName) => {\n            const similarity = StringUtils.computeCompletionSimilarity(priorWord, argName);\n            if (similarity > similarityLimit) {\n                const completionItem = vscode_languageserver_1.CompletionItem.create(argName);\n                completionItem.kind = vscode_languageserver_1.CompletionItemKind.Variable;\n                const completionItemData = {\n                    workspacePath: this._workspacePath,\n                    filePath: this._filePath,\n                    position: this._position,\n                };\n                completionItem.data = completionItemData;\n                completionItem.sortText = this._makeSortText(SortCategory.NamedParameter, argName);\n                completionList.items.push(completionItem);\n            }\n        });\n    }\n    _addNamedParametersToMap(type, paramMap) {\n        type.details.parameters.forEach((param) => {\n            if (param.name && !param.isNameSynthesized) {\n                // Don't add private or protected names. These are assumed\n                // not to be named parameters.\n                if (!SymbolNameUtils.isPrivateOrProtectedName(param.name)) {\n                    paramMap.set(param.name, param.name);\n                }\n            }\n        });\n    }\n    _addSymbols(node, priorWord, completionList) {\n        let curNode = node;\n        while (curNode) {\n            // Does this node have a scope associated with it?\n            let scope = AnalyzerNodeInfo.getScope(curNode);\n            if (scope) {\n                while (scope) {\n                    this._addSymbolsForSymbolTable(scope.symbolTable, () => true, priorWord, undefined, completionList);\n                    scope = scope.parent;\n                }\n                break;\n            }\n            curNode = curNode.parent;\n        }\n    }\n    _addSymbolsForSymbolTable(symbolTable, includeSymbolCallback, priorWord, objectThrough, completionList) {\n        symbolTable.forEach((symbol, name) => {\n            // If there are no declarations or the symbol is not\n            // exported from this scope, don't include it in the\n            // suggestion list.\n            if (!symbol.isExternallyHidden() && includeSymbolCallback(name)) {\n                this._addSymbol(name, symbol, priorWord, completionList, undefined, undefined, undefined, objectThrough);\n            }\n        });\n    }\n    _addSymbol(name, symbol, priorWord, completionList, autoImportSource, textEdit, additionalTextEdits, objectThrough) {\n        let primaryDecl = symbolUtils_1.getLastTypedDeclaredForSymbol(symbol);\n        if (!primaryDecl) {\n            const declarations = symbol.getDeclarations();\n            if (declarations.length > 0) {\n                primaryDecl = declarations[declarations.length - 1];\n            }\n        }\n        if (primaryDecl) {\n            let itemKind = vscode_languageserver_1.CompletionItemKind.Variable;\n            primaryDecl = this._evaluator.resolveAliasDeclaration(primaryDecl, /* resolveLocalNames */ true);\n            if (primaryDecl) {\n                itemKind = this._convertDeclarationTypeToItemKind(primaryDecl);\n                // Are we resolving a completion item? If so, see if this symbol\n                // is the one that we're trying to match.\n                if (this._itemToResolve) {\n                    const completionItemData = this._itemToResolve.data;\n                    if (completionItemData.symbolId === symbol.id) {\n                        // This call can be expensive to perform on every completion item\n                        // that we return, so we do it lazily in the \"resolve\" callback.\n                        const type = this._evaluator.getEffectiveTypeOfSymbol(symbol);\n                        if (type) {\n                            let typeDetail;\n                            let documentation;\n                            switch (primaryDecl.type) {\n                                case 0 /* Intrinsic */:\n                                case 1 /* Variable */:\n                                case 2 /* Parameter */:\n                                    typeDetail =\n                                        name + ': ' + this._evaluator.printType(type, /* expandTypeAlias */ false);\n                                    break;\n                                case 3 /* Function */: {\n                                    const functionType = objectThrough\n                                        ? this._evaluator.bindFunctionToClassOrObject(objectThrough, type, false)\n                                        : type;\n                                    if (functionType.category === 6 /* OverloadedFunction */) {\n                                        typeDetail = functionType.overloads\n                                            .map((overload) => name +\n                                            this._evaluator.printType(overload, /* expandTypeAlias */ false))\n                                            .join('\\n');\n                                    }\n                                    else {\n                                        typeDetail =\n                                            name +\n                                                ': ' +\n                                                this._evaluator.printType(functionType, /* expandTypeAlias */ false);\n                                    }\n                                    break;\n                                }\n                                case 4 /* Class */:\n                                case 5 /* SpecialBuiltInClass */: {\n                                    typeDetail = 'class ' + name + '()';\n                                    break;\n                                }\n                                case 6 /* Alias */: {\n                                    typeDetail = name;\n                                    if (primaryDecl.path) {\n                                        const lookupResults = this._importLookup(primaryDecl.path);\n                                        if (lookupResults) {\n                                            documentation = lookupResults.docString;\n                                        }\n                                    }\n                                    break;\n                                }\n                                default: {\n                                    typeDetail = name;\n                                    break;\n                                }\n                            }\n                            if (types_1.isModule(type)) {\n                                documentation = typeDocStringUtils_1.getModuleDocString(type, primaryDecl, this._sourceMapper);\n                            }\n                            else if (types_1.isClass(type)) {\n                                documentation = typeDocStringUtils_1.getClassDocString(type, primaryDecl, this._sourceMapper);\n                            }\n                            else if (type.category === 5 /* Function */) {\n                                documentation = typeDocStringUtils_1.getFunctionDocStringFromType(type, this._sourceMapper);\n                            }\n                            else if (type.category === 6 /* OverloadedFunction */) {\n                                documentation = typeDocStringUtils_1.getOverloadedFunctionDocStrings(type, primaryDecl, this._sourceMapper).find((doc) => doc);\n                            }\n                            else if (primaryDecl.type === 3 /* Function */) {\n                                // @property functions\n                                documentation = typeDocStringUtils_1.getFunctionDocStringFromDeclaration(primaryDecl, this._sourceMapper);\n                            }\n                            let markdownString = '```python\\n' + typeDetail + '\\n```\\n';\n                            if (documentation) {\n                                markdownString += '---\\n';\n                                markdownString += docStringToMarkdown_1.convertDocStringToMarkdown(documentation);\n                            }\n                            if (markdownString) {\n                                this._itemToResolve.documentation = {\n                                    kind: vscode_languageserver_1.MarkupKind.Markdown,\n                                    value: markdownString,\n                                };\n                            }\n                        }\n                    }\n                }\n            }\n            let autoImportText;\n            if (autoImportSource) {\n                autoImportText = `Auto-import from ${autoImportSource}`;\n            }\n            this._addNameToCompletionList(name, itemKind, priorWord, completionList, undefined, undefined, autoImportText, textEdit, additionalTextEdits, symbol.id);\n        }\n        else {\n            // Does the symbol have no declaration but instead has a synthesized type?\n            const synthesizedType = symbol.getSynthesizedType();\n            if (synthesizedType) {\n                const itemKind = vscode_languageserver_1.CompletionItemKind.Variable;\n                this._addNameToCompletionList(name, itemKind, priorWord, completionList, undefined, undefined, undefined, textEdit, additionalTextEdits, symbol.id);\n            }\n        }\n    }\n    _addNameToCompletionList(name, itemKind, filter, completionList, typeDetail, documentation, autoImportText, textEdit, additionalTextEdits, symbolId) {\n        const similarity = StringUtils.computeCompletionSimilarity(filter, name);\n        if (similarity > similarityLimit) {\n            const completionItem = vscode_languageserver_1.CompletionItem.create(name);\n            completionItem.kind = itemKind;\n            const completionItemData = {\n                workspacePath: this._workspacePath,\n                filePath: this._filePath,\n                position: this._position,\n            };\n            completionItem.data = completionItemData;\n            if (autoImportText) {\n                // Force auto-import entries to the end.\n                completionItem.sortText = this._makeSortText(SortCategory.AutoImport, name, autoImportText);\n                completionItemData.autoImportText = autoImportText;\n            }\n            else if (SymbolNameUtils.isDunderName(name)) {\n                // Force dunder-named symbols to appear after all other symbols.\n                completionItem.sortText = this._makeSortText(SortCategory.DunderSymbol, name);\n            }\n            else if (filter === '' && SymbolNameUtils.isPrivateOrProtectedName(name)) {\n                // Distinguish between normal and private symbols only if there is\n                // currently no filter text. Once we get a single character to filter\n                // upon, we'll no longer differentiate.\n                completionItem.sortText = this._makeSortText(SortCategory.PrivateSymbol, name);\n            }\n            else {\n                completionItem.sortText = this._makeSortText(SortCategory.NormalSymbol, name);\n            }\n            if (symbolId !== undefined) {\n                completionItemData.symbolId = symbolId;\n            }\n            let markdownString = '';\n            if (autoImportText) {\n                markdownString += autoImportText;\n                markdownString += '\\n\\n';\n                completionItem.data.autoImport = autoImportText;\n            }\n            if (typeDetail) {\n                markdownString += '```python\\n' + typeDetail + '\\n```\\n';\n            }\n            if (documentation) {\n                markdownString += '---\\n';\n                markdownString += docStringToMarkdown_1.convertDocStringToMarkdown(documentation);\n            }\n            if (markdownString) {\n                completionItem.documentation = {\n                    kind: vscode_languageserver_1.MarkupKind.Markdown,\n                    value: markdownString,\n                };\n            }\n            if (textEdit) {\n                completionItem.textEdit = textEdit;\n            }\n            if (additionalTextEdits) {\n                completionItem.additionalTextEdits = additionalTextEdits.map((te) => {\n                    const textEdit = {\n                        range: {\n                            start: { line: te.range.start.line, character: te.range.start.character },\n                            end: { line: te.range.end.line, character: te.range.end.character },\n                        },\n                        newText: te.replacementText,\n                    };\n                    return textEdit;\n                });\n            }\n            completionList.items.push(completionItem);\n        }\n    }\n    _getRecentListIndex(name, autoImportText) {\n        return CompletionProvider._mostRecentCompletions.findIndex((item) => item.label === name && item.autoImportText === autoImportText);\n    }\n    _makeSortText(sortCategory, name, autoImportText = '') {\n        const recentListIndex = this._getRecentListIndex(name, autoImportText);\n        // If the label is in the recent list, modify the category\n        // so it appears higher in our list.\n        if (recentListIndex >= 0) {\n            if (sortCategory === SortCategory.AutoImport) {\n                sortCategory = SortCategory.RecentAutoImport;\n            }\n            else if (sortCategory === SortCategory.ImportModuleName) {\n                sortCategory = SortCategory.RecentImportModuleName;\n            }\n            else if (sortCategory === SortCategory.Keyword ||\n                sortCategory === SortCategory.NormalSymbol ||\n                sortCategory === SortCategory.PrivateSymbol ||\n                sortCategory === SortCategory.DunderSymbol) {\n                sortCategory = SortCategory.RecentKeywordOrSymbol;\n            }\n        }\n        // Generate a sort string of the format\n        //    XX.YYYY.name\n        // where XX is the sort category\n        // and YYYY is the index of the item in the MRU list\n        return this._formatInteger(sortCategory, 2) + '.' + this._formatInteger(recentListIndex, 4) + '.' + name;\n    }\n    _formatInteger(val, digits) {\n        const charCodeZero = '0'.charCodeAt(0);\n        let result = '';\n        for (let i = 0; i < digits; i++) {\n            // Prepend the next digit.\n            let digit = Math.floor(val % 10);\n            if (digit < 0) {\n                digit = 9;\n            }\n            result = String.fromCharCode(digit + charCodeZero) + result;\n            val = Math.floor(val / 10);\n        }\n        return result;\n    }\n    _convertDeclarationTypeToItemKind(declaration) {\n        const resolvedDeclaration = this._evaluator.resolveAliasDeclaration(declaration, /* resolveLocalNames */ true);\n        if (!resolvedDeclaration) {\n            return vscode_languageserver_1.CompletionItemKind.Variable;\n        }\n        switch (resolvedDeclaration.type) {\n            case 0 /* Intrinsic */:\n                return resolvedDeclaration.intrinsicType === 'class'\n                    ? vscode_languageserver_1.CompletionItemKind.Class\n                    : vscode_languageserver_1.CompletionItemKind.Variable;\n            case 2 /* Parameter */:\n                return vscode_languageserver_1.CompletionItemKind.Variable;\n            case 1 /* Variable */:\n                return resolvedDeclaration.isConstant || resolvedDeclaration.isFinal\n                    ? vscode_languageserver_1.CompletionItemKind.Constant\n                    : vscode_languageserver_1.CompletionItemKind.Variable;\n            case 3 /* Function */:\n                return resolvedDeclaration.isMethod ? vscode_languageserver_1.CompletionItemKind.Method : vscode_languageserver_1.CompletionItemKind.Function;\n            case 4 /* Class */:\n            case 5 /* SpecialBuiltInClass */:\n                return vscode_languageserver_1.CompletionItemKind.Class;\n            case 6 /* Alias */:\n                return vscode_languageserver_1.CompletionItemKind.Module;\n        }\n    }\n    _getImportModuleCompletions(node) {\n        const execEnvironment = this._configOptions.findExecEnvironment(this._filePath);\n        const moduleDescriptor = {\n            leadingDots: node.leadingDots,\n            hasTrailingDot: node.hasTrailingDot,\n            nameParts: node.nameParts.map((part) => part.value),\n            importedSymbols: [],\n        };\n        const completions = this._importResolver.getCompletionSuggestions(this._filePath, execEnvironment, moduleDescriptor, similarityLimit);\n        const completionList = vscode_languageserver_1.CompletionList.create();\n        // If we're in the middle of a \"from X import Y\" statement, offer\n        // the \"import\" keyword as a completion.\n        if (!node.hasTrailingDot &&\n            node.parent &&\n            node.parent.nodeType === 22 /* ImportFrom */ &&\n            node.parent.missingImportKeyword) {\n            const keyword = 'import';\n            const completionItem = vscode_languageserver_1.CompletionItem.create(keyword);\n            completionItem.kind = vscode_languageserver_1.CompletionItemKind.Keyword;\n            completionList.items.push(completionItem);\n            completionItem.sortText = this._makeSortText(SortCategory.Keyword, keyword);\n        }\n        completions.forEach((completionName) => {\n            const completionItem = vscode_languageserver_1.CompletionItem.create(completionName);\n            completionItem.kind = vscode_languageserver_1.CompletionItemKind.Module;\n            completionList.items.push(completionItem);\n            completionItem.sortText = this._makeSortText(SortCategory.ImportModuleName, completionName);\n        });\n        return completionList;\n    }\n}\nexports.CompletionProvider = CompletionProvider;\nCompletionProvider._mostRecentCompletions = [];\n\n\n//# sourceURL=webpack://pyright-server/./src/languageService/completionProvider.ts?");

/***/ }),

/***/ "./src/languageService/definitionProvider.ts":
/*!***************************************************!*\
  !*** ./src/languageService/definitionProvider.ts ***!
  \***************************************************/
/*! flagged exports */
/*! export DefinitionProvider [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * definitionProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic that maps a position within a Python program file into\n * a \"definition\" of the item that is referred to at that position.\n * For example, if the location is within an import name, the\n * definition is the top of the resolved import file.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DefinitionProvider = void 0;\nconst ParseTreeUtils = __webpack_require__(/*! ../analyzer/parseTreeUtils */ \"./src/analyzer/parseTreeUtils.ts\");\nconst sourceMapper_1 = __webpack_require__(/*! ../analyzer/sourceMapper */ \"./src/analyzer/sourceMapper.ts\");\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst positionUtils_1 = __webpack_require__(/*! ../common/positionUtils */ \"./src/common/positionUtils.ts\");\nconst textRange_1 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\nclass DefinitionProvider {\n    static getDefinitionsForPosition(sourceMapper, parseResults, position, evaluator, token) {\n        cancellationUtils_1.throwIfCancellationRequested(token);\n        const offset = positionUtils_1.convertPositionToOffset(position, parseResults.tokenizerOutput.lines);\n        if (offset === undefined) {\n            return undefined;\n        }\n        const node = ParseTreeUtils.findNodeByOffset(parseResults.parseTree, offset);\n        if (node === undefined) {\n            return undefined;\n        }\n        const definitions = [];\n        if (node.nodeType === 39 /* Name */) {\n            const declarations = evaluator.getDeclarationsForNameNode(node);\n            if (declarations) {\n                declarations.forEach((decl) => {\n                    const resolvedDecl = evaluator.resolveAliasDeclaration(decl, /* resolveLocalNames */ true);\n                    if (resolvedDecl && resolvedDecl.path) {\n                        this._addIfUnique(definitions, {\n                            path: resolvedDecl.path,\n                            range: resolvedDecl.range,\n                        });\n                        if (sourceMapper_1.isStubFile(resolvedDecl.path)) {\n                            const implDecls = sourceMapper.findDeclarations(resolvedDecl);\n                            for (const implDecl of implDecls) {\n                                if (implDecl && implDecl.path) {\n                                    this._addIfUnique(definitions, {\n                                        path: implDecl.path,\n                                        range: implDecl.range,\n                                    });\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n        }\n        return definitions.length > 0 ? definitions : undefined;\n    }\n    static _addIfUnique(definitions, itemToAdd) {\n        for (const def of definitions) {\n            if (def.path === itemToAdd.path && textRange_1.rangesAreEqual(def.range, itemToAdd.range)) {\n                return;\n            }\n        }\n        definitions.push(itemToAdd);\n    }\n}\nexports.DefinitionProvider = DefinitionProvider;\n\n\n//# sourceURL=webpack://pyright-server/./src/languageService/definitionProvider.ts?");

/***/ }),

/***/ "./src/languageService/documentHighlightProvider.ts":
/*!**********************************************************!*\
  !*** ./src/languageService/documentHighlightProvider.ts ***!
  \**********************************************************/
/*! flagged exports */
/*! export DocumentHighlightProvider [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * documentHighlightProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic that maps a position within a Python program file into\n * one or more highlight types.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DocumentHighlightProvider = void 0;\nconst vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ \"./node_modules/vscode-languageserver/lib/node/main.js\");\nconst analyzerNodeInfo_1 = __webpack_require__(/*! ../analyzer/analyzerNodeInfo */ \"./src/analyzer/analyzerNodeInfo.ts\");\nconst declarationUtils_1 = __webpack_require__(/*! ../analyzer/declarationUtils */ \"./src/analyzer/declarationUtils.ts\");\nconst ParseTreeUtils = __webpack_require__(/*! ../analyzer/parseTreeUtils */ \"./src/analyzer/parseTreeUtils.ts\");\nconst parseTreeWalker_1 = __webpack_require__(/*! ../analyzer/parseTreeWalker */ \"./src/analyzer/parseTreeWalker.ts\");\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst positionUtils_1 = __webpack_require__(/*! ../common/positionUtils */ \"./src/common/positionUtils.ts\");\nconst textRange_1 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\n// This walker looks for symbols that are semantically equivalent\n// to the requested symbol.\nclass HighlightSymbolTreeWalker extends parseTreeWalker_1.ParseTreeWalker {\n    constructor(_symbolName, _declarations, _parseResults, _highlightResults, _evaluator, _cancellationToken) {\n        super();\n        this._symbolName = _symbolName;\n        this._declarations = _declarations;\n        this._parseResults = _parseResults;\n        this._highlightResults = _highlightResults;\n        this._evaluator = _evaluator;\n        this._cancellationToken = _cancellationToken;\n    }\n    findHighlights() {\n        this.walk(this._parseResults.parseTree);\n    }\n    walk(node) {\n        if (!analyzerNodeInfo_1.isCodeUnreachable(node)) {\n            super.walk(node);\n        }\n    }\n    visitModuleName(node) {\n        // Don't ever look for references within a module name.\n        return false;\n    }\n    visitName(node) {\n        cancellationUtils_1.throwIfCancellationRequested(this._cancellationToken);\n        // No need to do any more work if the symbol name doesn't match.\n        if (node.value !== this._symbolName) {\n            return false;\n        }\n        if (this._declarations.length > 0) {\n            const declarations = this._evaluator.getDeclarationsForNameNode(node);\n            if (declarations && declarations.length > 0) {\n                // Does this name share a declaration with the symbol of interest?\n                if (declarations.some((decl) => this._resultsContainsDeclaration(decl))) {\n                    this._addResult(node);\n                }\n            }\n        }\n        else {\n            // There were no declarations\n            this._addResult(node);\n        }\n        return true;\n    }\n    _addResult(node) {\n        this._highlightResults.push({\n            kind: this._isWriteAccess(node) ? vscode_languageserver_1.DocumentHighlightKind.Write : vscode_languageserver_1.DocumentHighlightKind.Read,\n            range: {\n                start: positionUtils_1.convertOffsetToPosition(node.start, this._parseResults.tokenizerOutput.lines),\n                end: positionUtils_1.convertOffsetToPosition(textRange_1.TextRange.getEnd(node), this._parseResults.tokenizerOutput.lines),\n            },\n        });\n    }\n    _isWriteAccess(node) {\n        let prevNode = node;\n        let curNode = prevNode.parent;\n        while (curNode) {\n            switch (curNode.nodeType) {\n                case 3 /* Assignment */: {\n                    return prevNode === curNode.leftExpression;\n                }\n                case 5 /* AugmentedAssignment */: {\n                    return prevNode === curNode.leftExpression;\n                }\n                case 4 /* AssignmentExpression */: {\n                    return prevNode === curNode.name;\n                }\n                case 14 /* Del */: {\n                    return true;\n                }\n                case 27 /* For */: {\n                    return prevNode === curNode.targetExpression;\n                }\n                case 21 /* ImportAs */: {\n                    return (prevNode === curNode.alias ||\n                        (curNode.module.nameParts.length > 0 && prevNode === curNode.module.nameParts[0]));\n                }\n                case 23 /* ImportFromAs */: {\n                    return prevNode === curNode.alias || (!curNode.alias && prevNode === curNode.name);\n                }\n                case 36 /* MemberAccess */: {\n                    if (prevNode !== curNode.memberName) {\n                        return false;\n                    }\n                    break;\n                }\n                case 26 /* Except */: {\n                    return prevNode === curNode.name;\n                }\n                case 59 /* With */: {\n                    return curNode.withItems.some((item) => item === prevNode);\n                }\n                case 34 /* ListComprehensionFor */: {\n                    return prevNode === curNode.targetExpression;\n                }\n                case 55 /* TypeAnnotation */: {\n                    if (prevNode === curNode.typeAnnotation) {\n                        return false;\n                    }\n                    break;\n                }\n                case 29 /* Function */:\n                case 10 /* Class */:\n                case 37 /* Module */: {\n                    return false;\n                }\n            }\n            prevNode = curNode;\n            curNode = curNode.parent;\n        }\n        return false;\n    }\n    _resultsContainsDeclaration(declaration) {\n        // Resolve the declaration.\n        const resolvedDecl = this._evaluator.resolveAliasDeclaration(declaration, /* resolveLocalNames */ false);\n        if (!resolvedDecl) {\n            return false;\n        }\n        // The reference results declarations are already resolved, so we don't\n        // need to call resolveAliasDeclaration on them.\n        if (this._declarations.some((decl) => declarationUtils_1.areDeclarationsSame(decl, resolvedDecl))) {\n            return true;\n        }\n        // We didn't find the declaration using local-only alias resolution. Attempt\n        // it again by fully resolving the alias.\n        const resolvedDeclNonlocal = this._evaluator.resolveAliasDeclaration(resolvedDecl, \n        /* resolveLocalNames */ true);\n        if (!resolvedDeclNonlocal || resolvedDeclNonlocal === resolvedDecl) {\n            return false;\n        }\n        return this._declarations.some((decl) => declarationUtils_1.areDeclarationsSame(decl, resolvedDeclNonlocal));\n    }\n}\n// This walker looks for strings that are equivalent\n// to the requested string.\nclass HighlightStringTreeWalker extends parseTreeWalker_1.ParseTreeWalker {\n    constructor(_stringValue, _parseResults, _highlightResults, _cancellationToken) {\n        super();\n        this._stringValue = _stringValue;\n        this._parseResults = _parseResults;\n        this._highlightResults = _highlightResults;\n        this._cancellationToken = _cancellationToken;\n    }\n    findHighlights() {\n        this.walk(this._parseResults.parseTree);\n    }\n    walk(node) {\n        if (!analyzerNodeInfo_1.isCodeUnreachable(node)) {\n            super.walk(node);\n        }\n    }\n    visitString(node) {\n        cancellationUtils_1.throwIfCancellationRequested(this._cancellationToken);\n        // Compare the unescaped values.\n        if (node.value !== this._stringValue) {\n            return false;\n        }\n        this._highlightResults.push({\n            kind: vscode_languageserver_1.DocumentHighlightKind.Text,\n            range: {\n                start: positionUtils_1.convertOffsetToPosition(node.start, this._parseResults.tokenizerOutput.lines),\n                end: positionUtils_1.convertOffsetToPosition(textRange_1.TextRange.getEnd(node), this._parseResults.tokenizerOutput.lines),\n            },\n        });\n        return true;\n    }\n}\nclass DocumentHighlightProvider {\n    static getDocumentHighlight(parseResults, position, evaluator, token) {\n        cancellationUtils_1.throwIfCancellationRequested(token);\n        const offset = positionUtils_1.convertPositionToOffset(position, parseResults.tokenizerOutput.lines);\n        if (offset === undefined) {\n            return undefined;\n        }\n        const node = ParseTreeUtils.findNodeByOffset(parseResults.parseTree, offset);\n        if (node === undefined) {\n            return undefined;\n        }\n        const results = [];\n        if (node.nodeType === 39 /* Name */) {\n            const declarations = evaluator.getDeclarationsForNameNode(node) || [];\n            const resolvedDeclarations = [];\n            declarations.forEach((decl) => {\n                const resolvedDecl = evaluator.resolveAliasDeclaration(decl, true);\n                if (resolvedDecl) {\n                    resolvedDeclarations.push(resolvedDecl);\n                }\n            });\n            const walker = new HighlightSymbolTreeWalker(node.value, resolvedDeclarations, parseResults, results, evaluator, token);\n            walker.findHighlights();\n        }\n        else if (node.nodeType === 50 /* String */) {\n            const walker = new HighlightStringTreeWalker(node.value, parseResults, results, token);\n            walker.findHighlights();\n        }\n        return results.length > 0 ? results : undefined;\n    }\n}\nexports.DocumentHighlightProvider = DocumentHighlightProvider;\n\n\n//# sourceURL=webpack://pyright-server/./src/languageService/documentHighlightProvider.ts?");

/***/ }),

/***/ "./src/languageService/documentSymbolProvider.ts":
/*!*******************************************************!*\
  !*** ./src/languageService/documentSymbolProvider.ts ***!
  \*******************************************************/
/*! flagged exports */
/*! export DocumentSymbolProvider [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * documentSymbolProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic that enumerates all of the symbols within a specified\n * source file document.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DocumentSymbolProvider = void 0;\nconst vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ \"./node_modules/vscode-languageserver/lib/node/main.js\");\nconst vscode_uri_1 = __webpack_require__(/*! vscode-uri */ \"./node_modules/vscode-uri/lib/esm/index.js\");\nconst AnalyzerNodeInfo = __webpack_require__(/*! ../analyzer/analyzerNodeInfo */ \"./src/analyzer/analyzerNodeInfo.ts\");\nconst ParseTreeUtils = __webpack_require__(/*! ../analyzer/parseTreeUtils */ \"./src/analyzer/parseTreeUtils.ts\");\nconst parseTreeWalker_1 = __webpack_require__(/*! ../analyzer/parseTreeWalker */ \"./src/analyzer/parseTreeWalker.ts\");\nconst symbolUtils_1 = __webpack_require__(/*! ../analyzer/symbolUtils */ \"./src/analyzer/symbolUtils.ts\");\nconst typeUtils_1 = __webpack_require__(/*! ../analyzer/typeUtils */ \"./src/analyzer/typeUtils.ts\");\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst positionUtils_1 = __webpack_require__(/*! ../common/positionUtils */ \"./src/common/positionUtils.ts\");\nconst StringUtils = __webpack_require__(/*! ../common/stringUtils */ \"./src/common/stringUtils.ts\");\n// We'll use a somewhat-arbitrary cutoff value here to determine\n// whether it's sufficiently similar.\nconst similarityLimit = 0.5;\nclass FindSymbolTreeWalker extends parseTreeWalker_1.ParseTreeWalker {\n    constructor(filePath, parseResults, symbolInfoResults, query, evaluator, token) {\n        super();\n        this._filePath = filePath;\n        this._parseResults = parseResults;\n        this._symbolResults = symbolInfoResults;\n        this._query = query;\n        this._evaluator = evaluator;\n        this._cancellationToken = token;\n    }\n    findSymbols() {\n        this.walk(this._parseResults.parseTree);\n    }\n    visitModule(node) {\n        this._addSymbolInformationForScope(node, '');\n        return true;\n    }\n    visitClass(node) {\n        const className = node.name.value;\n        this._addSymbolInformationForScope(node, className);\n        return true;\n    }\n    visitFunction(node) {\n        const functionName = node.name.value;\n        let containerName = functionName;\n        const containingClass = ParseTreeUtils.getEnclosingClass(node, true);\n        if (containingClass) {\n            containerName = containingClass.name.value + '.' + functionName;\n        }\n        this._addSymbolInformationForScope(node, containerName);\n        return true;\n    }\n    visitListComprehension(node) {\n        this._addSymbolInformationForScope(node);\n        return true;\n    }\n    _addSymbolInformationForScope(node, containerName) {\n        cancellationUtils_1.throwIfCancellationRequested(this._cancellationToken);\n        const scope = AnalyzerNodeInfo.getScope(node);\n        if (!scope) {\n            return;\n        }\n        const symbolTable = scope.symbolTable;\n        symbolTable.forEach((symbol, name) => {\n            if (!symbol.isIgnoredForProtocolMatch()) {\n                // Prefer declarations with a defined type.\n                let decl = symbolUtils_1.getLastTypedDeclaredForSymbol(symbol);\n                // Fall back to declarations without a type.\n                if (!decl && symbol.hasDeclarations()) {\n                    decl = symbol.getDeclarations()[0];\n                }\n                if (decl) {\n                    this._addSymbolInformationFromDeclaration(name, decl, containerName);\n                }\n            }\n        });\n    }\n    _addSymbolInformationFromDeclaration(name, declaration, containerName) {\n        if (declaration.path !== this._filePath) {\n            return;\n        }\n        if (this._query !== undefined) {\n            const similarity = StringUtils.computeCompletionSimilarity(this._query, name);\n            if (similarity < similarityLimit) {\n                return;\n            }\n        }\n        const resolvedSymbol = this._evaluator.resolveAliasDeclaration(declaration, /* resolveLocalNames */ true);\n        if (!resolvedSymbol) {\n            return;\n        }\n        const location = {\n            uri: vscode_uri_1.URI.file(this._filePath).toString(),\n            range: declaration.range,\n        };\n        const symbolKind = getSymbolKind(name, declaration, this._evaluator);\n        if (symbolKind === undefined) {\n            return;\n        }\n        const symbolInfo = {\n            name,\n            kind: symbolKind,\n            location,\n        };\n        if (containerName) {\n            symbolInfo.containerName = containerName;\n        }\n        this._symbolResults.push(symbolInfo);\n    }\n}\nfunction getSymbolKind(name, declaration, evaluator) {\n    let symbolKind;\n    switch (declaration.type) {\n        case 4 /* Class */:\n        case 5 /* SpecialBuiltInClass */:\n            symbolKind = vscode_languageserver_1.SymbolKind.Class;\n            break;\n        case 3 /* Function */:\n            if (declaration.isMethod) {\n                const declType = evaluator.getTypeForDeclaration(declaration);\n                if (declType && typeUtils_1.isProperty(declType)) {\n                    symbolKind = vscode_languageserver_1.SymbolKind.Property;\n                }\n                else {\n                    symbolKind = vscode_languageserver_1.SymbolKind.Method;\n                }\n            }\n            else {\n                symbolKind = vscode_languageserver_1.SymbolKind.Function;\n            }\n            break;\n        case 6 /* Alias */:\n            symbolKind = vscode_languageserver_1.SymbolKind.Module;\n            break;\n        case 2 /* Parameter */:\n            if (name === 'self' || name === 'cls' || name === '_') {\n                return;\n            }\n            symbolKind = vscode_languageserver_1.SymbolKind.Variable;\n            break;\n        case 1 /* Variable */:\n            if (name === '_') {\n                return;\n            }\n            symbolKind = declaration.isConstant || declaration.isFinal ? vscode_languageserver_1.SymbolKind.Constant : vscode_languageserver_1.SymbolKind.Variable;\n            break;\n        default:\n            symbolKind = vscode_languageserver_1.SymbolKind.Variable;\n            break;\n    }\n    return symbolKind;\n}\nfunction getDocumentSymbolsRecursive(node, docSymbolResults, parseResults, evaluator, token) {\n    cancellationUtils_1.throwIfCancellationRequested(token);\n    const scope = AnalyzerNodeInfo.getScope(node);\n    if (!scope) {\n        return;\n    }\n    const symbolTable = scope.symbolTable;\n    symbolTable.forEach((symbol, name) => {\n        if (!symbol.isIgnoredForProtocolMatch()) {\n            // Prefer declarations with a defined type.\n            let decl = symbolUtils_1.getLastTypedDeclaredForSymbol(symbol);\n            // Fall back to declarations without a type.\n            if (!decl && symbol.hasDeclarations()) {\n                decl = symbol.getDeclarations()[0];\n            }\n            if (decl) {\n                getDocumentSymbolRecursive(name, decl, evaluator, parseResults, docSymbolResults, token);\n            }\n        }\n    });\n}\nfunction getDocumentSymbolRecursive(name, declaration, evaluator, parseResults, docSymbolResults, token) {\n    if (declaration.type === 6 /* Alias */) {\n        return;\n    }\n    const symbolKind = getSymbolKind(name, declaration, evaluator);\n    if (symbolKind === undefined) {\n        return;\n    }\n    const selectionRange = declaration.range;\n    let range = selectionRange;\n    const children = [];\n    if (declaration.type === 4 /* Class */ || declaration.type === 3 /* Function */) {\n        getDocumentSymbolsRecursive(declaration.node, children, parseResults, evaluator, token);\n        const nameRange = positionUtils_1.convertOffsetsToRange(declaration.node.start, declaration.node.name.start + declaration.node.length, parseResults.tokenizerOutput.lines);\n        range = nameRange;\n    }\n    const symbolInfo = {\n        name,\n        kind: symbolKind,\n        range,\n        selectionRange,\n        children,\n    };\n    docSymbolResults.push(symbolInfo);\n}\nclass DocumentSymbolProvider {\n    static addSymbolsForDocument(symbolList, query, filePath, parseResults, evaluator, token) {\n        const symbolTreeWalker = new FindSymbolTreeWalker(filePath, parseResults, symbolList, query, evaluator, token);\n        symbolTreeWalker.findSymbols();\n    }\n    static addHierarchicalSymbolsForDocument(symbolList, parseResults, evaluator, token) {\n        getDocumentSymbolsRecursive(parseResults.parseTree, symbolList, parseResults, evaluator, token);\n    }\n}\nexports.DocumentSymbolProvider = DocumentSymbolProvider;\n\n\n//# sourceURL=webpack://pyright-server/./src/languageService/documentSymbolProvider.ts?");

/***/ }),

/***/ "./src/languageService/hoverProvider.ts":
/*!**********************************************!*\
  !*** ./src/languageService/hoverProvider.ts ***!
  \**********************************************/
/*! flagged exports */
/*! export HoverProvider [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export convertHoverResults [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * hoverProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic that maps a position within a Python program file into\n * markdown text that is displayed when the user hovers over that\n * position within a smart editor.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertHoverResults = exports.HoverProvider = void 0;\nconst vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ \"./node_modules/vscode-languageserver/lib/node/main.js\");\nconst docStringToMarkdown_1 = __webpack_require__(/*! ../analyzer/docStringToMarkdown */ \"./src/analyzer/docStringToMarkdown.ts\");\nconst ParseTreeUtils = __webpack_require__(/*! ../analyzer/parseTreeUtils */ \"./src/analyzer/parseTreeUtils.ts\");\nconst typeDocStringUtils_1 = __webpack_require__(/*! ../analyzer/typeDocStringUtils */ \"./src/analyzer/typeDocStringUtils.ts\");\nconst types_1 = __webpack_require__(/*! ../analyzer/types */ \"./src/analyzer/types.ts\");\nconst typeUtils_1 = __webpack_require__(/*! ../analyzer/typeUtils */ \"./src/analyzer/typeUtils.ts\");\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst positionUtils_1 = __webpack_require__(/*! ../common/positionUtils */ \"./src/common/positionUtils.ts\");\nconst textRange_1 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\nclass HoverProvider {\n    static getHoverForPosition(sourceMapper, parseResults, position, evaluator, token) {\n        cancellationUtils_1.throwIfCancellationRequested(token);\n        const offset = positionUtils_1.convertPositionToOffset(position, parseResults.tokenizerOutput.lines);\n        if (offset === undefined) {\n            return undefined;\n        }\n        const node = ParseTreeUtils.findNodeByOffset(parseResults.parseTree, offset);\n        if (node === undefined) {\n            return undefined;\n        }\n        const results = {\n            parts: [],\n            range: {\n                start: positionUtils_1.convertOffsetToPosition(node.start, parseResults.tokenizerOutput.lines),\n                end: positionUtils_1.convertOffsetToPosition(textRange_1.TextRange.getEnd(node), parseResults.tokenizerOutput.lines),\n            },\n        };\n        if (node.nodeType === 39 /* Name */) {\n            const declarations = evaluator.getDeclarationsForNameNode(node);\n            if (declarations && declarations.length > 0) {\n                this._addResultsForDeclaration(sourceMapper, results.parts, declarations[0], node, evaluator);\n            }\n            else if (!node.parent || node.parent.nodeType !== 38 /* ModuleName */) {\n                // If we had no declaration, see if we can provide a minimal tooltip. We'll skip\n                // this if it's part of a module name, since a module name part with no declaration\n                // is a directory (a namespace package), and we don't want to provide any hover\n                // information in that case.\n                if (results.parts.length === 0) {\n                    const type = evaluator.getType(node) || types_1.UnknownType.create();\n                    let typeText = '';\n                    if (types_1.isModule(type)) {\n                        // Handle modules specially because submodules aren't associated with\n                        // declarations, but we want them to be presented in the same way as\n                        // the top-level module, which does have a declaration.\n                        typeText = '(module) ' + node.value;\n                    }\n                    else {\n                        typeText = node.value + ': ' + evaluator.printType(type, /* expandTypeAlias */ false);\n                    }\n                    this._addResultsPart(results.parts, typeText, true);\n                    this._addDocumentationPart(sourceMapper, results.parts, node, evaluator, undefined);\n                }\n            }\n        }\n        return results.parts.length > 0 ? results : undefined;\n    }\n    static _addResultsForDeclaration(sourceMapper, parts, declaration, node, evaluator) {\n        var _a;\n        const resolvedDecl = evaluator.resolveAliasDeclaration(declaration, /* resolveLocalNames */ true);\n        if (!resolvedDecl) {\n            this._addResultsPart(parts, `(import) ` + node.value + this._getTypeText(node, evaluator), true);\n            return;\n        }\n        switch (resolvedDecl.type) {\n            case 0 /* Intrinsic */: {\n                this._addResultsPart(parts, node.value + this._getTypeText(node, evaluator), true);\n                this._addDocumentationPart(sourceMapper, parts, node, evaluator, resolvedDecl);\n                break;\n            }\n            case 1 /* Variable */: {\n                let label = resolvedDecl.isConstant || resolvedDecl.isFinal ? 'constant' : 'variable';\n                // If the named node is an aliased import symbol, we can't call\n                // getType on the original name because it's not in the symbol\n                // table. Instead, use the node from the resolved alias.\n                let typeNode = node;\n                if (declaration.node.nodeType === 21 /* ImportAs */ ||\n                    declaration.node.nodeType === 23 /* ImportFromAs */) {\n                    if (declaration.node.alias && node !== declaration.node.alias) {\n                        if (resolvedDecl.node.nodeType === 39 /* Name */) {\n                            typeNode = resolvedDecl.node;\n                        }\n                    }\n                }\n                else if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.nodeType) === 1 /* Argument */ && node.parent.name === node) {\n                    // If this is a named argument, we would normally have received a Parameter declaration\n                    // rather than a variable declaration, but we can get here in the case of a dataclass.\n                    // Replace the typeNode with the node of the variable declaration.\n                    if (declaration.node.nodeType === 39 /* Name */) {\n                        typeNode = declaration.node;\n                    }\n                }\n                // Determine if this identifier is a type alias. If so, expand\n                // the type alias when printing the type information.\n                const type = evaluator.getType(typeNode);\n                let expandTypeAlias = false;\n                if (type === null || type === void 0 ? void 0 : type.typeAliasInfo) {\n                    if (type.typeAliasInfo.aliasName === typeNode.value) {\n                        expandTypeAlias = true;\n                    }\n                    label = 'type alias';\n                }\n                this._addResultsPart(parts, `(${label}) ` + node.value + this._getTypeText(typeNode, evaluator, expandTypeAlias), true);\n                this._addDocumentationPart(sourceMapper, parts, node, evaluator, resolvedDecl);\n                break;\n            }\n            case 2 /* Parameter */: {\n                this._addResultsPart(parts, '(parameter) ' + node.value + this._getTypeText(node, evaluator), true);\n                this._addDocumentationPart(sourceMapper, parts, node, evaluator, resolvedDecl);\n                break;\n            }\n            case 4 /* Class */:\n            case 5 /* SpecialBuiltInClass */: {\n                if (this._addInitMethodInsteadIfCallNode(node, evaluator, parts, sourceMapper, resolvedDecl)) {\n                    return;\n                }\n                this._addResultsPart(parts, '(class) ' + node.value, true);\n                this._addDocumentationPart(sourceMapper, parts, node, evaluator, resolvedDecl);\n                break;\n            }\n            case 3 /* Function */: {\n                let label = 'function';\n                if (resolvedDecl.isMethod) {\n                    const declaredType = evaluator.getTypeForDeclaration(resolvedDecl);\n                    label = declaredType && typeUtils_1.isProperty(declaredType) ? 'property' : 'method';\n                }\n                this._addResultsPart(parts, `(${label}) ` + node.value + this._getTypeText(node, evaluator), true);\n                this._addDocumentationPart(sourceMapper, parts, node, evaluator, resolvedDecl);\n                break;\n            }\n            case 6 /* Alias */: {\n                this._addResultsPart(parts, '(module) ' + node.value, true);\n                this._addDocumentationPart(sourceMapper, parts, node, evaluator, resolvedDecl);\n                break;\n            }\n        }\n    }\n    static _addInitMethodInsteadIfCallNode(node, evaluator, parts, sourceMapper, declaration) {\n        // If the class is used as part of a call (i.e. it is being\n        // instantiated), include the constructor arguments within the\n        // hover text.\n        let callLeftNode = node;\n        // Allow the left to be a member access chain (e.g. a.b.c) if the\n        // node in question is the last item in the chain.\n        if (callLeftNode.parent &&\n            callLeftNode.parent.nodeType === 36 /* MemberAccess */ &&\n            node === callLeftNode.parent.memberName) {\n            callLeftNode = node.parent;\n        }\n        if (!callLeftNode ||\n            !callLeftNode.parent ||\n            callLeftNode.parent.nodeType !== 9 /* Call */ ||\n            callLeftNode.parent.leftExpression !== callLeftNode) {\n            return false;\n        }\n        // Get the init method for this class.\n        const classType = evaluator.getType(node);\n        if (!classType || !types_1.isClass(classType)) {\n            return false;\n        }\n        const initMethodMember = typeUtils_1.lookUpClassMember(classType, '__init__', 8 /* SkipInstanceVariables */ | 4 /* SkipObjectBaseClass */);\n        if (!initMethodMember) {\n            return false;\n        }\n        const instanceType = evaluator.getType(callLeftNode.parent);\n        const functionType = evaluator.getTypeOfMember(initMethodMember);\n        if (!instanceType || !functionType || !types_1.isObject(instanceType)) {\n            return false;\n        }\n        const initMethodType = evaluator.bindFunctionToClassOrObject(instanceType, functionType, false);\n        if (!initMethodType || initMethodType.category !== 5 /* Function */) {\n            return false;\n        }\n        const functionParts = evaluator.printFunctionParts(initMethodType);\n        const classText = `${node.value}(${functionParts[0].join(', ')})`;\n        this._addResultsPart(parts, '(class) ' + classText, true);\n        this._addDocumentationPartForType(sourceMapper, parts, initMethodType, declaration);\n        return true;\n    }\n    static _getTypeText(node, evaluator, expandTypeAlias = false) {\n        const type = evaluator.getType(node) || types_1.UnknownType.create();\n        return ': ' + evaluator.printType(type, expandTypeAlias);\n    }\n    static _addDocumentationPart(sourceMapper, parts, node, evaluator, resolvedDecl) {\n        const type = evaluator.getType(node);\n        if (type) {\n            this._addDocumentationPartForType(sourceMapper, parts, type, resolvedDecl);\n        }\n    }\n    static _addDocumentationPartForType(sourceMapper, parts, type, resolvedDecl) {\n        const docStrings = [];\n        if (types_1.isModule(type)) {\n            docStrings.push(typeDocStringUtils_1.getModuleDocString(type, resolvedDecl, sourceMapper));\n        }\n        else if (types_1.isClass(type)) {\n            docStrings.push(typeDocStringUtils_1.getClassDocString(type, resolvedDecl, sourceMapper));\n        }\n        else if (type.category === 5 /* Function */) {\n            docStrings.push(typeDocStringUtils_1.getFunctionDocStringFromType(type, sourceMapper));\n        }\n        else if (type.category === 6 /* OverloadedFunction */) {\n            docStrings.push(...typeDocStringUtils_1.getOverloadedFunctionDocStrings(type, resolvedDecl, sourceMapper));\n        }\n        else if ((resolvedDecl === null || resolvedDecl === void 0 ? void 0 : resolvedDecl.type) === 3 /* Function */) {\n            // @property functions\n            docStrings.push(typeDocStringUtils_1.getFunctionDocStringFromDeclaration(resolvedDecl, sourceMapper));\n        }\n        for (const docString of docStrings) {\n            if (docString) {\n                this._addDocumentationResultsPart(parts, docString);\n            }\n        }\n    }\n    static _addDocumentationResultsPart(parts, docString) {\n        if (docString) {\n            this._addResultsPart(parts, docStringToMarkdown_1.convertDocStringToMarkdown(docString));\n        }\n    }\n    static _addResultsPart(parts, text, python = false) {\n        parts.push({\n            python,\n            text,\n        });\n    }\n}\nexports.HoverProvider = HoverProvider;\nfunction convertHoverResults(hoverResults) {\n    if (!hoverResults) {\n        return undefined;\n    }\n    const markupString = hoverResults.parts\n        .map((part) => {\n        if (part.python) {\n            return '```python\\n' + part.text + '\\n```\\n';\n        }\n        return part.text;\n    })\n        .join('');\n    return {\n        contents: {\n            kind: vscode_languageserver_1.MarkupKind.Markdown,\n            value: markupString,\n        },\n        range: hoverResults.range,\n    };\n}\nexports.convertHoverResults = convertHoverResults;\n\n\n//# sourceURL=webpack://pyright-server/./src/languageService/hoverProvider.ts?");

/***/ }),

/***/ "./src/languageService/importSorter.ts":
/*!*********************************************!*\
  !*** ./src/languageService/importSorter.ts ***!
  \*********************************************/
/*! flagged exports */
/*! export ImportSorter [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * importSorter.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Provides code that sorts and formats import statements within a\n * python source file.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImportSorter = void 0;\nconst importStatementUtils_1 = __webpack_require__(/*! ../analyzer/importStatementUtils */ \"./src/analyzer/importStatementUtils.ts\");\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst positionUtils_1 = __webpack_require__(/*! ../common/positionUtils */ \"./src/common/positionUtils.ts\");\nconst textRange_1 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\n// We choose a line length that matches the default for the popular\n// \"black\" formatter used in many Python projects.\nconst _maxLineLength = 88;\nclass ImportSorter {\n    constructor(_parseResults, _cancellationToken) {\n        this._parseResults = _parseResults;\n        this._cancellationToken = _cancellationToken;\n    }\n    sort() {\n        cancellationUtils_1.throwIfCancellationRequested(this._cancellationToken);\n        const actions = [];\n        const importStatements = importStatementUtils_1.getTopLevelImports(this._parseResults.parseTree);\n        const sortedStatements = importStatements.orderedImports\n            .map((s) => s)\n            .sort((a, b) => {\n            return importStatementUtils_1.compareImportStatements(a, b);\n        });\n        if (sortedStatements.length === 0) {\n            // Nothing to do.\n            return [];\n        }\n        const primaryRange = this._getPrimaryReplacementRange(importStatements.orderedImports);\n        actions.push({\n            range: primaryRange,\n            replacementText: this._generateSortedImportText(sortedStatements),\n        });\n        this._addSecondaryReplacementRanges(importStatements.orderedImports, actions);\n        return actions;\n    }\n    // Determines the text range for the existing primary block of import statements.\n    // If there are other blocks of import statements separated by other statements,\n    // we'll ignore these other blocks for now.\n    _getPrimaryReplacementRange(statements) {\n        let statementLimit = statements.findIndex((s) => s.followsNonImportStatement);\n        if (statementLimit < 0) {\n            statementLimit = statements.length;\n        }\n        const lastStatement = statements[statementLimit - 1].node;\n        return {\n            start: positionUtils_1.convertOffsetToPosition(statements[0].node.start, this._parseResults.tokenizerOutput.lines),\n            end: positionUtils_1.convertOffsetToPosition(textRange_1.TextRange.getEnd(lastStatement), this._parseResults.tokenizerOutput.lines),\n        };\n    }\n    // If import statements are separated by other statements, we will remove the old\n    // secondary blocks.\n    _addSecondaryReplacementRanges(statements, actions) {\n        let secondaryBlockStart = statements.findIndex((s) => s.followsNonImportStatement);\n        if (secondaryBlockStart < 0) {\n            return;\n        }\n        while (true) {\n            let secondaryBlockLimit = statements.findIndex((s, index) => index > secondaryBlockStart && s.followsNonImportStatement);\n            if (secondaryBlockLimit < 0) {\n                secondaryBlockLimit = statements.length;\n            }\n            actions.push({\n                range: {\n                    start: positionUtils_1.convertOffsetToPosition(statements[secondaryBlockStart].node.start, this._parseResults.tokenizerOutput.lines),\n                    end: positionUtils_1.convertOffsetToPosition(textRange_1.TextRange.getEnd(statements[secondaryBlockLimit - 1].node), this._parseResults.tokenizerOutput.lines),\n                },\n                replacementText: '',\n            });\n            secondaryBlockStart = secondaryBlockLimit;\n            if (secondaryBlockStart >= statements.length) {\n                break;\n            }\n        }\n    }\n    _generateSortedImportText(sortedStatements) {\n        let importText = '';\n        let prevImportGroup = importStatementUtils_1.getImportGroup(sortedStatements[0]);\n        for (const statement of sortedStatements) {\n            // Insert a blank space between import type groups.\n            const curImportType = importStatementUtils_1.getImportGroup(statement);\n            if (prevImportGroup !== curImportType) {\n                importText += this._parseResults.tokenizerOutput.predominantEndOfLineSequence;\n                prevImportGroup = curImportType;\n            }\n            let importLine;\n            if (statement.node.nodeType === 20 /* Import */) {\n                importLine = this._formatImportNode(statement.subnode, statement.moduleName);\n            }\n            else {\n                importLine = this._formatImportFromNode(statement.node, statement.moduleName);\n            }\n            // If this isn't the last statement, add a newline.\n            if (statement !== sortedStatements[sortedStatements.length - 1]) {\n                importLine += this._parseResults.tokenizerOutput.predominantEndOfLineSequence;\n            }\n            importText += importLine;\n        }\n        return importText;\n    }\n    _formatImportNode(subnode, moduleName) {\n        let importText = `import ${moduleName}`;\n        if (subnode.alias) {\n            importText += ` as ${subnode.alias.value}`;\n        }\n        return importText;\n    }\n    _formatImportFromNode(node, moduleName) {\n        const symbols = node.imports\n            .sort((a, b) => this._compareSymbols(a, b))\n            .map((symbol) => {\n            let symbolText = symbol.name.value;\n            if (symbol.alias) {\n                symbolText += ` as ${symbol.alias.value}`;\n            }\n            return symbolText;\n        });\n        let cumulativeText = `from ${moduleName} import `;\n        if (node.isWildcardImport) {\n            return cumulativeText + '*';\n        }\n        const symbolText = symbols.join(', ');\n        if (cumulativeText.length + symbolText.length <= _maxLineLength) {\n            return cumulativeText + symbolText;\n        }\n        // We need to split across multiple lines with parens.\n        cumulativeText += '(' + this._parseResults.tokenizerOutput.predominantEndOfLineSequence;\n        for (const symbol of symbols) {\n            cumulativeText +=\n                this._parseResults.tokenizerOutput.predominantTabSequence +\n                    symbol +\n                    ',' +\n                    this._parseResults.tokenizerOutput.predominantEndOfLineSequence;\n        }\n        cumulativeText += ')';\n        return cumulativeText;\n    }\n    _compareSymbols(a, b) {\n        return a.name.value < b.name.value ? -1 : 1;\n    }\n}\nexports.ImportSorter = ImportSorter;\n\n\n//# sourceURL=webpack://pyright-server/./src/languageService/importSorter.ts?");

/***/ }),

/***/ "./src/languageService/quickActions.ts":
/*!*********************************************!*\
  !*** ./src/languageService/quickActions.ts ***!
  \*********************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export performQuickAction [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * quickActions.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Provides support for miscellaneous quick actions.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.performQuickAction = void 0;\nconst importStatementUtils_1 = __webpack_require__(/*! ../analyzer/importStatementUtils */ \"./src/analyzer/importStatementUtils.ts\");\nconst ParseTreeUtils = __webpack_require__(/*! ../analyzer/parseTreeUtils */ \"./src/analyzer/parseTreeUtils.ts\");\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst positionUtils_1 = __webpack_require__(/*! ../common/positionUtils */ \"./src/common/positionUtils.ts\");\nconst textRange_1 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\nconst importSorter_1 = __webpack_require__(/*! ./importSorter */ \"./src/languageService/importSorter.ts\");\nfunction performQuickAction(command, args, parseResults, token) {\n    if (command === \"pyright.organizeimports\" /* orderImports */) {\n        const importSorter = new importSorter_1.ImportSorter(parseResults, token);\n        return importSorter.sort();\n    }\n    else if (command === \"pyright.addoptionalforparam\" /* addMissingOptionalToParam */) {\n        if (args.length >= 1) {\n            const nodeOffset = parseInt(args[0], 10);\n            return _addMissingOptionalToParam(parseResults, nodeOffset, token);\n        }\n    }\n    return [];\n}\nexports.performQuickAction = performQuickAction;\n// Inserts text into the document to wrap an existing type annotation\n// with \"Optional[X]\".\nfunction _addMissingOptionalToParam(parseResults, offset, token) {\n    cancellationUtils_1.throwIfCancellationRequested(token);\n    let node = ParseTreeUtils.findNodeByOffset(parseResults.parseTree, offset);\n    while (node) {\n        if (node.nodeType === 42 /* Parameter */) {\n            break;\n        }\n        node = node.parent;\n    }\n    if (!node || !node.typeAnnotation) {\n        return [];\n    }\n    const editActions = [];\n    const startPos = positionUtils_1.convertOffsetToPosition(node.typeAnnotation.start, parseResults.tokenizerOutput.lines);\n    const endPos = positionUtils_1.convertOffsetToPosition(textRange_1.TextRange.getEnd(node.typeAnnotation), parseResults.tokenizerOutput.lines);\n    editActions.push({\n        range: { start: startPos, end: startPos },\n        replacementText: 'Optional[',\n    });\n    editActions.push({\n        range: { start: endPos, end: endPos },\n        replacementText: ']',\n    });\n    // Add the import statement if necessary.\n    const importStatements = importStatementUtils_1.getTopLevelImports(parseResults.parseTree);\n    const importStatement = importStatements.orderedImports.find((imp) => imp.moduleName === 'typing');\n    // If there's an existing import statement, insert into it.\n    if (importStatement && importStatement.node.nodeType === 22 /* ImportFrom */) {\n        const additionalEditActions = importStatementUtils_1.getTextEditsForAutoImportSymbolAddition('Optional', importStatement, parseResults);\n        editActions.push(...additionalEditActions);\n    }\n    else {\n        const additionalEditActions = importStatementUtils_1.getTextEditsForAutoImportInsertion('Optional', importStatements, 'typing', 0 /* BuiltIn */, parseResults);\n        editActions.push(...additionalEditActions);\n    }\n    return editActions;\n}\n\n\n//# sourceURL=webpack://pyright-server/./src/languageService/quickActions.ts?");

/***/ }),

/***/ "./src/languageService/referencesProvider.ts":
/*!***************************************************!*\
  !*** ./src/languageService/referencesProvider.ts ***!
  \***************************************************/
/*! flagged exports */
/*! export ReferencesProvider [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * referencesProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic that finds all of the references to a symbol specified\n * by a location within a file.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReferencesProvider = void 0;\nconst AnalyzerNodeInfo = __webpack_require__(/*! ../analyzer/analyzerNodeInfo */ \"./src/analyzer/analyzerNodeInfo.ts\");\nconst DeclarationUtils = __webpack_require__(/*! ../analyzer/declarationUtils */ \"./src/analyzer/declarationUtils.ts\");\nconst ParseTreeUtils = __webpack_require__(/*! ../analyzer/parseTreeUtils */ \"./src/analyzer/parseTreeUtils.ts\");\nconst parseTreeWalker_1 = __webpack_require__(/*! ../analyzer/parseTreeWalker */ \"./src/analyzer/parseTreeWalker.ts\");\nconst sourceMapper_1 = __webpack_require__(/*! ../analyzer/sourceMapper */ \"./src/analyzer/sourceMapper.ts\");\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst positionUtils_1 = __webpack_require__(/*! ../common/positionUtils */ \"./src/common/positionUtils.ts\");\nconst textRange_1 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\nclass FindReferencesTreeWalker extends parseTreeWalker_1.ParseTreeWalker {\n    constructor(_parseResults, _filePath, _referencesResult, _includeDeclaration, _evaluator, _cancellationToken) {\n        super();\n        this._parseResults = _parseResults;\n        this._filePath = _filePath;\n        this._referencesResult = _referencesResult;\n        this._includeDeclaration = _includeDeclaration;\n        this._evaluator = _evaluator;\n        this._cancellationToken = _cancellationToken;\n    }\n    findReferences() {\n        this.walk(this._parseResults.parseTree);\n    }\n    walk(node) {\n        if (!AnalyzerNodeInfo.isCodeUnreachable(node)) {\n            super.walk(node);\n        }\n    }\n    visitModuleName(node) {\n        // Don't ever look for references within a module name.\n        return false;\n    }\n    visitName(node) {\n        cancellationUtils_1.throwIfCancellationRequested(this._cancellationToken);\n        // No need to do any more work if the symbol name doesn't match.\n        if (node.value !== this._referencesResult.symbolName) {\n            return false;\n        }\n        const declarations = this._evaluator.getDeclarationsForNameNode(node);\n        if (declarations && declarations.length > 0) {\n            // Does this name share a declaration with the symbol of interest?\n            if (declarations.some((decl) => this._resultsContainsDeclaration(decl))) {\n                // Is it the same symbol?\n                if (this._includeDeclaration || node !== this._referencesResult.nodeAtOffset) {\n                    this._referencesResult.locations.push({\n                        path: this._filePath,\n                        range: {\n                            start: positionUtils_1.convertOffsetToPosition(node.start, this._parseResults.tokenizerOutput.lines),\n                            end: positionUtils_1.convertOffsetToPosition(textRange_1.TextRange.getEnd(node), this._parseResults.tokenizerOutput.lines),\n                        },\n                    });\n                }\n            }\n        }\n        return true;\n    }\n    _resultsContainsDeclaration(declaration) {\n        // Resolve the declaration.\n        const resolvedDecl = this._evaluator.resolveAliasDeclaration(declaration, /* resolveLocalNames */ false);\n        if (!resolvedDecl) {\n            return false;\n        }\n        // The reference results declarations are already resolved, so we don't\n        // need to call resolveAliasDeclaration on them.\n        if (this._referencesResult.declarations.some((decl) => DeclarationUtils.areDeclarationsSame(decl, resolvedDecl))) {\n            return true;\n        }\n        // We didn't find the declaration using local-only alias resolution. Attempt\n        // it again by fully resolving the alias.\n        const resolvedDeclNonlocal = this._evaluator.resolveAliasDeclaration(resolvedDecl, \n        /* resolveLocalNames */ true);\n        if (!resolvedDeclNonlocal || resolvedDeclNonlocal === resolvedDecl) {\n            return false;\n        }\n        return this._referencesResult.declarations.some((decl) => DeclarationUtils.areDeclarationsSame(decl, resolvedDeclNonlocal));\n    }\n}\nclass ReferencesProvider {\n    static getDeclarationForPosition(sourceMapper, parseResults, filePath, position, evaluator, token) {\n        var _a;\n        cancellationUtils_1.throwIfCancellationRequested(token);\n        const offset = positionUtils_1.convertPositionToOffset(position, parseResults.tokenizerOutput.lines);\n        if (offset === undefined) {\n            return undefined;\n        }\n        const node = ParseTreeUtils.findNodeByOffset(parseResults.parseTree, offset);\n        if (node === undefined) {\n            return undefined;\n        }\n        // If this isn't a name node, there are no references to be found.\n        if (node.nodeType !== 39 /* Name */) {\n            return undefined;\n        }\n        // Special case module names, which don't have references.\n        if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.nodeType) === 38 /* ModuleName */) {\n            return undefined;\n        }\n        const declarations = evaluator.getDeclarationsForNameNode(node);\n        if (!declarations) {\n            return undefined;\n        }\n        const resolvedDeclarations = [];\n        declarations.forEach((decl) => {\n            const resolvedDecl = evaluator.resolveAliasDeclaration(decl, /* resolveLocalNames */ false);\n            if (resolvedDecl) {\n                resolvedDeclarations.push(resolvedDecl);\n                if (sourceMapper_1.isStubFile(resolvedDecl.path)) {\n                    const implDecls = sourceMapper.findDeclarations(resolvedDecl);\n                    for (const implDecl of implDecls) {\n                        if (implDecl && implDecl.path) {\n                            this._addIfUnique(resolvedDeclarations, implDecl);\n                        }\n                    }\n                }\n            }\n        });\n        if (resolvedDeclarations.length === 0) {\n            return undefined;\n        }\n        // Does this symbol require search beyond the current file? Determine whether\n        // the symbol is declared within an evaluation scope that is within the current\n        // file and cannot be imported directly from other modules.\n        const requiresGlobalSearch = resolvedDeclarations.some((decl) => {\n            var _a, _b;\n            // If the declaration is outside of this file, a global search is needed.\n            if (decl.path !== filePath) {\n                return true;\n            }\n            const evalScope = ParseTreeUtils.getEvaluationScopeNode(decl.node);\n            // If the declaration is at the module level or a class level, it can be seen\n            // outside of the current module, so a global search is needed.\n            if (evalScope.nodeType === 37 /* Module */ || evalScope.nodeType === 10 /* Class */) {\n                return true;\n            }\n            // If the name node is a member variable, we need to do a global search.\n            if (((_b = (_a = decl.node) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.nodeType) === 36 /* MemberAccess */ &&\n                decl.node === decl.node.parent.memberName) {\n                return true;\n            }\n            return false;\n        });\n        return {\n            requiresGlobalSearch,\n            nodeAtOffset: node,\n            symbolName: node.value,\n            declarations: resolvedDeclarations,\n            locations: [],\n        };\n    }\n    static _addIfUnique(declarations, itemToAdd) {\n        for (const def of declarations) {\n            if (DeclarationUtils.areDeclarationsSame(def, itemToAdd)) {\n                return;\n            }\n        }\n        declarations.push(itemToAdd);\n    }\n    static addReferences(parseResults, filePath, referencesResult, includeDeclaration, evaluator, token) {\n        const refTreeWalker = new FindReferencesTreeWalker(parseResults, filePath, referencesResult, includeDeclaration, evaluator, token);\n        refTreeWalker.findReferences();\n    }\n}\nexports.ReferencesProvider = ReferencesProvider;\n\n\n//# sourceURL=webpack://pyright-server/./src/languageService/referencesProvider.ts?");

/***/ }),

/***/ "./src/languageService/signatureHelpProvider.ts":
/*!******************************************************!*\
  !*** ./src/languageService/signatureHelpProvider.ts ***!
  \******************************************************/
/*! flagged exports */
/*! export SignatureHelpProvider [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * signatureHelpProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic that maps a position within a Python call node into info\n * that can be presented to the developer to help fill in the remaining\n * arguments for the call.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SignatureHelpProvider = void 0;\nconst docStringUtils_1 = __webpack_require__(/*! ../analyzer/docStringUtils */ \"./src/analyzer/docStringUtils.ts\");\nconst ParseTreeUtils = __webpack_require__(/*! ../analyzer/parseTreeUtils */ \"./src/analyzer/parseTreeUtils.ts\");\nconst cancellationUtils_1 = __webpack_require__(/*! ../common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst positionUtils_1 = __webpack_require__(/*! ../common/positionUtils */ \"./src/common/positionUtils.ts\");\nclass SignatureHelpProvider {\n    static getSignatureHelpForPosition(parseResults, position, evaluator, token) {\n        cancellationUtils_1.throwIfCancellationRequested(token);\n        const offset = positionUtils_1.convertPositionToOffset(position, parseResults.tokenizerOutput.lines);\n        if (offset === undefined) {\n            return undefined;\n        }\n        let node = ParseTreeUtils.findNodeByOffset(parseResults.parseTree, offset);\n        // See if we can get to a \"better\" node by backing up a few columns.\n        // A \"better\" node is defined as one that's deeper than the current\n        // node.\n        const initialNode = node;\n        const initialDepth = node ? ParseTreeUtils.getNodeDepth(node) : 0;\n        let curOffset = offset;\n        while (curOffset >= 0) {\n            curOffset--;\n            const curNode = ParseTreeUtils.findNodeByOffset(parseResults.parseTree, curOffset);\n            if (curNode && curNode !== initialNode) {\n                if (ParseTreeUtils.getNodeDepth(curNode) > initialDepth) {\n                    node = curNode;\n                }\n                break;\n            }\n        }\n        if (node === undefined) {\n            return undefined;\n        }\n        const callSignatureInfo = evaluator.getCallSignatureInfo(node, offset, parseResults.tokenizerOutput.tokens);\n        if (!callSignatureInfo) {\n            return undefined;\n        }\n        const signatures = callSignatureInfo.signatures.map((sig) => this._makeSignature(sig, evaluator));\n        return {\n            signatures,\n        };\n    }\n    static _makeSignature(signature, evaluator) {\n        const functionType = signature.type;\n        const stringParts = evaluator.printFunctionParts(functionType);\n        const parameters = [];\n        const functionDocString = functionType.details.docString;\n        let label = '(';\n        stringParts[0].forEach((paramString, paramIndex) => {\n            const paramName = functionType.details.parameters[paramIndex].name || '';\n            parameters.push({\n                startOffset: label.length,\n                endOffset: label.length + paramString.length,\n                documentation: docStringUtils_1.extractParameterDocumentation(functionDocString || '', paramName),\n            });\n            label += paramString;\n            if (paramIndex < stringParts[0].length - 1) {\n                label += ', ';\n            }\n        });\n        label += ') -> ' + stringParts[1];\n        let activeParameter;\n        if (signature.activeParam) {\n            activeParameter = functionType.details.parameters.indexOf(signature.activeParam);\n            if (activeParameter === -1) {\n                activeParameter = undefined;\n            }\n        }\n        const sigInfo = {\n            label,\n            parameters,\n            documentation: functionDocString,\n            activeParameter,\n        };\n        return sigInfo;\n    }\n}\nexports.SignatureHelpProvider = SignatureHelpProvider;\n\n\n//# sourceURL=webpack://pyright-server/./src/languageService/signatureHelpProvider.ts?");

/***/ }),

/***/ "./src/localization/localize.ts":
/*!**************************************!*\
  !*** ./src/localization/localize.ts ***!
  \**************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * localize.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Code that localizes user-visible strings.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Localizer = exports.ParameterizedString = void 0;\nconst debug_1 = __webpack_require__(/*! ../common/debug */ \"./src/common/debug.ts\");\nconst enUsStrings = __webpack_require__(/*! ./package.nls.en-us.json */ \"./src/localization/package.nls.en-us.json\");\nconst deStrings = __webpack_require__(/*! ./package.nls.de.json */ \"./src/localization/package.nls.de.json\");\nconst esStrings = __webpack_require__(/*! ./package.nls.es.json */ \"./src/localization/package.nls.es.json\");\nconst frStrings = __webpack_require__(/*! ./package.nls.fr.json */ \"./src/localization/package.nls.fr.json\");\nconst jaStrings = __webpack_require__(/*! ./package.nls.ja.json */ \"./src/localization/package.nls.ja.json\");\nconst ruStrings = __webpack_require__(/*! ./package.nls.ru.json */ \"./src/localization/package.nls.ru.json\");\nconst zhCnStrings = __webpack_require__(/*! ./package.nls.zh-cn.json */ \"./src/localization/package.nls.zh-cn.json\");\nconst zhTwStrings = __webpack_require__(/*! ./package.nls.zh-tw.json */ \"./src/localization/package.nls.zh-tw.json\");\nclass ParameterizedString {\n    constructor(_formatString) {\n        this._formatString = _formatString;\n    }\n    format(params) {\n        let str = this._formatString;\n        Object.keys(params).forEach((key) => {\n            str = str.replace(`{${key}}`, params[key].toString());\n        });\n        return str;\n    }\n    getFormatString() {\n        return this._formatString;\n    }\n}\nexports.ParameterizedString = ParameterizedString;\nconst defaultLocale = 'en-us';\nconst stringMapsByLocale = {\n    de: deStrings,\n    'en-us': enUsStrings,\n    es: esStrings,\n    fr: frStrings,\n    ja: jaStrings,\n    ru: ruStrings,\n    'zh-cn': zhCnStrings,\n    'zh-tw': zhTwStrings,\n};\nlet localizedStrings = undefined;\nlet defaultStrings = {};\nfunction getRawString(key) {\n    if (localizedStrings === undefined) {\n        localizedStrings = initialize();\n    }\n    const keyParts = key.split('.');\n    const str = getRawStringFromMap(localizedStrings, keyParts) || getRawStringFromMap(defaultStrings, keyParts);\n    if (str) {\n        return str;\n    }\n    debug_1.fail(`Missing localized string for key \"${key}\"`);\n}\nfunction getRawStringFromMap(map, keyParts) {\n    let curObj = map;\n    for (const keyPart of keyParts) {\n        if (!curObj[keyPart]) {\n            return undefined;\n        }\n        curObj = curObj[keyPart];\n    }\n    return curObj;\n}\nfunction initialize() {\n    defaultStrings = loadDefaultStrings();\n    const currentLocale = getLocaleFromEnv();\n    return loadStringsForLocale(currentLocale);\n}\nfunction getLocaleFromEnv() {\n    const env = process.env;\n    // Start with the VSCode environment variables.\n    const vscodeConfigString = env.VSCODE_NLS_CONFIG;\n    if (vscodeConfigString) {\n        try {\n            return JSON.parse(vscodeConfigString).locale;\n        }\n        catch (_a) {\n            // Fall through\n        }\n    }\n    // See if there is a language env variable.\n    const localeString = env.LC_ALL || env.LC_MESSAGES || env.LANG || env.LANGUAGE;\n    if (localeString) {\n        // This string may contain a local followed by an encoding (e.g. \"en-us.UTF-8\").\n        const localeStringSplit = localeString.split('.');\n        if (localeStringSplit.length > 0 && localeStringSplit[0]) {\n            return localeStringSplit[0];\n        }\n    }\n    // Fall back to the default locale.\n    return defaultLocale;\n}\nfunction loadDefaultStrings() {\n    const defaultStrings = loadStringsFromJsonFile(defaultLocale);\n    if (defaultStrings) {\n        return defaultStrings;\n    }\n    console.error('Could not load default strings');\n    return {};\n}\nfunction loadStringsForLocale(locale) {\n    if (locale === defaultLocale) {\n        // No need to load override if we're using the default.\n        return {};\n    }\n    let override = loadStringsFromJsonFile(locale);\n    if (override !== undefined) {\n        return override;\n    }\n    // If we couldn't find the requested locale, try to fall back on a more\n    // general version.\n    const localeSplit = locale.split('-');\n    if (localeSplit.length > 0 && localeSplit[0]) {\n        override = loadStringsFromJsonFile(localeSplit[0]);\n        if (override !== undefined) {\n            return override;\n        }\n    }\n    return {};\n}\nfunction loadStringsFromJsonFile(locale) {\n    return stringMapsByLocale[locale];\n}\nvar Localizer;\n(function (Localizer) {\n    let Diagnostic;\n    (function (Diagnostic) {\n        Diagnostic.annotatedTypeArgMissing = () => getRawString('Diagnostic.annotatedTypeArgMissing');\n        Diagnostic.annotationFormatString = () => getRawString('Diagnostic.annotationFormatString');\n        Diagnostic.annotationNotSupported = () => getRawString('Diagnostic.annotationNotSupported');\n        Diagnostic.annotationSpansStrings = () => getRawString('Diagnostic.annotationSpansStrings');\n        Diagnostic.annotationStringEscape = () => getRawString('Diagnostic.annotationStringEscape');\n        Diagnostic.annotationTripleQuote = () => getRawString('Diagnostic.annotationTripleQuote');\n        Diagnostic.argAssignment = () => new ParameterizedString(getRawString('Diagnostic.argAssignment'));\n        Diagnostic.argAssignmentFunction = () => new ParameterizedString(getRawString('Diagnostic.argAssignmentFunction'));\n        Diagnostic.argAssignmentParam = () => new ParameterizedString(getRawString('Diagnostic.argAssignmentParam'));\n        Diagnostic.argAssignmentParamFunction = () => new ParameterizedString(getRawString('Diagnostic.argAssignmentParamFunction'));\n        Diagnostic.argMissingForParam = () => new ParameterizedString(getRawString('Diagnostic.argMissingForParam'));\n        Diagnostic.argMissingForParams = () => new ParameterizedString(getRawString('Diagnostic.argMissingForParams'));\n        Diagnostic.argPositional = () => getRawString('Diagnostic.argPositional');\n        Diagnostic.argPositionalExpectedCount = () => new ParameterizedString(getRawString('Diagnostic.argPositionalExpectedCount'));\n        Diagnostic.argPositionalExpectedOne = () => getRawString('Diagnostic.argPositionalExpectedOne');\n        Diagnostic.argTypePartiallyUnknown = () => getRawString('Diagnostic.argTypePartiallyUnknown');\n        Diagnostic.argTypeUnknown = () => getRawString('Diagnostic.argTypeUnknown');\n        Diagnostic.assertAlwaysTrue = () => getRawString('Diagnostic.assertAlwaysTrue');\n        Diagnostic.assignmentExprContext = () => getRawString('Diagnostic.assignmentExprContext');\n        Diagnostic.assignmentExprComprehension = () => new ParameterizedString(getRawString('Diagnostic.assignmentExprComprehension'));\n        Diagnostic.assignmentInProtocol = () => getRawString('Diagnostic.assignmentInProtocol');\n        Diagnostic.assignmentTargetExpr = () => getRawString('Diagnostic.assignmentTargetExpr');\n        Diagnostic.awaitIllegal = () => getRawString('Diagnostic.awaitIllegal');\n        Diagnostic.awaitNotInAsync = () => getRawString('Diagnostic.awaitNotInAsync');\n        Diagnostic.backticksIllegal = () => getRawString('Diagnostic.backticksIllegal');\n        Diagnostic.baseClassCircular = () => getRawString('Diagnostic.baseClassCircular');\n        Diagnostic.baseClassDoubleGeneric = () => getRawString('Diagnostic.baseClassDoubleGeneric');\n        Diagnostic.baseClassInvalid = () => getRawString('Diagnostic.baseClassInvalid');\n        Diagnostic.baseClassFinal = () => new ParameterizedString(getRawString('Diagnostic.baseClassFinal'));\n        Diagnostic.baseClassUnknown = () => getRawString('Diagnostic.baseClassUnknown');\n        Diagnostic.breakOutsideLoop = () => getRawString('Diagnostic.breakOutsideLoop');\n        Diagnostic.callableExtraArgs = () => getRawString('Diagnostic.callableExtraArgs');\n        Diagnostic.callableFirstArg = () => getRawString('Diagnostic.callableFirstArg');\n        Diagnostic.classMethodClsParam = () => getRawString('Diagnostic.classMethodClsParam');\n        Diagnostic.classDecoratorTypeUnknown = () => getRawString('Diagnostic.classDecoratorTypeUnknown');\n        Diagnostic.classVarFirstArgMissing = () => getRawString('Diagnostic.classVarFirstArgMissing');\n        Diagnostic.classVarTooManyArgs = () => getRawString('Diagnostic.classVarTooManyArgs');\n        Diagnostic.comprehensionInDict = () => getRawString('Diagnostic.comprehensionInDict');\n        Diagnostic.comprehensionInSet = () => getRawString('Diagnostic.comprehensionInSet');\n        Diagnostic.constantRedefinition = () => new ParameterizedString(getRawString('Diagnostic.constantRedefinition'));\n        Diagnostic.constructorNoArgs = () => new ParameterizedString(getRawString('Diagnostic.constructorNoArgs'));\n        Diagnostic.continueInFinally = () => getRawString('Diagnostic.continueInFinally');\n        Diagnostic.continueOutsideLoop = () => getRawString('Diagnostic.continueOutsideLoop');\n        Diagnostic.dataClassFieldWithDefault = () => getRawString('Diagnostic.dataClassFieldWithDefault');\n        Diagnostic.declaredReturnTypePartiallyUnknown = () => new ParameterizedString(getRawString('Diagnostic.declaredReturnTypePartiallyUnknown'));\n        Diagnostic.declaredReturnTypeUnknown = () => getRawString('Diagnostic.declaredReturnTypeUnknown');\n        Diagnostic.defaultValueContainsCall = () => getRawString('Diagnostic.defaultValueContainsCall');\n        Diagnostic.defaultValueNotAllowed = () => getRawString('Diagnostic.defaultValueNotAllowed');\n        Diagnostic.dictInAnnotation = () => getRawString('Diagnostic.dictInAnnotation');\n        Diagnostic.dictKeyValuePairs = () => getRawString('Diagnostic.dictKeyValuePairs');\n        Diagnostic.delTargetExpr = () => getRawString('Diagnostic.delTargetExpr');\n        Diagnostic.duplicateArgsParam = () => getRawString('Diagnostic.duplicateArgsParam');\n        Diagnostic.duplicateCatchAll = () => getRawString('Diagnostic.duplicateCatchAll');\n        Diagnostic.duplicateImport = () => new ParameterizedString(getRawString('Diagnostic.duplicateImport'));\n        Diagnostic.duplicateKwargsParam = () => getRawString('Diagnostic.duplicateKwargsParam');\n        Diagnostic.duplicateNameOnly = () => getRawString('Diagnostic.duplicateNameOnly');\n        Diagnostic.duplicateParam = () => new ParameterizedString(getRawString('Diagnostic.duplicateParam'));\n        Diagnostic.duplicatePositionOnly = () => getRawString('Diagnostic.duplicatePositionOnly');\n        Diagnostic.duplicateUnpack = () => getRawString('Diagnostic.duplicateUnpack');\n        Diagnostic.ellipsisContext = () => getRawString('Diagnostic.ellipsisContext');\n        Diagnostic.ellipsisSecondArg = () => getRawString('Diagnostic.ellipsisSecondArg');\n        Diagnostic.enumFirstArg = () => getRawString('Diagnostic.enumFirstArg');\n        Diagnostic.enumSecondArg = () => getRawString('Diagnostic.enumSecondArg');\n        Diagnostic.exceptionTypeIncorrect = () => new ParameterizedString(getRawString('Diagnostic.exceptionTypeIncorrect'));\n        Diagnostic.exceptionTypeNotClass = () => new ParameterizedString(getRawString('Diagnostic.exceptionTypeNotClass'));\n        Diagnostic.expectedAfterDecorator = () => getRawString('Diagnostic.expectedAfterDecorator');\n        Diagnostic.expectedAsAfterException = () => getRawString('Diagnostic.expectedAsAfterException');\n        Diagnostic.expectedAssignRightHandExpr = () => getRawString('Diagnostic.expectedAssignRightHandExpr');\n        Diagnostic.expectedBinaryRightHandExpr = () => getRawString('Diagnostic.expectedBinaryRightHandExpr');\n        Diagnostic.expectedBoolLiteral = () => getRawString('Diagnostic.expectedBoolLiteral');\n        Diagnostic.expectedClassName = () => getRawString('Diagnostic.expectedClassName');\n        Diagnostic.expectedCloseBracket = () => getRawString('Diagnostic.expectedCloseBracket');\n        Diagnostic.expectedCloseBrace = () => getRawString('Diagnostic.expectedCloseBrace');\n        Diagnostic.expectedCloseParen = () => getRawString('Diagnostic.expectedCloseParen');\n        Diagnostic.expectedColon = () => getRawString('Diagnostic.expectedColon');\n        Diagnostic.expectedDecoratorName = () => getRawString('Diagnostic.expectedDecoratorName');\n        Diagnostic.expectedDecoratorNewline = () => getRawString('Diagnostic.expectedDecoratorNewline');\n        Diagnostic.expectedDelExpr = () => getRawString('Diagnostic.expectedDelExpr');\n        Diagnostic.expectedElse = () => getRawString('Diagnostic.expectedElse');\n        Diagnostic.expectedExceptionClass = () => getRawString('Diagnostic.expectedExceptionClass');\n        Diagnostic.expectedExceptionObj = () => getRawString('Diagnostic.expectedExceptionObj');\n        Diagnostic.expectedExpr = () => getRawString('Diagnostic.expectedExpr');\n        Diagnostic.expectedImport = () => getRawString('Diagnostic.expectedImport');\n        Diagnostic.expectedImportAlias = () => getRawString('Diagnostic.expectedImportAlias');\n        Diagnostic.expectedImportSymbols = () => getRawString('Diagnostic.expectedImportSymbols');\n        Diagnostic.expectedIdentifier = () => getRawString('Diagnostic.expectedIdentifier');\n        Diagnostic.expectedIndentedBlock = () => getRawString('Diagnostic.expectedIndentedBlock');\n        Diagnostic.expectedIn = () => getRawString('Diagnostic.expectedIn');\n        Diagnostic.expectedInExpr = () => getRawString('Diagnostic.expectedInExpr');\n        Diagnostic.expectedFunctionAfterAsync = () => getRawString('Diagnostic.expectedFunctionAfterAsync');\n        Diagnostic.expectedFunctionName = () => getRawString('Diagnostic.expectedFunctionName');\n        Diagnostic.expectedMemberName = () => getRawString('Diagnostic.expectedMemberName');\n        Diagnostic.expectedModuleName = () => getRawString('Diagnostic.expectedModuleName');\n        Diagnostic.expectedNameAfterAs = () => getRawString('Diagnostic.expectedNameAfterAs');\n        Diagnostic.expectedNamedArgument = () => getRawString('Diagnostic.expectedNamedArgument');\n        Diagnostic.expectedNewlineOrSemicolon = () => getRawString('Diagnostic.expectedNewlineOrSemicolon');\n        Diagnostic.expectedOpenParen = () => getRawString('Diagnostic.expectedOpenParen');\n        Diagnostic.expectedParamName = () => getRawString('Diagnostic.expectedParamName');\n        Diagnostic.expectedReturnExpr = () => getRawString('Diagnostic.expectedReturnExpr');\n        Diagnostic.expectedSliceIndex = () => getRawString('Diagnostic.expectedSliceIndex');\n        Diagnostic.expectedTypeNotString = () => getRawString('Diagnostic.expectedTypeNotString');\n        Diagnostic.expectedYieldExpr = () => getRawString('Diagnostic.expectedYieldExpr');\n        Diagnostic.finalContext = () => getRawString('Diagnostic.finalContext');\n        Diagnostic.finalMethodOverride = () => new ParameterizedString(getRawString('Diagnostic.finalMethodOverride'));\n        Diagnostic.finalReassigned = () => new ParameterizedString(getRawString('Diagnostic.finalReassigned'));\n        Diagnostic.finalRedeclaration = () => new ParameterizedString(getRawString('Diagnostic.finalRedeclaration'));\n        Diagnostic.finalRedeclarationBySubclass = () => new ParameterizedString(getRawString('Diagnostic.finalRedeclarationBySubclass'));\n        Diagnostic.finalTooManyArgs = () => getRawString('Diagnostic.finalTooManyArgs');\n        Diagnostic.finalUnassigned = () => new ParameterizedString(getRawString('Diagnostic.finalUnassigned'));\n        Diagnostic.formatStringBrace = () => getRawString('Diagnostic.formatStringBrace');\n        Diagnostic.formatStringBytes = () => getRawString('Diagnostic.formatStringBytes');\n        Diagnostic.formatStringEscape = () => getRawString('Diagnostic.formatStringEscape');\n        Diagnostic.formatStringIllegal = () => getRawString('Diagnostic.formatStringIllegal');\n        Diagnostic.formatStringUnicode = () => getRawString('Diagnostic.formatStringUnicode');\n        Diagnostic.formatStringUnterminated = () => getRawString('Diagnostic.formatStringUnterminated');\n        Diagnostic.functionDecoratorTypeUnknown = () => getRawString('Diagnostic.functionDecoratorTypeUnknown');\n        Diagnostic.genericClassAssigned = () => getRawString('Diagnostic.genericClassAssigned');\n        Diagnostic.genericClassDeleted = () => getRawString('Diagnostic.genericClassDeleted');\n        Diagnostic.genericNotAllowed = () => getRawString('Diagnostic.genericNotAllowed');\n        Diagnostic.genericTypeArgMissing = () => getRawString('Diagnostic.genericTypeArgMissing');\n        Diagnostic.genericTypeArgTypeVar = () => getRawString('Diagnostic.genericTypeArgTypeVar');\n        Diagnostic.genericTypeArgUnique = () => getRawString('Diagnostic.genericTypeArgUnique');\n        Diagnostic.globalReassignment = () => new ParameterizedString(getRawString('Diagnostic.globalReassignment'));\n        Diagnostic.globalRedefinition = () => new ParameterizedString(getRawString('Diagnostic.globalRedefinition'));\n        Diagnostic.implicitStringConcat = () => getRawString('Diagnostic.implicitStringConcat');\n        Diagnostic.importCycleDetected = () => getRawString('Diagnostic.importCycleDetected');\n        Diagnostic.importDepthExceeded = () => new ParameterizedString(getRawString('Diagnostic.importDepthExceeded'));\n        Diagnostic.importResolveFailure = () => new ParameterizedString(getRawString('Diagnostic.importResolveFailure'));\n        Diagnostic.importSourceResolveFailure = () => new ParameterizedString(getRawString('Diagnostic.importSourceResolveFailure'));\n        Diagnostic.importSymbolUnknown = () => new ParameterizedString(getRawString('Diagnostic.importSymbolUnknown'));\n        Diagnostic.incompatibleMethodOverride = () => new ParameterizedString(getRawString('Diagnostic.incompatibleMethodOverride'));\n        Diagnostic.inconsistentIndent = () => getRawString('Diagnostic.inconsistentIndent');\n        Diagnostic.inconsistentTabs = () => getRawString('Diagnostic.inconsistentTabs');\n        Diagnostic.initSubclassClsParam = () => getRawString('Diagnostic.initSubclassClsParam');\n        Diagnostic.instanceMethodSelfParam = () => getRawString('Diagnostic.instanceMethodSelfParam');\n        Diagnostic.invalidIdentifierChar = () => getRawString('Diagnostic.invalidIdentifierChar');\n        Diagnostic.invalidStubStatement = () => getRawString('Diagnostic.invalidStubStatement');\n        Diagnostic.invalidTokenChars = () => new ParameterizedString(getRawString('Diagnostic.invalidTokenChars'));\n        Diagnostic.isInstanceInvalidType = () => new ParameterizedString(getRawString('Diagnostic.isInstanceInvalidType'));\n        Diagnostic.isSubclassInvalidType = () => new ParameterizedString(getRawString('Diagnostic.isSubclassInvalidType'));\n        Diagnostic.keyRequiredDeleted = () => new ParameterizedString(getRawString('Diagnostic.keyRequiredDeleted'));\n        Diagnostic.keyValueInSet = () => getRawString('Diagnostic.keyValueInSet');\n        Diagnostic.lambdaReturnTypeUnknown = () => getRawString('Diagnostic.lambdaReturnTypeUnknown');\n        Diagnostic.lambdaReturnTypePartiallyUnknown = () => new ParameterizedString(getRawString('Diagnostic.lambdaReturnTypePartiallyUnknown'));\n        Diagnostic.listInAnnotation = () => getRawString('Diagnostic.listInAnnotation');\n        Diagnostic.literalUnsupportedType = () => getRawString('Diagnostic.literalUnsupportedType');\n        Diagnostic.literalEmptyArgs = () => getRawString('Diagnostic.literalEmptyArgs');\n        Diagnostic.memberAccess = () => new ParameterizedString(getRawString('Diagnostic.memberAccess'));\n        Diagnostic.memberDelete = () => new ParameterizedString(getRawString('Diagnostic.memberDelete'));\n        Diagnostic.memberSet = () => new ParameterizedString(getRawString('Diagnostic.memberSet'));\n        Diagnostic.metaclassDuplicate = () => getRawString('Diagnostic.metaclassDuplicate');\n        Diagnostic.methodNotDefined = () => new ParameterizedString(getRawString('Diagnostic.methodNotDefined'));\n        Diagnostic.methodNotDefinedOnType = () => new ParameterizedString(getRawString('Diagnostic.methodNotDefinedOnType'));\n        Diagnostic.methodOrdering = () => getRawString('Diagnostic.methodOrdering');\n        Diagnostic.methodOverridden = () => new ParameterizedString(getRawString('Diagnostic.methodOverridden'));\n        Diagnostic.methodReturnsNonObject = () => new ParameterizedString(getRawString('Diagnostic.methodReturnsNonObject'));\n        Diagnostic.moduleContext = () => getRawString('Diagnostic.moduleContext');\n        Diagnostic.moduleUnknownMember = () => new ParameterizedString(getRawString('Diagnostic.moduleUnknownMember'));\n        Diagnostic.namedExceptAfterCatchAll = () => getRawString('Diagnostic.namedExceptAfterCatchAll');\n        Diagnostic.namedTupleEmptyName = () => getRawString('Diagnostic.namedTupleEmptyName');\n        Diagnostic.namedTupleFirstArg = () => getRawString('Diagnostic.namedTupleFirstArg');\n        Diagnostic.namedTupleNameString = () => getRawString('Diagnostic.namedTupleNameString');\n        Diagnostic.namedTupleNameType = () => getRawString('Diagnostic.namedTupleNameType');\n        Diagnostic.namedTupleNameUnique = () => getRawString('Diagnostic.namedTupleNameUnique');\n        Diagnostic.namedTupleNoTypes = () => getRawString('Diagnostic.namedTupleNoTypes');\n        Diagnostic.namedTupleSecondArg = () => getRawString('Diagnostic.namedTupleSecondArg');\n        Diagnostic.newClsParam = () => getRawString('Diagnostic.newClsParam');\n        Diagnostic.nonDefaultAfterDefault = () => getRawString('Diagnostic.nonDefaultAfterDefault');\n        Diagnostic.noneNotCallable = () => getRawString('Diagnostic.noneNotCallable');\n        Diagnostic.noneNotIterable = () => getRawString('Diagnostic.noneNotIterable');\n        Diagnostic.noneNotSubscriptable = () => getRawString('Diagnostic.noneNotSubscriptable');\n        Diagnostic.noneNotUsableWith = () => getRawString('Diagnostic.noneNotUsableWith');\n        Diagnostic.noneOperator = () => new ParameterizedString(getRawString('Diagnostic.noneOperator'));\n        Diagnostic.noneUnknownMember = () => new ParameterizedString(getRawString('Diagnostic.noneUnknownMember'));\n        Diagnostic.nonLocalNoBinding = () => new ParameterizedString(getRawString('Diagnostic.nonLocalNoBinding'));\n        Diagnostic.nonLocalReassignment = () => new ParameterizedString(getRawString('Diagnostic.nonLocalReassignment'));\n        Diagnostic.nonLocalRedefinition = () => new ParameterizedString(getRawString('Diagnostic.nonLocalRedefinition'));\n        Diagnostic.nonLocalInModule = () => getRawString('Diagnostic.nonLocalInModule');\n        Diagnostic.noOverload = () => new ParameterizedString(getRawString('Diagnostic.noOverload'));\n        Diagnostic.noReturnContainsReturn = () => getRawString('Diagnostic.noReturnContainsReturn');\n        Diagnostic.noReturnContainsYield = () => getRawString('Diagnostic.noReturnContainsYield');\n        Diagnostic.noReturnReturnsNone = () => getRawString('Diagnostic.noReturnReturnsNone');\n        Diagnostic.objectNotCallable = () => new ParameterizedString(getRawString('Diagnostic.objectNotCallable'));\n        Diagnostic.obscuredClassDeclaration = () => new ParameterizedString(getRawString('Diagnostic.obscuredClassDeclaration'));\n        Diagnostic.obscuredFunctionDeclaration = () => new ParameterizedString(getRawString('Diagnostic.obscuredFunctionDeclaration'));\n        Diagnostic.obscuredParameterDeclaration = () => new ParameterizedString(getRawString('Diagnostic.obscuredParameterDeclaration'));\n        Diagnostic.obscuredVariableDeclaration = () => new ParameterizedString(getRawString('Diagnostic.obscuredVariableDeclaration'));\n        Diagnostic.operatorLessOrGreaterDeprecated = () => getRawString('Diagnostic.operatorLessOrGreaterDeprecated');\n        Diagnostic.optionalExtraArgs = () => getRawString('Diagnostic.optionalExtraArgs');\n        Diagnostic.paramAfterKwargsParam = () => getRawString('Diagnostic.paramAfterKwargsParam');\n        Diagnostic.paramAlreadyAssigned = () => new ParameterizedString(getRawString('Diagnostic.paramAlreadyAssigned'));\n        Diagnostic.paramNameMissing = () => new ParameterizedString(getRawString('Diagnostic.paramNameMissing'));\n        Diagnostic.paramSpecAssignedName = () => new ParameterizedString(getRawString('Diagnostic.paramSpecAssignedName'));\n        Diagnostic.paramSpecContext = () => getRawString('Diagnostic.paramSpecContext');\n        Diagnostic.paramSpecIllegal = () => getRawString('Diagnostic.paramSpecIllegal');\n        Diagnostic.paramSpecFirstArg = () => getRawString('Diagnostic.paramSpecFirstArg');\n        Diagnostic.paramSpecUnknownArg = () => getRawString('Diagnostic.paramSpecUnknownArg');\n        Diagnostic.paramSpecUnknownMember = () => new ParameterizedString(getRawString('Diagnostic.paramSpecUnknownMember'));\n        Diagnostic.paramSpecUnknownParam = () => new ParameterizedString(getRawString('Diagnostic.paramSpecUnknownParam'));\n        Diagnostic.paramTypeUnknown = () => new ParameterizedString(getRawString('Diagnostic.paramTypeUnknown'));\n        Diagnostic.paramAssignmentMismatch = () => new ParameterizedString(getRawString('Diagnostic.paramAssignmentMismatch'));\n        Diagnostic.paramTypePartiallyUnknown = () => new ParameterizedString(getRawString('Diagnostic.paramTypePartiallyUnknown'));\n        Diagnostic.positionArgAfterNamedArg = () => getRawString('Diagnostic.positionArgAfterNamedArg');\n        Diagnostic.positionOnlyAfterNameOnly = () => getRawString('Diagnostic.positionOnlyAfterNameOnly');\n        Diagnostic.positionOnlyIncompatible = () => getRawString('Diagnostic.positionOnlyIncompatible');\n        Diagnostic.privateUsedOutsideOfClass = () => new ParameterizedString(getRawString('Diagnostic.privateUsedOutsideOfClass'));\n        Diagnostic.privateUsedOutsideOfModule = () => new ParameterizedString(getRawString('Diagnostic.privateUsedOutsideOfModule'));\n        Diagnostic.protectedUsedOutsideOfClass = () => new ParameterizedString(getRawString('Diagnostic.protectedUsedOutsideOfClass'));\n        Diagnostic.protocolIllegal = () => getRawString('Diagnostic.protocolIllegal');\n        Diagnostic.protocolUsedInCall = () => new ParameterizedString(getRawString('Diagnostic.protocolUsedInCall'));\n        Diagnostic.raiseParams = () => getRawString('Diagnostic.raiseParams');\n        Diagnostic.relativeImportNotAllowed = () => getRawString('Diagnostic.relativeImportNotAllowed');\n        Diagnostic.returnMissing = () => new ParameterizedString(getRawString('Diagnostic.returnMissing'));\n        Diagnostic.returnOutsideFunction = () => getRawString('Diagnostic.returnOutsideFunction');\n        Diagnostic.returnTypeMismatch = () => new ParameterizedString(getRawString('Diagnostic.returnTypeMismatch'));\n        Diagnostic.returnTypeUnknown = () => getRawString('Diagnostic.returnTypeUnknown');\n        Diagnostic.returnTypePartiallyUnknown = () => new ParameterizedString(getRawString('Diagnostic.returnTypePartiallyUnknown'));\n        Diagnostic.staticClsSelfParam = () => getRawString('Diagnostic.staticClsSelfParam');\n        Diagnostic.stringNonAsciiBytes = () => getRawString('Diagnostic.stringNonAsciiBytes');\n        Diagnostic.stringUnsupportedEscape = () => getRawString('Diagnostic.stringUnsupportedEscape');\n        Diagnostic.stringUnterminated = () => getRawString('Diagnostic.stringUnterminated');\n        Diagnostic.stubFileMissing = () => new ParameterizedString(getRawString('Diagnostic.stubFileMissing'));\n        Diagnostic.stubUsesGetAttr = () => getRawString('Diagnostic.stubUsesGetAttr');\n        Diagnostic.sublistParamsIncompatible = () => getRawString('Diagnostic.sublistParamsIncompatible');\n        Diagnostic.superCallArgCount = () => getRawString('Diagnostic.superCallArgCount');\n        Diagnostic.superCallFirstArg = () => new ParameterizedString(getRawString('Diagnostic.superCallFirstArg'));\n        Diagnostic.superCallSecondArg = () => new ParameterizedString(getRawString('Diagnostic.superCallSecondArg'));\n        Diagnostic.superCallZeroArgForm = () => getRawString('Diagnostic.superCallZeroArgForm');\n        Diagnostic.symbolIsUnbound = () => new ParameterizedString(getRawString('Diagnostic.symbolIsUnbound'));\n        Diagnostic.symbolIsUndefined = () => new ParameterizedString(getRawString('Diagnostic.symbolIsUndefined'));\n        Diagnostic.symbolIsPossiblyUnbound = () => new ParameterizedString(getRawString('Diagnostic.symbolIsPossiblyUnbound'));\n        Diagnostic.symbolOverridden = () => new ParameterizedString(getRawString('Diagnostic.symbolOverridden'));\n        Diagnostic.tupleInAnnotation = () => getRawString('Diagnostic.tupleInAnnotation');\n        Diagnostic.tupleSizeMismatch = () => new ParameterizedString(getRawString('Diagnostic.tupleSizeMismatch'));\n        Diagnostic.typeAbstract = () => new ParameterizedString(getRawString('Diagnostic.typeAbstract'));\n        Diagnostic.typeAliasNotInModule = () => getRawString('Diagnostic.typeAliasNotInModule');\n        Diagnostic.typeAliasRedeclared = () => new ParameterizedString(getRawString('Diagnostic.typeAliasRedeclared'));\n        Diagnostic.typeArgsExpectingNone = () => getRawString('Diagnostic.typeArgsExpectingNone');\n        Diagnostic.typeArgsMismatchOne = () => new ParameterizedString(getRawString('Diagnostic.typeArgsMismatchOne'));\n        Diagnostic.typeArgsTooMany = () => new ParameterizedString(getRawString('Diagnostic.typeArgsTooMany'));\n        Diagnostic.typeAssignmentMismatch = () => new ParameterizedString(getRawString('Diagnostic.typeAssignmentMismatch'));\n        Diagnostic.typeCallNotAllowed = () => getRawString('Diagnostic.typeCallNotAllowed');\n        Diagnostic.typedDictAccess = () => getRawString('Diagnostic.typedDictAccess');\n        Diagnostic.typedDictBadVar = () => getRawString('Diagnostic.typedDictBadVar');\n        Diagnostic.typedDictBaseClass = () => getRawString('Diagnostic.typedDictBaseClass');\n        Diagnostic.typedDictDelete = () => getRawString('Diagnostic.typedDictDelete');\n        Diagnostic.typedDictEmptyName = () => getRawString('Diagnostic.typedDictEmptyName');\n        Diagnostic.typedDictEntryName = () => getRawString('Diagnostic.typedDictEntryName');\n        Diagnostic.typedDictEntryUnique = () => getRawString('Diagnostic.typedDictEntryUnique');\n        Diagnostic.typedDictExtraArgs = () => getRawString('Diagnostic.typedDictExtraArgs');\n        Diagnostic.typedDictFirstArg = () => getRawString('Diagnostic.typedDictFirstArg');\n        Diagnostic.typedDictSecondArgDict = () => getRawString('Diagnostic.typedDictSecondArgDict');\n        Diagnostic.typedDictSecondArgDictEntry = () => getRawString('Diagnostic.typedDictSecondArgDictEntry');\n        Diagnostic.typedDictSet = () => getRawString('Diagnostic.typedDictSet');\n        Diagnostic.typedDictTotalParam = () => getRawString('Diagnostic.typedDictTotalParam');\n        Diagnostic.typeExpectedClass = () => new ParameterizedString(getRawString('Diagnostic.typeExpectedClass'));\n        Diagnostic.typeNotAwaitable = () => new ParameterizedString(getRawString('Diagnostic.typeNotAwaitable'));\n        Diagnostic.typeNotCallable = () => new ParameterizedString(getRawString('Diagnostic.typeNotCallable'));\n        Diagnostic.typeNotIntantiable = () => new ParameterizedString(getRawString('Diagnostic.typeNotIntantiable'));\n        Diagnostic.typeNotIterable = () => new ParameterizedString(getRawString('Diagnostic.typeNotIterable'));\n        Diagnostic.typeNotSpecializable = () => new ParameterizedString(getRawString('Diagnostic.typeNotSpecializable'));\n        Diagnostic.typeNotSubscriptable = () => new ParameterizedString(getRawString('Diagnostic.typeNotSubscriptable'));\n        Diagnostic.typeNotUsableWith = () => new ParameterizedString(getRawString('Diagnostic.typeNotUsableWith'));\n        Diagnostic.typeNotSupportBinaryOperator = () => new ParameterizedString(getRawString('Diagnostic.typeNotSupportBinaryOperator'));\n        Diagnostic.typeNotSupportUnaryOperator = () => new ParameterizedString(getRawString('Diagnostic.typeNotSupportUnaryOperator'));\n        Diagnostic.typePartiallyUnknown = () => new ParameterizedString(getRawString('Diagnostic.typePartiallyUnknown'));\n        Diagnostic.typeUnknown = () => new ParameterizedString(getRawString('Diagnostic.typeUnknown'));\n        Diagnostic.typeVarAssignedName = () => new ParameterizedString(getRawString('Diagnostic.typeVarAssignedName'));\n        Diagnostic.typeVarAssignmentMismatch = () => new ParameterizedString(getRawString('Diagnostic.typeVarAssignmentMismatch'));\n        Diagnostic.typeVarBoundAndConstrained = () => getRawString('Diagnostic.typeVarBoundAndConstrained');\n        Diagnostic.typeVarFirstArg = () => getRawString('Diagnostic.typeVarFirstArg');\n        Diagnostic.typeVarGeneric = () => getRawString('Diagnostic.typeVarGeneric');\n        Diagnostic.typeVarUnknownParam = () => new ParameterizedString(getRawString('Diagnostic.typeVarUnknownParam'));\n        Diagnostic.typeVarVariance = () => getRawString('Diagnostic.typeVarVariance');\n        Diagnostic.unaccessedClass = () => new ParameterizedString(getRawString('Diagnostic.unaccessedClass'));\n        Diagnostic.unaccessedFunction = () => new ParameterizedString(getRawString('Diagnostic.unaccessedFunction'));\n        Diagnostic.unaccessedImport = () => new ParameterizedString(getRawString('Diagnostic.unaccessedImport'));\n        Diagnostic.unaccessedSymbol = () => new ParameterizedString(getRawString('Diagnostic.unaccessedSymbol'));\n        Diagnostic.unaccessedVariable = () => new ParameterizedString(getRawString('Diagnostic.unaccessedVariable'));\n        Diagnostic.unexpectedAsyncToken = () => getRawString('Diagnostic.unexpectedAsyncToken');\n        Diagnostic.unexpectedExprToken = () => getRawString('Diagnostic.unexpectedExprToken');\n        Diagnostic.unexpectedIndent = () => getRawString('Diagnostic.unexpectedIndent');\n        Diagnostic.unexpectedUnindent = () => getRawString('Diagnostic.unexpectedUnindent');\n        Diagnostic.unionSyntaxIllegal = () => getRawString('Diagnostic.unionSyntaxIllegal');\n        Diagnostic.unnecessaryCast = () => new ParameterizedString(getRawString('Diagnostic.unnecessaryCast'));\n        Diagnostic.unnecessaryIsInstanceNever = () => new ParameterizedString(getRawString('Diagnostic.unnecessaryIsInstanceNever'));\n        Diagnostic.unnecessaryIsInstanceAlways = () => new ParameterizedString(getRawString('Diagnostic.unnecessaryIsInstanceAlways'));\n        Diagnostic.unnecessaryIsSubclassAlways = () => new ParameterizedString(getRawString('Diagnostic.unnecessaryIsSubclassAlways'));\n        Diagnostic.unnecessaryIsSubclassNever = () => new ParameterizedString(getRawString('Diagnostic.unnecessaryIsSubclassNever'));\n        Diagnostic.unpackInDict = () => getRawString('Diagnostic.unpackInDict');\n        Diagnostic.unpackInSet = () => getRawString('Diagnostic.unpackInSet');\n        Diagnostic.unpackTuplesIllegal = () => getRawString('Diagnostic.unpackTuplesIllegal');\n        Diagnostic.unreachableCode = () => getRawString('Diagnostic.unreachableCode');\n        Diagnostic.varAnnotationIllegal = () => getRawString('Diagnostic.varAnnotationIllegal');\n        Diagnostic.walrusIllegal = () => getRawString('Diagnostic.walrusIllegal');\n        Diagnostic.walrusNotAllowed = () => getRawString('Diagnostic.walrusNotAllowed');\n        Diagnostic.wildcardInFunction = () => getRawString('Diagnostic.wildcardInFunction');\n        Diagnostic.yieldFromIllegal = () => getRawString('Diagnostic.yieldFromIllegal');\n        Diagnostic.yieldFromOutsideAsync = () => getRawString('Diagnostic.yieldFromOutsideAsync');\n        Diagnostic.yieldOutsideFunction = () => getRawString('Diagnostic.yieldOutsideFunction');\n        Diagnostic.yieldTypeMismatch = () => new ParameterizedString(getRawString('Diagnostic.yieldTypeMismatch'));\n    })(Diagnostic = Localizer.Diagnostic || (Localizer.Diagnostic = {}));\n    let DiagnosticAddendum;\n    (function (DiagnosticAddendum) {\n        DiagnosticAddendum.argParam = () => new ParameterizedString(getRawString('DiagnosticAddendum.argParam'));\n        DiagnosticAddendum.argParamFunction = () => new ParameterizedString(getRawString('DiagnosticAddendum.argParamFunction'));\n        DiagnosticAddendum.argumentType = () => new ParameterizedString(getRawString('DiagnosticAddendum.argumentType'));\n        DiagnosticAddendum.argumentTypes = () => new ParameterizedString(getRawString('DiagnosticAddendum.argumentTypes'));\n        DiagnosticAddendum.assignToNone = () => getRawString('DiagnosticAddendum.assignToNone');\n        DiagnosticAddendum.asyncHelp = () => getRawString('DiagnosticAddendum.asyncHelp');\n        DiagnosticAddendum.finalMethod = () => getRawString('DiagnosticAddendum.finalMethod');\n        DiagnosticAddendum.functionReturnTypeMismatch = () => new ParameterizedString(getRawString('DiagnosticAddendum.functionReturnTypeMismatch'));\n        DiagnosticAddendum.functionTooFewParams = () => new ParameterizedString(getRawString('DiagnosticAddendum.functionTooFewParams'));\n        DiagnosticAddendum.functionTooManyParams = () => new ParameterizedString(getRawString('DiagnosticAddendum.functionTooManyParams'));\n        DiagnosticAddendum.keyUndefined = () => new ParameterizedString(getRawString('DiagnosticAddendum.keyUndefined'));\n        DiagnosticAddendum.literalAssignmentMismatch = () => new ParameterizedString(getRawString('DiagnosticAddendum.literalAssignmentMismatch'));\n        DiagnosticAddendum.memberAssignment = () => new ParameterizedString(getRawString('DiagnosticAddendum.memberAssignment'));\n        DiagnosticAddendum.memberIsAbstract = () => new ParameterizedString(getRawString('DiagnosticAddendum.memberIsAbstract'));\n        DiagnosticAddendum.memberIsAbstractMore = () => new ParameterizedString(getRawString('DiagnosticAddendum.memberIsAbstractMore'));\n        DiagnosticAddendum.memberSetClassVar = () => new ParameterizedString(getRawString('DiagnosticAddendum.memberSetClassVar'));\n        DiagnosticAddendum.memberTypeMismatch = () => new ParameterizedString(getRawString('DiagnosticAddendum.memberTypeMismatch'));\n        DiagnosticAddendum.memberUnknown = () => new ParameterizedString(getRawString('DiagnosticAddendum.memberUnknown'));\n        DiagnosticAddendum.namedParamMissingInDest = () => new ParameterizedString(getRawString('DiagnosticAddendum.namedParamMissingInDest'));\n        DiagnosticAddendum.namedParamMissingInSource = () => new ParameterizedString(getRawString('DiagnosticAddendum.namedParamMissingInSource'));\n        DiagnosticAddendum.namedParamTypeMismatch = () => new ParameterizedString(getRawString('DiagnosticAddendum.namedParamTypeMismatch'));\n        DiagnosticAddendum.noOverloadAssignable = () => new ParameterizedString(getRawString('DiagnosticAddendum.noOverloadAssignable'));\n        DiagnosticAddendum.overloadCallName = () => new ParameterizedString(getRawString('DiagnosticAddendum.overloadCallName'));\n        DiagnosticAddendum.overriddenMethod = () => getRawString('DiagnosticAddendum.overriddenMethod');\n        DiagnosticAddendum.overriddenSymbol = () => getRawString('DiagnosticAddendum.overriddenSymbol');\n        DiagnosticAddendum.overrideParamCount = () => new ParameterizedString(getRawString('DiagnosticAddendum.overrideParamCount'));\n        DiagnosticAddendum.overrideParamName = () => new ParameterizedString(getRawString('DiagnosticAddendum.overrideParamName'));\n        DiagnosticAddendum.overrideParamType = () => new ParameterizedString(getRawString('DiagnosticAddendum.overrideParamType'));\n        DiagnosticAddendum.overrideReturnType = () => new ParameterizedString(getRawString('DiagnosticAddendum.overrideReturnType'));\n        DiagnosticAddendum.overrideType = () => new ParameterizedString(getRawString('DiagnosticAddendum.overrideType'));\n        DiagnosticAddendum.paramAssignment = () => new ParameterizedString(getRawString('DiagnosticAddendum.paramAssignment'));\n        DiagnosticAddendum.paramType = () => new ParameterizedString(getRawString('DiagnosticAddendum.paramType'));\n        DiagnosticAddendum.propertyMissingDeleter = () => new ParameterizedString(getRawString('DiagnosticAddendum.propertyMissingDeleter'));\n        DiagnosticAddendum.propertyMissingSetter = () => new ParameterizedString(getRawString('DiagnosticAddendum.propertyMissingSetter'));\n        DiagnosticAddendum.protocolMemberClassVar = () => new ParameterizedString(getRawString('DiagnosticAddendum.protocolMemberClassVar'));\n        DiagnosticAddendum.protocolMemberMissing = () => new ParameterizedString(getRawString('DiagnosticAddendum.protocolMemberMissing'));\n        DiagnosticAddendum.seeDeclaration = () => getRawString('DiagnosticAddendum.seeDeclaration');\n        DiagnosticAddendum.seeClassDeclaration = () => getRawString('DiagnosticAddendum.seeClassDeclaration');\n        DiagnosticAddendum.seeFunctionDeclaration = () => getRawString('DiagnosticAddendum.seeFunctionDeclaration');\n        DiagnosticAddendum.seeMethodDeclaration = () => getRawString('DiagnosticAddendum.seeMethodDeclaration');\n        DiagnosticAddendum.seeParameterDeclaration = () => getRawString('DiagnosticAddendum.seeParameterDeclaration');\n        DiagnosticAddendum.seeVariableDeclaration = () => getRawString('DiagnosticAddendum.seeVariableDeclaration');\n        DiagnosticAddendum.tupleEntryTypeMismatch = () => new ParameterizedString(getRawString('DiagnosticAddendum.tupleEntryTypeMismatch'));\n        DiagnosticAddendum.tupleSizeMismatch = () => new ParameterizedString(getRawString('DiagnosticAddendum.tupleSizeMismatch'));\n        DiagnosticAddendum.typeAssignmentMismatch = () => new ParameterizedString(getRawString('DiagnosticAddendum.typeAssignmentMismatch'));\n        DiagnosticAddendum.typeBound = () => new ParameterizedString(getRawString('DiagnosticAddendum.typeBound'));\n        DiagnosticAddendum.typeConstrainedTypeVar = () => new ParameterizedString(getRawString('DiagnosticAddendum.typeConstrainedTypeVar'));\n        DiagnosticAddendum.typeConstraint = () => new ParameterizedString(getRawString('DiagnosticAddendum.typeConstraint'));\n        DiagnosticAddendum.typedDictFieldMissing = () => new ParameterizedString(getRawString('DiagnosticAddendum.typedDictFieldMissing'));\n        DiagnosticAddendum.typedDictFieldNotRequired = () => new ParameterizedString(getRawString('DiagnosticAddendum.typedDictFieldNotRequired'));\n        DiagnosticAddendum.typedDictFieldRequired = () => new ParameterizedString(getRawString('DiagnosticAddendum.typedDictFieldRequired'));\n        DiagnosticAddendum.typedDictFieldTypeMismatch = () => new ParameterizedString(getRawString('DiagnosticAddendum.typedDictFieldTypeMismatch'));\n        DiagnosticAddendum.typedDictFieldUndefined = () => new ParameterizedString(getRawString('DiagnosticAddendum.typedDictFieldUndefined'));\n        DiagnosticAddendum.typeIncompatible = () => new ParameterizedString(getRawString('DiagnosticAddendum.typeIncompatible'));\n        DiagnosticAddendum.typeNotClass = () => new ParameterizedString(getRawString('DiagnosticAddendum.typeNotClass'));\n        DiagnosticAddendum.typeParamSpec = () => new ParameterizedString(getRawString('DiagnosticAddendum.typeParamSpec'));\n        DiagnosticAddendum.typeNotStringLiteral = () => new ParameterizedString(getRawString('DiagnosticAddendum.typeNotStringLiteral'));\n        DiagnosticAddendum.typeOfSymbol = () => new ParameterizedString(getRawString('DiagnosticAddendum.typeOfSymbol'));\n        DiagnosticAddendum.typeUnsupported = () => new ParameterizedString(getRawString('DiagnosticAddendum.typeUnsupported'));\n        DiagnosticAddendum.typeVarIsContravariant = () => new ParameterizedString(getRawString('DiagnosticAddendum.typeVarIsContravariant'));\n        DiagnosticAddendum.typeVarIsCovariant = () => new ParameterizedString(getRawString('DiagnosticAddendum.typeVarIsCovariant'));\n        DiagnosticAddendum.typeVarIsInvariant = () => new ParameterizedString(getRawString('DiagnosticAddendum.typeVarIsInvariant'));\n        DiagnosticAddendum.typeVarNotAllowed = () => getRawString('DiagnosticAddendum.typeVarNotAllowed');\n        DiagnosticAddendum.useDictInstead = () => getRawString('DiagnosticAddendum.useDictInstead');\n        DiagnosticAddendum.useListInstead = () => getRawString('DiagnosticAddendum.useListInstead');\n        DiagnosticAddendum.useTupleInstead = () => getRawString('DiagnosticAddendum.useTupleInstead');\n        DiagnosticAddendum.useTypeInstead = () => getRawString('DiagnosticAddendum.useTypeInstead');\n    })(DiagnosticAddendum = Localizer.DiagnosticAddendum || (Localizer.DiagnosticAddendum = {}));\n    let CodeAction;\n    (function (CodeAction) {\n        CodeAction.addOptionalToAnnotation = () => getRawString('CodeAction.addOptionalToAnnotation');\n        CodeAction.createTypeStub = () => getRawString('CodeAction.createTypeStub');\n        CodeAction.createTypeStubFor = () => new ParameterizedString(getRawString('CodeAction.createTypeStubFor'));\n        CodeAction.executingCommand = () => getRawString('CodeAction.executingCommand');\n        CodeAction.filesToAnalyzeOne = () => getRawString('CodeAction.filesToAnalyzeOne');\n        CodeAction.filesToAnalyzeCount = () => new ParameterizedString(getRawString('CodeAction.filesToAnalyzeCount'));\n        CodeAction.findingReferences = () => getRawString('CodeAction.findingReferences');\n        CodeAction.organizeImports = () => getRawString('CodeAction.organizeImports');\n    })(CodeAction = Localizer.CodeAction || (Localizer.CodeAction = {}));\n})(Localizer = exports.Localizer || (exports.Localizer = {}));\n\n\n//# sourceURL=webpack://pyright-server/./src/localization/localize.ts?");

/***/ }),

/***/ "./src/parser/characterStream.ts":
/*!***************************************!*\
  !*** ./src/parser/characterStream.ts ***!
  \***************************************/
/*! flagged exports */
/*! export CharacterStream [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * characterStream.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Based on code from vscode-python repository:\n *  https://github.com/Microsoft/vscode-python\n *\n * Class that represents a stream of characters.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CharacterStream = void 0;\nconst characters_1 = __webpack_require__(/*! ./characters */ \"./src/parser/characters.ts\");\nclass CharacterStream {\n    constructor(text) {\n        this._text = text;\n        this._position = 0;\n        this._currentChar = text.length > 0 ? text.charCodeAt(0) : 0;\n        this._isEndOfStream = text.length === 0;\n    }\n    getText() {\n        return this._text;\n    }\n    get position() {\n        return this._position;\n    }\n    set position(value) {\n        this._position = value;\n        this._checkBounds();\n    }\n    get currentChar() {\n        return this._currentChar;\n    }\n    // We also expose a (non-property) method that is\n    // the equivalent of currentChar above. This allows\n    // us to work around assumptions in the TypeScript\n    // compiler that method calls (e.g. moveNext()) don't\n    // modify properties.\n    getCurrentChar() {\n        return this._currentChar;\n    }\n    get nextChar() {\n        return this.position + 1 < this._text.length ? this._text.charCodeAt(this.position + 1) : 0;\n    }\n    get prevChar() {\n        return this.position - 1 >= 0 ? this._text.charCodeAt(this.position - 1) : 0;\n    }\n    isEndOfStream() {\n        return this._isEndOfStream;\n    }\n    lookAhead(offset) {\n        const pos = this._position + offset;\n        return pos < 0 || pos >= this._text.length ? 0 : this._text.charCodeAt(pos);\n    }\n    advance(offset) {\n        this.position += offset;\n    }\n    moveNext() {\n        if (this._position < this._text.length - 1) {\n            // Most common case, no need to check bounds extensively\n            this._position += 1;\n            this._currentChar = this._text.charCodeAt(this._position);\n            return true;\n        }\n        this.advance(1);\n        return !this.isEndOfStream();\n    }\n    isAtWhiteSpace() {\n        return characters_1.isWhiteSpace(this.currentChar);\n    }\n    isAtLineBreak() {\n        return characters_1.isLineBreak(this.currentChar);\n    }\n    skipLineBreak() {\n        if (this._currentChar === 13 /* CarriageReturn */) {\n            this.moveNext();\n            if (this.currentChar === 10 /* LineFeed */) {\n                this.moveNext();\n            }\n        }\n        else if (this._currentChar === 10 /* LineFeed */) {\n            this.moveNext();\n        }\n    }\n    skipWhitespace() {\n        while (!this.isEndOfStream() && this.isAtWhiteSpace()) {\n            this.moveNext();\n        }\n    }\n    skipToEol() {\n        while (!this.isEndOfStream() && !this.isAtLineBreak()) {\n            this.moveNext();\n        }\n    }\n    skipToWhitespace() {\n        while (!this.isEndOfStream() && !this.isAtWhiteSpace()) {\n            this.moveNext();\n        }\n    }\n    charCodeAt(index) {\n        return this._text.charCodeAt(index);\n    }\n    get length() {\n        return this._text.length;\n    }\n    _checkBounds() {\n        if (this._position < 0) {\n            this._position = 0;\n        }\n        this._isEndOfStream = this._position >= this._text.length;\n        if (this._isEndOfStream) {\n            this._position = this._text.length;\n        }\n        this._currentChar = this._isEndOfStream ? 0 : this._text.charCodeAt(this._position);\n    }\n}\nexports.CharacterStream = CharacterStream;\n\n\n//# sourceURL=webpack://pyright-server/./src/parser/characterStream.ts?");

/***/ }),

/***/ "./src/parser/characters.ts":
/*!**********************************!*\
  !*** ./src/parser/characters.ts ***!
  \**********************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isBinary [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isDecimal [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isHex [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isIdentifierChar [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isIdentifierStartChar [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isLineBreak [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isNumber [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isOctal [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isWhiteSpace [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * characters.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Based on code from vscode-python repository:\n *  https://github.com/Microsoft/vscode-python\n *\n * Utility routines used by tokenizer.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isBinary = exports.isOctal = exports.isHex = exports.isDecimal = exports.isNumber = exports.isLineBreak = exports.isWhiteSpace = exports.isIdentifierChar = exports.isIdentifierStartChar = void 0;\nconst unicode = __webpack_require__(/*! ./unicode */ \"./src/parser/unicode.ts\");\nvar CharCategory;\n(function (CharCategory) {\n    // Character cannot appear in identifier\n    CharCategory[CharCategory[\"NotIdentifierChar\"] = 0] = \"NotIdentifierChar\";\n    // Character can appear at beginning or within identifier\n    CharCategory[CharCategory[\"StartIdentifierChar\"] = 1] = \"StartIdentifierChar\";\n    // Character can appear only within identifier, not at beginning\n    CharCategory[CharCategory[\"IdentifierChar\"] = 2] = \"IdentifierChar\";\n})(CharCategory || (CharCategory = {}));\n// Table of first 256 character codes (the most common cases).\nconst _identifierCharFastTableSize = 256;\nconst _identifierCharFastTable = new Array(_identifierCharFastTableSize);\n// Map of remaining characters that can appear within identifier.\nconst _identifierCharMap = {};\n// We do lazy initialization of this map because it's rarely used.\nlet _identifierCharMapInitialized = false;\nfunction isIdentifierStartChar(ch) {\n    if (ch < _identifierCharFastTableSize) {\n        return _identifierCharFastTable[ch] === CharCategory.StartIdentifierChar;\n    }\n    // Lazy initialize the char map. We'll rarely get here.\n    if (!_identifierCharMapInitialized) {\n        _buildIdentifierLookupTable(false);\n        _identifierCharMapInitialized = true;\n    }\n    return _identifierCharMap[ch] === CharCategory.StartIdentifierChar;\n}\nexports.isIdentifierStartChar = isIdentifierStartChar;\nfunction isIdentifierChar(ch) {\n    if (ch < _identifierCharFastTableSize) {\n        return (_identifierCharFastTable[ch] === CharCategory.StartIdentifierChar ||\n            _identifierCharFastTable[ch] === CharCategory.IdentifierChar);\n    }\n    return (_identifierCharMap[ch] === CharCategory.StartIdentifierChar ||\n        _identifierCharMap[ch] === CharCategory.IdentifierChar);\n}\nexports.isIdentifierChar = isIdentifierChar;\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* Space */ || ch === 9 /* Tab */ || ch === 12 /* FormFeed */;\n}\nexports.isWhiteSpace = isWhiteSpace;\nfunction isLineBreak(ch) {\n    return ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */;\n}\nexports.isLineBreak = isLineBreak;\nfunction isNumber(ch) {\n    return (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) || ch === 95 /* Underscore */;\n}\nexports.isNumber = isNumber;\nfunction isDecimal(ch) {\n    return (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) || ch === 95 /* Underscore */;\n}\nexports.isDecimal = isDecimal;\nfunction isHex(ch) {\n    return isDecimal(ch) || (ch >= 97 /* a */ && ch <= 102 /* f */) || (ch >= 65 /* A */ && ch <= 70 /* F */) || ch === 95 /* Underscore */;\n}\nexports.isHex = isHex;\nfunction isOctal(ch) {\n    return (ch >= 48 /* _0 */ && ch <= 55 /* _7 */) || ch === 95 /* Underscore */;\n}\nexports.isOctal = isOctal;\nfunction isBinary(ch) {\n    return ch === 48 /* _0 */ || ch === 49 /* _1 */ || ch === 95 /* Underscore */;\n}\nexports.isBinary = isBinary;\n// Underscore is explicitly allowed to start an identifier.\n// Characters with the Other_ID_Start property.\nconst _specialStartIdentifierChars = [\n    95 /* Underscore */,\n    0x1885,\n    0x1886,\n    0x2118,\n    0x212e,\n    0x309b,\n    0x309c,\n];\nconst _startIdentifierCharRanges = [\n    _specialStartIdentifierChars,\n    unicode.unicodeLu,\n    unicode.unicodeLl,\n    unicode.unicodeLt,\n    unicode.unicodeLo,\n    unicode.unicodeLm,\n    unicode.unicodeNl,\n];\n// Characters with the Other_ID_Start property.\nconst _specialIdentifierChars = [\n    0x00b7,\n    0x0387,\n    0x1369,\n    0x136a,\n    0x136b,\n    0x136c,\n    0x136d,\n    0x136e,\n    0x136f,\n    0x1370,\n    0x1371,\n    0x19da,\n];\nconst _identifierCharRanges = [\n    _specialIdentifierChars,\n    unicode.unicodeMn,\n    unicode.unicodeMc,\n    unicode.unicodeNd,\n    unicode.unicodePc,\n];\nfunction _buildIdentifierLookupTableFromUnicodeRangeTable(table, category, fastTableOnly) {\n    for (let entryIndex = 0; entryIndex < table.length; entryIndex++) {\n        const entry = table[entryIndex];\n        let rangeStart;\n        let rangeEnd;\n        if (Array.isArray(entry)) {\n            rangeStart = entry[0];\n            rangeEnd = entry[1];\n        }\n        else {\n            rangeStart = rangeEnd = entry;\n        }\n        for (let i = rangeStart; i <= rangeEnd; i++) {\n            if (i < _identifierCharFastTableSize) {\n                _identifierCharFastTable[i] = category;\n            }\n            else {\n                _identifierCharMap[i] = category;\n            }\n        }\n        if (fastTableOnly && rangeStart >= _identifierCharFastTableSize) {\n            break;\n        }\n    }\n}\n// Build a lookup table for to speed up tokenization of identifiers.\nfunction _buildIdentifierLookupTable(fastTableOnly) {\n    _identifierCharFastTable.fill(CharCategory.NotIdentifierChar);\n    _identifierCharRanges.forEach((table) => {\n        _buildIdentifierLookupTableFromUnicodeRangeTable(table, CharCategory.IdentifierChar, fastTableOnly);\n    });\n    _startIdentifierCharRanges.forEach((table) => {\n        _buildIdentifierLookupTableFromUnicodeRangeTable(table, CharCategory.StartIdentifierChar, fastTableOnly);\n    });\n}\n_buildIdentifierLookupTable(true);\n\n\n//# sourceURL=webpack://pyright-server/./src/parser/characters.ts?");

/***/ }),

/***/ "./src/parser/parseNodes.ts":
/*!**********************************!*\
  !*** ./src/parser/parseNodes.ts ***!
  \**********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * parseNodes.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Definition of parse nodes that make up the Python abstract\n * syntax tree (AST).\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RaiseNode = exports.ReturnNode = exports.ContinueNode = exports.BreakNode = exports.AssertNode = exports.NonlocalNode = exports.GlobalNode = exports.ImportFromAsNode = exports.ImportFromNode = exports.ImportAsNode = exports.ModuleNameNode = exports.ImportNode = exports.PassNode = exports.DelNode = exports.ArgumentNode = exports.ListNode = exports.SetNode = exports.DictionaryExpandEntryNode = exports.DictionaryKeyEntryNode = exports.DictionaryNode = exports.StringListNode = exports.FormatStringNode = exports.StringNode = exports.NumberNode = exports.EllipsisNode = exports.ConstantNode = exports.NameNode = exports.LambdaNode = exports.MemberAccessNode = exports.YieldFromNode = exports.YieldNode = exports.SliceNode = exports.IndexNode = exports.IndexItemsNode = exports.ListComprehensionNode = exports.CallNode = exports.TupleNode = exports.UnpackNode = exports.TernaryNode = exports.AwaitNode = exports.AugmentedAssignmentNode = exports.TypeAnnotationNode = exports.AssignmentNode = exports.AssignmentExpressionNode = exports.BinaryOperationNode = exports.UnaryOperationNode = exports.ErrorNode = exports.isExpressionNode = exports.StatementListNode = exports.DecoratorNode = exports.WithItemNode = exports.WithNode = exports.ClassNode = exports.ParameterNode = exports.FunctionNode = exports.ExceptNode = exports.TryNode = exports.ListComprehensionIfNode = exports.ListComprehensionForNode = exports.ForNode = exports.WhileNode = exports.IfNode = exports.SuiteNode = exports.ModuleNode = exports.extendRange = exports.getNextNodeId = void 0;\nconst textRange_1 = __webpack_require__(/*! ../common/textRange */ \"./src/common/textRange.ts\");\nlet _nextNodeId = 1;\nfunction getNextNodeId() {\n    return _nextNodeId++;\n}\nexports.getNextNodeId = getNextNodeId;\nfunction extendRange(node, newRange) {\n    if (newRange.start < node.start) {\n        node.length += node.start - newRange.start;\n        node.start = newRange.start;\n    }\n    if (textRange_1.TextRange.getEnd(newRange) > textRange_1.TextRange.getEnd(node)) {\n        node.length = textRange_1.TextRange.getEnd(newRange) - node.start;\n    }\n}\nexports.extendRange = extendRange;\nvar ModuleNode;\n(function (ModuleNode) {\n    function create(range) {\n        const node = {\n            start: range.start,\n            length: range.length,\n            nodeType: 37 /* Module */,\n            id: _nextNodeId++,\n            statements: [],\n        };\n        return node;\n    }\n    ModuleNode.create = create;\n})(ModuleNode = exports.ModuleNode || (exports.ModuleNode = {}));\nvar SuiteNode;\n(function (SuiteNode) {\n    function create(range) {\n        const node = {\n            start: range.start,\n            length: range.length,\n            nodeType: 51 /* Suite */,\n            id: _nextNodeId++,\n            statements: [],\n        };\n        return node;\n    }\n    SuiteNode.create = create;\n})(SuiteNode = exports.SuiteNode || (exports.SuiteNode = {}));\nvar IfNode;\n(function (IfNode) {\n    function create(ifOrElifToken, testExpression, ifSuite, elseSuite) {\n        const node = {\n            start: ifOrElifToken.start,\n            length: ifOrElifToken.length,\n            nodeType: 19 /* If */,\n            id: _nextNodeId++,\n            testExpression,\n            ifSuite,\n            elseSuite,\n        };\n        testExpression.parent = node;\n        ifSuite.parent = node;\n        extendRange(node, testExpression);\n        extendRange(node, ifSuite);\n        if (elseSuite) {\n            extendRange(node, elseSuite);\n            elseSuite.parent = node;\n        }\n        return node;\n    }\n    IfNode.create = create;\n})(IfNode = exports.IfNode || (exports.IfNode = {}));\nvar WhileNode;\n(function (WhileNode) {\n    function create(whileToken, testExpression, whileSuite) {\n        const node = {\n            start: whileToken.start,\n            length: whileToken.length,\n            nodeType: 58 /* While */,\n            id: _nextNodeId++,\n            testExpression,\n            whileSuite,\n        };\n        testExpression.parent = node;\n        whileSuite.parent = node;\n        extendRange(node, whileSuite);\n        return node;\n    }\n    WhileNode.create = create;\n})(WhileNode = exports.WhileNode || (exports.WhileNode = {}));\nvar ForNode;\n(function (ForNode) {\n    function create(forToken, targetExpression, iterableExpression, forSuite) {\n        const node = {\n            start: forToken.start,\n            length: forToken.length,\n            nodeType: 27 /* For */,\n            id: _nextNodeId++,\n            targetExpression,\n            iterableExpression,\n            forSuite,\n        };\n        targetExpression.parent = node;\n        iterableExpression.parent = node;\n        forSuite.parent = node;\n        extendRange(node, forSuite);\n        return node;\n    }\n    ForNode.create = create;\n})(ForNode = exports.ForNode || (exports.ForNode = {}));\nvar ListComprehensionForNode;\n(function (ListComprehensionForNode) {\n    function create(startToken, targetExpression, iterableExpression) {\n        const node = {\n            start: startToken.start,\n            length: startToken.length,\n            nodeType: 34 /* ListComprehensionFor */,\n            id: _nextNodeId++,\n            targetExpression,\n            iterableExpression,\n        };\n        targetExpression.parent = node;\n        iterableExpression.parent = node;\n        extendRange(node, targetExpression);\n        extendRange(node, iterableExpression);\n        return node;\n    }\n    ListComprehensionForNode.create = create;\n})(ListComprehensionForNode = exports.ListComprehensionForNode || (exports.ListComprehensionForNode = {}));\nvar ListComprehensionIfNode;\n(function (ListComprehensionIfNode) {\n    function create(ifToken, testExpression) {\n        const node = {\n            start: ifToken.start,\n            length: ifToken.length,\n            nodeType: 35 /* ListComprehensionIf */,\n            id: _nextNodeId++,\n            testExpression,\n        };\n        testExpression.parent = node;\n        extendRange(node, testExpression);\n        return node;\n    }\n    ListComprehensionIfNode.create = create;\n})(ListComprehensionIfNode = exports.ListComprehensionIfNode || (exports.ListComprehensionIfNode = {}));\nvar TryNode;\n(function (TryNode) {\n    function create(tryToken, trySuite) {\n        const node = {\n            start: tryToken.start,\n            length: tryToken.length,\n            nodeType: 54 /* Try */,\n            id: _nextNodeId++,\n            trySuite,\n            exceptClauses: [],\n        };\n        trySuite.parent = node;\n        extendRange(node, trySuite);\n        return node;\n    }\n    TryNode.create = create;\n})(TryNode = exports.TryNode || (exports.TryNode = {}));\nvar ExceptNode;\n(function (ExceptNode) {\n    function create(exceptToken, exceptSuite) {\n        const node = {\n            start: exceptToken.start,\n            length: exceptToken.length,\n            nodeType: 26 /* Except */,\n            id: _nextNodeId++,\n            exceptSuite,\n        };\n        exceptSuite.parent = node;\n        extendRange(node, exceptSuite);\n        return node;\n    }\n    ExceptNode.create = create;\n})(ExceptNode = exports.ExceptNode || (exports.ExceptNode = {}));\nvar FunctionNode;\n(function (FunctionNode) {\n    function create(defToken, name, suite) {\n        const node = {\n            start: defToken.start,\n            length: defToken.length,\n            nodeType: 29 /* Function */,\n            id: _nextNodeId++,\n            decorators: [],\n            name,\n            parameters: [],\n            suite,\n        };\n        name.parent = node;\n        suite.parent = node;\n        extendRange(node, suite);\n        return node;\n    }\n    FunctionNode.create = create;\n})(FunctionNode = exports.FunctionNode || (exports.FunctionNode = {}));\nvar ParameterNode;\n(function (ParameterNode) {\n    function create(startToken, paramCategory) {\n        const node = {\n            start: startToken.start,\n            length: startToken.length,\n            nodeType: 42 /* Parameter */,\n            id: _nextNodeId++,\n            category: paramCategory,\n        };\n        return node;\n    }\n    ParameterNode.create = create;\n})(ParameterNode = exports.ParameterNode || (exports.ParameterNode = {}));\nvar ClassNode;\n(function (ClassNode) {\n    function create(classToken, name, suite) {\n        const node = {\n            start: classToken.start,\n            length: classToken.length,\n            nodeType: 10 /* Class */,\n            id: _nextNodeId++,\n            decorators: [],\n            name,\n            arguments: [],\n            suite,\n        };\n        name.parent = node;\n        suite.parent = node;\n        extendRange(node, suite);\n        return node;\n    }\n    ClassNode.create = create;\n    // This variant is used to create a dummy class\n    // when the parser encounters decorators with no\n    // function or class declaration.\n    function createDummyForDecorators(decorators) {\n        const node = {\n            start: 0,\n            length: 0,\n            nodeType: 10 /* Class */,\n            id: _nextNodeId++,\n            decorators,\n            name: {\n                start: 0,\n                length: 0,\n                id: 0,\n                nodeType: 39 /* Name */,\n                token: {\n                    type: 7 /* Identifier */,\n                    start: 0,\n                    length: 0,\n                    comments: [],\n                    value: '',\n                },\n                value: '',\n            },\n            arguments: [],\n            suite: {\n                start: 0,\n                length: 0,\n                id: 0,\n                nodeType: 51 /* Suite */,\n                statements: [],\n            },\n        };\n        decorators.forEach((decorator) => {\n            decorator.parent = node;\n            extendRange(node, decorator);\n        });\n        node.name.parent = node;\n        node.suite.parent = node;\n        return node;\n    }\n    ClassNode.createDummyForDecorators = createDummyForDecorators;\n})(ClassNode = exports.ClassNode || (exports.ClassNode = {}));\nvar WithNode;\n(function (WithNode) {\n    function create(withToken, suite) {\n        const node = {\n            start: withToken.start,\n            length: withToken.length,\n            nodeType: 59 /* With */,\n            id: _nextNodeId++,\n            withItems: [],\n            suite,\n        };\n        suite.parent = node;\n        extendRange(node, suite);\n        return node;\n    }\n    WithNode.create = create;\n})(WithNode = exports.WithNode || (exports.WithNode = {}));\nvar WithItemNode;\n(function (WithItemNode) {\n    function create(expression) {\n        const node = {\n            start: expression.start,\n            length: expression.length,\n            nodeType: 60 /* WithItem */,\n            id: _nextNodeId++,\n            expression,\n        };\n        expression.parent = node;\n        return node;\n    }\n    WithItemNode.create = create;\n})(WithItemNode = exports.WithItemNode || (exports.WithItemNode = {}));\nvar DecoratorNode;\n(function (DecoratorNode) {\n    function create(atToken, leftExpression) {\n        const node = {\n            start: atToken.start,\n            length: atToken.length,\n            nodeType: 13 /* Decorator */,\n            id: _nextNodeId++,\n            leftExpression,\n            arguments: undefined,\n        };\n        leftExpression.parent = node;\n        extendRange(node, leftExpression);\n        return node;\n    }\n    DecoratorNode.create = create;\n})(DecoratorNode = exports.DecoratorNode || (exports.DecoratorNode = {}));\nvar StatementListNode;\n(function (StatementListNode) {\n    function create(atToken) {\n        const node = {\n            start: atToken.start,\n            length: atToken.length,\n            nodeType: 48 /* StatementList */,\n            id: _nextNodeId++,\n            statements: [],\n        };\n        return node;\n    }\n    StatementListNode.create = create;\n})(StatementListNode = exports.StatementListNode || (exports.StatementListNode = {}));\nfunction isExpressionNode(node) {\n    switch (node.nodeType) {\n        case 0 /* Error */:\n        case 56 /* UnaryOperation */:\n        case 7 /* BinaryOperation */:\n        case 4 /* AssignmentExpression */:\n        case 55 /* TypeAnnotation */:\n        case 6 /* Await */:\n        case 52 /* Ternary */:\n        case 57 /* Unpack */:\n        case 53 /* Tuple */:\n        case 9 /* Call */:\n        case 33 /* ListComprehension */:\n        case 24 /* Index */:\n        case 47 /* Slice */:\n        case 61 /* Yield */:\n        case 62 /* YieldFrom */:\n        case 36 /* MemberAccess */:\n        case 31 /* Lambda */:\n        case 39 /* Name */:\n        case 11 /* Constant */:\n        case 18 /* Ellipsis */:\n        case 41 /* Number */:\n        case 50 /* String */:\n        case 28 /* FormatString */:\n        case 49 /* StringList */:\n        case 15 /* Dictionary */:\n        case 16 /* DictionaryExpandEntry */:\n        case 32 /* List */:\n        case 46 /* Set */:\n            return true;\n        default:\n            return false;\n    }\n}\nexports.isExpressionNode = isExpressionNode;\nvar ErrorNode;\n(function (ErrorNode) {\n    function create(initialRange, category, child) {\n        const node = {\n            start: initialRange.start,\n            length: initialRange.length,\n            nodeType: 0 /* Error */,\n            id: _nextNodeId++,\n            category,\n            child,\n        };\n        if (child) {\n            child.parent = node;\n            extendRange(node, child);\n        }\n        return node;\n    }\n    ErrorNode.create = create;\n})(ErrorNode = exports.ErrorNode || (exports.ErrorNode = {}));\nvar UnaryOperationNode;\n(function (UnaryOperationNode) {\n    function create(operatorToken, expression, operator) {\n        const node = {\n            start: operatorToken.start,\n            length: operatorToken.length,\n            nodeType: 56 /* UnaryOperation */,\n            id: _nextNodeId++,\n            operator,\n            operatorToken,\n            expression,\n        };\n        expression.parent = node;\n        extendRange(node, expression);\n        return node;\n    }\n    UnaryOperationNode.create = create;\n})(UnaryOperationNode = exports.UnaryOperationNode || (exports.UnaryOperationNode = {}));\nvar BinaryOperationNode;\n(function (BinaryOperationNode) {\n    function create(leftExpression, rightExpression, operatorToken, operator) {\n        const node = {\n            start: leftExpression.start,\n            length: leftExpression.length,\n            nodeType: 7 /* BinaryOperation */,\n            id: _nextNodeId++,\n            leftExpression,\n            operatorToken,\n            operator,\n            rightExpression,\n        };\n        leftExpression.parent = node;\n        rightExpression.parent = node;\n        extendRange(node, rightExpression);\n        return node;\n    }\n    BinaryOperationNode.create = create;\n})(BinaryOperationNode = exports.BinaryOperationNode || (exports.BinaryOperationNode = {}));\nvar AssignmentExpressionNode;\n(function (AssignmentExpressionNode) {\n    function create(name, rightExpression) {\n        const node = {\n            start: name.start,\n            length: name.length,\n            nodeType: 4 /* AssignmentExpression */,\n            id: _nextNodeId++,\n            name,\n            rightExpression,\n        };\n        name.parent = node;\n        rightExpression.parent = node;\n        extendRange(node, rightExpression);\n        return node;\n    }\n    AssignmentExpressionNode.create = create;\n})(AssignmentExpressionNode = exports.AssignmentExpressionNode || (exports.AssignmentExpressionNode = {}));\nvar AssignmentNode;\n(function (AssignmentNode) {\n    function create(leftExpression, rightExpression) {\n        const node = {\n            start: leftExpression.start,\n            length: leftExpression.length,\n            nodeType: 3 /* Assignment */,\n            id: _nextNodeId++,\n            leftExpression,\n            rightExpression,\n        };\n        leftExpression.parent = node;\n        rightExpression.parent = node;\n        extendRange(node, rightExpression);\n        return node;\n    }\n    AssignmentNode.create = create;\n})(AssignmentNode = exports.AssignmentNode || (exports.AssignmentNode = {}));\nvar TypeAnnotationNode;\n(function (TypeAnnotationNode) {\n    function create(valueExpression, typeAnnotation) {\n        const node = {\n            start: valueExpression.start,\n            length: valueExpression.length,\n            nodeType: 55 /* TypeAnnotation */,\n            id: _nextNodeId++,\n            valueExpression,\n            typeAnnotation,\n        };\n        valueExpression.parent = node;\n        typeAnnotation.parent = node;\n        extendRange(node, typeAnnotation);\n        return node;\n    }\n    TypeAnnotationNode.create = create;\n})(TypeAnnotationNode = exports.TypeAnnotationNode || (exports.TypeAnnotationNode = {}));\nvar AugmentedAssignmentNode;\n(function (AugmentedAssignmentNode) {\n    function create(leftExpression, rightExpression, operator, destExpression) {\n        const node = {\n            start: leftExpression.start,\n            length: leftExpression.length,\n            nodeType: 5 /* AugmentedAssignment */,\n            id: _nextNodeId++,\n            leftExpression,\n            operator,\n            rightExpression,\n            destExpression,\n        };\n        leftExpression.parent = node;\n        rightExpression.parent = node;\n        destExpression.parent = node;\n        extendRange(node, rightExpression);\n        return node;\n    }\n    AugmentedAssignmentNode.create = create;\n})(AugmentedAssignmentNode = exports.AugmentedAssignmentNode || (exports.AugmentedAssignmentNode = {}));\nvar AwaitNode;\n(function (AwaitNode) {\n    function create(awaitToken, expression) {\n        const node = {\n            start: awaitToken.start,\n            length: awaitToken.length,\n            nodeType: 6 /* Await */,\n            id: _nextNodeId++,\n            expression,\n        };\n        expression.parent = node;\n        extendRange(node, expression);\n        return node;\n    }\n    AwaitNode.create = create;\n})(AwaitNode = exports.AwaitNode || (exports.AwaitNode = {}));\nvar TernaryNode;\n(function (TernaryNode) {\n    function create(ifExpression, testExpression, elseExpression) {\n        const node = {\n            start: ifExpression.start,\n            length: ifExpression.length,\n            nodeType: 52 /* Ternary */,\n            id: _nextNodeId++,\n            ifExpression,\n            testExpression,\n            elseExpression,\n        };\n        ifExpression.parent = node;\n        testExpression.parent = node;\n        elseExpression.parent = node;\n        extendRange(node, elseExpression);\n        return node;\n    }\n    TernaryNode.create = create;\n})(TernaryNode = exports.TernaryNode || (exports.TernaryNode = {}));\nvar UnpackNode;\n(function (UnpackNode) {\n    function create(starToken, expression) {\n        const node = {\n            start: starToken.start,\n            length: starToken.length,\n            nodeType: 57 /* Unpack */,\n            id: _nextNodeId++,\n            expression,\n        };\n        expression.parent = node;\n        extendRange(node, expression);\n        return node;\n    }\n    UnpackNode.create = create;\n})(UnpackNode = exports.UnpackNode || (exports.UnpackNode = {}));\nvar TupleNode;\n(function (TupleNode) {\n    function create(range, enclosedInParens) {\n        const node = {\n            start: range.start,\n            length: range.length,\n            nodeType: 53 /* Tuple */,\n            id: _nextNodeId++,\n            expressions: [],\n            enclosedInParens,\n        };\n        return node;\n    }\n    TupleNode.create = create;\n})(TupleNode = exports.TupleNode || (exports.TupleNode = {}));\nvar CallNode;\n(function (CallNode) {\n    function create(leftExpression) {\n        const node = {\n            start: leftExpression.start,\n            length: leftExpression.length,\n            nodeType: 9 /* Call */,\n            id: _nextNodeId++,\n            leftExpression,\n            arguments: [],\n        };\n        leftExpression.parent = node;\n        return node;\n    }\n    CallNode.create = create;\n})(CallNode = exports.CallNode || (exports.CallNode = {}));\nvar ListComprehensionNode;\n(function (ListComprehensionNode) {\n    function create(expression) {\n        const node = {\n            start: expression.start,\n            length: expression.length,\n            nodeType: 33 /* ListComprehension */,\n            id: _nextNodeId++,\n            expression,\n            comprehensions: [],\n        };\n        expression.parent = node;\n        return node;\n    }\n    ListComprehensionNode.create = create;\n})(ListComprehensionNode = exports.ListComprehensionNode || (exports.ListComprehensionNode = {}));\nvar IndexItemsNode;\n(function (IndexItemsNode) {\n    function create(openBracketToken, closeBracketToken, items) {\n        const node = {\n            start: openBracketToken.start,\n            length: openBracketToken.length,\n            nodeType: 25 /* IndexItems */,\n            id: _nextNodeId++,\n            items,\n        };\n        items.forEach((item) => {\n            item.parent = node;\n        });\n        extendRange(node, closeBracketToken);\n        return node;\n    }\n    IndexItemsNode.create = create;\n})(IndexItemsNode = exports.IndexItemsNode || (exports.IndexItemsNode = {}));\nvar IndexNode;\n(function (IndexNode) {\n    function create(baseExpression, items) {\n        const node = {\n            start: baseExpression.start,\n            length: baseExpression.length,\n            nodeType: 24 /* Index */,\n            id: _nextNodeId++,\n            baseExpression,\n            items,\n        };\n        baseExpression.parent = node;\n        items.parent = node;\n        extendRange(node, items);\n        return node;\n    }\n    IndexNode.create = create;\n})(IndexNode = exports.IndexNode || (exports.IndexNode = {}));\nvar SliceNode;\n(function (SliceNode) {\n    function create(range) {\n        const node = {\n            start: range.start,\n            length: range.length,\n            nodeType: 47 /* Slice */,\n            id: _nextNodeId++,\n        };\n        return node;\n    }\n    SliceNode.create = create;\n})(SliceNode = exports.SliceNode || (exports.SliceNode = {}));\nvar YieldNode;\n(function (YieldNode) {\n    function create(yieldToken, expression) {\n        const node = {\n            start: yieldToken.start,\n            length: yieldToken.length,\n            nodeType: 61 /* Yield */,\n            id: _nextNodeId++,\n            expression,\n        };\n        if (expression) {\n            expression.parent = node;\n            extendRange(node, expression);\n        }\n        return node;\n    }\n    YieldNode.create = create;\n})(YieldNode = exports.YieldNode || (exports.YieldNode = {}));\nvar YieldFromNode;\n(function (YieldFromNode) {\n    function create(yieldToken, expression) {\n        const node = {\n            start: yieldToken.start,\n            length: yieldToken.length,\n            nodeType: 62 /* YieldFrom */,\n            id: _nextNodeId++,\n            expression,\n        };\n        expression.parent = node;\n        extendRange(node, expression);\n        return node;\n    }\n    YieldFromNode.create = create;\n})(YieldFromNode = exports.YieldFromNode || (exports.YieldFromNode = {}));\nvar MemberAccessNode;\n(function (MemberAccessNode) {\n    function create(leftExpression, memberName) {\n        const node = {\n            start: leftExpression.start,\n            length: leftExpression.length,\n            nodeType: 36 /* MemberAccess */,\n            id: _nextNodeId++,\n            leftExpression,\n            memberName,\n        };\n        leftExpression.parent = node;\n        memberName.parent = node;\n        extendRange(node, memberName);\n        return node;\n    }\n    MemberAccessNode.create = create;\n})(MemberAccessNode = exports.MemberAccessNode || (exports.MemberAccessNode = {}));\nvar LambdaNode;\n(function (LambdaNode) {\n    function create(lambdaToken, expression) {\n        const node = {\n            start: lambdaToken.start,\n            length: lambdaToken.length,\n            nodeType: 31 /* Lambda */,\n            id: _nextNodeId++,\n            parameters: [],\n            expression,\n        };\n        expression.parent = node;\n        extendRange(node, expression);\n        return node;\n    }\n    LambdaNode.create = create;\n})(LambdaNode = exports.LambdaNode || (exports.LambdaNode = {}));\nvar NameNode;\n(function (NameNode) {\n    function create(nameToken) {\n        const node = {\n            start: nameToken.start,\n            length: nameToken.length,\n            nodeType: 39 /* Name */,\n            id: _nextNodeId++,\n            token: nameToken,\n            value: nameToken.value,\n        };\n        return node;\n    }\n    NameNode.create = create;\n})(NameNode = exports.NameNode || (exports.NameNode = {}));\nvar ConstantNode;\n(function (ConstantNode) {\n    function create(token) {\n        const node = {\n            start: token.start,\n            length: token.length,\n            nodeType: 11 /* Constant */,\n            id: _nextNodeId++,\n            constType: token.keywordType,\n        };\n        return node;\n    }\n    ConstantNode.create = create;\n})(ConstantNode = exports.ConstantNode || (exports.ConstantNode = {}));\nvar EllipsisNode;\n(function (EllipsisNode) {\n    function create(range) {\n        const node = {\n            start: range.start,\n            length: range.length,\n            nodeType: 18 /* Ellipsis */,\n            id: _nextNodeId++,\n        };\n        return node;\n    }\n    EllipsisNode.create = create;\n})(EllipsisNode = exports.EllipsisNode || (exports.EllipsisNode = {}));\nvar NumberNode;\n(function (NumberNode) {\n    function create(token) {\n        const node = {\n            start: token.start,\n            length: token.length,\n            nodeType: 41 /* Number */,\n            id: _nextNodeId++,\n            value: token.value,\n            isInteger: token.isInteger,\n            isImaginary: token.isImaginary,\n        };\n        return node;\n    }\n    NumberNode.create = create;\n})(NumberNode = exports.NumberNode || (exports.NumberNode = {}));\nvar StringNode;\n(function (StringNode) {\n    function create(token, unescapedValue, hasUnescapeErrors) {\n        const node = {\n            start: token.start,\n            length: token.length,\n            nodeType: 50 /* String */,\n            id: _nextNodeId++,\n            token,\n            value: unescapedValue,\n            hasUnescapeErrors,\n        };\n        return node;\n    }\n    StringNode.create = create;\n})(StringNode = exports.StringNode || (exports.StringNode = {}));\nvar FormatStringNode;\n(function (FormatStringNode) {\n    function create(token, unescapedValue, hasUnescapeErrors, expressions) {\n        const node = {\n            start: token.start,\n            length: token.length,\n            nodeType: 28 /* FormatString */,\n            id: _nextNodeId++,\n            token,\n            value: unescapedValue,\n            hasUnescapeErrors,\n            expressions,\n        };\n        expressions.forEach((expr) => {\n            expr.parent = node;\n        });\n        return node;\n    }\n    FormatStringNode.create = create;\n})(FormatStringNode = exports.FormatStringNode || (exports.FormatStringNode = {}));\nvar StringListNode;\n(function (StringListNode) {\n    function create(strings) {\n        const node = {\n            start: strings[0].start,\n            length: strings[0].length,\n            nodeType: 49 /* StringList */,\n            id: _nextNodeId++,\n            strings,\n        };\n        if (strings.length > 0) {\n            strings.forEach((str) => {\n                str.parent = node;\n            });\n            extendRange(node, strings[strings.length - 1]);\n        }\n        return node;\n    }\n    StringListNode.create = create;\n})(StringListNode = exports.StringListNode || (exports.StringListNode = {}));\nvar DictionaryNode;\n(function (DictionaryNode) {\n    function create(range) {\n        const node = {\n            start: range.start,\n            length: range.length,\n            nodeType: 15 /* Dictionary */,\n            id: _nextNodeId++,\n            entries: [],\n        };\n        return node;\n    }\n    DictionaryNode.create = create;\n})(DictionaryNode = exports.DictionaryNode || (exports.DictionaryNode = {}));\nvar DictionaryKeyEntryNode;\n(function (DictionaryKeyEntryNode) {\n    function create(keyExpression, valueExpression) {\n        const node = {\n            start: keyExpression.start,\n            length: keyExpression.length,\n            nodeType: 17 /* DictionaryKeyEntry */,\n            id: _nextNodeId++,\n            keyExpression,\n            valueExpression,\n        };\n        keyExpression.parent = node;\n        valueExpression.parent = node;\n        extendRange(node, valueExpression);\n        return node;\n    }\n    DictionaryKeyEntryNode.create = create;\n})(DictionaryKeyEntryNode = exports.DictionaryKeyEntryNode || (exports.DictionaryKeyEntryNode = {}));\nvar DictionaryExpandEntryNode;\n(function (DictionaryExpandEntryNode) {\n    function create(expandExpression) {\n        const node = {\n            start: expandExpression.start,\n            length: expandExpression.length,\n            nodeType: 16 /* DictionaryExpandEntry */,\n            id: _nextNodeId++,\n            expandExpression,\n        };\n        expandExpression.parent = node;\n        return node;\n    }\n    DictionaryExpandEntryNode.create = create;\n})(DictionaryExpandEntryNode = exports.DictionaryExpandEntryNode || (exports.DictionaryExpandEntryNode = {}));\nvar SetNode;\n(function (SetNode) {\n    function create(range) {\n        const node = {\n            start: range.start,\n            length: range.length,\n            nodeType: 46 /* Set */,\n            id: _nextNodeId++,\n            entries: [],\n        };\n        return node;\n    }\n    SetNode.create = create;\n})(SetNode = exports.SetNode || (exports.SetNode = {}));\nvar ListNode;\n(function (ListNode) {\n    function create(range) {\n        const node = {\n            start: range.start,\n            length: range.length,\n            nodeType: 32 /* List */,\n            id: _nextNodeId++,\n            entries: [],\n        };\n        return node;\n    }\n    ListNode.create = create;\n})(ListNode = exports.ListNode || (exports.ListNode = {}));\nvar ArgumentNode;\n(function (ArgumentNode) {\n    function create(startToken, valueExpression, argCategory) {\n        const node = {\n            start: startToken.start,\n            length: startToken.length,\n            nodeType: 1 /* Argument */,\n            id: _nextNodeId++,\n            valueExpression,\n            argumentCategory: argCategory,\n        };\n        valueExpression.parent = node;\n        extendRange(node, valueExpression);\n        return node;\n    }\n    ArgumentNode.create = create;\n})(ArgumentNode = exports.ArgumentNode || (exports.ArgumentNode = {}));\nvar DelNode;\n(function (DelNode) {\n    function create(delToken) {\n        const node = {\n            start: delToken.start,\n            length: delToken.length,\n            nodeType: 14 /* Del */,\n            id: _nextNodeId++,\n            expressions: [],\n        };\n        return node;\n    }\n    DelNode.create = create;\n})(DelNode = exports.DelNode || (exports.DelNode = {}));\nvar PassNode;\n(function (PassNode) {\n    function create(passToken) {\n        const node = {\n            start: passToken.start,\n            length: passToken.length,\n            nodeType: 43 /* Pass */,\n            id: _nextNodeId++,\n        };\n        return node;\n    }\n    PassNode.create = create;\n})(PassNode = exports.PassNode || (exports.PassNode = {}));\nvar ImportNode;\n(function (ImportNode) {\n    function create(passToken) {\n        const node = {\n            start: passToken.start,\n            length: passToken.length,\n            nodeType: 20 /* Import */,\n            id: _nextNodeId++,\n            list: [],\n        };\n        return node;\n    }\n    ImportNode.create = create;\n})(ImportNode = exports.ImportNode || (exports.ImportNode = {}));\nvar ModuleNameNode;\n(function (ModuleNameNode) {\n    function create(range) {\n        const node = {\n            start: range.start,\n            length: range.length,\n            nodeType: 38 /* ModuleName */,\n            id: _nextNodeId++,\n            leadingDots: 0,\n            nameParts: [],\n        };\n        return node;\n    }\n    ModuleNameNode.create = create;\n})(ModuleNameNode = exports.ModuleNameNode || (exports.ModuleNameNode = {}));\nvar ImportAsNode;\n(function (ImportAsNode) {\n    function create(module) {\n        const node = {\n            start: module.start,\n            length: module.length,\n            nodeType: 21 /* ImportAs */,\n            id: _nextNodeId++,\n            module,\n        };\n        module.parent = node;\n        return node;\n    }\n    ImportAsNode.create = create;\n})(ImportAsNode = exports.ImportAsNode || (exports.ImportAsNode = {}));\nvar ImportFromNode;\n(function (ImportFromNode) {\n    function create(fromToken, module) {\n        const node = {\n            start: fromToken.start,\n            length: fromToken.length,\n            nodeType: 22 /* ImportFrom */,\n            id: _nextNodeId++,\n            module,\n            imports: [],\n            isWildcardImport: false,\n            usesParens: false,\n        };\n        module.parent = node;\n        extendRange(node, module);\n        return node;\n    }\n    ImportFromNode.create = create;\n})(ImportFromNode = exports.ImportFromNode || (exports.ImportFromNode = {}));\nvar ImportFromAsNode;\n(function (ImportFromAsNode) {\n    function create(name) {\n        const node = {\n            start: name.start,\n            length: name.length,\n            nodeType: 23 /* ImportFromAs */,\n            id: _nextNodeId++,\n            name,\n        };\n        name.parent = node;\n        return node;\n    }\n    ImportFromAsNode.create = create;\n})(ImportFromAsNode = exports.ImportFromAsNode || (exports.ImportFromAsNode = {}));\nvar GlobalNode;\n(function (GlobalNode) {\n    function create(range) {\n        const node = {\n            start: range.start,\n            length: range.length,\n            nodeType: 30 /* Global */,\n            id: _nextNodeId++,\n            nameList: [],\n        };\n        return node;\n    }\n    GlobalNode.create = create;\n})(GlobalNode = exports.GlobalNode || (exports.GlobalNode = {}));\nvar NonlocalNode;\n(function (NonlocalNode) {\n    function create(range) {\n        const node = {\n            start: range.start,\n            length: range.length,\n            nodeType: 40 /* Nonlocal */,\n            id: _nextNodeId++,\n            nameList: [],\n        };\n        return node;\n    }\n    NonlocalNode.create = create;\n})(NonlocalNode = exports.NonlocalNode || (exports.NonlocalNode = {}));\nvar AssertNode;\n(function (AssertNode) {\n    function create(assertToken, testExpression) {\n        const node = {\n            start: assertToken.start,\n            length: assertToken.length,\n            nodeType: 2 /* Assert */,\n            id: _nextNodeId++,\n            testExpression,\n        };\n        testExpression.parent = node;\n        extendRange(node, testExpression);\n        return node;\n    }\n    AssertNode.create = create;\n})(AssertNode = exports.AssertNode || (exports.AssertNode = {}));\nvar BreakNode;\n(function (BreakNode) {\n    function create(range) {\n        const node = {\n            start: range.start,\n            length: range.length,\n            nodeType: 8 /* Break */,\n            id: _nextNodeId++,\n        };\n        return node;\n    }\n    BreakNode.create = create;\n})(BreakNode = exports.BreakNode || (exports.BreakNode = {}));\nvar ContinueNode;\n(function (ContinueNode) {\n    function create(range) {\n        const node = {\n            start: range.start,\n            length: range.length,\n            nodeType: 12 /* Continue */,\n            id: _nextNodeId++,\n        };\n        return node;\n    }\n    ContinueNode.create = create;\n})(ContinueNode = exports.ContinueNode || (exports.ContinueNode = {}));\nvar ReturnNode;\n(function (ReturnNode) {\n    function create(range) {\n        const node = {\n            start: range.start,\n            length: range.length,\n            nodeType: 45 /* Return */,\n            id: _nextNodeId++,\n        };\n        return node;\n    }\n    ReturnNode.create = create;\n})(ReturnNode = exports.ReturnNode || (exports.ReturnNode = {}));\nvar RaiseNode;\n(function (RaiseNode) {\n    function create(range) {\n        const node = {\n            start: range.start,\n            length: range.length,\n            nodeType: 44 /* Raise */,\n            id: _nextNodeId++,\n        };\n        return node;\n    }\n    RaiseNode.create = create;\n})(RaiseNode = exports.RaiseNode || (exports.RaiseNode = {}));\n\n\n//# sourceURL=webpack://pyright-server/./src/parser/parseNodes.ts?");

/***/ }),

/***/ "./src/parser/parser.ts":
/*!******************************!*\
  !*** ./src/parser/parser.ts ***!
  \******************************/
/*! flagged exports */
/*! export ParseOptions [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Parser [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * parser.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Based on code from python-language-server repository:\n *  https://github.com/Microsoft/python-language-server\n *\n * Parser for the Python language. Converts a stream of tokens\n * into an abstract syntax tree (AST).\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Parser = exports.ParseOptions = void 0;\nconst debug_1 = __webpack_require__(/*! ../common/debug */ \"./src/common/debug.ts\");\nconst diagnostic_1 = __webpack_require__(/*! ../common/diagnostic */ \"./src/common/diagnostic.ts\");\nconst diagnosticSink_1 = __webpack_require__(/*! ../common/diagnosticSink */ \"./src/common/diagnosticSink.ts\");\nconst positionUtils_1 = __webpack_require__(/*! ../common/positionUtils */ \"./src/common/positionUtils.ts\");\nconst pythonVersion_1 = __webpack_require__(/*! ../common/pythonVersion */ \"./src/common/pythonVersion.ts\");\nconst timing_1 = __webpack_require__(/*! ../common/timing */ \"./src/common/timing.ts\");\nconst localize_1 = __webpack_require__(/*! ../localization/localize */ \"./src/localization/localize.ts\");\nconst parseNodes_1 = __webpack_require__(/*! ./parseNodes */ \"./src/parser/parseNodes.ts\");\nconst StringTokenUtils = __webpack_require__(/*! ./stringTokenUtils */ \"./src/parser/stringTokenUtils.ts\");\nconst tokenizer_1 = __webpack_require__(/*! ./tokenizer */ \"./src/parser/tokenizer.ts\");\nconst tokenizerTypes_1 = __webpack_require__(/*! ./tokenizerTypes */ \"./src/parser/tokenizerTypes.ts\");\nclass ParseOptions {\n    constructor() {\n        this.isStubFile = false;\n        this.pythonVersion = pythonVersion_1.latestStablePythonVersion;\n    }\n}\nexports.ParseOptions = ParseOptions;\nclass Parser {\n    constructor() {\n        this._tokenIndex = 0;\n        this._parseOptions = new ParseOptions();\n        this._diagSink = new diagnosticSink_1.DiagnosticSink();\n        this._isInLoop = false;\n        this._isInFunction = false;\n        this._isInFinally = false;\n        this._isParsingTypeAnnotation = false;\n        this._isParsingIndexTrailer = false;\n        this._futureImportMap = new Map();\n        this._importedModules = [];\n        this._containsWildcardImport = false;\n        this._assignmentExpressionsAllowed = true;\n    }\n    parseSourceFile(fileContents, parseOptions, diagSink) {\n        timing_1.timingStats.tokenizeFileTime.timeOperation(() => {\n            this._startNewParse(fileContents, 0, fileContents.length, parseOptions, diagSink);\n        });\n        const moduleNode = parseNodes_1.ModuleNode.create({ start: 0, length: fileContents.length });\n        timing_1.timingStats.parseFileTime.timeOperation(() => {\n            while (!this._atEof()) {\n                if (!this._consumeTokenIfType(2 /* NewLine */)) {\n                    // Handle a common error case and try to recover.\n                    const nextToken = this._peekToken();\n                    if (nextToken.type === 3 /* Indent */) {\n                        this._getNextToken();\n                        const indentToken = nextToken;\n                        if (indentToken.isIndentAmbiguous) {\n                            this._addError(localize_1.Localizer.Diagnostic.inconsistentTabs(), indentToken);\n                        }\n                        else {\n                            this._addError(localize_1.Localizer.Diagnostic.unexpectedIndent(), nextToken);\n                        }\n                    }\n                    const statement = this._parseStatement();\n                    if (!statement) {\n                        // Perform basic error recovery to get to the next line.\n                        this._consumeTokensUntilType([2 /* NewLine */]);\n                    }\n                    else {\n                        statement.parent = moduleNode;\n                        moduleNode.statements.push(statement);\n                    }\n                }\n            }\n        });\n        debug_1.assert(this._tokenizerOutput !== undefined);\n        return {\n            text: fileContents,\n            parseTree: moduleNode,\n            importedModules: this._importedModules,\n            futureImports: this._futureImportMap,\n            tokenizerOutput: this._tokenizerOutput,\n            containsWildcardImport: this._containsWildcardImport,\n        };\n    }\n    parseTextExpression(fileContents, textOffset, textLength, parseOptions, parseTypeAnnotation, initialParenDepth = 0) {\n        const diagSink = new diagnosticSink_1.DiagnosticSink();\n        this._startNewParse(fileContents, textOffset, textLength, parseOptions, diagSink, initialParenDepth);\n        let parseTree;\n        if (parseTypeAnnotation) {\n            parseTree = this._parseTypeAnnotation(/* allowUnionNotation */ false);\n        }\n        else {\n            parseTree = this._parseTestExpression(false);\n        }\n        if (this._peekTokenType() === 2 /* NewLine */) {\n            this._getNextToken();\n        }\n        if (!this._atEof()) {\n            this._addError(localize_1.Localizer.Diagnostic.unexpectedExprToken(), this._peekToken());\n        }\n        return {\n            parseTree,\n            lines: this._tokenizerOutput.lines,\n            diagnostics: diagSink.fetchAndClear(),\n        };\n    }\n    _startNewParse(fileContents, textOffset, textLength, parseOptions, diagSink, initialParenDepth = 0) {\n        this._fileContents = fileContents;\n        this._parseOptions = parseOptions;\n        this._diagSink = diagSink;\n        // Tokenize the file contents.\n        const tokenizer = new tokenizer_1.Tokenizer();\n        this._tokenizerOutput = tokenizer.tokenize(fileContents, textOffset, textLength, initialParenDepth);\n        this._tokenIndex = 0;\n    }\n    // stmt: simple_stmt | compound_stmt\n    // compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt\n    //   | funcdef | classdef | decorated | async_stmt\n    _parseStatement() {\n        // Handle the errant condition of a dedent token here to provide\n        // better recovery.\n        if (this._consumeTokenIfType(4 /* Dedent */)) {\n            this._addError(localize_1.Localizer.Diagnostic.unexpectedUnindent(), this._peekToken());\n        }\n        switch (this._peekKeywordType()) {\n            case 19 /* If */:\n                return this._parseIfStatement();\n            case 33 /* While */:\n                return this._parseWhileStatement();\n            case 16 /* For */:\n                return this._parseForStatement();\n            case 32 /* Try */:\n                return this._parseTryStatement();\n            case 34 /* With */:\n                return this._parseWithStatement();\n            case 9 /* Def */:\n                return this._parseFunctionDef();\n            case 6 /* Class */:\n                return this._parseClassDef();\n            case 3 /* Async */:\n                return this._parseAsyncStatement();\n        }\n        if (this._peekOperatorType() === 22 /* MatrixMultiply */) {\n            return this._parseDecorated();\n        }\n        return this._parseSimpleStatement();\n    }\n    // async_stmt: 'async' (funcdef | with_stmt | for_stmt)\n    _parseAsyncStatement() {\n        const asyncToken = this._getKeywordToken(3 /* Async */);\n        switch (this._peekKeywordType()) {\n            case 9 /* Def */:\n                return this._parseFunctionDef(asyncToken);\n            case 34 /* With */:\n                return this._parseWithStatement(asyncToken);\n            case 16 /* For */:\n                return this._parseForStatement(asyncToken);\n        }\n        this._addError(localize_1.Localizer.Diagnostic.unexpectedAsyncToken(), asyncToken);\n        return undefined;\n    }\n    // if_stmt: 'if' test_suite ('elif' test_suite)* ['else' suite]\n    // test_suite: test suite\n    // test: or_test ['if' or_test 'else' test] | lambdef\n    _parseIfStatement(keywordType = 19 /* If */) {\n        const ifOrElifToken = this._getKeywordToken(keywordType);\n        const test = this._parseTestExpression(true);\n        const suite = this._parseSuite(this._isInFunction);\n        const ifNode = parseNodes_1.IfNode.create(ifOrElifToken, test, suite);\n        if (this._consumeTokenIfKeyword(12 /* Else */)) {\n            ifNode.elseSuite = this._parseSuite(this._isInFunction);\n            ifNode.elseSuite.parent = ifNode;\n            parseNodes_1.extendRange(ifNode, ifNode.elseSuite);\n        }\n        else if (this._peekKeywordType() === 11 /* Elif */) {\n            // Recursively handle an \"elif\" statement.\n            ifNode.elseSuite = this._parseIfStatement(11 /* Elif */);\n            ifNode.elseSuite.parent = ifNode;\n            parseNodes_1.extendRange(ifNode, ifNode.elseSuite);\n        }\n        return ifNode;\n    }\n    _parseLoopSuite() {\n        const wasInLoop = this._isInLoop;\n        const wasInFinally = this._isInFinally;\n        this._isInLoop = true;\n        this._isInFinally = false;\n        const suite = this._parseSuite(this._isInFunction);\n        this._isInLoop = wasInLoop;\n        this._isInFinally = wasInFinally;\n        return suite;\n    }\n    // suite: ':' (simple_stmt | NEWLINE INDENT stmt+ DEDENT)\n    _parseSuite(isFunction = false) {\n        const nextToken = this._peekToken();\n        const suite = parseNodes_1.SuiteNode.create(nextToken);\n        if (!this._consumeTokenIfType(10 /* Colon */)) {\n            this._addError(localize_1.Localizer.Diagnostic.expectedColon(), nextToken);\n            // Try to perform parse recovery by consuming tokens until\n            // we find the end of the line.\n            if (this._consumeTokensUntilType([2 /* NewLine */, 10 /* Colon */])) {\n                this._getNextToken();\n            }\n        }\n        const wasFunction = this._isInFunction;\n        this._isInFunction = isFunction;\n        if (this._consumeTokenIfType(2 /* NewLine */)) {\n            const possibleIndent = this._peekToken();\n            if (!this._consumeTokenIfType(3 /* Indent */)) {\n                this._addError(localize_1.Localizer.Diagnostic.expectedIndentedBlock(), this._peekToken());\n            }\n            else {\n                const indentToken = possibleIndent;\n                if (indentToken.isIndentAmbiguous) {\n                    this._addError(localize_1.Localizer.Diagnostic.inconsistentTabs(), indentToken);\n                }\n            }\n            while (true) {\n                // Handle a common error here and see if we can recover.\n                const nextToken = this._peekToken();\n                if (nextToken.type === 3 /* Indent */) {\n                    this._getNextToken();\n                    const indentToken = nextToken;\n                    if (indentToken.isIndentAmbiguous) {\n                        this._addError(localize_1.Localizer.Diagnostic.inconsistentTabs(), indentToken);\n                    }\n                    else {\n                        this._addError(localize_1.Localizer.Diagnostic.unexpectedIndent(), nextToken);\n                    }\n                }\n                const statement = this._parseStatement();\n                if (!statement) {\n                    // Perform basic error recovery to get to the next line.\n                    this._consumeTokensUntilType([2 /* NewLine */]);\n                }\n                else {\n                    statement.parent = suite;\n                    suite.statements.push(statement);\n                }\n                const dedentToken = this._peekToken();\n                if (this._consumeTokenIfType(4 /* Dedent */)) {\n                    if (!dedentToken.matchesIndent) {\n                        this._addError(localize_1.Localizer.Diagnostic.inconsistentIndent(), dedentToken);\n                    }\n                    break;\n                }\n                if (this._peekTokenType() === 1 /* EndOfStream */) {\n                    break;\n                }\n            }\n        }\n        else {\n            const simpleStatement = this._parseSimpleStatement();\n            suite.statements.push(simpleStatement);\n            simpleStatement.parent = suite;\n        }\n        if (suite.statements.length > 0) {\n            parseNodes_1.extendRange(suite, suite.statements[suite.statements.length - 1]);\n        }\n        this._isInFunction = wasFunction;\n        return suite;\n    }\n    // for_stmt: [async] 'for' exprlist 'in' testlist suite ['else' suite]\n    _parseForStatement(asyncToken) {\n        const forToken = this._getKeywordToken(16 /* For */);\n        const exprListResult = this._parseExpressionList(true);\n        const targetExpr = this._makeExpressionOrTuple(exprListResult, /* enclosedInParens */ false);\n        let seqExpr;\n        let forSuite;\n        let elseSuite;\n        if (!this._consumeTokenIfKeyword(21 /* In */)) {\n            seqExpr = this._handleExpressionParseError(0 /* MissingIn */, localize_1.Localizer.Diagnostic.expectedIn());\n            forSuite = parseNodes_1.SuiteNode.create(this._peekToken());\n        }\n        else {\n            seqExpr = this._parseTestListAsExpression(2 /* MissingExpression */, localize_1.Localizer.Diagnostic.expectedInExpr());\n            forSuite = this._parseLoopSuite();\n            if (this._consumeTokenIfKeyword(12 /* Else */)) {\n                elseSuite = this._parseSuite(this._isInFunction);\n            }\n        }\n        const forNode = parseNodes_1.ForNode.create(forToken, targetExpr, seqExpr, forSuite);\n        forNode.elseSuite = elseSuite;\n        if (elseSuite) {\n            parseNodes_1.extendRange(forNode, elseSuite);\n            elseSuite.parent = forNode;\n        }\n        if (asyncToken) {\n            forNode.isAsync = true;\n            parseNodes_1.extendRange(forNode, asyncToken);\n        }\n        return forNode;\n    }\n    // comp_iter: comp_for | comp_if\n    _tryParseListComprehension(target) {\n        const compFor = this._tryParseCompForStatement();\n        if (!compFor) {\n            return undefined;\n        }\n        const listCompNode = parseNodes_1.ListComprehensionNode.create(target);\n        const compList = [compFor];\n        while (true) {\n            const compIter = this._tryParseCompForStatement() || this._tryParseCompIfStatement();\n            if (!compIter) {\n                break;\n            }\n            compIter.parent = listCompNode;\n            compList.push(compIter);\n        }\n        listCompNode.comprehensions = compList;\n        if (compList.length > 0) {\n            compList.forEach((comp) => {\n                comp.parent = listCompNode;\n            });\n            parseNodes_1.extendRange(listCompNode, compList[compList.length - 1]);\n        }\n        return listCompNode;\n    }\n    // comp_for: ['async'] 'for' exprlist 'in' or_test [comp_iter]\n    _tryParseCompForStatement() {\n        const startTokenKeywordType = this._peekKeywordType();\n        if (startTokenKeywordType === 3 /* Async */) {\n            const nextToken = this._peekToken(1);\n            if (nextToken.type !== 8 /* Keyword */ || nextToken.keywordType !== 16 /* For */) {\n                return undefined;\n            }\n        }\n        else if (startTokenKeywordType !== 16 /* For */) {\n            return undefined;\n        }\n        let asyncToken;\n        if (this._peekKeywordType() === 3 /* Async */) {\n            asyncToken = this._getKeywordToken(3 /* Async */);\n        }\n        const forToken = this._getKeywordToken(16 /* For */);\n        const exprListResult = this._parseExpressionList(true);\n        const targetExpr = this._makeExpressionOrTuple(exprListResult, /* enclosedInParens */ false);\n        let seqExpr;\n        if (!this._consumeTokenIfKeyword(21 /* In */)) {\n            seqExpr = this._handleExpressionParseError(0 /* MissingIn */, localize_1.Localizer.Diagnostic.expectedIn());\n        }\n        else {\n            this._disallowAssignmentExpression(() => {\n                seqExpr = this._parseOrTest();\n            });\n        }\n        const compForNode = parseNodes_1.ListComprehensionForNode.create(asyncToken || forToken, targetExpr, seqExpr);\n        if (asyncToken) {\n            compForNode.isAsync = true;\n        }\n        return compForNode;\n    }\n    // comp_if: 'if' test_nocond [comp_iter]\n    // comp_iter: comp_for | comp_if\n    _tryParseCompIfStatement() {\n        if (this._peekKeywordType() !== 19 /* If */) {\n            return undefined;\n        }\n        const ifToken = this._getKeywordToken(19 /* If */);\n        const ifExpr = this._tryParseLambdaExpression() || this._parseAssignmentExpression();\n        const compIfNode = parseNodes_1.ListComprehensionIfNode.create(ifToken, ifExpr);\n        return compIfNode;\n    }\n    // while_stmt: 'while' test suite ['else' suite]\n    _parseWhileStatement() {\n        const whileToken = this._getKeywordToken(33 /* While */);\n        const whileNode = parseNodes_1.WhileNode.create(whileToken, this._parseTestExpression(true), this._parseLoopSuite());\n        if (this._consumeTokenIfKeyword(12 /* Else */)) {\n            whileNode.elseSuite = this._parseSuite(this._isInFunction);\n            whileNode.elseSuite.parent = whileNode;\n            parseNodes_1.extendRange(whileNode, whileNode.elseSuite);\n        }\n        return whileNode;\n    }\n    // try_stmt: ('try' suite\n    //         ((except_clause suite)+\n    //             ['else' suite]\n    //             ['finally' suite] |\n    //         'finally' suite))\n    // except_clause: 'except' [test ['as' NAME]]\n    _parseTryStatement() {\n        const tryToken = this._getKeywordToken(32 /* Try */);\n        const trySuite = this._parseSuite(this._isInFunction);\n        const tryNode = parseNodes_1.TryNode.create(tryToken, trySuite);\n        let sawCatchAllExcept = false;\n        while (true) {\n            const exceptToken = this._peekToken();\n            if (!this._consumeTokenIfKeyword(13 /* Except */)) {\n                break;\n            }\n            let typeExpr;\n            let symbolName;\n            if (this._peekTokenType() !== 10 /* Colon */) {\n                typeExpr = this._parseTestExpression(true);\n                if (this._consumeTokenIfKeyword(1 /* As */)) {\n                    symbolName = this._getTokenIfIdentifier();\n                    if (!symbolName) {\n                        this._addError(localize_1.Localizer.Diagnostic.expectedNameAfterAs(), this._peekToken());\n                    }\n                }\n                else {\n                    // Handle the python 2.x syntax in a graceful manner.\n                    const peekToken = this._peekToken();\n                    if (this._consumeTokenIfType(12 /* Comma */)) {\n                        this._addError(localize_1.Localizer.Diagnostic.expectedAsAfterException(), peekToken);\n                        // Parse the expression expected in python 2.x, but discard it.\n                        this._parseTestExpression(false);\n                    }\n                }\n            }\n            if (!typeExpr) {\n                if (sawCatchAllExcept) {\n                    this._addError(localize_1.Localizer.Diagnostic.duplicateCatchAll(), exceptToken);\n                }\n                sawCatchAllExcept = true;\n            }\n            else {\n                if (sawCatchAllExcept) {\n                    this._addError(localize_1.Localizer.Diagnostic.namedExceptAfterCatchAll(), typeExpr);\n                }\n            }\n            const exceptSuite = this._parseSuite(this._isInFunction);\n            const exceptNode = parseNodes_1.ExceptNode.create(exceptToken, exceptSuite);\n            if (typeExpr) {\n                exceptNode.typeExpression = typeExpr;\n                exceptNode.typeExpression.parent = exceptNode;\n            }\n            if (symbolName) {\n                exceptNode.name = parseNodes_1.NameNode.create(symbolName);\n                exceptNode.name.parent = exceptNode;\n            }\n            tryNode.exceptClauses.push(exceptNode);\n            exceptNode.parent = tryNode;\n        }\n        if (tryNode.exceptClauses.length > 0) {\n            parseNodes_1.extendRange(tryNode, tryNode.exceptClauses[tryNode.exceptClauses.length - 1]);\n            if (this._consumeTokenIfKeyword(12 /* Else */)) {\n                tryNode.elseSuite = this._parseSuite(this._isInFunction);\n                tryNode.elseSuite.parent = tryNode;\n                parseNodes_1.extendRange(tryNode, tryNode.elseSuite);\n            }\n        }\n        if (this._consumeTokenIfKeyword(15 /* Finally */)) {\n            tryNode.finallySuite = this._parseSuite(this._isInFunction);\n            tryNode.finallySuite.parent = tryNode;\n            parseNodes_1.extendRange(tryNode, tryNode.finallySuite);\n        }\n        return tryNode;\n    }\n    // funcdef: 'def' NAME parameters ['->' test] ':' suite\n    // parameters: '(' [typedargslist] ')'\n    _parseFunctionDef(asyncToken, decorators) {\n        const defToken = this._getKeywordToken(9 /* Def */);\n        const nameToken = this._getTokenIfIdentifier();\n        if (!nameToken) {\n            this._addError(localize_1.Localizer.Diagnostic.expectedFunctionName(), defToken);\n            return parseNodes_1.ErrorNode.create(defToken, 10 /* MissingFunctionParameterList */);\n        }\n        if (!this._consumeTokenIfType(13 /* OpenParenthesis */)) {\n            this._addError(localize_1.Localizer.Diagnostic.expectedOpenParen(), this._peekToken());\n            return parseNodes_1.ErrorNode.create(nameToken, 10 /* MissingFunctionParameterList */, parseNodes_1.NameNode.create(nameToken));\n        }\n        const paramList = this._parseVarArgsList(14 /* CloseParenthesis */, true);\n        if (!this._consumeTokenIfType(14 /* CloseParenthesis */)) {\n            this._addError(localize_1.Localizer.Diagnostic.expectedCloseParen(), this._peekToken());\n            this._consumeTokensUntilType([10 /* Colon */]);\n        }\n        let returnType;\n        if (this._consumeTokenIfType(21 /* Arrow */)) {\n            returnType = this._parseTypeAnnotation();\n        }\n        const suite = this._parseSuite(true);\n        const functionNode = parseNodes_1.FunctionNode.create(defToken, parseNodes_1.NameNode.create(nameToken), suite);\n        if (asyncToken) {\n            functionNode.isAsync = true;\n            parseNodes_1.extendRange(functionNode, asyncToken);\n        }\n        functionNode.parameters = paramList;\n        paramList.forEach((param) => {\n            param.parent = functionNode;\n        });\n        if (decorators) {\n            functionNode.decorators = decorators;\n            decorators.forEach((decorator) => {\n                decorator.parent = functionNode;\n            });\n            if (decorators.length > 0) {\n                parseNodes_1.extendRange(functionNode, decorators[0]);\n            }\n        }\n        if (returnType) {\n            functionNode.returnTypeAnnotation = returnType;\n            functionNode.returnTypeAnnotation.parent = functionNode;\n            parseNodes_1.extendRange(functionNode, returnType);\n        }\n        return functionNode;\n    }\n    // typedargslist: (\n    //   tfpdef ['=' test] (',' tfpdef ['=' test])*\n    //      [ ','\n    //          [\n    //              '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n    //              | '**' tfpdef [',']\n    //          ]\n    //      ]\n    //   | '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n    //   | '**' tfpdef [','])\n    // tfpdef: NAME [':' test]\n    // vfpdef: NAME;\n    _parseVarArgsList(terminator, allowAnnotations) {\n        const paramMap = new Map();\n        const paramList = [];\n        let sawDefaultParam = false;\n        let reportedNonDefaultParamErr = false;\n        let sawKwSeparator = false;\n        let sawPositionOnlySeparator = false;\n        let sawVarArgs = false;\n        let sawKwArgs = false;\n        while (true) {\n            if (this._peekTokenType() === terminator) {\n                break;\n            }\n            const param = this._parseParameter(allowAnnotations);\n            if (!param) {\n                this._consumeTokensUntilType([terminator]);\n                break;\n            }\n            if (param.name) {\n                const name = param.name.value;\n                if (paramMap.has(name)) {\n                    this._addError(localize_1.Localizer.Diagnostic.duplicateParam().format({ name }), param.name);\n                }\n                else {\n                    paramMap.set(name, name);\n                }\n            }\n            if (param.category === 0 /* Simple */) {\n                if (!param.name) {\n                    if (sawPositionOnlySeparator) {\n                        this._addError(localize_1.Localizer.Diagnostic.duplicatePositionOnly(), param);\n                    }\n                    else if (sawKwSeparator) {\n                        this._addError(localize_1.Localizer.Diagnostic.positionOnlyAfterNameOnly(), param);\n                    }\n                    sawPositionOnlySeparator = true;\n                }\n                else {\n                    if (param.defaultValue) {\n                        sawDefaultParam = true;\n                    }\n                    else if (sawDefaultParam && !sawKwSeparator && !sawVarArgs) {\n                        // Report this error only once.\n                        if (!reportedNonDefaultParamErr) {\n                            this._addError(localize_1.Localizer.Diagnostic.nonDefaultAfterDefault(), param);\n                            reportedNonDefaultParamErr = true;\n                        }\n                    }\n                }\n            }\n            paramList.push(param);\n            if (param.category === 1 /* VarArgList */) {\n                if (!param.name) {\n                    if (sawKwSeparator) {\n                        this._addError(localize_1.Localizer.Diagnostic.duplicateNameOnly(), param);\n                    }\n                    sawKwSeparator = true;\n                }\n                else {\n                    if (sawVarArgs) {\n                        this._addError(localize_1.Localizer.Diagnostic.duplicateArgsParam(), param);\n                    }\n                    sawVarArgs = true;\n                }\n            }\n            if (param.category === 2 /* VarArgDictionary */) {\n                if (sawKwArgs) {\n                    this._addError(localize_1.Localizer.Diagnostic.duplicateKwargsParam(), param);\n                }\n                sawKwArgs = true;\n            }\n            else if (sawKwArgs) {\n                this._addError(localize_1.Localizer.Diagnostic.paramAfterKwargsParam(), param);\n            }\n            if (!this._consumeTokenIfType(12 /* Comma */)) {\n                break;\n            }\n        }\n        if (paramList.length > 0) {\n            const lastParam = paramList[paramList.length - 1];\n            if (lastParam.category === 1 /* VarArgList */ && !lastParam.name) {\n                this._addError(localize_1.Localizer.Diagnostic.expectedNamedArgument(), lastParam);\n            }\n        }\n        return paramList;\n    }\n    _parseParameter(allowAnnotations) {\n        let starCount = 0;\n        let slashCount = 0;\n        const firstToken = this._peekToken();\n        if (this._consumeTokenIfOperator(26 /* Multiply */)) {\n            starCount = 1;\n        }\n        else if (this._consumeTokenIfOperator(29 /* Power */)) {\n            starCount = 2;\n        }\n        else if (this._consumeTokenIfOperator(10 /* Divide */)) {\n            if (this._getLanguageVersion() < pythonVersion_1.PythonVersion.V3_8) {\n                this._addError(localize_1.Localizer.Diagnostic.positionOnlyIncompatible(), firstToken);\n            }\n            slashCount = 1;\n        }\n        const paramName = this._getTokenIfIdentifier();\n        if (!paramName) {\n            if (starCount === 1) {\n                const paramNode = parseNodes_1.ParameterNode.create(firstToken, 1 /* VarArgList */);\n                return paramNode;\n            }\n            else if (slashCount === 1) {\n                const paramNode = parseNodes_1.ParameterNode.create(firstToken, 0 /* Simple */);\n                return paramNode;\n            }\n            // Check for the Python 2.x parameter sublist syntax and handle it gracefully.\n            if (this._peekTokenType() === 13 /* OpenParenthesis */) {\n                const sublistStart = this._getNextToken();\n                if (this._consumeTokensUntilType([14 /* CloseParenthesis */])) {\n                    this._getNextToken();\n                }\n                this._addError(localize_1.Localizer.Diagnostic.sublistParamsIncompatible(), sublistStart);\n            }\n            else {\n                this._addError(localize_1.Localizer.Diagnostic.expectedParamName(), this._peekToken());\n            }\n        }\n        let paramType = 0 /* Simple */;\n        if (starCount === 1) {\n            paramType = 1 /* VarArgList */;\n        }\n        else if (starCount === 2) {\n            paramType = 2 /* VarArgDictionary */;\n        }\n        const paramNode = parseNodes_1.ParameterNode.create(firstToken, paramType);\n        if (paramName) {\n            paramNode.name = parseNodes_1.NameNode.create(paramName);\n            paramNode.name.parent = paramNode;\n            parseNodes_1.extendRange(paramNode, paramName);\n        }\n        if (allowAnnotations && this._consumeTokenIfType(10 /* Colon */)) {\n            paramNode.typeAnnotation = this._parseTypeAnnotation();\n            paramNode.typeAnnotation.parent = paramNode;\n            parseNodes_1.extendRange(paramNode, paramNode.typeAnnotation);\n        }\n        if (this._consumeTokenIfOperator(2 /* Assign */)) {\n            paramNode.defaultValue = this._parseTestExpression(false);\n            paramNode.defaultValue.parent = paramNode;\n            parseNodes_1.extendRange(paramNode, paramNode.defaultValue);\n            if (starCount > 0) {\n                this._addError(localize_1.Localizer.Diagnostic.defaultValueNotAllowed(), paramNode.defaultValue);\n            }\n        }\n        return paramNode;\n    }\n    // with_stmt: 'with' with_item (',' with_item)*  ':' suite\n    _parseWithStatement(asyncToken) {\n        const withToken = this._getKeywordToken(34 /* With */);\n        const withItemList = [];\n        while (true) {\n            withItemList.push(this._parseWithItem());\n            if (!this._consumeTokenIfType(12 /* Comma */)) {\n                break;\n            }\n        }\n        const withSuite = this._parseSuite(this._isInFunction);\n        const withNode = parseNodes_1.WithNode.create(withToken, withSuite);\n        if (asyncToken) {\n            withNode.isAsync = true;\n            parseNodes_1.extendRange(withNode, asyncToken);\n        }\n        withNode.withItems = withItemList;\n        withItemList.forEach((withItem) => {\n            withItem.parent = withNode;\n        });\n        return withNode;\n    }\n    // with_item: test ['as' expr]\n    _parseWithItem() {\n        const expr = this._parseTestExpression(true);\n        const itemNode = parseNodes_1.WithItemNode.create(expr);\n        if (this._consumeTokenIfKeyword(1 /* As */)) {\n            itemNode.target = this._parseExpression(false);\n            itemNode.target.parent = itemNode;\n            parseNodes_1.extendRange(itemNode, itemNode.target);\n        }\n        return itemNode;\n    }\n    // decorators: decorator+\n    // decorated: decorators (classdef | funcdef | async_funcdef)\n    _parseDecorated() {\n        const decoratorList = [];\n        while (true) {\n            if (this._peekOperatorType() === 22 /* MatrixMultiply */) {\n                decoratorList.push(this._parseDecorator());\n            }\n            else {\n                break;\n            }\n        }\n        const nextToken = this._peekToken();\n        if (nextToken.type === 8 /* Keyword */) {\n            if (nextToken.keywordType === 3 /* Async */) {\n                this._getNextToken();\n                if (this._peekKeywordType() !== 9 /* Def */) {\n                    this._addError(localize_1.Localizer.Diagnostic.expectedFunctionAfterAsync(), this._peekToken());\n                }\n                else {\n                    return this._parseFunctionDef(nextToken, decoratorList);\n                }\n            }\n            else if (nextToken.keywordType === 9 /* Def */) {\n                return this._parseFunctionDef(undefined, decoratorList);\n            }\n            else if (nextToken.keywordType === 6 /* Class */) {\n                return this._parseClassDef(decoratorList);\n            }\n        }\n        this._addError(localize_1.Localizer.Diagnostic.expectedAfterDecorator(), this._peekToken());\n        // Return a dummy class declaration so the completion provider has\n        // some parse nodes to work with.\n        return parseNodes_1.ClassNode.createDummyForDecorators(decoratorList);\n    }\n    // decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE\n    _parseDecorator() {\n        const atOperator = this._getNextToken();\n        debug_1.assert(atOperator.operatorType === 22 /* MatrixMultiply */);\n        let callNameExpr;\n        while (true) {\n            const namePart = this._getTokenIfIdentifier();\n            if (!namePart) {\n                this._addError(localize_1.Localizer.Diagnostic.expectedDecoratorName(), this._peekToken());\n                if (callNameExpr) {\n                    callNameExpr = parseNodes_1.ErrorNode.create(this._peekToken(), 7 /* MissingMemberAccessName */, callNameExpr);\n                }\n                else {\n                    callNameExpr = parseNodes_1.ErrorNode.create(this._peekToken(), 4 /* MissingDecoratorCallName */);\n                }\n                break;\n            }\n            const namePartNode = parseNodes_1.NameNode.create(namePart);\n            if (!callNameExpr) {\n                callNameExpr = namePartNode;\n            }\n            else {\n                callNameExpr = parseNodes_1.MemberAccessNode.create(callNameExpr, namePartNode);\n            }\n            if (!this._consumeTokenIfType(20 /* Dot */)) {\n                break;\n            }\n        }\n        const decoratorNode = parseNodes_1.DecoratorNode.create(atOperator, callNameExpr);\n        if (this._consumeTokenIfType(13 /* OpenParenthesis */)) {\n            decoratorNode.arguments = this._parseArgList();\n            decoratorNode.arguments.forEach((arg) => {\n                arg.parent = decoratorNode;\n                parseNodes_1.extendRange(decoratorNode, arg);\n            });\n            const nextToken = this._peekToken();\n            if (!this._consumeTokenIfType(14 /* CloseParenthesis */)) {\n                this._addError(localize_1.Localizer.Diagnostic.expectedCloseParen(), this._peekToken());\n            }\n            else {\n                parseNodes_1.extendRange(decoratorNode, nextToken);\n            }\n        }\n        if (!this._consumeTokenIfType(2 /* NewLine */)) {\n            this._addError(localize_1.Localizer.Diagnostic.expectedDecoratorNewline(), this._peekToken());\n            this._consumeTokensUntilType([2 /* NewLine */]);\n        }\n        return decoratorNode;\n    }\n    // classdef: 'class' NAME ['(' [arglist] ')'] suite\n    _parseClassDef(decorators) {\n        const classToken = this._getKeywordToken(6 /* Class */);\n        let nameToken = this._getTokenIfIdentifier();\n        if (!nameToken) {\n            this._addError(localize_1.Localizer.Diagnostic.expectedClassName(), this._peekToken());\n            nameToken = tokenizerTypes_1.IdentifierToken.create(0, 0, '', undefined);\n        }\n        let argList = [];\n        if (this._consumeTokenIfType(13 /* OpenParenthesis */)) {\n            argList = this._parseArgList();\n            if (!this._consumeTokenIfType(14 /* CloseParenthesis */)) {\n                this._addError(localize_1.Localizer.Diagnostic.expectedCloseParen(), this._peekToken());\n            }\n        }\n        const suite = this._parseSuite(false);\n        const classNode = parseNodes_1.ClassNode.create(classToken, parseNodes_1.NameNode.create(nameToken), suite);\n        classNode.arguments = argList;\n        argList.forEach((arg) => {\n            arg.parent = classNode;\n        });\n        if (decorators) {\n            classNode.decorators = decorators;\n            if (decorators.length > 0) {\n                decorators.forEach((decorator) => {\n                    decorator.parent = classNode;\n                });\n                parseNodes_1.extendRange(classNode, decorators[0]);\n            }\n        }\n        return classNode;\n    }\n    _parsePassStatement() {\n        return parseNodes_1.PassNode.create(this._getKeywordToken(28 /* Pass */));\n    }\n    _parseBreakStatement() {\n        const breakToken = this._getKeywordToken(5 /* Break */);\n        if (!this._isInLoop) {\n            this._addError(localize_1.Localizer.Diagnostic.breakOutsideLoop(), breakToken);\n        }\n        return parseNodes_1.BreakNode.create(breakToken);\n    }\n    _parseContinueStatement() {\n        const continueToken = this._getKeywordToken(7 /* Continue */);\n        if (!this._isInLoop) {\n            this._addError(localize_1.Localizer.Diagnostic.continueOutsideLoop(), continueToken);\n        }\n        else if (this._isInFinally) {\n            this._addError(localize_1.Localizer.Diagnostic.continueInFinally(), continueToken);\n        }\n        return parseNodes_1.ContinueNode.create(continueToken);\n    }\n    // return_stmt: 'return' [testlist]\n    _parseReturnStatement() {\n        const returnToken = this._getKeywordToken(30 /* Return */);\n        const returnNode = parseNodes_1.ReturnNode.create(returnToken);\n        if (!this._isInFunction) {\n            this._addError(localize_1.Localizer.Diagnostic.returnOutsideFunction(), returnToken);\n        }\n        if (!this._isNextTokenNeverExpression()) {\n            const returnExpr = this._parseTestOrStarListAsExpression(\n            /* allowAssignmentExpression */ true, 2 /* MissingExpression */, localize_1.Localizer.Diagnostic.expectedReturnExpr());\n            this._reportConditionalErrorForStarTupleElement(returnExpr);\n            returnNode.returnExpression = returnExpr;\n            returnNode.returnExpression.parent = returnNode;\n            parseNodes_1.extendRange(returnNode, returnExpr);\n        }\n        return returnNode;\n    }\n    // import_from: ('from' (('.' | '...')* dotted_name | ('.' | '...')+)\n    //             'import' ('*' | '(' import_as_names ')' | import_as_names))\n    // import_as_names: import_as_name (',' import_as_name)* [',']\n    // import_as_name: NAME ['as' NAME]\n    _parseFromStatement() {\n        const fromToken = this._getKeywordToken(17 /* From */);\n        const modName = this._parseDottedModuleName(true);\n        const importFromNode = parseNodes_1.ImportFromNode.create(fromToken, modName);\n        // Handle imports from __future__ specially because they can\n        // change the way we interpret the rest of the file.\n        const isFutureImport = modName.leadingDots === 0 && modName.nameParts.length === 1 && modName.nameParts[0].value === '__future__';\n        const possibleInputToken = this._peekToken();\n        if (!this._consumeTokenIfKeyword(20 /* Import */)) {\n            this._addError(localize_1.Localizer.Diagnostic.expectedImport(), this._peekToken());\n            if (!modName.hasTrailingDot) {\n                importFromNode.missingImportKeyword = true;\n            }\n        }\n        else {\n            parseNodes_1.extendRange(importFromNode, possibleInputToken);\n            // Look for \"*\" token.\n            const possibleStarToken = this._peekToken();\n            if (this._consumeTokenIfOperator(26 /* Multiply */)) {\n                parseNodes_1.extendRange(importFromNode, possibleStarToken);\n                importFromNode.isWildcardImport = true;\n                this._containsWildcardImport = true;\n            }\n            else {\n                const inParen = this._consumeTokenIfType(13 /* OpenParenthesis */);\n                while (true) {\n                    const importName = this._getTokenIfIdentifier();\n                    if (!importName) {\n                        break;\n                    }\n                    const importFromAsNode = parseNodes_1.ImportFromAsNode.create(parseNodes_1.NameNode.create(importName));\n                    if (this._consumeTokenIfKeyword(1 /* As */)) {\n                        const aliasName = this._getTokenIfIdentifier();\n                        if (!aliasName) {\n                            this._addError(localize_1.Localizer.Diagnostic.expectedImportAlias(), this._peekToken());\n                        }\n                        else {\n                            importFromAsNode.alias = parseNodes_1.NameNode.create(aliasName);\n                            importFromAsNode.alias.parent = importFromAsNode;\n                            parseNodes_1.extendRange(importFromAsNode, aliasName);\n                        }\n                    }\n                    importFromNode.imports.push(importFromAsNode);\n                    importFromAsNode.parent = importFromNode;\n                    parseNodes_1.extendRange(importFromNode, importFromAsNode);\n                    if (isFutureImport) {\n                        // Add the future import to the map.\n                        this._futureImportMap.set(importName.value, true);\n                    }\n                    if (!this._consumeTokenIfType(12 /* Comma */)) {\n                        break;\n                    }\n                }\n                if (importFromNode.imports.length === 0) {\n                    this._addError(localize_1.Localizer.Diagnostic.expectedImportSymbols(), this._peekToken());\n                }\n                if (inParen) {\n                    importFromNode.usesParens = true;\n                    const nextToken = this._peekToken();\n                    if (!this._consumeTokenIfType(14 /* CloseParenthesis */)) {\n                        this._addError(localize_1.Localizer.Diagnostic.expectedCloseParen(), this._peekToken());\n                    }\n                    else {\n                        parseNodes_1.extendRange(importFromNode, nextToken);\n                    }\n                }\n            }\n        }\n        this._importedModules.push({\n            nameNode: importFromNode.module,\n            leadingDots: importFromNode.module.leadingDots,\n            nameParts: importFromNode.module.nameParts.map((p) => p.value),\n            importedSymbols: importFromNode.imports.map((imp) => imp.name.value),\n        });\n        return importFromNode;\n    }\n    // import_name: 'import' dotted_as_names\n    // dotted_as_names: dotted_as_name (',' dotted_as_name)*\n    // dotted_as_name: dotted_name ['as' NAME]\n    _parseImportStatement() {\n        const importToken = this._getKeywordToken(20 /* Import */);\n        const importNode = parseNodes_1.ImportNode.create(importToken);\n        while (true) {\n            const modName = this._parseDottedModuleName();\n            const importAsNode = parseNodes_1.ImportAsNode.create(modName);\n            if (this._consumeTokenIfKeyword(1 /* As */)) {\n                const aliasToken = this._getTokenIfIdentifier();\n                if (aliasToken) {\n                    importAsNode.alias = parseNodes_1.NameNode.create(aliasToken);\n                    importAsNode.alias.parent = importAsNode;\n                    parseNodes_1.extendRange(importAsNode, importAsNode.alias);\n                }\n                else {\n                    this._addError(localize_1.Localizer.Diagnostic.expectedImportAlias(), this._peekToken());\n                }\n            }\n            if (importAsNode.module.leadingDots > 0) {\n                this._addError(localize_1.Localizer.Diagnostic.relativeImportNotAllowed(), importAsNode.module);\n            }\n            importNode.list.push(importAsNode);\n            importAsNode.parent = importNode;\n            this._importedModules.push({\n                nameNode: importAsNode.module,\n                leadingDots: importAsNode.module.leadingDots,\n                nameParts: importAsNode.module.nameParts.map((p) => p.value),\n                importedSymbols: undefined,\n            });\n            if (!this._consumeTokenIfType(12 /* Comma */)) {\n                break;\n            }\n        }\n        if (importNode.list.length > 0) {\n            parseNodes_1.extendRange(importNode, importNode.list[importNode.list.length - 1]);\n        }\n        return importNode;\n    }\n    // ('.' | '...')* dotted_name | ('.' | '...')+\n    // dotted_name: NAME ('.' NAME)*\n    _parseDottedModuleName(allowJustDots = false) {\n        const moduleNameNode = parseNodes_1.ModuleNameNode.create(this._peekToken());\n        while (true) {\n            if (this._consumeTokenIfType(19 /* Ellipsis */)) {\n                moduleNameNode.leadingDots += 3;\n            }\n            else if (this._consumeTokenIfType(20 /* Dot */)) {\n                moduleNameNode.leadingDots++;\n            }\n            else {\n                break;\n            }\n        }\n        while (true) {\n            const identifier = this._getTokenIfIdentifier([20 /* Import */]);\n            if (!identifier) {\n                if (!allowJustDots || moduleNameNode.leadingDots === 0) {\n                    this._addError(localize_1.Localizer.Diagnostic.expectedModuleName(), this._peekToken());\n                    moduleNameNode.hasTrailingDot = true;\n                }\n                break;\n            }\n            const namePart = parseNodes_1.NameNode.create(identifier);\n            moduleNameNode.nameParts.push(namePart);\n            namePart.parent = moduleNameNode;\n            parseNodes_1.extendRange(moduleNameNode, namePart);\n            const nextToken = this._peekToken();\n            if (!this._consumeTokenIfType(20 /* Dot */)) {\n                break;\n            }\n            // Extend the module name to include the dot.\n            parseNodes_1.extendRange(moduleNameNode, nextToken);\n        }\n        return moduleNameNode;\n    }\n    _parseGlobalStatement() {\n        const globalToken = this._getKeywordToken(18 /* Global */);\n        const globalNode = parseNodes_1.GlobalNode.create(globalToken);\n        globalNode.nameList = this._parseNameList();\n        if (globalNode.nameList.length > 0) {\n            globalNode.nameList.forEach((name) => {\n                name.parent = globalNode;\n            });\n            parseNodes_1.extendRange(globalNode, globalNode.nameList[globalNode.nameList.length - 1]);\n        }\n        return globalNode;\n    }\n    _parseNonlocalStatement() {\n        const nonlocalToken = this._getKeywordToken(25 /* Nonlocal */);\n        const nonlocalNode = parseNodes_1.NonlocalNode.create(nonlocalToken);\n        nonlocalNode.nameList = this._parseNameList();\n        if (nonlocalNode.nameList.length > 0) {\n            nonlocalNode.nameList.forEach((name) => {\n                name.parent = nonlocalNode;\n            });\n            parseNodes_1.extendRange(nonlocalNode, nonlocalNode.nameList[nonlocalNode.nameList.length - 1]);\n        }\n        return nonlocalNode;\n    }\n    _parseNameList() {\n        const nameList = [];\n        while (true) {\n            const name = this._getTokenIfIdentifier();\n            if (!name) {\n                this._addError(localize_1.Localizer.Diagnostic.expectedIdentifier(), this._peekToken());\n                break;\n            }\n            nameList.push(parseNodes_1.NameNode.create(name));\n            if (!this._consumeTokenIfType(12 /* Comma */)) {\n                break;\n            }\n        }\n        return nameList;\n    }\n    // raise_stmt: 'raise' [test ['from' test]]\n    // (old) raise_stmt: 'raise' [test [',' test [',' test]]]\n    _parseRaiseStatement() {\n        const raiseToken = this._getKeywordToken(29 /* Raise */);\n        const raiseNode = parseNodes_1.RaiseNode.create(raiseToken);\n        if (!this._isNextTokenNeverExpression()) {\n            raiseNode.typeExpression = this._parseTestExpression(true);\n            raiseNode.typeExpression.parent = raiseNode;\n            parseNodes_1.extendRange(raiseNode, raiseNode.typeExpression);\n            if (this._consumeTokenIfKeyword(17 /* From */)) {\n                raiseNode.valueExpression = this._parseTestExpression(true);\n                raiseNode.valueExpression.parent = raiseNode;\n                parseNodes_1.extendRange(raiseNode, raiseNode.valueExpression);\n            }\n            else {\n                if (this._consumeTokenIfType(12 /* Comma */)) {\n                    // Handle the Python 2.x variant\n                    raiseNode.valueExpression = this._parseTestExpression(true);\n                    raiseNode.valueExpression.parent = raiseNode;\n                    parseNodes_1.extendRange(raiseNode, raiseNode.valueExpression);\n                    if (this._consumeTokenIfType(12 /* Comma */)) {\n                        raiseNode.tracebackExpression = this._parseTestExpression(true);\n                        raiseNode.tracebackExpression.parent = raiseNode;\n                        parseNodes_1.extendRange(raiseNode, raiseNode.tracebackExpression);\n                    }\n                }\n            }\n        }\n        return raiseNode;\n    }\n    // assert_stmt: 'assert' test [',' test]\n    _parseAssertStatement() {\n        const assertToken = this._getKeywordToken(2 /* Assert */);\n        const expr = this._parseTestExpression(true);\n        const assertNode = parseNodes_1.AssertNode.create(assertToken, expr);\n        if (this._consumeTokenIfType(12 /* Comma */)) {\n            const exceptionExpr = this._parseTestExpression(true);\n            assertNode.exceptionExpression = exceptionExpr;\n            assertNode.exceptionExpression.parent = assertNode;\n            parseNodes_1.extendRange(assertNode, exceptionExpr);\n        }\n        return assertNode;\n    }\n    // del_stmt: 'del' exprlist\n    _parseDelStatement() {\n        const delToken = this._getKeywordToken(10 /* Del */);\n        const exprListResult = this._parseExpressionList(true);\n        if (!exprListResult.parseError && exprListResult.list.length === 0) {\n            this._addError(localize_1.Localizer.Diagnostic.expectedDelExpr(), this._peekToken());\n        }\n        const delNode = parseNodes_1.DelNode.create(delToken);\n        delNode.expressions = exprListResult.list;\n        if (delNode.expressions.length > 0) {\n            delNode.expressions.forEach((expr) => {\n                expr.parent = delNode;\n            });\n            parseNodes_1.extendRange(delNode, delNode.expressions[delNode.expressions.length - 1]);\n        }\n        return delNode;\n    }\n    // yield_expr: 'yield' [yield_arg]\n    // yield_arg: 'from' test | testlist\n    _parseYieldExpression() {\n        const yieldToken = this._getKeywordToken(35 /* Yield */);\n        const nextToken = this._peekToken();\n        if (this._consumeTokenIfKeyword(17 /* From */)) {\n            if (this._getLanguageVersion() < pythonVersion_1.PythonVersion.V3_3) {\n                this._addError(localize_1.Localizer.Diagnostic.yieldFromIllegal(), nextToken);\n            }\n            return parseNodes_1.YieldFromNode.create(yieldToken, this._parseTestExpression(true));\n        }\n        let exprList;\n        if (!this._isNextTokenNeverExpression()) {\n            exprList = this._parseTestOrStarListAsExpression(\n            /* allowAssignmentExpression */ true, 2 /* MissingExpression */, localize_1.Localizer.Diagnostic.expectedYieldExpr());\n            this._reportConditionalErrorForStarTupleElement(exprList);\n        }\n        return parseNodes_1.YieldNode.create(yieldToken, exprList);\n    }\n    _tryParseYieldExpression() {\n        if (this._peekKeywordType() !== 35 /* Yield */) {\n            return undefined;\n        }\n        return this._parseYieldExpression();\n    }\n    // simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE\n    _parseSimpleStatement() {\n        const statement = parseNodes_1.StatementListNode.create(this._peekToken());\n        while (true) {\n            // Swallow invalid tokens to make sure we make forward progress.\n            if (this._peekTokenType() === 0 /* Invalid */) {\n                const invalidToken = this._getNextToken();\n                const text = this._fileContents.substr(invalidToken.start, invalidToken.length);\n                // Remove any non-printable characters.\n                const cleanedText = text.replace(/[\\S\\W]/g, '');\n                this._addError(localize_1.Localizer.Diagnostic.invalidTokenChars().format({ text: cleanedText }), invalidToken);\n                this._consumeTokensUntilType([2 /* NewLine */]);\n                break;\n            }\n            const smallStatement = this._parseSmallStatement();\n            statement.statements.push(smallStatement);\n            smallStatement.parent = statement;\n            parseNodes_1.extendRange(statement, smallStatement);\n            if (smallStatement.nodeType === 0 /* Error */) {\n                // No need to log an error here. We assume that\n                // it was already logged by _parseSmallStatement.\n                break;\n            }\n            // Consume the semicolon if present.\n            if (!this._consumeTokenIfType(11 /* Semicolon */)) {\n                break;\n            }\n            const nextTokenType = this._peekTokenType();\n            if (nextTokenType === 2 /* NewLine */ || nextTokenType === 1 /* EndOfStream */) {\n                break;\n            }\n        }\n        if (!this._consumeTokenIfType(2 /* NewLine */)) {\n            this._addError(localize_1.Localizer.Diagnostic.expectedNewlineOrSemicolon(), this._peekToken());\n        }\n        return statement;\n    }\n    // small_stmt: (expr_stmt | del_stmt | pass_stmt | flow_stmt |\n    //             import_stmt | global_stmt | nonlocal_stmt | assert_stmt)\n    // flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt\n    // import_stmt: import_name | import_from\n    _parseSmallStatement() {\n        switch (this._peekKeywordType()) {\n            case 28 /* Pass */:\n                return this._parsePassStatement();\n            case 5 /* Break */:\n                return this._parseBreakStatement();\n            case 7 /* Continue */:\n                return this._parseContinueStatement();\n            case 30 /* Return */:\n                return this._parseReturnStatement();\n            case 17 /* From */:\n                return this._parseFromStatement();\n            case 20 /* Import */:\n                return this._parseImportStatement();\n            case 18 /* Global */:\n                return this._parseGlobalStatement();\n            case 25 /* Nonlocal */:\n                return this._parseNonlocalStatement();\n            case 29 /* Raise */:\n                return this._parseRaiseStatement();\n            case 2 /* Assert */:\n                return this._parseAssertStatement();\n            case 10 /* Del */:\n                return this._parseDelStatement();\n            case 35 /* Yield */:\n                return this._parseYieldExpression();\n        }\n        return this._parseExpressionStatement();\n    }\n    _makeExpressionOrTuple(exprListResult, enclosedInParens) {\n        // A single-element tuple with no trailing comma is simply an expression\n        // that's surrounded by parens.\n        if (exprListResult.list.length === 1 && !exprListResult.trailingComma) {\n            return exprListResult.list[0];\n        }\n        // To accommodate empty tuples (\"()\"), we will reach back to get\n        // the opening parenthesis as the opening token.\n        const tupleStartRange = exprListResult.list.length > 0 ? exprListResult.list[0] : this._peekToken(-1);\n        const tupleNode = parseNodes_1.TupleNode.create(tupleStartRange, enclosedInParens);\n        tupleNode.expressions = exprListResult.list;\n        if (exprListResult.list.length > 0) {\n            exprListResult.list.forEach((expr) => {\n                expr.parent = tupleNode;\n            });\n            parseNodes_1.extendRange(tupleNode, exprListResult.list[exprListResult.list.length - 1]);\n        }\n        return tupleNode;\n    }\n    _parseTestListAsExpression(errorCategory, errorString) {\n        if (this._isNextTokenNeverExpression()) {\n            return this._handleExpressionParseError(errorCategory, errorString);\n        }\n        const exprListResult = this._parseTestExpressionList();\n        if (exprListResult.parseError) {\n            return exprListResult.parseError;\n        }\n        return this._makeExpressionOrTuple(exprListResult, /* enclosedInParens */ false);\n    }\n    _parseTestOrStarListAsExpression(allowAssignmentExpression, errorCategory, errorString) {\n        if (this._isNextTokenNeverExpression()) {\n            return this._handleExpressionParseError(errorCategory, errorString);\n        }\n        const exprListResult = this._parseTestOrStarExpressionList(allowAssignmentExpression);\n        if (exprListResult.parseError) {\n            return exprListResult.parseError;\n        }\n        return this._makeExpressionOrTuple(exprListResult, /* enclosedInParens */ false);\n    }\n    _parseExpressionList(allowStar) {\n        return this._parseExpressionListGeneric(() => this._parseExpression(allowStar));\n    }\n    // testlist: test (',' test)* [',']\n    _parseTestExpressionList() {\n        return this._parseExpressionListGeneric(() => this._parseTestExpression(false));\n    }\n    _parseTestOrStarExpressionList(allowAssignmentExpression) {\n        const exprListResult = this._parseExpressionListGeneric(() => this._parseTestOrStarExpression(allowAssignmentExpression));\n        if (!exprListResult.parseError) {\n            // Make sure that we don't have more than one star expression in the list.\n            let sawStar = false;\n            for (const expr of exprListResult.list) {\n                if (expr.nodeType === 57 /* Unpack */) {\n                    if (sawStar) {\n                        this._addError(localize_1.Localizer.Diagnostic.duplicateUnpack(), expr);\n                        break;\n                    }\n                    sawStar = true;\n                }\n            }\n        }\n        return exprListResult;\n    }\n    // exp_or_star: expr | star_expr\n    // expr: xor_expr ('|' xor_expr)*\n    // star_expr: '*' expr\n    _parseExpression(allowUnpack) {\n        const startToken = this._peekToken();\n        if (allowUnpack && this._consumeTokenIfOperator(26 /* Multiply */)) {\n            return parseNodes_1.UnpackNode.create(startToken, this._parseExpression(false));\n        }\n        return this._parseBitwiseOrExpression();\n    }\n    // test_or_star: test | star_expr\n    _parseTestOrStarExpression(allowAssignmentExpression) {\n        if (this._peekOperatorType() === 26 /* Multiply */) {\n            return this._parseExpression(true);\n        }\n        return this._parseTestExpression(allowAssignmentExpression);\n    }\n    // test: or_test ['if' or_test 'else' test] | lambdef\n    _parseTestExpression(allowAssignmentExpression) {\n        if (this._peekKeywordType() === 23 /* Lambda */) {\n            return this._parseLambdaExpression();\n        }\n        const ifExpr = allowAssignmentExpression ? this._parseAssignmentExpression() : this._parseOrTest();\n        if (ifExpr.nodeType === 0 /* Error */) {\n            return ifExpr;\n        }\n        if (!this._consumeTokenIfKeyword(19 /* If */)) {\n            return ifExpr;\n        }\n        const testExpr = this._parseAssignmentExpression();\n        if (testExpr.nodeType === 0 /* Error */) {\n            return testExpr;\n        }\n        if (!this._consumeTokenIfKeyword(12 /* Else */)) {\n            return this._handleExpressionParseError(1 /* MissingElse */, localize_1.Localizer.Diagnostic.expectedElse());\n        }\n        const elseExpr = this._parseTestExpression(true);\n        if (elseExpr.nodeType === 0 /* Error */) {\n            return elseExpr;\n        }\n        return parseNodes_1.TernaryNode.create(ifExpr, testExpr, elseExpr);\n    }\n    // assign_expr: (NAME := (or_test | lambdef)) | or_test\n    _parseAssignmentExpression() {\n        const leftExpr = this._parseOrTest();\n        if (leftExpr.nodeType === 0 /* Error */) {\n            return leftExpr;\n        }\n        if (leftExpr.nodeType !== 39 /* Name */) {\n            return leftExpr;\n        }\n        const walrusToken = this._peekToken();\n        if (!this._consumeTokenIfOperator(35 /* Walrus */)) {\n            return leftExpr;\n        }\n        if (!this._assignmentExpressionsAllowed) {\n            this._addError(localize_1.Localizer.Diagnostic.walrusNotAllowed(), walrusToken);\n        }\n        if (this._getLanguageVersion() < pythonVersion_1.PythonVersion.V3_8) {\n            this._addError(localize_1.Localizer.Diagnostic.walrusIllegal(), walrusToken);\n        }\n        let rightExpr;\n        if (this._peekKeywordType() === 23 /* Lambda */) {\n            rightExpr = this._parseLambdaExpression();\n        }\n        else {\n            rightExpr = this._parseOrTest();\n        }\n        return parseNodes_1.AssignmentExpressionNode.create(leftExpr, rightExpr);\n    }\n    // or_test: and_test ('or' and_test)*\n    _parseOrTest() {\n        let leftExpr = this._parseAndTest();\n        if (leftExpr.nodeType === 0 /* Error */) {\n            return leftExpr;\n        }\n        while (true) {\n            const peekToken = this._peekToken();\n            if (!this._consumeTokenIfKeyword(27 /* Or */)) {\n                break;\n            }\n            const rightExpr = this._parseAndTest();\n            leftExpr = parseNodes_1.BinaryOperationNode.create(leftExpr, rightExpr, peekToken, 37 /* Or */);\n        }\n        return leftExpr;\n    }\n    // and_test: not_test ('and' not_test)*\n    _parseAndTest() {\n        let leftExpr = this._parseNotTest();\n        if (leftExpr.nodeType === 0 /* Error */) {\n            return leftExpr;\n        }\n        while (true) {\n            const peekToken = this._peekToken();\n            if (!this._consumeTokenIfKeyword(0 /* And */)) {\n                break;\n            }\n            const rightExpr = this._parseNotTest();\n            leftExpr = parseNodes_1.BinaryOperationNode.create(leftExpr, rightExpr, peekToken, 36 /* And */);\n        }\n        return leftExpr;\n    }\n    // not_test: 'not' not_test | comparison\n    _parseNotTest() {\n        const notToken = this._peekToken();\n        if (this._consumeTokenIfKeyword(26 /* Not */)) {\n            const notExpr = this._parseNotTest();\n            return parseNodes_1.UnaryOperationNode.create(notToken, notExpr, 38 /* Not */);\n        }\n        return this._parseComparison();\n    }\n    // comparison: expr (comp_op expr)*\n    // comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'\n    _parseComparison() {\n        let leftExpr = this._parseBitwiseOrExpression();\n        if (leftExpr.nodeType === 0 /* Error */) {\n            return leftExpr;\n        }\n        while (true) {\n            let comparisonOperator;\n            const peekToken = this._peekToken();\n            if (tokenizer_1.Tokenizer.isOperatorComparison(this._peekOperatorType())) {\n                comparisonOperator = this._peekOperatorType();\n                if (comparisonOperator === 19 /* LessOrGreaterThan */) {\n                    this._addError(localize_1.Localizer.Diagnostic.operatorLessOrGreaterDeprecated(), peekToken);\n                    comparisonOperator = 28 /* NotEquals */;\n                }\n                this._getNextToken();\n            }\n            else if (this._consumeTokenIfKeyword(21 /* In */)) {\n                comparisonOperator = 41 /* In */;\n            }\n            else if (this._consumeTokenIfKeyword(22 /* Is */)) {\n                if (this._consumeTokenIfKeyword(26 /* Not */)) {\n                    comparisonOperator = 40 /* IsNot */;\n                }\n                else {\n                    comparisonOperator = 39 /* Is */;\n                }\n            }\n            else if (this._peekKeywordType() === 26 /* Not */) {\n                const tokenAfterNot = this._peekToken(1);\n                if (tokenAfterNot.type === 8 /* Keyword */ &&\n                    tokenAfterNot.keywordType === 21 /* In */) {\n                    this._getNextToken();\n                    this._getNextToken();\n                    comparisonOperator = 42 /* NotIn */;\n                }\n            }\n            if (comparisonOperator === undefined) {\n                break;\n            }\n            const rightExpr = this._parseBitwiseOrExpression();\n            leftExpr = parseNodes_1.BinaryOperationNode.create(leftExpr, rightExpr, peekToken, comparisonOperator);\n        }\n        return leftExpr;\n    }\n    // expr: xor_expr ('|' xor_expr)*\n    _parseBitwiseOrExpression() {\n        let leftExpr = this._parseBitwiseXorExpression();\n        if (leftExpr.nodeType === 0 /* Error */) {\n            return leftExpr;\n        }\n        while (true) {\n            const peekToken = this._peekToken();\n            if (!this._consumeTokenIfOperator(6 /* BitwiseOr */)) {\n                break;\n            }\n            const rightExpr = this._parseBitwiseXorExpression();\n            leftExpr = parseNodes_1.BinaryOperationNode.create(leftExpr, rightExpr, peekToken, 6 /* BitwiseOr */);\n        }\n        return leftExpr;\n    }\n    // xor_expr: and_expr ('^' and_expr)*\n    _parseBitwiseXorExpression() {\n        let leftExpr = this._parseBitwiseAndExpression();\n        if (leftExpr.nodeType === 0 /* Error */) {\n            return leftExpr;\n        }\n        while (true) {\n            const peekToken = this._peekToken();\n            if (!this._consumeTokenIfOperator(8 /* BitwiseXor */)) {\n                break;\n            }\n            const rightExpr = this._parseBitwiseAndExpression();\n            leftExpr = parseNodes_1.BinaryOperationNode.create(leftExpr, rightExpr, peekToken, 8 /* BitwiseXor */);\n        }\n        return leftExpr;\n    }\n    // and_expr: shift_expr ('&' shift_expr)*\n    _parseBitwiseAndExpression() {\n        let leftExpr = this._parseShiftExpression();\n        if (leftExpr.nodeType === 0 /* Error */) {\n            return leftExpr;\n        }\n        while (true) {\n            const peekToken = this._peekToken();\n            if (!this._consumeTokenIfOperator(3 /* BitwiseAnd */)) {\n                break;\n            }\n            const rightExpr = this._parseShiftExpression();\n            leftExpr = parseNodes_1.BinaryOperationNode.create(leftExpr, rightExpr, peekToken, 3 /* BitwiseAnd */);\n        }\n        return leftExpr;\n    }\n    // shift_expr: arith_expr (('<<'|'>>') arith_expr)*\n    _parseShiftExpression() {\n        let leftExpr = this._parseArithmeticExpression();\n        if (leftExpr.nodeType === 0 /* Error */) {\n            return leftExpr;\n        }\n        let peekToken = this._peekToken();\n        let nextOperator = this._peekOperatorType();\n        while (nextOperator === 17 /* LeftShift */ || nextOperator === 31 /* RightShift */) {\n            this._getNextToken();\n            const rightExpr = this._parseArithmeticExpression();\n            leftExpr = parseNodes_1.BinaryOperationNode.create(leftExpr, rightExpr, peekToken, nextOperator);\n            peekToken = this._peekToken();\n            nextOperator = this._peekOperatorType();\n        }\n        return leftExpr;\n    }\n    // arith_expr: term (('+'|'-') term)*\n    _parseArithmeticExpression() {\n        let leftExpr = this._parseArithmeticTerm();\n        if (leftExpr.nodeType === 0 /* Error */) {\n            return leftExpr;\n        }\n        let peekToken = this._peekToken();\n        let nextOperator = this._peekOperatorType();\n        while (nextOperator === 0 /* Add */ || nextOperator === 33 /* Subtract */) {\n            this._getNextToken();\n            const rightExpr = this._parseArithmeticTerm();\n            if (rightExpr.nodeType === 0 /* Error */) {\n                return rightExpr;\n            }\n            leftExpr = parseNodes_1.BinaryOperationNode.create(leftExpr, rightExpr, peekToken, nextOperator);\n            peekToken = this._peekToken();\n            nextOperator = this._peekOperatorType();\n        }\n        return leftExpr;\n    }\n    // term: factor (('*'|'@'|'/'|'%'|'//') factor)*\n    _parseArithmeticTerm() {\n        let leftExpr = this._parseArithmeticFactor();\n        if (leftExpr.nodeType === 0 /* Error */) {\n            return leftExpr;\n        }\n        let peekToken = this._peekToken();\n        let nextOperator = this._peekOperatorType();\n        while (nextOperator === 26 /* Multiply */ ||\n            nextOperator === 22 /* MatrixMultiply */ ||\n            nextOperator === 10 /* Divide */ ||\n            nextOperator === 24 /* Mod */ ||\n            nextOperator === 13 /* FloorDivide */) {\n            this._getNextToken();\n            const rightExpr = this._parseArithmeticFactor();\n            leftExpr = parseNodes_1.BinaryOperationNode.create(leftExpr, rightExpr, peekToken, nextOperator);\n            peekToken = this._peekToken();\n            nextOperator = this._peekOperatorType();\n        }\n        return leftExpr;\n    }\n    // factor: ('+'|'-'|'~') factor | power\n    // power: atom_expr ['**' factor]\n    _parseArithmeticFactor() {\n        const nextToken = this._peekToken();\n        const nextOperator = this._peekOperatorType();\n        if (nextOperator === 0 /* Add */ ||\n            nextOperator === 33 /* Subtract */ ||\n            nextOperator === 5 /* BitwiseInvert */) {\n            this._getNextToken();\n            const expression = this._parseArithmeticFactor();\n            return parseNodes_1.UnaryOperationNode.create(nextToken, expression, nextOperator);\n        }\n        const leftExpr = this._parseAtomExpression();\n        if (leftExpr.nodeType === 0 /* Error */) {\n            return leftExpr;\n        }\n        const peekToken = this._peekToken();\n        if (this._consumeTokenIfOperator(29 /* Power */)) {\n            const rightExpr = this._parseArithmeticFactor();\n            return parseNodes_1.BinaryOperationNode.create(leftExpr, rightExpr, peekToken, 29 /* Power */);\n        }\n        return leftExpr;\n    }\n    _isTypingAnnotation(typeAnnotation, name) {\n        if (typeAnnotation.nodeType === 39 /* Name */) {\n            if (typeAnnotation.value === name) {\n                return true;\n            }\n        }\n        else if (typeAnnotation.nodeType === 36 /* MemberAccess */) {\n            if (typeAnnotation.leftExpression.nodeType === 39 /* Name */ &&\n                (typeAnnotation.leftExpression.value === 'typing' || typeAnnotation.leftExpression.value === 't') &&\n                typeAnnotation.memberName.value === name) {\n                return true;\n            }\n        }\n        return false;\n    }\n    // atom_expr: ['await'] atom trailer*\n    // trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME\n    _parseAtomExpression() {\n        let awaitToken;\n        if (this._peekKeywordType() === 4 /* Await */ && !this._isParsingTypeAnnotation) {\n            awaitToken = this._getKeywordToken(4 /* Await */);\n            if (this._getLanguageVersion() < pythonVersion_1.PythonVersion.V3_5) {\n                this._addError(localize_1.Localizer.Diagnostic.awaitIllegal(), awaitToken);\n            }\n        }\n        let atomExpression = this._parseAtom();\n        if (atomExpression.nodeType === 0 /* Error */) {\n            return atomExpression;\n        }\n        // Consume trailers.\n        while (true) {\n            const nextToken = this._peekToken();\n            // Is it a function call?\n            if (this._consumeTokenIfType(13 /* OpenParenthesis */)) {\n                // Generally, function calls are not allowed within type annotations,\n                // but they are permitted in \"Annotated\" annotations.\n                const wasParsingTypeAnnotation = this._isParsingTypeAnnotation;\n                this._isParsingTypeAnnotation = false;\n                const argList = this._parseArgList();\n                const callNode = parseNodes_1.CallNode.create(atomExpression);\n                callNode.arguments = argList;\n                if (argList.length > 0) {\n                    argList.forEach((arg) => {\n                        arg.parent = callNode;\n                    });\n                    parseNodes_1.extendRange(callNode, argList[argList.length - 1]);\n                }\n                const nextToken = this._peekToken();\n                let isArgListTerminated = false;\n                if (!this._consumeTokenIfType(14 /* CloseParenthesis */)) {\n                    this._addError(localize_1.Localizer.Diagnostic.expectedCloseParen(), this._peekToken());\n                    // Consume the remainder of tokens on the line for error\n                    // recovery.\n                    this._consumeTokensUntilType([2 /* NewLine */]);\n                    // Extend the node's range to include the rest of the line.\n                    // This helps the signatureHelpProvider.\n                    parseNodes_1.extendRange(callNode, this._peekToken());\n                }\n                else {\n                    parseNodes_1.extendRange(callNode, nextToken);\n                    isArgListTerminated = true;\n                }\n                this._isParsingTypeAnnotation = wasParsingTypeAnnotation;\n                if (this._isParsingTypeAnnotation) {\n                    const diag = new diagnostic_1.DiagnosticAddendum();\n                    if (atomExpression.nodeType === 39 /* Name */ && atomExpression.value === 'type') {\n                        diag.addMessage(localize_1.Localizer.DiagnosticAddendum.useTypeInstead());\n                        this._addError(localize_1.Localizer.Diagnostic.typeCallNotAllowed() + diag.getString(), callNode);\n                    }\n                }\n                atomExpression = callNode;\n                // If the argument list wasn't terminated, break out of the loop\n                if (!isArgListTerminated) {\n                    break;\n                }\n            }\n            else if (this._consumeTokenIfType(15 /* OpenBracket */)) {\n                // Is it an index operator?\n                // This is an unfortunate hack that's necessary to accommodate 'Literal'\n                // type annotations properly. We need to suspend treating strings as\n                // type annotations within a Literal subscript. Note that the code previously\n                // looked for \"typing.Literal\", but someone submitted a bug report because\n                // they were using an aliased version of 'typing'.\n                const isLiteralSubscript = this._isTypingAnnotation(atomExpression, 'Literal');\n                const wasParsingIndexTrailer = this._isParsingIndexTrailer;\n                const wasParsingTypeAnnotation = this._isParsingTypeAnnotation;\n                if (isLiteralSubscript) {\n                    this._isParsingTypeAnnotation = false;\n                }\n                this._isParsingIndexTrailer = true;\n                const indexExpressions = this._parseSubscriptList();\n                this._isParsingTypeAnnotation = wasParsingTypeAnnotation;\n                this._isParsingIndexTrailer = wasParsingIndexTrailer;\n                const closingToken = this._peekToken();\n                const indexItemsNode = parseNodes_1.IndexItemsNode.create(nextToken, closingToken, indexExpressions);\n                const indexNode = parseNodes_1.IndexNode.create(atomExpression, indexItemsNode);\n                parseNodes_1.extendRange(indexNode, indexNode);\n                if (!this._consumeTokenIfType(16 /* CloseBracket */)) {\n                    return this._handleExpressionParseError(6 /* MissingIndexCloseBracket */, localize_1.Localizer.Diagnostic.expectedCloseBracket(), indexNode);\n                }\n                atomExpression = indexNode;\n            }\n            else if (this._consumeTokenIfType(20 /* Dot */)) {\n                // Is it a member access?\n                const memberName = this._getTokenIfIdentifier();\n                if (!memberName) {\n                    return this._handleExpressionParseError(7 /* MissingMemberAccessName */, localize_1.Localizer.Diagnostic.expectedMemberName(), atomExpression);\n                }\n                atomExpression = parseNodes_1.MemberAccessNode.create(atomExpression, parseNodes_1.NameNode.create(memberName));\n            }\n            else {\n                break;\n            }\n        }\n        if (awaitToken) {\n            return parseNodes_1.AwaitNode.create(awaitToken, atomExpression);\n        }\n        return atomExpression;\n    }\n    // subscriptlist: subscript (',' subscript)* [',']\n    _parseSubscriptList() {\n        const listResult = this._parseExpressionListGeneric(() => this._parseSubscript(), () => {\n            // Override the normal terminal check to exclude colons,\n            // which are a valid way to start subscription expressions.\n            if (this._peekTokenType() === 10 /* Colon */) {\n                return false;\n            }\n            return this._isNextTokenNeverExpression();\n        });\n        if (listResult.parseError) {\n            return [listResult.parseError];\n        }\n        if (listResult.list.length === 0) {\n            return [\n                this._handleExpressionParseError(3 /* MissingIndexOrSlice */, localize_1.Localizer.Diagnostic.expectedSliceIndex()),\n            ];\n        }\n        return listResult.list;\n    }\n    // subscript: test | [test] ':' [test] [sliceop]\n    // sliceop: ':' [test]\n    _parseSubscript() {\n        const firstToken = this._peekToken();\n        const sliceExpressions = [undefined, undefined, undefined];\n        let sliceIndex = 0;\n        let sawColon = false;\n        while (true) {\n            const nextTokenType = this._peekTokenType();\n            if (nextTokenType === 16 /* CloseBracket */ || nextTokenType === 12 /* Comma */) {\n                break;\n            }\n            if (nextTokenType !== 10 /* Colon */) {\n                sliceExpressions[sliceIndex] = this._parseTestExpression(false);\n            }\n            sliceIndex++;\n            if (sliceIndex >= 3 || !this._consumeTokenIfType(10 /* Colon */)) {\n                break;\n            }\n            sawColon = true;\n        }\n        // If this was a simple expression with no colons return it.\n        if (!sawColon) {\n            return sliceExpressions[0];\n        }\n        const sliceNode = parseNodes_1.SliceNode.create(firstToken);\n        sliceNode.startValue = sliceExpressions[0];\n        if (sliceNode.startValue) {\n            sliceNode.startValue.parent = sliceNode;\n        }\n        sliceNode.endValue = sliceExpressions[1];\n        if (sliceNode.endValue) {\n            sliceNode.endValue.parent = sliceNode;\n        }\n        sliceNode.stepValue = sliceExpressions[2];\n        if (sliceNode.stepValue) {\n            sliceNode.stepValue.parent = sliceNode;\n        }\n        const extension = sliceExpressions[2] || sliceExpressions[1] || sliceExpressions[0];\n        if (extension) {\n            parseNodes_1.extendRange(sliceNode, extension);\n        }\n        return sliceNode;\n    }\n    // arglist: argument (',' argument)*  [',']\n    _parseArgList() {\n        const argList = [];\n        let sawKeywordArg = false;\n        while (true) {\n            const nextTokenType = this._peekTokenType();\n            if (nextTokenType === 14 /* CloseParenthesis */ ||\n                nextTokenType === 2 /* NewLine */ ||\n                nextTokenType === 1 /* EndOfStream */) {\n                break;\n            }\n            const arg = this._parseArgument();\n            if (arg.name) {\n                sawKeywordArg = true;\n            }\n            else if (sawKeywordArg && arg.argumentCategory === 0 /* Simple */) {\n                this._addError(localize_1.Localizer.Diagnostic.positionArgAfterNamedArg(), arg);\n            }\n            argList.push(arg);\n            if (!this._consumeTokenIfType(12 /* Comma */)) {\n                break;\n            }\n        }\n        return argList;\n    }\n    // argument: ( test [comp_for] |\n    //             test '=' test |\n    //             '**' test |\n    //             '*' test )\n    _parseArgument() {\n        const firstToken = this._peekToken();\n        let argType = 0 /* Simple */;\n        if (this._consumeTokenIfOperator(26 /* Multiply */)) {\n            argType = 1 /* UnpackedList */;\n        }\n        else if (this._consumeTokenIfOperator(29 /* Power */)) {\n            argType = 2 /* UnpackedDictionary */;\n        }\n        let valueExpr = this._parseTestExpression(true);\n        let nameIdentifier;\n        if (argType === 0 /* Simple */) {\n            if (this._consumeTokenIfOperator(2 /* Assign */)) {\n                const nameExpr = valueExpr;\n                valueExpr = this._parseTestExpression(false);\n                if (nameExpr.nodeType === 39 /* Name */) {\n                    nameIdentifier = nameExpr.token;\n                }\n                else {\n                    this._addError(localize_1.Localizer.Diagnostic.expectedParamName(), nameExpr);\n                }\n            }\n            else {\n                const listComp = this._tryParseListComprehension(valueExpr);\n                if (listComp) {\n                    valueExpr = listComp;\n                }\n            }\n        }\n        const argNode = parseNodes_1.ArgumentNode.create(firstToken, valueExpr, argType);\n        if (nameIdentifier) {\n            argNode.name = parseNodes_1.NameNode.create(nameIdentifier);\n            argNode.name.parent = argNode;\n        }\n        return argNode;\n    }\n    // atom: ('(' [yield_expr | testlist_comp] ')' |\n    //     '[' [testlist_comp] ']' |\n    //     '{' [dictorsetmaker] '}' |\n    //     NAME | NUMBER | STRING+ | '...' | 'None' | 'True' | 'False' | '__debug__')\n    _parseAtom() {\n        const nextToken = this._peekToken();\n        if (nextToken.type === 19 /* Ellipsis */) {\n            return parseNodes_1.EllipsisNode.create(this._getNextToken());\n        }\n        if (nextToken.type === 6 /* Number */) {\n            return parseNodes_1.NumberNode.create(this._getNextToken());\n        }\n        if (nextToken.type === 7 /* Identifier */) {\n            return parseNodes_1.NameNode.create(this._getNextToken());\n        }\n        if (nextToken.type === 5 /* String */) {\n            return this._parseStringList();\n        }\n        if (nextToken.type === 22 /* Backtick */) {\n            this._getNextToken();\n            // Atoms with backticks are no longer allowed in Python 3.x, but they\n            // were a thing in Python 2.x. We'll parse them to improve parse recovery\n            // and emit an error.\n            this._addError(localize_1.Localizer.Diagnostic.backticksIllegal(), nextToken);\n            const expressionNode = this._parseTestListAsExpression(2 /* MissingExpression */, localize_1.Localizer.Diagnostic.expectedExpr());\n            this._consumeTokenIfType(22 /* Backtick */);\n            return expressionNode;\n        }\n        if (nextToken.type === 13 /* OpenParenthesis */) {\n            const possibleTupleNode = this._parseTupleAtom();\n            if (possibleTupleNode.nodeType === 53 /* Tuple */ &&\n                this._isParsingTypeAnnotation &&\n                !this._isParsingIndexTrailer) {\n                // This is allowed inside of an index trailer, specifically\n                // to support Tuple[()], which is the documented way to annotate\n                // a zero-length tuple.\n                const diag = new diagnostic_1.DiagnosticAddendum();\n                diag.addMessage(localize_1.Localizer.DiagnosticAddendum.useTupleInstead());\n                this._addError(localize_1.Localizer.Diagnostic.tupleInAnnotation() + diag.getString(), possibleTupleNode);\n            }\n            if (possibleTupleNode.nodeType === 7 /* BinaryOperation */) {\n                // Mark the binary expression as parenthesized so we don't attempt\n                // to use comparison chaining, which isn't appropriate when the\n                // expression is parenthesized.\n                possibleTupleNode.parenthesized = true;\n            }\n            return possibleTupleNode;\n        }\n        else if (nextToken.type === 15 /* OpenBracket */) {\n            const listNode = this._parseListAtom();\n            if (this._isParsingTypeAnnotation && !this._isParsingIndexTrailer) {\n                const diag = new diagnostic_1.DiagnosticAddendum();\n                diag.addMessage(localize_1.Localizer.DiagnosticAddendum.useListInstead());\n                this._addError(localize_1.Localizer.Diagnostic.listInAnnotation() + diag.getString(), listNode);\n            }\n            return listNode;\n        }\n        else if (nextToken.type === 17 /* OpenCurlyBrace */) {\n            const dictNode = this._parseDictionaryOrSetAtom();\n            if (this._isParsingTypeAnnotation) {\n                const diag = new diagnostic_1.DiagnosticAddendum();\n                diag.addMessage(localize_1.Localizer.DiagnosticAddendum.useDictInstead());\n                this._addError(localize_1.Localizer.Diagnostic.dictInAnnotation() + diag.getString(), dictNode);\n            }\n            return dictNode;\n        }\n        if (nextToken.type === 8 /* Keyword */) {\n            const keywordToken = nextToken;\n            if (keywordToken.keywordType === 14 /* False */ ||\n                keywordToken.keywordType === 31 /* True */ ||\n                keywordToken.keywordType === 8 /* Debug */ ||\n                keywordToken.keywordType === 24 /* None */) {\n                return parseNodes_1.ConstantNode.create(this._getNextToken());\n            }\n            // Make an identifier out of the keyword.\n            const keywordAsIdentifier = this._getTokenIfIdentifier();\n            if (keywordAsIdentifier) {\n                return parseNodes_1.NameNode.create(keywordAsIdentifier);\n            }\n        }\n        return this._handleExpressionParseError(2 /* MissingExpression */, localize_1.Localizer.Diagnostic.expectedExpr());\n    }\n    // Allocates a dummy \"error expression\" and consumes the remainder\n    // of the tokens on the line for error recovery. A partially-completed\n    // child node can be passed to help the completion provider determine\n    // what to do.\n    _handleExpressionParseError(category, errorMsg, childNode) {\n        this._addError(errorMsg, this._peekToken());\n        const expr = parseNodes_1.ErrorNode.create(this._peekToken(), category, childNode);\n        this._consumeTokensUntilType([2 /* NewLine */]);\n        return expr;\n    }\n    // lambdef: 'lambda' [varargslist] ':' test\n    _parseLambdaExpression(allowConditional = true) {\n        const lambdaToken = this._getKeywordToken(23 /* Lambda */);\n        const argList = this._parseVarArgsList(10 /* Colon */, false);\n        if (!this._consumeTokenIfType(10 /* Colon */)) {\n            this._addError(localize_1.Localizer.Diagnostic.expectedColon(), this._peekToken());\n        }\n        let testExpr;\n        if (allowConditional) {\n            testExpr = this._parseTestExpression(false);\n        }\n        else {\n            testExpr = this._tryParseLambdaExpression(false) || this._parseOrTest();\n        }\n        const lambdaNode = parseNodes_1.LambdaNode.create(lambdaToken, testExpr);\n        lambdaNode.parameters = argList;\n        argList.forEach((arg) => {\n            arg.parent = lambdaNode;\n        });\n        return lambdaNode;\n    }\n    _tryParseLambdaExpression(allowConditional = true) {\n        if (this._peekKeywordType() !== 23 /* Lambda */) {\n            return undefined;\n        }\n        return this._parseLambdaExpression(allowConditional);\n    }\n    // ('(' [yield_expr | testlist_comp] ')'\n    // testlist_comp: (test | star_expr) (comp_for | (',' (test | star_expr))* [','])\n    _parseTupleAtom() {\n        const startParen = this._getNextToken();\n        debug_1.assert(startParen.type === 13 /* OpenParenthesis */);\n        const yieldExpr = this._tryParseYieldExpression();\n        if (yieldExpr) {\n            if (this._peekTokenType() !== 14 /* CloseParenthesis */) {\n                return this._handleExpressionParseError(8 /* MissingTupleCloseParen */, localize_1.Localizer.Diagnostic.expectedCloseParen());\n            }\n            else {\n                parseNodes_1.extendRange(yieldExpr, this._getNextToken());\n            }\n            return yieldExpr;\n        }\n        const exprListResult = this._parseTestListWithComprehension();\n        const tupleOrExpression = this._makeExpressionOrTuple(exprListResult, /* enclosedInParens */ true);\n        if (this._peekTokenType() !== 14 /* CloseParenthesis */) {\n            return this._handleExpressionParseError(8 /* MissingTupleCloseParen */, localize_1.Localizer.Diagnostic.expectedCloseParen());\n        }\n        else {\n            parseNodes_1.extendRange(tupleOrExpression, this._getNextToken());\n        }\n        return tupleOrExpression;\n    }\n    // '[' [testlist_comp] ']'\n    // testlist_comp: (test | star_expr) (comp_for | (',' (test | star_expr))* [','])\n    _parseListAtom() {\n        const startBracket = this._getNextToken();\n        debug_1.assert(startBracket.type === 15 /* OpenBracket */);\n        const exprListResult = this._parseTestListWithComprehension();\n        const closeBracket = this._peekToken();\n        if (!this._consumeTokenIfType(16 /* CloseBracket */)) {\n            return this._handleExpressionParseError(9 /* MissingListCloseBracket */, localize_1.Localizer.Diagnostic.expectedCloseBracket());\n        }\n        const listAtom = parseNodes_1.ListNode.create(startBracket);\n        parseNodes_1.extendRange(listAtom, closeBracket);\n        if (exprListResult.list.length > 0) {\n            exprListResult.list.forEach((expr) => {\n                expr.parent = listAtom;\n            });\n            parseNodes_1.extendRange(listAtom, exprListResult.list[exprListResult.list.length - 1]);\n        }\n        listAtom.entries = exprListResult.list;\n        return listAtom;\n    }\n    _parseTestListWithComprehension() {\n        let sawComprehension = false;\n        return this._parseExpressionListGeneric(() => {\n            let expr = this._parseTestOrStarExpression(true);\n            const listComp = this._tryParseListComprehension(expr);\n            if (listComp) {\n                expr = listComp;\n                sawComprehension = true;\n            }\n            return expr;\n        }, () => this._isNextTokenNeverExpression(), () => sawComprehension);\n    }\n    // '{' [dictorsetmaker] '}'\n    // dictorsetmaker: (\n    //    (dictentry (comp_for | (',' dictentry)* [',']))\n    //    | (setentry (comp_for | (',' setentry)* [',']))\n    // )\n    // dictentry: (test ':' test | '**' expr)\n    // setentry: test | star_expr\n    _parseDictionaryOrSetAtom() {\n        const startBrace = this._getNextToken();\n        debug_1.assert(startBrace.type === 17 /* OpenCurlyBrace */);\n        const dictionaryEntries = [];\n        const setEntries = [];\n        let isDictionary = false;\n        let isSet = false;\n        let sawListComprehension = false;\n        let isFirstEntry = true;\n        while (true) {\n            if (this._peekTokenType() === 18 /* CloseCurlyBrace */) {\n                break;\n            }\n            let doubleStarExpression;\n            let keyExpression;\n            let valueExpression;\n            if (this._consumeTokenIfOperator(29 /* Power */)) {\n                doubleStarExpression = this._parseExpression(false);\n            }\n            else {\n                keyExpression = this._parseTestOrStarExpression(true);\n                if (this._consumeTokenIfType(10 /* Colon */)) {\n                    valueExpression = this._parseTestExpression(false);\n                }\n            }\n            if (keyExpression && valueExpression) {\n                if (keyExpression.nodeType === 57 /* Unpack */) {\n                    this._addError(localize_1.Localizer.Diagnostic.unpackInDict(), keyExpression);\n                }\n                if (isSet) {\n                    this._addError(localize_1.Localizer.Diagnostic.keyValueInSet(), valueExpression);\n                }\n                else {\n                    const keyEntryNode = parseNodes_1.DictionaryKeyEntryNode.create(keyExpression, valueExpression);\n                    let dictEntry = keyEntryNode;\n                    const listComp = this._tryParseListComprehension(keyEntryNode);\n                    if (listComp) {\n                        dictEntry = listComp;\n                        sawListComprehension = true;\n                        if (!isFirstEntry) {\n                            this._addError(localize_1.Localizer.Diagnostic.comprehensionInDict(), dictEntry);\n                        }\n                    }\n                    dictionaryEntries.push(dictEntry);\n                    isDictionary = true;\n                }\n            }\n            else if (doubleStarExpression) {\n                if (isSet) {\n                    this._addError(localize_1.Localizer.Diagnostic.unpackInSet(), doubleStarExpression);\n                }\n                else {\n                    const listEntryNode = parseNodes_1.DictionaryExpandEntryNode.create(doubleStarExpression);\n                    let expandEntryNode = listEntryNode;\n                    const listComp = this._tryParseListComprehension(listEntryNode);\n                    if (listComp) {\n                        expandEntryNode = listComp;\n                        sawListComprehension = true;\n                        if (!isFirstEntry) {\n                            this._addError(localize_1.Localizer.Diagnostic.comprehensionInDict(), doubleStarExpression);\n                        }\n                    }\n                    dictionaryEntries.push(expandEntryNode);\n                    isDictionary = true;\n                }\n            }\n            else {\n                debug_1.assert(keyExpression !== undefined);\n                if (keyExpression) {\n                    if (isDictionary) {\n                        this._addError(localize_1.Localizer.Diagnostic.dictKeyValuePairs(), keyExpression);\n                    }\n                    else {\n                        const listComp = this._tryParseListComprehension(keyExpression);\n                        if (listComp) {\n                            keyExpression = listComp;\n                            sawListComprehension = true;\n                            if (!isFirstEntry) {\n                                this._addError(localize_1.Localizer.Diagnostic.comprehensionInSet(), keyExpression);\n                            }\n                        }\n                        setEntries.push(keyExpression);\n                        isSet = true;\n                    }\n                }\n            }\n            // List comprehension statements always end the list.\n            if (sawListComprehension) {\n                break;\n            }\n            if (!this._consumeTokenIfType(12 /* Comma */)) {\n                break;\n            }\n            isFirstEntry = false;\n        }\n        let closeCurlyBrace = this._peekToken();\n        if (!this._consumeTokenIfType(18 /* CloseCurlyBrace */)) {\n            this._addError(localize_1.Localizer.Diagnostic.expectedCloseBrace(), this._peekToken());\n            closeCurlyBrace = undefined;\n        }\n        if (isSet) {\n            const setAtom = parseNodes_1.SetNode.create(startBrace);\n            if (closeCurlyBrace) {\n                parseNodes_1.extendRange(setAtom, closeCurlyBrace);\n            }\n            if (setEntries.length > 0) {\n                parseNodes_1.extendRange(setAtom, setEntries[setEntries.length - 1]);\n            }\n            setEntries.forEach((entry) => {\n                entry.parent = setAtom;\n            });\n            setAtom.entries = setEntries;\n            return setAtom;\n        }\n        const dictionaryAtom = parseNodes_1.DictionaryNode.create(startBrace);\n        if (closeCurlyBrace) {\n            parseNodes_1.extendRange(dictionaryAtom, closeCurlyBrace);\n        }\n        if (dictionaryEntries.length > 0) {\n            dictionaryEntries.forEach((entry) => {\n                entry.parent = dictionaryAtom;\n            });\n            parseNodes_1.extendRange(dictionaryAtom, dictionaryEntries[dictionaryEntries.length - 1]);\n        }\n        dictionaryAtom.entries = dictionaryEntries;\n        return dictionaryAtom;\n    }\n    _parseExpressionListGeneric(parser, terminalCheck = () => this._isNextTokenNeverExpression(), finalEntryCheck = () => false) {\n        let trailingComma = false;\n        const list = [];\n        let parseError;\n        while (true) {\n            if (terminalCheck()) {\n                break;\n            }\n            const expr = parser();\n            if (expr.nodeType === 0 /* Error */) {\n                parseError = expr;\n                break;\n            }\n            list.push(expr);\n            // Should we stop without checking for a trailing comma?\n            if (finalEntryCheck()) {\n                break;\n            }\n            if (!this._consumeTokenIfType(12 /* Comma */)) {\n                trailingComma = false;\n                break;\n            }\n            trailingComma = true;\n        }\n        return { trailingComma, list, parseError };\n    }\n    // expr_stmt: testlist_star_expr (annassign | augassign (yield_expr | testlist) |\n    //                     ('=' (yield_expr | testlist_star_expr))*)\n    // testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']\n    // annassign: ':' test ['=' test]\n    // augassign: ('+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' |\n    //             '<<=' | '>>=' | '**=' | '//=')\n    _parseExpressionStatement() {\n        let leftExpr = this._parseTestOrStarListAsExpression(\n        /* allowAssignmentExpression */ false, 2 /* MissingExpression */, localize_1.Localizer.Diagnostic.expectedExpr());\n        let annotationExpr;\n        if (leftExpr.nodeType === 0 /* Error */) {\n            return leftExpr;\n        }\n        // Is this a type annotation assignment?\n        if (this._consumeTokenIfType(10 /* Colon */)) {\n            annotationExpr = this._parseTypeAnnotation();\n            leftExpr = parseNodes_1.TypeAnnotationNode.create(leftExpr, annotationExpr);\n            if (!this._parseOptions.isStubFile && this._getLanguageVersion() < pythonVersion_1.PythonVersion.V3_6) {\n                this._addError(localize_1.Localizer.Diagnostic.varAnnotationIllegal(), annotationExpr);\n            }\n            if (!this._consumeTokenIfOperator(2 /* Assign */)) {\n                return leftExpr;\n            }\n            // This is an unfortunate hack that's necessary to accommodate 'TypeAlias'\n            // declarations properly. We need to treat this assignment differently than\n            // most because the expression on the right side is treated like a type\n            // annotation and therefore allows string-literal forward declarations.\n            const isTypeAliasDeclaration = this._isTypingAnnotation(annotationExpr, 'TypeAlias');\n            const wasParsingTypeAnnotation = this._isParsingTypeAnnotation;\n            if (isTypeAliasDeclaration) {\n                this._isParsingTypeAnnotation = true;\n            }\n            const rightExpr = this._parseTestExpression(false);\n            this._isParsingTypeAnnotation = wasParsingTypeAnnotation;\n            return parseNodes_1.AssignmentNode.create(leftExpr, rightExpr);\n        }\n        // Is this a simple assignment?\n        if (this._consumeTokenIfOperator(2 /* Assign */)) {\n            return this._parseChainAssignments(leftExpr);\n        }\n        if (!annotationExpr && tokenizer_1.Tokenizer.isOperatorAssignment(this._peekOperatorType())) {\n            const operatorToken = this._getNextToken();\n            const rightExpr = this._tryParseYieldExpression() ||\n                this._parseTestListAsExpression(2 /* MissingExpression */, localize_1.Localizer.Diagnostic.expectedBinaryRightHandExpr());\n            // Make a shallow copy of the dest expression but give it a new ID.\n            const destExpr = Object.assign({}, leftExpr);\n            destExpr.id = parseNodes_1.getNextNodeId();\n            return parseNodes_1.AugmentedAssignmentNode.create(leftExpr, rightExpr, operatorToken.operatorType, destExpr);\n        }\n        return leftExpr;\n    }\n    _parseChainAssignments(leftExpr) {\n        let rightExpr;\n        rightExpr = this._tryParseYieldExpression();\n        if (!rightExpr) {\n            rightExpr = this._parseTestOrStarListAsExpression(\n            /* allowAssignmentExpression */ false, 2 /* MissingExpression */, localize_1.Localizer.Diagnostic.expectedAssignRightHandExpr());\n        }\n        if (rightExpr.nodeType === 0 /* Error */) {\n            return parseNodes_1.AssignmentNode.create(leftExpr, rightExpr);\n        }\n        // Recur until we've consumed the entire chain.\n        if (this._consumeTokenIfOperator(2 /* Assign */)) {\n            rightExpr = this._parseChainAssignments(rightExpr);\n            if (rightExpr.nodeType === 0 /* Error */) {\n                return rightExpr;\n            }\n        }\n        const assignmentNode = parseNodes_1.AssignmentNode.create(leftExpr, rightExpr);\n        // Look for a type annotation comment at the end of the line.\n        const typeAnnotationComment = this._getTypeAnnotationComment();\n        if (typeAnnotationComment) {\n            assignmentNode.typeAnnotationComment = typeAnnotationComment;\n            assignmentNode.typeAnnotationComment.parent = assignmentNode;\n            parseNodes_1.extendRange(assignmentNode, assignmentNode.typeAnnotationComment);\n        }\n        return assignmentNode;\n    }\n    _parseTypeAnnotation(allowUnionNotation = true) {\n        // Temporary set a flag that indicates we're parsing a type annotation.\n        const wasParsingTypeAnnotation = this._isParsingTypeAnnotation;\n        this._isParsingTypeAnnotation = true;\n        let result;\n        let bitwiseOrToken;\n        while (true) {\n            const annotationExpr = this._parseAtomExpression();\n            // Is this the first atom we've seen, or are we creating a\n            // union with previous types?\n            if (result === undefined || bitwiseOrToken === undefined) {\n                result = annotationExpr;\n            }\n            else {\n                result = parseNodes_1.BinaryOperationNode.create(result, annotationExpr, bitwiseOrToken, 6 /* BitwiseOr */);\n            }\n            if (!allowUnionNotation) {\n                break;\n            }\n            bitwiseOrToken = this._peekToken();\n            if (this._peekOperatorType() === 6 /* BitwiseOr */) {\n                this._getNextToken();\n            }\n            else {\n                break;\n            }\n        }\n        this._isParsingTypeAnnotation = wasParsingTypeAnnotation;\n        return result;\n    }\n    _reportStringTokenErrors(stringToken, unescapedResult) {\n        if (stringToken.flags & 65536 /* Unterminated */) {\n            this._addError(localize_1.Localizer.Diagnostic.stringUnterminated(), stringToken);\n        }\n        if (unescapedResult.nonAsciiInBytes) {\n            this._addError(localize_1.Localizer.Diagnostic.stringNonAsciiBytes(), stringToken);\n        }\n        if (stringToken.flags & 64 /* Format */) {\n            if (this._getLanguageVersion() < pythonVersion_1.PythonVersion.V3_6) {\n                this._addError(localize_1.Localizer.Diagnostic.formatStringIllegal(), stringToken);\n            }\n            if (stringToken.flags & 32 /* Bytes */) {\n                this._addError(localize_1.Localizer.Diagnostic.formatStringBytes(), stringToken);\n            }\n            if (stringToken.flags & 16 /* Unicode */) {\n                this._addError(localize_1.Localizer.Diagnostic.formatStringUnicode(), stringToken);\n            }\n        }\n    }\n    _makeStringNode(stringToken) {\n        const unescapedResult = StringTokenUtils.getUnescapedString(stringToken);\n        this._reportStringTokenErrors(stringToken, unescapedResult);\n        return parseNodes_1.StringNode.create(stringToken, unescapedResult.value, unescapedResult.unescapeErrors.length > 0);\n    }\n    _getTypeAnnotationComment() {\n        if (this._tokenIndex === 0) {\n            return undefined;\n        }\n        const curToken = this._tokenizerOutput.tokens.getItemAt(this._tokenIndex - 1);\n        const nextToken = this._tokenizerOutput.tokens.getItemAt(this._tokenIndex);\n        if (curToken.start + curToken.length === nextToken.start) {\n            return undefined;\n        }\n        const interTokenContents = this._fileContents.substring(curToken.start + curToken.length, nextToken.start);\n        const commentRegEx = /^(\\s*#\\s*type:\\s*)([^\\r\\n]*)/;\n        const match = interTokenContents.match(commentRegEx);\n        if (!match) {\n            return undefined;\n        }\n        // Synthesize a string token and StringNode.\n        const typeString = match[2];\n        // Ignore all \"ignore\" comments. Include \"[\" in the regular\n        // expression because mypy supports ignore comments of the\n        // form ignore[errorCode, ...]. We'll treat these as regular\n        // ignore statements (as though no errorCodes were included).\n        if (typeString.trim().match(/^ignore(\\s|\\[|$)/)) {\n            return undefined;\n        }\n        const tokenOffset = curToken.start + curToken.length + match[1].length;\n        const stringToken = tokenizerTypes_1.StringToken.create(tokenOffset, typeString.length, 0 /* None */, typeString, 0, undefined);\n        const stringNode = this._makeStringNode(stringToken);\n        const stringListNode = parseNodes_1.StringListNode.create([stringNode]);\n        const parser = new Parser();\n        const parseResults = parser.parseTextExpression(this._fileContents, tokenOffset, typeString.length, this._parseOptions, \n        /* parseTypeAnnotation */ true);\n        parseResults.diagnostics.forEach((diag) => {\n            this._addError(diag.message, stringListNode);\n        });\n        if (!parseResults.parseTree) {\n            return undefined;\n        }\n        return parseResults.parseTree;\n    }\n    _parseFormatStringSegment(stringToken, segment, segmentOffset, segmentLength) {\n        debug_1.assert(segment.isExpression);\n        const parser = new Parser();\n        const parseResults = parser.parseTextExpression(this._fileContents, stringToken.start + stringToken.prefixLength + stringToken.quoteMarkLength + segment.offset + segmentOffset, segmentLength, this._parseOptions, \n        /* parseTypeAnnotation */ false, \n        /* initialParenDepth */ 1);\n        parseResults.diagnostics.forEach((diag) => {\n            const textRangeStart = (diag.range ? positionUtils_1.convertPositionToOffset(diag.range.start, parseResults.lines) : stringToken.start) ||\n                stringToken.start;\n            const textRangeEnd = (diag.range\n                ? (positionUtils_1.convertPositionToOffset(diag.range.end, parseResults.lines) || 0) + 1\n                : stringToken.start + stringToken.length) || stringToken.start + stringToken.length;\n            const textRange = { start: textRangeStart, length: textRangeEnd - textRangeStart };\n            this._addError(diag.message, textRange);\n        });\n        return parseResults.parseTree;\n    }\n    _parseFormatString(stringToken) {\n        const unescapedResult = StringTokenUtils.getUnescapedString(stringToken);\n        this._reportStringTokenErrors(stringToken, unescapedResult);\n        const formatExpressions = [];\n        for (const segment of unescapedResult.formatStringSegments) {\n            if (segment.isExpression) {\n                // Determine if we need to truncate the expression because it\n                // contains formatting directives that start with a ! or :.\n                const segmentExprLength = this._getFormatStringExpressionLength(segment.value.trimEnd());\n                const parseTree = this._parseFormatStringSegment(stringToken, segment, 0, segmentExprLength);\n                if (parseTree) {\n                    formatExpressions.push(parseTree);\n                }\n                // Look for additional expressions within the format directive.\n                const formatDirective = segment.value.substr(segmentExprLength);\n                let braceDepth = 0;\n                let startOfExprOffset = 0;\n                for (let i = 0; i < formatDirective.length; i++) {\n                    if (formatDirective.charCodeAt(i) === 123 /* OpenBrace */) {\n                        if (braceDepth === 0) {\n                            startOfExprOffset = i + 1;\n                        }\n                        braceDepth++;\n                    }\n                    else if (formatDirective.charCodeAt(i) === 125 /* CloseBrace */) {\n                        if (braceDepth > 0) {\n                            braceDepth--;\n                            if (braceDepth === 0) {\n                                const parseTree = this._parseFormatStringSegment(stringToken, segment, segmentExprLength + startOfExprOffset, i - startOfExprOffset);\n                                if (parseTree) {\n                                    formatExpressions.push(parseTree);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return parseNodes_1.FormatStringNode.create(stringToken, unescapedResult.value, unescapedResult.unescapeErrors.length > 0, formatExpressions);\n    }\n    _getFormatStringExpressionLength(segmentValue) {\n        let segmentExprLength = 0;\n        // PEP 498 says: Expressions cannot contain ':' or '!' outside of\n        // strings or parentheses, brackets, or braces. The exception is\n        // that the '!=' operator is allowed as a special case.\n        let inSingleQuote = false;\n        let inDoubleQuote = false;\n        let braceCount = 0;\n        let parenCount = 0;\n        let bracketCount = 0;\n        let prevCharWasEqual = false;\n        while (segmentExprLength < segmentValue.length) {\n            const curChar = segmentValue[segmentExprLength];\n            const ignoreSeparator = inSingleQuote || inDoubleQuote || braceCount > 0 || parenCount > 0 || bracketCount > 0;\n            const inString = inSingleQuote || inDoubleQuote;\n            if (curChar === '=') {\n                prevCharWasEqual = true;\n            }\n            else {\n                if (curChar === ':') {\n                    if (!ignoreSeparator) {\n                        break;\n                    }\n                }\n                else if (curChar === '!') {\n                    if (!ignoreSeparator) {\n                        // Allow !=, as per PEP 498\n                        if (segmentExprLength === segmentValue.length - 1 ||\n                            segmentValue[segmentExprLength + 1] !== '=') {\n                            break;\n                        }\n                    }\n                }\n                else if (curChar === \"'\") {\n                    if (!inDoubleQuote) {\n                        inSingleQuote = !inSingleQuote;\n                    }\n                }\n                else if (curChar === '\"') {\n                    if (!inSingleQuote) {\n                        inDoubleQuote = !inDoubleQuote;\n                    }\n                }\n                else if (curChar === '(') {\n                    if (!inString) {\n                        parenCount++;\n                    }\n                }\n                else if (curChar === ')') {\n                    if (!inString && parenCount > 0) {\n                        parenCount--;\n                    }\n                }\n                else if (curChar === '{') {\n                    if (!inString) {\n                        braceCount++;\n                    }\n                }\n                else if (curChar === '}') {\n                    if (!inString && braceCount > 0) {\n                        braceCount--;\n                    }\n                }\n                else if (curChar === '[') {\n                    if (!inString) {\n                        bracketCount++;\n                    }\n                }\n                else if (curChar === ']') {\n                    if (!inString && bracketCount > 0) {\n                        bracketCount--;\n                    }\n                }\n                prevCharWasEqual = false;\n            }\n            segmentExprLength++;\n        }\n        // Handle Python 3.8 f-string formatting expressions that\n        // end in an \"=\".\n        if (this._parseOptions.pythonVersion >= pythonVersion_1.PythonVersion.V3_8 && prevCharWasEqual) {\n            segmentExprLength--;\n        }\n        return segmentExprLength;\n    }\n    _parseStringList() {\n        const stringList = [];\n        while (this._peekTokenType() === 5 /* String */) {\n            const stringToken = this._getNextToken();\n            if (stringToken.flags & 64 /* Format */) {\n                stringList.push(this._parseFormatString(stringToken));\n            }\n            else {\n                stringList.push(this._makeStringNode(stringToken));\n            }\n        }\n        const stringNode = parseNodes_1.StringListNode.create(stringList);\n        // If we're parsing a type annotation, parse the contents of the string.\n        if (this._isParsingTypeAnnotation) {\n            // Don't allow multiple strings because we have no way of reporting\n            // parse errors that span strings.\n            if (stringNode.strings.length > 1) {\n                this._addError(localize_1.Localizer.Diagnostic.annotationSpansStrings(), stringNode);\n            }\n            else if (stringNode.strings[0].token.flags & 4 /* Triplicate */) {\n                this._addError(localize_1.Localizer.Diagnostic.annotationTripleQuote(), stringNode);\n            }\n            else if (stringNode.strings[0].token.flags & 64 /* Format */) {\n                this._addError(localize_1.Localizer.Diagnostic.annotationFormatString(), stringNode);\n            }\n            else {\n                const stringToken = stringNode.strings[0].token;\n                const stringValue = StringTokenUtils.getUnescapedString(stringNode.strings[0].token);\n                const unescapedString = stringValue.value;\n                const tokenOffset = stringToken.start;\n                const prefixLength = stringToken.prefixLength + stringToken.quoteMarkLength;\n                // Don't allow escape characters because we have no way of mapping\n                // error ranges back to the escaped text.\n                if (unescapedString.length !== stringToken.length - prefixLength - stringToken.quoteMarkLength) {\n                    this._addError(localize_1.Localizer.Diagnostic.annotationStringEscape(), stringNode);\n                }\n                else {\n                    const parser = new Parser();\n                    const parseResults = parser.parseTextExpression(this._fileContents, tokenOffset + prefixLength, unescapedString.length, this._parseOptions, \n                    /* parseTypeAnnotation */ true);\n                    parseResults.diagnostics.forEach((diag) => {\n                        this._addError(diag.message, stringNode);\n                    });\n                    if (parseResults.parseTree) {\n                        stringNode.typeAnnotation = parseResults.parseTree;\n                        stringNode.typeAnnotation.parent = stringNode;\n                    }\n                }\n            }\n        }\n        return stringNode;\n    }\n    // Python 3.8 added support for star (unpack) expressions in tuples\n    // following a return or yield statement in cases where the tuple\n    // wasn't surrounded in parentheses.\n    _reportConditionalErrorForStarTupleElement(possibleTupleExpr) {\n        if (possibleTupleExpr.nodeType !== 53 /* Tuple */) {\n            return;\n        }\n        if (possibleTupleExpr.enclosedInParens) {\n            return;\n        }\n        if (this._parseOptions.pythonVersion >= pythonVersion_1.PythonVersion.V3_8) {\n            return;\n        }\n        for (const expr of possibleTupleExpr.expressions) {\n            if (expr.nodeType === 57 /* Unpack */) {\n                this._addError(localize_1.Localizer.Diagnostic.unpackTuplesIllegal(), expr);\n                return;\n            }\n        }\n    }\n    // Peeks at the next token and returns true if it can never\n    // represent the start of an expression.\n    _isNextTokenNeverExpression() {\n        const nextToken = this._peekToken();\n        switch (nextToken.type) {\n            case 8 /* Keyword */: {\n                switch (this._peekKeywordType()) {\n                    case 16 /* For */:\n                    case 21 /* In */:\n                    case 19 /* If */:\n                        return true;\n                }\n                break;\n            }\n            case 9 /* Operator */: {\n                switch (this._peekOperatorType()) {\n                    case 1 /* AddEqual */:\n                    case 34 /* SubtractEqual */:\n                    case 27 /* MultiplyEqual */:\n                    case 11 /* DivideEqual */:\n                    case 25 /* ModEqual */:\n                    case 4 /* BitwiseAndEqual */:\n                    case 7 /* BitwiseOrEqual */:\n                    case 9 /* BitwiseXorEqual */:\n                    case 18 /* LeftShiftEqual */:\n                    case 32 /* RightShiftEqual */:\n                    case 30 /* PowerEqual */:\n                    case 14 /* FloorDivideEqual */:\n                    case 2 /* Assign */:\n                        return true;\n                }\n                break;\n            }\n            case 3 /* Indent */:\n            case 4 /* Dedent */:\n            case 2 /* NewLine */:\n            case 1 /* EndOfStream */:\n            case 11 /* Semicolon */:\n            case 14 /* CloseParenthesis */:\n            case 16 /* CloseBracket */:\n            case 18 /* CloseCurlyBrace */:\n            case 12 /* Comma */:\n            case 10 /* Colon */:\n                return true;\n        }\n        return false;\n    }\n    _disallowAssignmentExpression(callback) {\n        const wasAllowed = this._assignmentExpressionsAllowed;\n        this._assignmentExpressionsAllowed = false;\n        callback();\n        this._assignmentExpressionsAllowed = wasAllowed;\n    }\n    _getNextToken() {\n        const token = this._tokenizerOutput.tokens.getItemAt(this._tokenIndex);\n        if (!this._atEof()) {\n            this._tokenIndex++;\n        }\n        return token;\n    }\n    _atEof() {\n        // Are we pointing at the last token in the stream (which is\n        // assumed to be an end-of-stream token)?\n        return this._tokenIndex >= this._tokenizerOutput.tokens.count - 1;\n    }\n    _peekToken(count = 0) {\n        if (this._tokenIndex + count < 0) {\n            this._tokenizerOutput.tokens.getItemAt(0);\n        }\n        if (this._tokenIndex + count >= this._tokenizerOutput.tokens.count) {\n            return this._tokenizerOutput.tokens.getItemAt(this._tokenizerOutput.tokens.count - 1);\n        }\n        return this._tokenizerOutput.tokens.getItemAt(this._tokenIndex + count);\n    }\n    _peekTokenType() {\n        return this._peekToken().type;\n    }\n    _peekKeywordType() {\n        const nextToken = this._peekToken();\n        if (nextToken.type !== 8 /* Keyword */) {\n            return undefined;\n        }\n        return nextToken.keywordType;\n    }\n    _peekOperatorType() {\n        const nextToken = this._peekToken();\n        if (nextToken.type !== 9 /* Operator */) {\n            return undefined;\n        }\n        return nextToken.operatorType;\n    }\n    _getTokenIfIdentifier(disallowedKeywords = []) {\n        const nextToken = this._peekToken();\n        if (nextToken.type === 7 /* Identifier */) {\n            return this._getNextToken();\n        }\n        // If the next token is invalid, treat it as an identifier.\n        if (nextToken.type === 0 /* Invalid */) {\n            this._getNextToken();\n            this._addError(localize_1.Localizer.Diagnostic.invalidIdentifierChar(), nextToken);\n            return tokenizerTypes_1.IdentifierToken.create(nextToken.start, nextToken.length, '', nextToken.comments);\n        }\n        // If keywords are allowed in this context, convert the keyword\n        // to an identifier token.\n        if (nextToken.type === 8 /* Keyword */) {\n            const keywordType = this._peekKeywordType();\n            if (!disallowedKeywords.find((type) => type === keywordType)) {\n                const keywordText = this._fileContents.substr(nextToken.start, nextToken.length);\n                this._getNextToken();\n                return tokenizerTypes_1.IdentifierToken.create(nextToken.start, nextToken.length, keywordText, nextToken.comments);\n            }\n        }\n        return undefined;\n    }\n    // Consumes tokens until the next one in the stream is\n    // either a specified terminator or the end-of-stream\n    // token.\n    _consumeTokensUntilType(terminators) {\n        while (true) {\n            const token = this._peekToken();\n            if (terminators.some((term) => term === token.type)) {\n                return true;\n            }\n            if (token.type === 1 /* EndOfStream */) {\n                return false;\n            }\n            this._getNextToken();\n        }\n    }\n    _consumeTokenIfType(tokenType) {\n        if (this._peekTokenType() === tokenType) {\n            this._getNextToken();\n            return true;\n        }\n        return false;\n    }\n    _consumeTokenIfKeyword(keywordType) {\n        if (this._peekKeywordType() === keywordType) {\n            this._getNextToken();\n            return true;\n        }\n        return false;\n    }\n    _consumeTokenIfOperator(operatorType) {\n        if (this._peekOperatorType() === operatorType) {\n            this._getNextToken();\n            return true;\n        }\n        return false;\n    }\n    _getKeywordToken(keywordType) {\n        const keywordToken = this._getNextToken();\n        debug_1.assert(keywordToken.type === 8 /* Keyword */);\n        debug_1.assert(keywordToken.keywordType === keywordType);\n        return keywordToken;\n    }\n    _getLanguageVersion() {\n        return this._parseOptions.pythonVersion;\n    }\n    _addError(message, range) {\n        debug_1.assert(range !== undefined);\n        this._diagSink.addError(message, positionUtils_1.convertOffsetsToRange(range.start, range.start + range.length, this._tokenizerOutput.lines));\n    }\n}\nexports.Parser = Parser;\n\n\n//# sourceURL=webpack://pyright-server/./src/parser/parser.ts?");

/***/ }),

/***/ "./src/parser/stringTokenUtils.ts":
/*!****************************************!*\
  !*** ./src/parser/stringTokenUtils.ts ***!
  \****************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getUnescapedString [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * stringTokenUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Methods that handle unescaping of escaped string token\n * literal values.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getUnescapedString = void 0;\nfunction getUnescapedString(stringToken) {\n    const escapedString = stringToken.escapedValue;\n    const isRaw = (stringToken.flags & 8 /* Raw */) !== 0;\n    const isBytes = (stringToken.flags & 32 /* Bytes */) !== 0;\n    const isFormat = (stringToken.flags & 64 /* Format */) !== 0;\n    let formatExpressionNestCount = 0;\n    let formatSegment = {\n        offset: 0,\n        length: 0,\n        value: '',\n        isExpression: false,\n    };\n    let strOffset = 0;\n    const output = {\n        value: '',\n        unescapeErrors: [],\n        nonAsciiInBytes: false,\n        formatStringSegments: [],\n    };\n    const addInvalidEscapeOffset = () => {\n        // Invalid escapes are not reported for raw strings.\n        if (!isRaw) {\n            output.unescapeErrors.push({\n                offset: strOffset - 1,\n                length: 2,\n                errorType: 0 /* InvalidEscapeSequence */,\n            });\n        }\n    };\n    const getEscapedCharacter = (offset = 0) => {\n        if (strOffset + offset >= escapedString.length) {\n            return 3 /* EndOfText */;\n        }\n        return escapedString.charCodeAt(strOffset + offset);\n    };\n    const scanHexEscape = (digitCount) => {\n        let foundIllegalHexDigit = false;\n        let hexValue = 0;\n        let localValue = '';\n        for (let i = 0; i < digitCount; i++) {\n            const charCode = getEscapedCharacter(1 + i);\n            if (!_isHexCharCode(charCode)) {\n                foundIllegalHexDigit = true;\n                break;\n            }\n            hexValue = 16 * hexValue + _getHexDigitValue(charCode);\n        }\n        if (foundIllegalHexDigit) {\n            addInvalidEscapeOffset();\n            localValue = '\\\\' + String.fromCharCode(getEscapedCharacter());\n            strOffset++;\n        }\n        else {\n            localValue = String.fromCharCode(hexValue);\n            strOffset += 1 + digitCount;\n        }\n        return localValue;\n    };\n    const appendOutputChar = (charCode) => {\n        const char = String.fromCharCode(charCode);\n        output.value += char;\n        formatSegment.value += char;\n    };\n    while (true) {\n        let curChar = getEscapedCharacter();\n        if (curChar === 3 /* EndOfText */) {\n            if (isFormat) {\n                if (formatSegment.isExpression) {\n                    // The last format segment was an unterminated expression.\n                    output.unescapeErrors.push({\n                        offset: formatSegment.offset,\n                        length: strOffset - formatSegment.offset,\n                        errorType: 3 /* UnterminatedFormatExpression */,\n                    });\n                }\n                // Push the last segment.\n                if (strOffset !== formatSegment.offset) {\n                    formatSegment.length = strOffset - formatSegment.offset;\n                    output.formatStringSegments.push(formatSegment);\n                }\n            }\n            return output;\n        }\n        if (curChar === 92 /* Backslash */) {\n            if (isFormat && formatSegment.isExpression) {\n                // Backslashes aren't allowed within format string expressions.\n                output.unescapeErrors.push({\n                    offset: strOffset,\n                    length: 1,\n                    errorType: 1 /* EscapeWithinFormatExpression */,\n                });\n            }\n            // Move past the escape (backslash) character.\n            strOffset++;\n            curChar = getEscapedCharacter();\n            let localValue = '';\n            if (curChar === 13 /* CarriageReturn */ || curChar === 10 /* LineFeed */) {\n                if (curChar === 13 /* CarriageReturn */ && getEscapedCharacter(1) === 10 /* LineFeed */) {\n                    if (isRaw) {\n                        localValue += String.fromCharCode(curChar);\n                    }\n                    strOffset++;\n                    curChar = getEscapedCharacter();\n                }\n                if (isRaw) {\n                    localValue = '\\\\' + localValue + String.fromCharCode(curChar);\n                }\n                strOffset++;\n            }\n            else {\n                if (isRaw) {\n                    localValue = '\\\\' + String.fromCharCode(curChar);\n                    strOffset++;\n                }\n                else {\n                    switch (curChar) {\n                        case 92 /* Backslash */:\n                        case 39 /* SingleQuote */:\n                        case 34 /* DoubleQuote */:\n                            localValue = String.fromCharCode(curChar);\n                            strOffset++;\n                            break;\n                        case 97 /* a */:\n                            localValue = '\\u0007';\n                            strOffset++;\n                            break;\n                        case 98 /* b */:\n                            localValue = '\\b';\n                            strOffset++;\n                            break;\n                        case 102 /* f */:\n                            localValue = '\\f';\n                            strOffset++;\n                            break;\n                        case 110 /* n */:\n                            localValue = '\\n';\n                            strOffset++;\n                            break;\n                        case 114 /* r */:\n                            localValue = '\\r';\n                            strOffset++;\n                            break;\n                        case 116 /* t */:\n                            localValue = '\\t';\n                            strOffset++;\n                            break;\n                        case 118 /* v */:\n                            localValue = '\\v';\n                            strOffset++;\n                            break;\n                        case 120 /* x */:\n                            localValue = scanHexEscape(2);\n                            break;\n                        case 78 /* N */: {\n                            let foundIllegalChar = false;\n                            let charCount = 1;\n                            if (getEscapedCharacter(charCount) !== 123 /* OpenBrace */) {\n                                foundIllegalChar = true;\n                            }\n                            else {\n                                charCount++;\n                                while (true) {\n                                    const lookaheadChar = getEscapedCharacter(charCount);\n                                    if (lookaheadChar === 125 /* CloseBrace */) {\n                                        break;\n                                    }\n                                    else if (!_isAlphaNumericChar(lookaheadChar) && lookaheadChar !== 32 /* Space */) {\n                                        foundIllegalChar = true;\n                                        break;\n                                    }\n                                    else {\n                                        charCount++;\n                                    }\n                                }\n                            }\n                            if (foundIllegalChar) {\n                                addInvalidEscapeOffset();\n                                localValue = '\\\\' + String.fromCharCode(curChar);\n                                strOffset++;\n                            }\n                            else {\n                                // We don't have the Unicode name database handy, so\n                                // assume that the name is valid and use a '-' as a\n                                // replacement character.\n                                localValue = '-';\n                                strOffset += 1 + charCount;\n                            }\n                            break;\n                        }\n                        case 117 /* u */:\n                            localValue = scanHexEscape(4);\n                            break;\n                        case 85 /* U */:\n                            localValue = scanHexEscape(8);\n                            break;\n                        default:\n                            if (_isOctalCharCode(curChar)) {\n                                let octalCode = curChar - 48 /* _0 */;\n                                strOffset++;\n                                curChar = getEscapedCharacter();\n                                if (_isOctalCharCode(curChar)) {\n                                    octalCode = octalCode * 8 + curChar - 48 /* _0 */;\n                                    strOffset++;\n                                    curChar = getEscapedCharacter();\n                                    if (_isOctalCharCode(curChar)) {\n                                        octalCode = octalCode * 8 + curChar - 48 /* _0 */;\n                                        strOffset++;\n                                    }\n                                }\n                                localValue = String.fromCharCode(octalCode);\n                            }\n                            else {\n                                localValue = '\\\\' + String.fromCharCode(curChar);\n                                addInvalidEscapeOffset();\n                                strOffset++;\n                            }\n                            break;\n                    }\n                }\n            }\n            output.value += localValue;\n            formatSegment.value += localValue;\n        }\n        else if (curChar === 10 /* LineFeed */ || curChar === 13 /* CarriageReturn */) {\n            // Skip over the escaped new line (either one or two characters).\n            if (curChar === 13 /* CarriageReturn */ && getEscapedCharacter(1) === 10 /* LineFeed */) {\n                appendOutputChar(curChar);\n                strOffset++;\n                curChar = getEscapedCharacter();\n            }\n            appendOutputChar(curChar);\n            strOffset++;\n        }\n        else if (isFormat && curChar === 123 /* OpenBrace */) {\n            if (!formatSegment.isExpression && getEscapedCharacter(1) === 123 /* OpenBrace */) {\n                appendOutputChar(curChar);\n                strOffset += 2;\n            }\n            else {\n                if (formatExpressionNestCount === 0) {\n                    // A single open brace within a format literal indicates that\n                    // an expression is starting.\n                    formatSegment.length = strOffset - formatSegment.offset;\n                    if (formatSegment.length > 0) {\n                        output.formatStringSegments.push(formatSegment);\n                    }\n                    strOffset++;\n                    // Start a new segment.\n                    formatSegment = {\n                        offset: strOffset,\n                        length: 0,\n                        value: '',\n                        isExpression: true,\n                    };\n                }\n                else {\n                    appendOutputChar(curChar);\n                    strOffset++;\n                }\n                formatExpressionNestCount++;\n            }\n        }\n        else if (isFormat && curChar === 125 /* CloseBrace */) {\n            if (!formatSegment.isExpression && getEscapedCharacter(1) === 125 /* CloseBrace */) {\n                appendOutputChar(curChar);\n                strOffset += 2;\n            }\n            else if (formatExpressionNestCount === 0) {\n                output.unescapeErrors.push({\n                    offset: strOffset,\n                    length: 1,\n                    errorType: 2 /* SingleCloseBraceWithinFormatLiteral */,\n                });\n                strOffset++;\n            }\n            else {\n                formatExpressionNestCount--;\n                if (formatExpressionNestCount === 0) {\n                    // A close brace within a format expression indicates that\n                    // the expression is complete.\n                    formatSegment.length = strOffset - formatSegment.offset;\n                    output.formatStringSegments.push(formatSegment);\n                    strOffset++;\n                    // Start a new segment.\n                    formatSegment = {\n                        offset: strOffset,\n                        length: 0,\n                        value: '',\n                        isExpression: false,\n                    };\n                }\n                else {\n                    appendOutputChar(curChar);\n                    strOffset++;\n                }\n            }\n        }\n        else if (formatSegment.isExpression && (curChar === 39 /* SingleQuote */ || curChar === 34 /* DoubleQuote */)) {\n            // We're within an expression, and we've encountered a string literal.\n            // Skip over it.\n            const quoteChar = curChar;\n            appendOutputChar(curChar);\n            const isTriplicate = getEscapedCharacter(1) === quoteChar && getEscapedCharacter(2) === quoteChar;\n            if (isTriplicate) {\n                strOffset += 2;\n                appendOutputChar(curChar);\n                appendOutputChar(curChar);\n                output.value += String.fromCharCode(curChar);\n                output.value += String.fromCharCode(curChar);\n            }\n            while (true) {\n                strOffset++;\n                let strChar = getEscapedCharacter();\n                if (strChar === 3 /* EndOfText */) {\n                    break;\n                }\n                if (strChar === 92 /* Backslash */) {\n                    appendOutputChar(strChar);\n                    strOffset++;\n                    strChar = getEscapedCharacter();\n                    appendOutputChar(strChar);\n                    continue;\n                }\n                if (strChar === 10 /* LineFeed */ || strChar === 13 /* CarriageReturn */) {\n                    break;\n                }\n                if (strChar === quoteChar) {\n                    if (!isTriplicate) {\n                        strOffset++;\n                        appendOutputChar(strChar);\n                        break;\n                    }\n                    if (getEscapedCharacter(1) === quoteChar && getEscapedCharacter(2) === quoteChar) {\n                        strOffset += 3;\n                        appendOutputChar(strChar);\n                        appendOutputChar(strChar);\n                        appendOutputChar(strChar);\n                        break;\n                    }\n                }\n                appendOutputChar(strChar);\n            }\n        }\n        else {\n            // There's nothing to unescape, so output the escaped character directly.\n            if (isBytes && curChar >= 128) {\n                output.nonAsciiInBytes = true;\n            }\n            appendOutputChar(curChar);\n            strOffset++;\n        }\n    }\n}\nexports.getUnescapedString = getUnescapedString;\nfunction _isAlphaNumericChar(charCode) {\n    if (charCode >= 48 /* _0 */ && charCode <= 57 /* _9 */) {\n        return true;\n    }\n    if (charCode >= 97 /* a */ && charCode <= 122 /* z */) {\n        return true;\n    }\n    if (charCode >= 65 /* A */ && charCode <= 90 /* Z */) {\n        return true;\n    }\n    return false;\n}\nfunction _isOctalCharCode(charCode) {\n    return charCode >= 48 /* _0 */ && charCode <= 55 /* _7 */;\n}\nfunction _isHexCharCode(charCode) {\n    if (charCode >= 48 /* _0 */ && charCode <= 57 /* _9 */) {\n        return true;\n    }\n    if (charCode >= 97 /* a */ && charCode <= 102 /* f */) {\n        return true;\n    }\n    if (charCode >= 65 /* A */ && charCode <= 70 /* F */) {\n        return true;\n    }\n    return false;\n}\nfunction _getHexDigitValue(charCode) {\n    if (charCode >= 48 /* _0 */ && charCode <= 57 /* _9 */) {\n        return charCode - 48 /* _0 */;\n    }\n    if (charCode >= 97 /* a */ && charCode <= 102 /* f */) {\n        return charCode - 97 /* a */ + 10;\n    }\n    if (charCode >= 65 /* A */ && charCode <= 70 /* F */) {\n        return charCode - 65 /* A */ + 10;\n    }\n    return 0;\n}\n\n\n//# sourceURL=webpack://pyright-server/./src/parser/stringTokenUtils.ts?");

/***/ }),

/***/ "./src/parser/tokenizer.ts":
/*!*********************************!*\
  !*** ./src/parser/tokenizer.ts ***!
  \*********************************/
/*! flagged exports */
/*! export Tokenizer [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * tokenizer.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Based on code from vscode-python repository:\n *  https://github.com/Microsoft/vscode-python\n *\n * Converts a Python program text stream into a stream of tokens.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Tokenizer = void 0;\nconst textRangeCollection_1 = __webpack_require__(/*! ../common/textRangeCollection */ \"./src/common/textRangeCollection.ts\");\nconst characters_1 = __webpack_require__(/*! ./characters */ \"./src/parser/characters.ts\");\nconst characterStream_1 = __webpack_require__(/*! ./characterStream */ \"./src/parser/characterStream.ts\");\nconst tokenizerTypes_1 = __webpack_require__(/*! ./tokenizerTypes */ \"./src/parser/tokenizerTypes.ts\");\nconst _keywords = {\n    and: 0 /* And */,\n    as: 1 /* As */,\n    assert: 2 /* Assert */,\n    async: 3 /* Async */,\n    await: 4 /* Await */,\n    break: 5 /* Break */,\n    class: 6 /* Class */,\n    continue: 7 /* Continue */,\n    __debug__: 8 /* Debug */,\n    def: 9 /* Def */,\n    del: 10 /* Del */,\n    elif: 11 /* Elif */,\n    else: 12 /* Else */,\n    except: 13 /* Except */,\n    finally: 15 /* Finally */,\n    for: 16 /* For */,\n    from: 17 /* From */,\n    global: 18 /* Global */,\n    if: 19 /* If */,\n    import: 20 /* Import */,\n    in: 21 /* In */,\n    is: 22 /* Is */,\n    lambda: 23 /* Lambda */,\n    nonlocal: 25 /* Nonlocal */,\n    not: 26 /* Not */,\n    or: 27 /* Or */,\n    pass: 28 /* Pass */,\n    raise: 29 /* Raise */,\n    return: 30 /* Return */,\n    try: 32 /* Try */,\n    while: 33 /* While */,\n    with: 34 /* With */,\n    yield: 35 /* Yield */,\n    False: 14 /* False */,\n    None: 24 /* None */,\n    True: 31 /* True */,\n};\nconst _operatorInfo = {\n    [0 /* Add */]: 1 /* Unary */ | 2 /* Binary */,\n    [1 /* AddEqual */]: 4 /* Assignment */,\n    [2 /* Assign */]: 4 /* Assignment */,\n    [3 /* BitwiseAnd */]: 2 /* Binary */,\n    [4 /* BitwiseAndEqual */]: 4 /* Assignment */,\n    [5 /* BitwiseInvert */]: 1 /* Unary */,\n    [6 /* BitwiseOr */]: 2 /* Binary */,\n    [7 /* BitwiseOrEqual */]: 4 /* Assignment */,\n    [8 /* BitwiseXor */]: 2 /* Binary */,\n    [9 /* BitwiseXorEqual */]: 4 /* Assignment */,\n    [10 /* Divide */]: 2 /* Binary */,\n    [11 /* DivideEqual */]: 4 /* Assignment */,\n    [12 /* Equals */]: 2 /* Binary */ | 8 /* Comparison */,\n    [13 /* FloorDivide */]: 2 /* Binary */,\n    [14 /* FloorDivideEqual */]: 4 /* Assignment */,\n    [15 /* GreaterThan */]: 2 /* Binary */ | 8 /* Comparison */,\n    [16 /* GreaterThanOrEqual */]: 2 /* Binary */ | 8 /* Comparison */,\n    [17 /* LeftShift */]: 2 /* Binary */,\n    [18 /* LeftShiftEqual */]: 4 /* Assignment */,\n    [19 /* LessOrGreaterThan */]: 2 /* Binary */ | 8 /* Comparison */ | 16 /* Deprecated */,\n    [20 /* LessThan */]: 2 /* Binary */ | 8 /* Comparison */,\n    [21 /* LessThanOrEqual */]: 2 /* Binary */ | 8 /* Comparison */,\n    [22 /* MatrixMultiply */]: 2 /* Binary */,\n    [23 /* MatrixMultiplyEqual */]: 4 /* Assignment */,\n    [24 /* Mod */]: 2 /* Binary */,\n    [25 /* ModEqual */]: 4 /* Assignment */,\n    [26 /* Multiply */]: 2 /* Binary */,\n    [27 /* MultiplyEqual */]: 4 /* Assignment */,\n    [28 /* NotEquals */]: 2 /* Binary */ | 8 /* Comparison */,\n    [29 /* Power */]: 2 /* Binary */,\n    [30 /* PowerEqual */]: 4 /* Assignment */,\n    [31 /* RightShift */]: 2 /* Binary */,\n    [32 /* RightShiftEqual */]: 4 /* Assignment */,\n    [33 /* Subtract */]: 2 /* Binary */,\n    [34 /* SubtractEqual */]: 4 /* Assignment */,\n    [36 /* And */]: 2 /* Binary */,\n    [37 /* Or */]: 2 /* Binary */,\n    [38 /* Not */]: 1 /* Unary */,\n    [39 /* Is */]: 2 /* Binary */,\n    [40 /* IsNot */]: 2 /* Binary */,\n    [41 /* In */]: 2 /* Binary */,\n    [42 /* NotIn */]: 2 /* Binary */,\n};\nconst _byteOrderMarker = 0xfeff;\nclass Tokenizer {\n    constructor() {\n        this._cs = new characterStream_1.CharacterStream('');\n        this._tokens = [];\n        this._prevLineStart = 0;\n        this._parenDepth = 0;\n        this._lineRanges = [];\n        this._indentAmounts = [];\n        this._typeIgnoreAll = false;\n        this._typeIgnoreLines = {};\n        // Total times CR, CR/LF, and LF are used to terminate\n        // lines. Used to determine the predominant line ending.\n        this._crCount = 0;\n        this._crLfCount = 0;\n        this._lfCount = 0;\n        // Number of times an indent token is emitted.\n        this._indentCount = 0;\n        // Number of times an indent token is emitted and a tab character\n        // is present (used to determine predominant tab sequence).\n        this._indentTabCount = 0;\n        // Number of spaces that are added for an indent token\n        // (used to determine predominant tab sequence).\n        this._indentSpacesTotal = 0;\n        // Number of single or double quote string literals found\n        // in the code.\n        this._singleQuoteCount = 0;\n        this._doubleQuoteCount = 0;\n    }\n    tokenize(text, start, length, initialParenDepth = 0) {\n        if (start === undefined) {\n            start = 0;\n        }\n        else if (start < 0 || start > text.length) {\n            throw new Error('Invalid range start');\n        }\n        if (length === undefined) {\n            length = text.length;\n        }\n        else if (length < 0 || start + length > text.length) {\n            throw new Error('Invalid range length');\n        }\n        else if (start + length < text.length) {\n            text = text.substr(0, start + length);\n        }\n        this._cs = new characterStream_1.CharacterStream(text);\n        this._cs.position = start;\n        this._tokens = [];\n        this._prevLineStart = 0;\n        this._parenDepth = initialParenDepth;\n        this._lineRanges = [];\n        this._indentAmounts = [];\n        const end = start + length;\n        while (!this._cs.isEndOfStream()) {\n            this._addNextToken();\n            if (this._cs.position >= end) {\n                break;\n            }\n        }\n        // Insert an implied new line to make parsing easier.\n        if (this._tokens.length === 0 || this._tokens[this._tokens.length - 1].type !== 2 /* NewLine */) {\n            this._tokens.push(tokenizerTypes_1.NewLineToken.create(this._cs.position, 0, 3 /* Implied */, this._getComments()));\n        }\n        // Insert any implied dedent tokens.\n        this._setIndent(0, 0, true, false);\n        // Add a final end-of-stream token to make parsing easier.\n        this._tokens.push(tokenizerTypes_1.Token.create(1 /* EndOfStream */, this._cs.position, 0, this._getComments()));\n        // Add the final line range.\n        this._addLineRange();\n        let predominantEndOfLineSequence = '\\n';\n        if (this._crCount > this._crLfCount && this._crCount > this._lfCount) {\n            predominantEndOfLineSequence = '\\r';\n        }\n        else if (this._crLfCount > this._crCount && this._crLfCount > this._lfCount) {\n            predominantEndOfLineSequence = '\\r\\n';\n        }\n        let predominantTabSequence = '    ';\n        // If more than half of the indents use tab sequences,\n        // assume we're using tabs rather than spaces.\n        if (this._indentTabCount > this._indentCount / 2) {\n            predominantTabSequence = '\\t';\n        }\n        else if (this._indentCount > 0) {\n            // Compute the average number of spaces per indent\n            // to estimate the predominant tab value.\n            let averageSpacePerIndent = Math.round(this._indentSpacesTotal / this._indentCount);\n            if (averageSpacePerIndent < 1) {\n                averageSpacePerIndent = 1;\n            }\n            else if (averageSpacePerIndent > 8) {\n                averageSpacePerIndent = 8;\n            }\n            predominantTabSequence = '';\n            for (let i = 0; i < averageSpacePerIndent; i++) {\n                predominantTabSequence += ' ';\n            }\n        }\n        return {\n            tokens: new textRangeCollection_1.TextRangeCollection(this._tokens),\n            lines: new textRangeCollection_1.TextRangeCollection(this._lineRanges),\n            typeIgnoreLines: this._typeIgnoreLines,\n            typeIgnoreAll: this._typeIgnoreAll,\n            predominantEndOfLineSequence,\n            predominantTabSequence,\n            predominantSingleQuoteCharacter: this._singleQuoteCount >= this._doubleQuoteCount ? \"'\" : '\"',\n        };\n    }\n    static getOperatorInfo(operatorType) {\n        return _operatorInfo[operatorType];\n    }\n    static isOperatorAssignment(operatorType) {\n        if (operatorType === undefined || _operatorInfo[operatorType] === undefined) {\n            return false;\n        }\n        return (_operatorInfo[operatorType] & 4 /* Assignment */) !== 0;\n    }\n    static isOperatorComparison(operatorType) {\n        if (operatorType === undefined || _operatorInfo[operatorType] === undefined) {\n            return false;\n        }\n        return (_operatorInfo[operatorType] & 8 /* Comparison */) !== 0;\n    }\n    _addNextToken() {\n        this._cs.skipWhitespace();\n        if (this._cs.isEndOfStream()) {\n            return;\n        }\n        if (!this._handleCharacter()) {\n            this._cs.moveNext();\n        }\n    }\n    _handleCharacter() {\n        // f-strings, b-strings, etc\n        const stringPrefixLength = this._getStringPrefixLength();\n        if (stringPrefixLength >= 0) {\n            let stringPrefix = '';\n            if (stringPrefixLength > 0) {\n                stringPrefix = this._cs.getText().substr(this._cs.position, stringPrefixLength);\n                // Indeed a string\n                this._cs.advance(stringPrefixLength);\n            }\n            const quoteTypeFlags = this._getQuoteTypeFlags(stringPrefix);\n            if (quoteTypeFlags !== 0 /* None */) {\n                this._handleString(quoteTypeFlags, stringPrefixLength);\n                return true;\n            }\n        }\n        if (this._cs.currentChar === 35 /* Hash */) {\n            this._handleComment();\n            return true;\n        }\n        switch (this._cs.currentChar) {\n            case _byteOrderMarker: {\n                // Skip the BOM if it's at the start of the file.\n                if (this._cs.position === 0) {\n                    return false;\n                }\n                this._handleInvalid();\n                break;\n            }\n            case 13 /* CarriageReturn */: {\n                const length = this._cs.nextChar === 10 /* LineFeed */ ? 2 : 1;\n                const newLineType = length === 2 ? 2 /* CarriageReturnLineFeed */ : 0 /* CarriageReturn */;\n                this._handleNewLine(length, newLineType);\n                return true;\n            }\n            case 10 /* LineFeed */: {\n                this._handleNewLine(1, 1 /* LineFeed */);\n                return true;\n            }\n            case 92 /* Backslash */: {\n                if (this._cs.nextChar === 13 /* CarriageReturn */) {\n                    if (this._cs.lookAhead(2) === 10 /* LineFeed */) {\n                        this._cs.advance(3);\n                    }\n                    else {\n                        this._cs.advance(2);\n                    }\n                    this._addLineRange();\n                    return true;\n                }\n                else if (this._cs.nextChar === 10 /* LineFeed */) {\n                    this._cs.advance(2);\n                    this._addLineRange();\n                    return true;\n                }\n                this._handleInvalid();\n                return false;\n            }\n            case 40 /* OpenParenthesis */: {\n                this._parenDepth++;\n                this._tokens.push(tokenizerTypes_1.Token.create(13 /* OpenParenthesis */, this._cs.position, 1, this._getComments()));\n                break;\n            }\n            case 41 /* CloseParenthesis */: {\n                if (this._parenDepth > 0) {\n                    this._parenDepth--;\n                }\n                this._tokens.push(tokenizerTypes_1.Token.create(14 /* CloseParenthesis */, this._cs.position, 1, this._getComments()));\n                break;\n            }\n            case 91 /* OpenBracket */: {\n                this._parenDepth++;\n                this._tokens.push(tokenizerTypes_1.Token.create(15 /* OpenBracket */, this._cs.position, 1, this._getComments()));\n                break;\n            }\n            case 93 /* CloseBracket */: {\n                if (this._parenDepth > 0) {\n                    this._parenDepth--;\n                }\n                this._tokens.push(tokenizerTypes_1.Token.create(16 /* CloseBracket */, this._cs.position, 1, this._getComments()));\n                break;\n            }\n            case 123 /* OpenBrace */: {\n                this._parenDepth++;\n                this._tokens.push(tokenizerTypes_1.Token.create(17 /* OpenCurlyBrace */, this._cs.position, 1, this._getComments()));\n                break;\n            }\n            case 125 /* CloseBrace */: {\n                if (this._parenDepth > 0) {\n                    this._parenDepth--;\n                }\n                this._tokens.push(tokenizerTypes_1.Token.create(18 /* CloseCurlyBrace */, this._cs.position, 1, this._getComments()));\n                break;\n            }\n            case 44 /* Comma */: {\n                this._tokens.push(tokenizerTypes_1.Token.create(12 /* Comma */, this._cs.position, 1, this._getComments()));\n                break;\n            }\n            case 96 /* Backtick */: {\n                this._tokens.push(tokenizerTypes_1.Token.create(22 /* Backtick */, this._cs.position, 1, this._getComments()));\n                break;\n            }\n            case 59 /* Semicolon */: {\n                this._tokens.push(tokenizerTypes_1.Token.create(11 /* Semicolon */, this._cs.position, 1, this._getComments()));\n                break;\n            }\n            case 58 /* Colon */: {\n                if (this._cs.nextChar === 61 /* Equal */) {\n                    this._tokens.push(tokenizerTypes_1.OperatorToken.create(this._cs.position, 2, 35 /* Walrus */, this._getComments()));\n                    this._cs.advance(1);\n                    break;\n                }\n                this._tokens.push(tokenizerTypes_1.Token.create(10 /* Colon */, this._cs.position, 1, this._getComments()));\n                break;\n            }\n            default: {\n                if (this._isPossibleNumber()) {\n                    if (this._tryNumber()) {\n                        return true;\n                    }\n                }\n                if (this._cs.currentChar === 46 /* Period */) {\n                    if (this._cs.nextChar === 46 /* Period */ && this._cs.lookAhead(2) === 46 /* Period */) {\n                        this._tokens.push(tokenizerTypes_1.Token.create(19 /* Ellipsis */, this._cs.position, 3, this._getComments()));\n                        this._cs.advance(3);\n                        return true;\n                    }\n                    this._tokens.push(tokenizerTypes_1.Token.create(20 /* Dot */, this._cs.position, 1, this._getComments()));\n                    break;\n                }\n                if (!this._tryIdentifier()) {\n                    if (!this._tryOperator()) {\n                        this._handleInvalid();\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _addLineRange() {\n        const lineLength = this._cs.position - this._prevLineStart;\n        if (lineLength > 0) {\n            this._lineRanges.push({ start: this._prevLineStart, length: lineLength });\n        }\n        this._prevLineStart = this._cs.position;\n    }\n    _handleNewLine(length, newLineType) {\n        if (this._parenDepth === 0 && newLineType !== 3 /* Implied */) {\n            // New lines are ignored within parentheses.\n            // We'll also avoid adding multiple newlines in a row to simplify parsing.\n            if (this._tokens.length === 0 || this._tokens[this._tokens.length - 1].type !== 2 /* NewLine */) {\n                this._tokens.push(tokenizerTypes_1.NewLineToken.create(this._cs.position, length, newLineType, this._getComments()));\n            }\n        }\n        if (newLineType === 0 /* CarriageReturn */) {\n            this._crCount++;\n        }\n        else if (newLineType === 2 /* CarriageReturnLineFeed */) {\n            this._crLfCount++;\n        }\n        else {\n            this._lfCount++;\n        }\n        this._cs.advance(length);\n        this._addLineRange();\n        this._readIndentationAfterNewLine();\n    }\n    _readIndentationAfterNewLine() {\n        let tab1Spaces = 0;\n        let tab8Spaces = 0;\n        let isTabPresent = false;\n        let isSpacePresent = false;\n        while (!this._cs.isEndOfStream()) {\n            switch (this._cs.currentChar) {\n                case 32 /* Space */:\n                    tab1Spaces++;\n                    tab8Spaces++;\n                    isSpacePresent = true;\n                    this._cs.moveNext();\n                    break;\n                case 9 /* Tab */:\n                    // Translate tabs into spaces assuming both 1-space\n                    // and 8-space tab stops.\n                    tab1Spaces++;\n                    tab8Spaces += 8 - (tab8Spaces % 8);\n                    isTabPresent = true;\n                    this._cs.moveNext();\n                    break;\n                case 12 /* FormFeed */:\n                    tab1Spaces = 0;\n                    tab8Spaces = 0;\n                    isTabPresent = false;\n                    isSpacePresent = false;\n                    this._cs.moveNext();\n                    break;\n                default:\n                    // Non-blank line. Set the current indent level.\n                    this._setIndent(tab1Spaces, tab8Spaces, isSpacePresent, isTabPresent);\n                    return;\n                case 35 /* Hash */:\n                case 10 /* LineFeed */:\n                case 13 /* CarriageReturn */:\n                    // Blank line -- no need to adjust indentation.\n                    return;\n            }\n        }\n    }\n    // The caller must specify two space count values. The first assumes\n    // that tabs are translated into one-space tab stops. The second assumes\n    // that tabs are translated into eight-space tab stops.\n    _setIndent(tab1Spaces, tab8Spaces, isSpacePresent, isTabPresent) {\n        // Indentations are ignored within a parenthesized clause.\n        if (this._parenDepth > 0) {\n            return;\n        }\n        // Insert indent or dedent tokens as necessary.\n        if (this._indentAmounts.length === 0) {\n            if (tab8Spaces > 0) {\n                this._indentCount++;\n                if (isTabPresent) {\n                    this._indentTabCount++;\n                }\n                this._indentSpacesTotal += tab8Spaces;\n                this._indentAmounts.push({\n                    tab1Spaces,\n                    tab8Spaces,\n                    isSpacePresent,\n                    isTabPresent,\n                });\n                this._tokens.push(tokenizerTypes_1.IndentToken.create(this._cs.position, 0, tab8Spaces, false, this._getComments()));\n            }\n        }\n        else {\n            const prevTabInfo = this._indentAmounts[this._indentAmounts.length - 1];\n            if (prevTabInfo.tab8Spaces < tab8Spaces) {\n                // The Python spec says that if there is ambiguity about how tabs should\n                // be translated into spaces because the user has intermixed tabs and\n                // spaces, it should be an error. We'll record this condition in the token\n                // so the parser can later report it.\n                const isIndentAmbiguous = ((prevTabInfo.isSpacePresent && isTabPresent) || (prevTabInfo.isTabPresent && isSpacePresent)) &&\n                    prevTabInfo.tab1Spaces >= tab1Spaces;\n                this._indentCount++;\n                if (isTabPresent) {\n                    this._indentTabCount++;\n                }\n                this._indentSpacesTotal += tab8Spaces - this._indentAmounts[this._indentAmounts.length - 1].tab8Spaces;\n                this._indentAmounts.push({\n                    tab1Spaces,\n                    tab8Spaces,\n                    isSpacePresent,\n                    isTabPresent,\n                });\n                this._tokens.push(tokenizerTypes_1.IndentToken.create(this._cs.position, 0, tab8Spaces, isIndentAmbiguous, this._getComments()));\n            }\n            else {\n                // The Python spec says that dedent amounts need to match the indent\n                // amount exactly. An error is generated at runtime if it doesn't.\n                // We'll record that error condition within the token, allowing the\n                // parser to report it later.\n                const dedentPoints = [];\n                while (this._indentAmounts.length > 0 &&\n                    this._indentAmounts[this._indentAmounts.length - 1].tab8Spaces > tab8Spaces) {\n                    dedentPoints.push(this._indentAmounts.length > 1\n                        ? this._indentAmounts[this._indentAmounts.length - 2].tab8Spaces\n                        : 0);\n                    this._indentAmounts.pop();\n                }\n                dedentPoints.forEach((dedentAmount, index) => {\n                    const matchesIndent = index < dedentPoints.length - 1 || dedentAmount === tab8Spaces;\n                    const actualDedentAmount = index < dedentPoints.length - 1 ? dedentAmount : tab8Spaces;\n                    this._tokens.push(tokenizerTypes_1.DedentToken.create(this._cs.position, 0, actualDedentAmount, matchesIndent, this._getComments()));\n                });\n            }\n        }\n    }\n    _tryIdentifier() {\n        const start = this._cs.position;\n        if (characters_1.isIdentifierStartChar(this._cs.currentChar)) {\n            this._cs.moveNext();\n            while (characters_1.isIdentifierChar(this._cs.currentChar)) {\n                this._cs.moveNext();\n            }\n        }\n        if (this._cs.position > start) {\n            const value = this._cs.getText().substr(start, this._cs.position - start);\n            if (_keywords[value] !== undefined) {\n                this._tokens.push(tokenizerTypes_1.KeywordToken.create(start, this._cs.position - start, _keywords[value], this._getComments()));\n            }\n            else {\n                this._tokens.push(tokenizerTypes_1.IdentifierToken.create(start, this._cs.position - start, value, this._getComments()));\n            }\n            return true;\n        }\n        return false;\n    }\n    _isPossibleNumber() {\n        if (characters_1.isDecimal(this._cs.currentChar)) {\n            return true;\n        }\n        if (this._cs.currentChar === 46 /* Period */ && characters_1.isDecimal(this._cs.nextChar)) {\n            return true;\n        }\n        return false;\n    }\n    _tryNumber() {\n        const start = this._cs.position;\n        if (this._cs.currentChar === 48 /* _0 */) {\n            let radix = 0;\n            let leadingChars = 0;\n            // Try hex => hexinteger: \"0\" (\"x\" | \"X\") ([\"_\"] hexdigit)+\n            if ((this._cs.nextChar === 120 /* x */ || this._cs.nextChar === 88 /* X */) && characters_1.isHex(this._cs.lookAhead(2))) {\n                this._cs.advance(2);\n                leadingChars = 2;\n                while (characters_1.isHex(this._cs.currentChar)) {\n                    this._cs.moveNext();\n                }\n                radix = 16;\n            }\n            // Try binary => bininteger: \"0\" (\"b\" | \"B\") ([\"_\"] bindigit)+\n            if ((this._cs.nextChar === 98 /* b */ || this._cs.nextChar === 66 /* B */) && characters_1.isBinary(this._cs.lookAhead(2))) {\n                this._cs.advance(2);\n                leadingChars = 2;\n                while (characters_1.isBinary(this._cs.currentChar)) {\n                    this._cs.moveNext();\n                }\n                radix = 2;\n            }\n            // Try octal => octinteger: \"0\" (\"o\" | \"O\") ([\"_\"] octdigit)+\n            if ((this._cs.nextChar === 111 /* o */ || this._cs.nextChar === 79 /* O */) && characters_1.isOctal(this._cs.lookAhead(2))) {\n                this._cs.advance(2);\n                leadingChars = 2;\n                while (characters_1.isOctal(this._cs.currentChar)) {\n                    this._cs.moveNext();\n                }\n                radix = 8;\n            }\n            if (radix > 0) {\n                const text = this._cs.getText().substr(start, this._cs.position - start);\n                const value = parseInt(text.substr(leadingChars).replace(/_/g, ''), radix);\n                if (!isNaN(value)) {\n                    this._tokens.push(tokenizerTypes_1.NumberToken.create(start, text.length, value, true, false, this._getComments()));\n                    return true;\n                }\n            }\n        }\n        let isDecimalInteger = false;\n        let mightBeFloatingPoint = false;\n        // Try decimal int =>\n        //    decinteger: nonzerodigit ([\"_\"] digit)* | \"0\" ([\"_\"] \"0\")*\n        //    nonzerodigit: \"1\"...\"9\"\n        //    digit: \"0\"...\"9\"\n        if (this._cs.currentChar >= 49 /* _1 */ && this._cs.currentChar <= 57 /* _9 */) {\n            while (characters_1.isDecimal(this._cs.currentChar)) {\n                mightBeFloatingPoint = true;\n                this._cs.moveNext();\n            }\n            isDecimalInteger =\n                this._cs.currentChar !== 46 /* Period */ &&\n                    this._cs.currentChar !== 101 /* e */ &&\n                    this._cs.currentChar !== 69 /* E */;\n        }\n        // \"0\" ([\"_\"] \"0\")*\n        if (this._cs.currentChar === 48 /* _0 */) {\n            mightBeFloatingPoint = true;\n            while (this._cs.currentChar === 48 /* _0 */ || this._cs.currentChar === 95 /* Underscore */) {\n                this._cs.moveNext();\n            }\n            isDecimalInteger =\n                this._cs.currentChar !== 46 /* Period */ &&\n                    this._cs.currentChar !== 101 /* e */ &&\n                    this._cs.currentChar !== 69 /* E */;\n        }\n        if (isDecimalInteger) {\n            let text = this._cs.getText().substr(start, this._cs.position - start);\n            const value = parseInt(text.replace(/_/g, ''), 10);\n            if (!isNaN(value)) {\n                let isImaginary = false;\n                if (this._cs.currentChar === 106 /* j */ || this._cs.currentChar === 74 /* J */) {\n                    isImaginary = true;\n                    text += String.fromCharCode(this._cs.currentChar);\n                    this._cs.moveNext();\n                }\n                this._tokens.push(tokenizerTypes_1.NumberToken.create(start, text.length, value, true, isImaginary, this._getComments()));\n                return true;\n            }\n        }\n        // Floating point. Sign and leading digits were already skipped over.\n        this._cs.position = start;\n        if (mightBeFloatingPoint ||\n            (this._cs.currentChar === 46 /* Period */ && this._cs.nextChar >= 48 /* _0 */ && this._cs.nextChar <= 57 /* _9 */)) {\n            if (this._skipFloatingPointCandidate()) {\n                let text = this._cs.getText().substr(start, this._cs.position - start);\n                const value = parseFloat(text);\n                if (!isNaN(value)) {\n                    let isImaginary = false;\n                    if (this._cs.currentChar === 106 /* j */ || this._cs.currentChar === 74 /* J */) {\n                        isImaginary = true;\n                        text += String.fromCharCode(this._cs.currentChar);\n                        this._cs.moveNext();\n                    }\n                    this._tokens.push(tokenizerTypes_1.NumberToken.create(start, this._cs.position - start, value, false, isImaginary, this._getComments()));\n                    return true;\n                }\n            }\n        }\n        this._cs.position = start;\n        return false;\n    }\n    _tryOperator() {\n        let length = 0;\n        const nextChar = this._cs.nextChar;\n        let operatorType;\n        switch (this._cs.currentChar) {\n            case 43 /* Plus */:\n                length = nextChar === 61 /* Equal */ ? 2 : 1;\n                operatorType = length === 2 ? 1 /* AddEqual */ : 0 /* Add */;\n                break;\n            case 38 /* Ampersand */:\n                length = nextChar === 61 /* Equal */ ? 2 : 1;\n                operatorType = length === 2 ? 4 /* BitwiseAndEqual */ : 3 /* BitwiseAnd */;\n                break;\n            case 124 /* Bar */:\n                length = nextChar === 61 /* Equal */ ? 2 : 1;\n                operatorType = length === 2 ? 7 /* BitwiseOrEqual */ : 6 /* BitwiseOr */;\n                break;\n            case 94 /* Caret */:\n                length = nextChar === 61 /* Equal */ ? 2 : 1;\n                operatorType = length === 2 ? 9 /* BitwiseXorEqual */ : 8 /* BitwiseXor */;\n                break;\n            case 61 /* Equal */:\n                length = nextChar === 61 /* Equal */ ? 2 : 1;\n                operatorType = length === 2 ? 12 /* Equals */ : 2 /* Assign */;\n                break;\n            case 33 /* ExclamationMark */:\n                if (nextChar !== 61 /* Equal */) {\n                    return false;\n                }\n                length = 2;\n                operatorType = 28 /* NotEquals */;\n                break;\n            case 37 /* Percent */:\n                length = nextChar === 61 /* Equal */ ? 2 : 1;\n                operatorType = length === 2 ? 25 /* ModEqual */ : 24 /* Mod */;\n                break;\n            case 126 /* Tilde */:\n                length = 1;\n                operatorType = 5 /* BitwiseInvert */;\n                break;\n            case 45 /* Hyphen */:\n                if (nextChar === 62 /* Greater */) {\n                    this._tokens.push(tokenizerTypes_1.Token.create(21 /* Arrow */, this._cs.position, 2, this._getComments()));\n                    this._cs.advance(2);\n                    return true;\n                }\n                length = nextChar === 61 /* Equal */ ? 2 : 1;\n                operatorType = length === 2 ? 34 /* SubtractEqual */ : 33 /* Subtract */;\n                break;\n            case 42 /* Asterisk */:\n                if (nextChar === 42 /* Asterisk */) {\n                    length = this._cs.lookAhead(2) === 61 /* Equal */ ? 3 : 2;\n                    operatorType = length === 3 ? 30 /* PowerEqual */ : 29 /* Power */;\n                }\n                else {\n                    length = nextChar === 61 /* Equal */ ? 2 : 1;\n                    operatorType = length === 2 ? 27 /* MultiplyEqual */ : 26 /* Multiply */;\n                }\n                break;\n            case 47 /* Slash */:\n                if (nextChar === 47 /* Slash */) {\n                    length = this._cs.lookAhead(2) === 61 /* Equal */ ? 3 : 2;\n                    operatorType = length === 3 ? 14 /* FloorDivideEqual */ : 13 /* FloorDivide */;\n                }\n                else {\n                    length = nextChar === 61 /* Equal */ ? 2 : 1;\n                    operatorType = length === 2 ? 11 /* DivideEqual */ : 10 /* Divide */;\n                }\n                break;\n            case 60 /* Less */:\n                if (nextChar === 60 /* Less */) {\n                    length = this._cs.lookAhead(2) === 61 /* Equal */ ? 3 : 2;\n                    operatorType = length === 3 ? 18 /* LeftShiftEqual */ : 17 /* LeftShift */;\n                }\n                else if (nextChar === 62 /* Greater */) {\n                    length = 2;\n                    operatorType = 19 /* LessOrGreaterThan */;\n                }\n                else {\n                    length = nextChar === 61 /* Equal */ ? 2 : 1;\n                    operatorType = length === 2 ? 21 /* LessThanOrEqual */ : 20 /* LessThan */;\n                }\n                break;\n            case 62 /* Greater */:\n                if (nextChar === 62 /* Greater */) {\n                    length = this._cs.lookAhead(2) === 61 /* Equal */ ? 3 : 2;\n                    operatorType = length === 3 ? 32 /* RightShiftEqual */ : 31 /* RightShift */;\n                }\n                else {\n                    length = nextChar === 61 /* Equal */ ? 2 : 1;\n                    operatorType = length === 2 ? 16 /* GreaterThanOrEqual */ : 15 /* GreaterThan */;\n                }\n                break;\n            case 64 /* At */:\n                length = nextChar === 61 /* Equal */ ? 2 : 1;\n                operatorType = length === 2 ? 23 /* MatrixMultiplyEqual */ : 22 /* MatrixMultiply */;\n                break;\n            default:\n                return false;\n        }\n        this._tokens.push(tokenizerTypes_1.OperatorToken.create(this._cs.position, length, operatorType, this._getComments()));\n        this._cs.advance(length);\n        return length > 0;\n    }\n    _handleInvalid() {\n        const start = this._cs.position;\n        this._cs.skipToWhitespace();\n        const length = this._cs.position - start;\n        if (length > 0) {\n            this._tokens.push(tokenizerTypes_1.Token.create(0 /* Invalid */, start, length, this._getComments()));\n            return true;\n        }\n        return false;\n    }\n    _getComments() {\n        const prevComments = this._comments;\n        this._comments = undefined;\n        return prevComments;\n    }\n    _handleComment() {\n        const start = this._cs.position + 1;\n        this._cs.skipToEol();\n        const length = this._cs.position - start;\n        const value = this._cs.getText().substr(start, length);\n        const comment = tokenizerTypes_1.Comment.create(start, length, value);\n        // We include \"[\" in the regular expression because mypy supports\n        // ignore comments of the form ignore[errorCode, ...]. We'll treat\n        // these as regular ignore statements (as though no errorCodes were\n        // included).\n        if (value.match(/^\\s*type:\\s*ignore(\\s|\\[|$)/)) {\n            if (this._tokens.findIndex((t) => t.type !== 2 /* NewLine */ && t && t.type !== 3 /* Indent */) < 0) {\n                this._typeIgnoreAll = true;\n            }\n            else {\n                this._typeIgnoreLines[this._lineRanges.length] = true;\n            }\n        }\n        if (this._comments) {\n            this._comments.push(comment);\n        }\n        else {\n            this._comments = [comment];\n        }\n    }\n    _getStringPrefixLength() {\n        if (this._cs.currentChar === 39 /* SingleQuote */ || this._cs.currentChar === 34 /* DoubleQuote */) {\n            // Simple string, no prefix\n            return 0;\n        }\n        if (this._cs.nextChar === 39 /* SingleQuote */ || this._cs.nextChar === 34 /* DoubleQuote */) {\n            switch (this._cs.currentChar) {\n                case 102 /* f */:\n                case 70 /* F */:\n                case 114 /* r */:\n                case 82 /* R */:\n                case 98 /* b */:\n                case 66 /* B */:\n                case 117 /* u */:\n                case 85 /* U */:\n                    // Single-char prefix like u\"\" or r\"\"\n                    return 1;\n                default:\n                    break;\n            }\n        }\n        if (this._cs.lookAhead(2) === 39 /* SingleQuote */ || this._cs.lookAhead(2) === 34 /* DoubleQuote */) {\n            const prefix = this._cs.getText().substr(this._cs.position, 2).toLowerCase();\n            switch (prefix) {\n                case 'rf':\n                case 'fr':\n                case 'ur':\n                case 'ru':\n                case 'br':\n                case 'rb':\n                    return 2;\n                default:\n                    break;\n            }\n        }\n        return -1;\n    }\n    _getQuoteTypeFlags(prefix) {\n        let flags = 0 /* None */;\n        prefix = prefix.toLowerCase();\n        for (let i = 0; i < prefix.length; i++) {\n            switch (prefix[i]) {\n                case 'u':\n                    flags |= 16 /* Unicode */;\n                    break;\n                case 'b':\n                    flags |= 32 /* Bytes */;\n                    break;\n                case 'r':\n                    flags |= 8 /* Raw */;\n                    break;\n                case 'f':\n                    flags |= 64 /* Format */;\n                    break;\n            }\n        }\n        if (this._cs.currentChar === 39 /* SingleQuote */) {\n            flags |= 1 /* SingleQuote */;\n            if (this._cs.nextChar === 39 /* SingleQuote */ && this._cs.lookAhead(2) === 39 /* SingleQuote */) {\n                flags |= 4 /* Triplicate */;\n            }\n        }\n        else if (this._cs.currentChar === 34 /* DoubleQuote */) {\n            flags |= 2 /* DoubleQuote */;\n            if (this._cs.nextChar === 34 /* DoubleQuote */ && this._cs.lookAhead(2) === 34 /* DoubleQuote */) {\n                flags |= 4 /* Triplicate */;\n            }\n        }\n        return flags;\n    }\n    _handleString(flags, stringPrefixLength) {\n        const start = this._cs.position - stringPrefixLength;\n        if (flags & 4 /* Triplicate */) {\n            this._cs.advance(3);\n        }\n        else {\n            this._cs.moveNext();\n            if (flags & 1 /* SingleQuote */) {\n                this._singleQuoteCount++;\n            }\n            else {\n                this._doubleQuoteCount++;\n            }\n        }\n        const stringLiteralInfo = this._skipToEndOfStringLiteral(flags);\n        const end = this._cs.position;\n        this._tokens.push(tokenizerTypes_1.StringToken.create(start, end - start, stringLiteralInfo.flags, stringLiteralInfo.escapedValue, stringPrefixLength, this._getComments()));\n    }\n    _skipToEndOfStringLiteral(flags) {\n        const quoteChar = flags & 1 /* SingleQuote */ ? 39 /* SingleQuote */ : 34 /* DoubleQuote */;\n        const isTriplicate = (flags & 4 /* Triplicate */) !== 0;\n        let escapedValue = '';\n        while (true) {\n            if (this._cs.isEndOfStream()) {\n                // Hit the end of file without a termination.\n                flags |= 65536 /* Unterminated */;\n                return { escapedValue, flags };\n            }\n            if (this._cs.currentChar === 92 /* Backslash */) {\n                escapedValue += String.fromCharCode(this._cs.currentChar);\n                // Move past the escape (backslash) character.\n                this._cs.moveNext();\n                if (this._cs.getCurrentChar() === 13 /* CarriageReturn */ || this._cs.getCurrentChar() === 10 /* LineFeed */) {\n                    if (this._cs.getCurrentChar() === 13 /* CarriageReturn */ && this._cs.nextChar === 10 /* LineFeed */) {\n                        escapedValue += String.fromCharCode(this._cs.getCurrentChar());\n                        this._cs.moveNext();\n                    }\n                    escapedValue += String.fromCharCode(this._cs.getCurrentChar());\n                    this._cs.moveNext();\n                    this._addLineRange();\n                }\n                else {\n                    escapedValue += String.fromCharCode(this._cs.getCurrentChar());\n                    this._cs.moveNext();\n                }\n            }\n            else if (this._cs.currentChar === 10 /* LineFeed */ || this._cs.currentChar === 13 /* CarriageReturn */) {\n                if (!isTriplicate) {\n                    // Unterminated single-line string\n                    flags |= 65536 /* Unterminated */;\n                    return { escapedValue, flags };\n                }\n                // Skip over the new line (either one or two characters).\n                if (this._cs.currentChar === 13 /* CarriageReturn */ && this._cs.nextChar === 10 /* LineFeed */) {\n                    escapedValue += String.fromCharCode(this._cs.currentChar);\n                    this._cs.moveNext();\n                }\n                escapedValue += String.fromCharCode(this._cs.currentChar);\n                this._cs.moveNext();\n                this._addLineRange();\n            }\n            else if (!isTriplicate && this._cs.currentChar === quoteChar) {\n                this._cs.moveNext();\n                break;\n            }\n            else if (isTriplicate &&\n                this._cs.currentChar === quoteChar &&\n                this._cs.nextChar === quoteChar &&\n                this._cs.lookAhead(2) === quoteChar) {\n                this._cs.advance(3);\n                break;\n            }\n            else {\n                escapedValue += String.fromCharCode(this._cs.currentChar);\n                this._cs.moveNext();\n            }\n        }\n        return { escapedValue, flags };\n    }\n    _skipFloatingPointCandidate() {\n        // Determine end of the potential floating point number\n        const start = this._cs.position;\n        this._skipFractionalNumber();\n        if (this._cs.position > start) {\n            // Optional exponent sign\n            if (this._cs.currentChar === 101 /* e */ || this._cs.currentChar === 69 /* E */) {\n                this._cs.moveNext();\n                // Skip exponent value\n                this._skipDecimalNumber(true);\n            }\n        }\n        return this._cs.position > start;\n    }\n    _skipFractionalNumber() {\n        this._skipDecimalNumber(false);\n        if (this._cs.currentChar === 46 /* Period */) {\n            // Optional period\n            this._cs.moveNext();\n        }\n        this._skipDecimalNumber(false);\n    }\n    _skipDecimalNumber(allowSign) {\n        if (allowSign && (this._cs.currentChar === 45 /* Hyphen */ || this._cs.currentChar === 43 /* Plus */)) {\n            // Optional sign\n            this._cs.moveNext();\n        }\n        while (characters_1.isDecimal(this._cs.currentChar)) {\n            // Skip integer part\n            this._cs.moveNext();\n        }\n    }\n}\nexports.Tokenizer = Tokenizer;\n\n\n//# sourceURL=webpack://pyright-server/./src/parser/tokenizer.ts?");

/***/ }),

/***/ "./src/parser/tokenizerTypes.ts":
/*!**************************************!*\
  !*** ./src/parser/tokenizerTypes.ts ***!
  \**************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * tokenizerTypes.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Based on code from vscode-python repository:\n *  https://github.com/Microsoft/vscode-python\n *\n * Interface, enumeration and class definitions used within\n * the Python tokenizer.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IdentifierToken = exports.OperatorToken = exports.NumberToken = exports.StringToken = exports.KeywordToken = exports.NewLineToken = exports.DedentToken = exports.IndentToken = exports.Token = exports.Comment = void 0;\nvar Comment;\n(function (Comment) {\n    function create(start, length, value) {\n        const comment = {\n            start,\n            length,\n            value,\n        };\n        return comment;\n    }\n    Comment.create = create;\n})(Comment = exports.Comment || (exports.Comment = {}));\nvar Token;\n(function (Token) {\n    function create(type, start, length, comments) {\n        const token = {\n            start,\n            length,\n            type,\n            comments,\n        };\n        return token;\n    }\n    Token.create = create;\n})(Token = exports.Token || (exports.Token = {}));\nvar IndentToken;\n(function (IndentToken) {\n    function create(start, length, indentAmount, isIndentAmbiguous, comments) {\n        const token = {\n            start,\n            length,\n            type: 3 /* Indent */,\n            isIndentAmbiguous,\n            comments,\n            indentAmount,\n        };\n        return token;\n    }\n    IndentToken.create = create;\n})(IndentToken = exports.IndentToken || (exports.IndentToken = {}));\nvar DedentToken;\n(function (DedentToken) {\n    function create(start, length, indentAmount, matchesIndent, comments) {\n        const token = {\n            start,\n            length,\n            type: 4 /* Dedent */,\n            comments,\n            indentAmount,\n            matchesIndent,\n        };\n        return token;\n    }\n    DedentToken.create = create;\n})(DedentToken = exports.DedentToken || (exports.DedentToken = {}));\nvar NewLineToken;\n(function (NewLineToken) {\n    function create(start, length, newLineType, comments) {\n        const token = {\n            start,\n            length,\n            type: 2 /* NewLine */,\n            comments,\n            newLineType,\n        };\n        return token;\n    }\n    NewLineToken.create = create;\n})(NewLineToken = exports.NewLineToken || (exports.NewLineToken = {}));\nvar KeywordToken;\n(function (KeywordToken) {\n    function create(start, length, keywordType, comments) {\n        const token = {\n            start,\n            length,\n            type: 8 /* Keyword */,\n            comments,\n            keywordType,\n        };\n        return token;\n    }\n    KeywordToken.create = create;\n})(KeywordToken = exports.KeywordToken || (exports.KeywordToken = {}));\nvar StringToken;\n(function (StringToken) {\n    function create(start, length, flags, escapedValue, prefixLength, comments) {\n        const token = {\n            start,\n            length,\n            type: 5 /* String */,\n            flags,\n            escapedValue,\n            prefixLength,\n            quoteMarkLength: flags & 4 /* Triplicate */ ? 3 : 1,\n            comments,\n        };\n        return token;\n    }\n    StringToken.create = create;\n})(StringToken = exports.StringToken || (exports.StringToken = {}));\nvar NumberToken;\n(function (NumberToken) {\n    function create(start, length, value, isInteger, isImaginary, comments) {\n        const token = {\n            start,\n            length,\n            type: 6 /* Number */,\n            isInteger,\n            isImaginary,\n            value,\n            comments,\n        };\n        return token;\n    }\n    NumberToken.create = create;\n})(NumberToken = exports.NumberToken || (exports.NumberToken = {}));\nvar OperatorToken;\n(function (OperatorToken) {\n    function create(start, length, operatorType, comments) {\n        const token = {\n            start,\n            length,\n            type: 9 /* Operator */,\n            operatorType,\n            comments,\n        };\n        return token;\n    }\n    OperatorToken.create = create;\n})(OperatorToken = exports.OperatorToken || (exports.OperatorToken = {}));\nvar IdentifierToken;\n(function (IdentifierToken) {\n    function create(start, length, value, comments) {\n        const token = {\n            start,\n            length,\n            type: 7 /* Identifier */,\n            value,\n            comments,\n        };\n        return token;\n    }\n    IdentifierToken.create = create;\n})(IdentifierToken = exports.IdentifierToken || (exports.IdentifierToken = {}));\n\n\n//# sourceURL=webpack://pyright-server/./src/parser/tokenizerTypes.ts?");

/***/ }),

/***/ "./src/parser/unicode.ts":
/*!*******************************!*\
  !*** ./src/parser/unicode.ts ***!
  \*******************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export unicodeLl [provided] [no usage info] [missing usage info prevents renaming] */
/*! export unicodeLm [provided] [no usage info] [missing usage info prevents renaming] */
/*! export unicodeLo [provided] [no usage info] [missing usage info prevents renaming] */
/*! export unicodeLt [provided] [no usage info] [missing usage info prevents renaming] */
/*! export unicodeLu [provided] [no usage info] [missing usage info prevents renaming] */
/*! export unicodeMc [provided] [no usage info] [missing usage info prevents renaming] */
/*! export unicodeMn [provided] [no usage info] [missing usage info prevents renaming] */
/*! export unicodeNd [provided] [no usage info] [missing usage info prevents renaming] */
/*! export unicodeNl [provided] [no usage info] [missing usage info prevents renaming] */
/*! export unicodePc [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*\n * unicode.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Tables that encode Unicode character codes for various Unicode-\n * defined categories used in the Python spec. These tables were built\n * from the npm package unicode, which contains the same information\n * in a much more verbose form.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unicodePc = exports.unicodeNd = exports.unicodeMc = exports.unicodeMn = exports.unicodeNl = exports.unicodeLm = exports.unicodeLo = exports.unicodeLt = exports.unicodeLl = exports.unicodeLu = void 0;\nexports.unicodeLu = [\n    [65, 90],\n    [192, 214],\n    [216, 222],\n    256,\n    258,\n    260,\n    262,\n    264,\n    266,\n    268,\n    270,\n    272,\n    274,\n    276,\n    278,\n    280,\n    282,\n    284,\n    286,\n    288,\n    290,\n    292,\n    294,\n    296,\n    298,\n    300,\n    302,\n    304,\n    306,\n    308,\n    310,\n    313,\n    315,\n    317,\n    319,\n    321,\n    323,\n    325,\n    327,\n    330,\n    332,\n    334,\n    336,\n    338,\n    340,\n    342,\n    344,\n    346,\n    348,\n    350,\n    352,\n    354,\n    356,\n    358,\n    360,\n    362,\n    364,\n    366,\n    368,\n    370,\n    372,\n    374,\n    [376, 377],\n    379,\n    381,\n    [385, 386],\n    388,\n    [390, 391],\n    [393, 395],\n    [398, 401],\n    [403, 404],\n    [406, 408],\n    [412, 413],\n    [415, 416],\n    418,\n    420,\n    [422, 423],\n    425,\n    428,\n    [430, 431],\n    [433, 435],\n    437,\n    [439, 440],\n    444,\n    452,\n    455,\n    458,\n    461,\n    463,\n    465,\n    467,\n    469,\n    471,\n    473,\n    475,\n    478,\n    480,\n    482,\n    484,\n    486,\n    488,\n    490,\n    492,\n    494,\n    497,\n    500,\n    [502, 504],\n    506,\n    508,\n    510,\n    512,\n    514,\n    516,\n    518,\n    520,\n    522,\n    524,\n    526,\n    528,\n    530,\n    532,\n    534,\n    536,\n    538,\n    540,\n    542,\n    544,\n    546,\n    548,\n    550,\n    552,\n    554,\n    556,\n    558,\n    560,\n    562,\n    [570, 571],\n    [573, 574],\n    577,\n    [579, 582],\n    584,\n    586,\n    588,\n    590,\n    880,\n    882,\n    886,\n    895,\n    902,\n    [904, 906],\n    908,\n    [910, 911],\n    [913, 929],\n    [931, 939],\n    975,\n    [978, 980],\n    984,\n    986,\n    988,\n    990,\n    992,\n    994,\n    996,\n    998,\n    1000,\n    1002,\n    1004,\n    1006,\n    1012,\n    1015,\n    [1017, 1018],\n    [1021, 1071],\n    1120,\n    1122,\n    1124,\n    1126,\n    1128,\n    1130,\n    1132,\n    1134,\n    1136,\n    1138,\n    1140,\n    1142,\n    1144,\n    1146,\n    1148,\n    1150,\n    1152,\n    1162,\n    1164,\n    1166,\n    1168,\n    1170,\n    1172,\n    1174,\n    1176,\n    1178,\n    1180,\n    1182,\n    1184,\n    1186,\n    1188,\n    1190,\n    1192,\n    1194,\n    1196,\n    1198,\n    1200,\n    1202,\n    1204,\n    1206,\n    1208,\n    1210,\n    1212,\n    1214,\n    [1216, 1217],\n    1219,\n    1221,\n    1223,\n    1225,\n    1227,\n    1229,\n    1232,\n    1234,\n    1236,\n    1238,\n    1240,\n    1242,\n    1244,\n    1246,\n    1248,\n    1250,\n    1252,\n    1254,\n    1256,\n    1258,\n    1260,\n    1262,\n    1264,\n    1266,\n    1268,\n    1270,\n    1272,\n    1274,\n    1276,\n    1278,\n    1280,\n    1282,\n    1284,\n    1286,\n    1288,\n    1290,\n    1292,\n    1294,\n    1296,\n    1298,\n    1300,\n    1302,\n    1304,\n    1306,\n    1308,\n    1310,\n    1312,\n    1314,\n    1316,\n    1318,\n    1320,\n    1322,\n    1324,\n    1326,\n    [1329, 1366],\n    [4256, 4293],\n    4295,\n    4301,\n    [5024, 5109],\n    7680,\n    7682,\n    7684,\n    7686,\n    7688,\n    7690,\n    7692,\n    7694,\n    7696,\n    7698,\n    7700,\n    7702,\n    7704,\n    7706,\n    7708,\n    7710,\n    7712,\n    7714,\n    7716,\n    7718,\n    7720,\n    7722,\n    7724,\n    7726,\n    7728,\n    7730,\n    7732,\n    7734,\n    7736,\n    7738,\n    7740,\n    7742,\n    7744,\n    7746,\n    7748,\n    7750,\n    7752,\n    7754,\n    7756,\n    7758,\n    7760,\n    7762,\n    7764,\n    7766,\n    7768,\n    7770,\n    7772,\n    7774,\n    7776,\n    7778,\n    7780,\n    7782,\n    7784,\n    7786,\n    7788,\n    7790,\n    7792,\n    7794,\n    7796,\n    7798,\n    7800,\n    7802,\n    7804,\n    7806,\n    7808,\n    7810,\n    7812,\n    7814,\n    7816,\n    7818,\n    7820,\n    7822,\n    7824,\n    7826,\n    7828,\n    7838,\n    7840,\n    7842,\n    7844,\n    7846,\n    7848,\n    7850,\n    7852,\n    7854,\n    7856,\n    7858,\n    7860,\n    7862,\n    7864,\n    7866,\n    7868,\n    7870,\n    7872,\n    7874,\n    7876,\n    7878,\n    7880,\n    7882,\n    7884,\n    7886,\n    7888,\n    7890,\n    7892,\n    7894,\n    7896,\n    7898,\n    7900,\n    7902,\n    7904,\n    7906,\n    7908,\n    7910,\n    7912,\n    7914,\n    7916,\n    7918,\n    7920,\n    7922,\n    7924,\n    7926,\n    7928,\n    7930,\n    7932,\n    7934,\n    [7944, 7951],\n    [7960, 7965],\n    [7976, 7983],\n    [7992, 7999],\n    [8008, 8013],\n    8025,\n    8027,\n    8029,\n    8031,\n    [8040, 8047],\n    [8120, 8123],\n    [8136, 8139],\n    [8152, 8155],\n    [8168, 8172],\n    [8184, 8187],\n    8450,\n    8455,\n    [8459, 8461],\n    [8464, 8466],\n    8469,\n    [8473, 8477],\n    8484,\n    8486,\n    8488,\n    [8490, 8493],\n    [8496, 8499],\n    [8510, 8511],\n    8517,\n    8579,\n    [11264, 11310],\n    11360,\n    [11362, 11364],\n    11367,\n    11369,\n    11371,\n    [11373, 11376],\n    11378,\n    11381,\n    [11390, 11392],\n    11394,\n    11396,\n    11398,\n    11400,\n    11402,\n    11404,\n    11406,\n    11408,\n    11410,\n    11412,\n    11414,\n    11416,\n    11418,\n    11420,\n    11422,\n    11424,\n    11426,\n    11428,\n    11430,\n    11432,\n    11434,\n    11436,\n    11438,\n    11440,\n    11442,\n    11444,\n    11446,\n    11448,\n    11450,\n    11452,\n    11454,\n    11456,\n    11458,\n    11460,\n    11462,\n    11464,\n    11466,\n    11468,\n    11470,\n    11472,\n    11474,\n    11476,\n    11478,\n    11480,\n    11482,\n    11484,\n    11486,\n    11488,\n    11490,\n    11499,\n    11501,\n    11506,\n    42560,\n    42562,\n    42564,\n    42566,\n    42568,\n    42570,\n    42572,\n    42574,\n    42576,\n    42578,\n    42580,\n    42582,\n    42584,\n    42586,\n    42588,\n    42590,\n    42592,\n    42594,\n    42596,\n    42598,\n    42600,\n    42602,\n    42604,\n    42624,\n    42626,\n    42628,\n    42630,\n    42632,\n    42634,\n    42636,\n    42638,\n    42640,\n    42642,\n    42644,\n    42646,\n    42648,\n    42650,\n    42786,\n    42788,\n    42790,\n    42792,\n    42794,\n    42796,\n    42798,\n    42802,\n    42804,\n    42806,\n    42808,\n    42810,\n    42812,\n    42814,\n    42816,\n    42818,\n    42820,\n    42822,\n    42824,\n    42826,\n    42828,\n    42830,\n    42832,\n    42834,\n    42836,\n    42838,\n    42840,\n    42842,\n    42844,\n    42846,\n    42848,\n    42850,\n    42852,\n    42854,\n    42856,\n    42858,\n    42860,\n    42862,\n    42873,\n    42875,\n    [42877, 42878],\n    42880,\n    42882,\n    42884,\n    42886,\n    42891,\n    42893,\n    42896,\n    42898,\n    42902,\n    42904,\n    42906,\n    42908,\n    42910,\n    42912,\n    42914,\n    42916,\n    42918,\n    42920,\n    [42922, 42926],\n    [42928, 42932],\n    42934,\n    [65313, 65338],\n    [66560, 66599],\n    [66736, 66771],\n    [68736, 68786],\n    [71840, 71871],\n    [119808, 119833],\n    [119860, 119885],\n    [119912, 119937],\n    119964,\n    [119966, 119967],\n    119970,\n    [119973, 119974],\n    [119977, 119980],\n    [119982, 119989],\n    [120016, 120041],\n    [120068, 120069],\n    [120071, 120074],\n    [120077, 120084],\n    [120086, 120092],\n    [120120, 120121],\n    [120123, 120126],\n    [120128, 120132],\n    120134,\n    [120138, 120144],\n    [120172, 120197],\n    [120224, 120249],\n    [120276, 120301],\n    [120328, 120353],\n    [120380, 120405],\n    [120432, 120457],\n    [120488, 120512],\n    [120546, 120570],\n    [120604, 120628],\n    [120662, 120686],\n    [120720, 120744],\n    120778,\n    [125184, 125217],\n];\nexports.unicodeLl = [\n    [97, 122],\n    181,\n    [223, 246],\n    [248, 255],\n    257,\n    259,\n    261,\n    263,\n    265,\n    267,\n    269,\n    271,\n    273,\n    275,\n    277,\n    279,\n    281,\n    283,\n    285,\n    287,\n    289,\n    291,\n    293,\n    295,\n    297,\n    299,\n    301,\n    303,\n    305,\n    307,\n    309,\n    [311, 312],\n    314,\n    316,\n    318,\n    320,\n    322,\n    324,\n    326,\n    [328, 329],\n    331,\n    333,\n    335,\n    337,\n    339,\n    341,\n    343,\n    345,\n    347,\n    349,\n    351,\n    353,\n    355,\n    357,\n    359,\n    361,\n    363,\n    365,\n    367,\n    369,\n    371,\n    373,\n    375,\n    378,\n    380,\n    [382, 384],\n    387,\n    389,\n    392,\n    [396, 397],\n    402,\n    405,\n    [409, 411],\n    414,\n    417,\n    419,\n    421,\n    424,\n    [426, 427],\n    429,\n    432,\n    436,\n    438,\n    [441, 442],\n    [445, 447],\n    454,\n    457,\n    460,\n    462,\n    464,\n    466,\n    468,\n    470,\n    472,\n    474,\n    [476, 477],\n    479,\n    481,\n    483,\n    485,\n    487,\n    489,\n    491,\n    493,\n    [495, 496],\n    499,\n    501,\n    505,\n    507,\n    509,\n    511,\n    513,\n    515,\n    517,\n    519,\n    521,\n    523,\n    525,\n    527,\n    529,\n    531,\n    533,\n    535,\n    537,\n    539,\n    541,\n    543,\n    545,\n    547,\n    549,\n    551,\n    553,\n    555,\n    557,\n    559,\n    561,\n    [563, 569],\n    572,\n    [575, 576],\n    578,\n    583,\n    585,\n    587,\n    589,\n    [591, 659],\n    [661, 687],\n    881,\n    883,\n    887,\n    [891, 893],\n    912,\n    [940, 974],\n    [976, 977],\n    [981, 983],\n    985,\n    987,\n    989,\n    991,\n    993,\n    995,\n    997,\n    999,\n    1001,\n    1003,\n    1005,\n    [1007, 1011],\n    1013,\n    1016,\n    [1019, 1020],\n    [1072, 1119],\n    1121,\n    1123,\n    1125,\n    1127,\n    1129,\n    1131,\n    1133,\n    1135,\n    1137,\n    1139,\n    1141,\n    1143,\n    1145,\n    1147,\n    1149,\n    1151,\n    1153,\n    1163,\n    1165,\n    1167,\n    1169,\n    1171,\n    1173,\n    1175,\n    1177,\n    1179,\n    1181,\n    1183,\n    1185,\n    1187,\n    1189,\n    1191,\n    1193,\n    1195,\n    1197,\n    1199,\n    1201,\n    1203,\n    1205,\n    1207,\n    1209,\n    1211,\n    1213,\n    1215,\n    1218,\n    1220,\n    1222,\n    1224,\n    1226,\n    1228,\n    [1230, 1231],\n    1233,\n    1235,\n    1237,\n    1239,\n    1241,\n    1243,\n    1245,\n    1247,\n    1249,\n    1251,\n    1253,\n    1255,\n    1257,\n    1259,\n    1261,\n    1263,\n    1265,\n    1267,\n    1269,\n    1271,\n    1273,\n    1275,\n    1277,\n    1279,\n    1281,\n    1283,\n    1285,\n    1287,\n    1289,\n    1291,\n    1293,\n    1295,\n    1297,\n    1299,\n    1301,\n    1303,\n    1305,\n    1307,\n    1309,\n    1311,\n    1313,\n    1315,\n    1317,\n    1319,\n    1321,\n    1323,\n    1325,\n    1327,\n    [1377, 1415],\n    [5112, 5117],\n    [7296, 7304],\n    [7424, 7467],\n    [7531, 7543],\n    [7545, 7578],\n    7681,\n    7683,\n    7685,\n    7687,\n    7689,\n    7691,\n    7693,\n    7695,\n    7697,\n    7699,\n    7701,\n    7703,\n    7705,\n    7707,\n    7709,\n    7711,\n    7713,\n    7715,\n    7717,\n    7719,\n    7721,\n    7723,\n    7725,\n    7727,\n    7729,\n    7731,\n    7733,\n    7735,\n    7737,\n    7739,\n    7741,\n    7743,\n    7745,\n    7747,\n    7749,\n    7751,\n    7753,\n    7755,\n    7757,\n    7759,\n    7761,\n    7763,\n    7765,\n    7767,\n    7769,\n    7771,\n    7773,\n    7775,\n    7777,\n    7779,\n    7781,\n    7783,\n    7785,\n    7787,\n    7789,\n    7791,\n    7793,\n    7795,\n    7797,\n    7799,\n    7801,\n    7803,\n    7805,\n    7807,\n    7809,\n    7811,\n    7813,\n    7815,\n    7817,\n    7819,\n    7821,\n    7823,\n    7825,\n    7827,\n    [7829, 7837],\n    7839,\n    7841,\n    7843,\n    7845,\n    7847,\n    7849,\n    7851,\n    7853,\n    7855,\n    7857,\n    7859,\n    7861,\n    7863,\n    7865,\n    7867,\n    7869,\n    7871,\n    7873,\n    7875,\n    7877,\n    7879,\n    7881,\n    7883,\n    7885,\n    7887,\n    7889,\n    7891,\n    7893,\n    7895,\n    7897,\n    7899,\n    7901,\n    7903,\n    7905,\n    7907,\n    7909,\n    7911,\n    7913,\n    7915,\n    7917,\n    7919,\n    7921,\n    7923,\n    7925,\n    7927,\n    7929,\n    7931,\n    7933,\n    [7935, 7943],\n    [7952, 7957],\n    [7968, 7975],\n    [7984, 7991],\n    [8000, 8005],\n    [8016, 8023],\n    [8032, 8039],\n    [8048, 8061],\n    [8064, 8071],\n    [8080, 8087],\n    [8096, 8103],\n    [8112, 8116],\n    [8118, 8119],\n    8126,\n    [8130, 8132],\n    [8134, 8135],\n    [8144, 8147],\n    [8150, 8151],\n    [8160, 8167],\n    [8178, 8180],\n    [8182, 8183],\n    8458,\n    [8462, 8463],\n    8467,\n    8495,\n    8500,\n    8505,\n    [8508, 8509],\n    [8518, 8521],\n    8526,\n    8580,\n    [11312, 11358],\n    11361,\n    [11365, 11366],\n    11368,\n    11370,\n    11372,\n    11377,\n    [11379, 11380],\n    [11382, 11387],\n    11393,\n    11395,\n    11397,\n    11399,\n    11401,\n    11403,\n    11405,\n    11407,\n    11409,\n    11411,\n    11413,\n    11415,\n    11417,\n    11419,\n    11421,\n    11423,\n    11425,\n    11427,\n    11429,\n    11431,\n    11433,\n    11435,\n    11437,\n    11439,\n    11441,\n    11443,\n    11445,\n    11447,\n    11449,\n    11451,\n    11453,\n    11455,\n    11457,\n    11459,\n    11461,\n    11463,\n    11465,\n    11467,\n    11469,\n    11471,\n    11473,\n    11475,\n    11477,\n    11479,\n    11481,\n    11483,\n    11485,\n    11487,\n    11489,\n    [11491, 11492],\n    11500,\n    11502,\n    11507,\n    [11520, 11557],\n    11559,\n    11565,\n    42561,\n    42563,\n    42565,\n    42567,\n    42569,\n    42571,\n    42573,\n    42575,\n    42577,\n    42579,\n    2581,\n    42583,\n    42585,\n    42587,\n    42589,\n    42591,\n    42593,\n    42595,\n    42597,\n    42599,\n    42601,\n    42603,\n    42605,\n    42625,\n    42627,\n    42629,\n    42631,\n    42633,\n    42635,\n    42637,\n    42639,\n    42641,\n    42643,\n    42645,\n    42647,\n    42649,\n    42651,\n    42787,\n    42789,\n    42791,\n    42793,\n    42795,\n    42797,\n    [42799, 42801],\n    42803,\n    42805,\n    42807,\n    42809,\n    42811,\n    42813,\n    42815,\n    42817,\n    42819,\n    42821,\n    42823,\n    42825,\n    42827,\n    42829,\n    42831,\n    42833,\n    42835,\n    42837,\n    42839,\n    42841,\n    42843,\n    42845,\n    42847,\n    42849,\n    42851,\n    42853,\n    42855,\n    42857,\n    42859,\n    42861,\n    42863,\n    [42865, 42872],\n    42874,\n    42876,\n    42879,\n    42881,\n    42883,\n    42885,\n    42887,\n    42892,\n    42894,\n    42897,\n    [42899, 42901],\n    42903,\n    42905,\n    42907,\n    42909,\n    42911,\n    42913,\n    42915,\n    42917,\n    42919,\n    42921,\n    42933,\n    42935,\n    43002,\n    [43824, 43866],\n    [43872, 43877],\n    [43888, 43967],\n    [64256, 64262],\n    [64275, 64279],\n    [65345, 65370],\n    [66600, 66639],\n    [66776, 66811],\n    [68800, 68850],\n    [71872, 71903],\n    [119834, 119859],\n    [119886, 119892],\n    [119894, 119911],\n    [119938, 119963],\n    [119990, 119993],\n    119995,\n    [119997, 120003],\n    [120005, 120015],\n    [120042, 120067],\n    [120094, 120119],\n    [120146, 120171],\n    [120198, 120223],\n    [120250, 120275],\n    [120302, 120327],\n    [120354, 120379],\n    [120406, 120431],\n    [120458, 120485],\n    [120514, 120538],\n    [120540, 120545],\n    [120572, 120596],\n    [120598, 120603],\n    [120630, 120654],\n    [120656, 120661],\n    [120688, 120712],\n    [120714, 120719],\n    [120746, 120770],\n    [120772, 120777],\n    120779,\n    [125218, 125251],\n];\nexports.unicodeLt = [\n    453,\n    456,\n    459,\n    498,\n    [8072, 8079],\n    [8088, 8095],\n    [8104, 8111],\n    8124,\n    8140,\n    8188,\n];\nexports.unicodeLo = [\n    170,\n    186,\n    443,\n    [448, 451],\n    660,\n    [1488, 1514],\n    [1520, 1522],\n    [1568, 1599],\n    [1601, 1610],\n    [1646, 1647],\n    [1649, 1747],\n    1749,\n    [1774, 1775],\n    [1786, 1788],\n    1791,\n    1808,\n    [1810, 1839],\n    [1869, 1957],\n    1969,\n    [1994, 2026],\n    [2048, 2069],\n    [2112, 2136],\n    [2144, 2154],\n    [2208, 2228],\n    [2230, 2237],\n    [2308, 2361],\n    2365,\n    2384,\n    [2392, 2401],\n    [2418, 2432],\n    [2437, 2444],\n    [2447, 2448],\n    [2451, 2472],\n    [2474, 2480],\n    2482,\n    [2486, 2489],\n    2493,\n    2510,\n    [2524, 2525],\n    [2527, 2529],\n    [2544, 2545],\n    2556,\n    [2565, 2570],\n    [2575, 2576],\n    [2579, 2600],\n    [2602, 2608],\n    [2610, 2611],\n    [2613, 2614],\n    [2616, 2617],\n    [2649, 2652],\n    2654,\n    [2674, 2676],\n    [2693, 2701],\n    [2703, 2705],\n    [2707, 2728],\n    [2730, 2736],\n    [2738, 2739],\n    [2741, 2745],\n    2749,\n    2768,\n    [2784, 2785],\n    2809,\n    [2821, 2828],\n    [2831, 2832],\n    [2835, 2856],\n    [2858, 2864],\n    [2866, 2867],\n    [2869, 2873],\n    2877,\n    [2908, 2909],\n    [2911, 2913],\n    2929,\n    2947,\n    [2949, 2954],\n    [2958, 2960],\n    [2962, 2965],\n    [2969, 2970],\n    2972,\n    [2974, 2975],\n    [2979, 2980],\n    [2984, 2986],\n    [2990, 3001],\n    3024,\n    [3077, 3084],\n    [3086, 3088],\n    [3090, 3112],\n    [3114, 3129],\n    3133,\n    [3160, 3162],\n    [3168, 3169],\n    3200,\n    [3205, 3212],\n    [3214, 3216],\n    [3218, 3240],\n    [3242, 3251],\n    [3253, 3257],\n    3261,\n    3294,\n    [3296, 3297],\n    [3313, 3314],\n    [3333, 3340],\n    [3342, 3344],\n    [3346, 3386],\n    3389,\n    3406,\n    [3412, 3414],\n    [3423, 3425],\n    [3450, 3455],\n    [3461, 3478],\n    [3482, 3505],\n    [3507, 3515],\n    3517,\n    [3520, 3526],\n    [3585, 3632],\n    [3634, 3635],\n    [3648, 3653],\n    [3713, 3714],\n    3716,\n    [3719, 3720],\n    3722,\n    3725,\n    [3732, 3735],\n    [3737, 3743],\n    [3745, 3747],\n    3749,\n    3751,\n    [3754, 3755],\n    [3757, 3760],\n    [3762, 3763],\n    3773,\n    [3776, 3780],\n    [3804, 3807],\n    3840,\n    [3904, 3911],\n    [3913, 3948],\n    [3976, 3980],\n    [4096, 4138],\n    4159,\n    [4176, 4181],\n    [4186, 4189],\n    4193,\n    [4197, 4198],\n    [4206, 4208],\n    [4213, 4225],\n    4238,\n    [4304, 4346],\n    [4349, 4680],\n    [4682, 4685],\n    [4688, 4694],\n    4696,\n    [4698, 4701],\n    [4704, 4744],\n    [4746, 4749],\n    [4752, 4784],\n    [4786, 4789],\n    [4792, 4798],\n    4800,\n    [4802, 4805],\n    [4808, 4822],\n    [4824, 4880],\n    [4882, 4885],\n    [4888, 4954],\n    [4992, 5007],\n    [5121, 5740],\n    [5743, 5759],\n    [5761, 5786],\n    [5792, 5866],\n    [5873, 5880],\n    [5888, 5900],\n    [5902, 5905],\n    [5920, 5937],\n    [5952, 5969],\n    [5984, 5996],\n    [5998, 6000],\n    [6016, 6067],\n    6108,\n    [6176, 6210],\n    [6212, 6263],\n    [6272, 6276],\n    [6279, 6312],\n    6314,\n    [6320, 6389],\n    [6400, 6430],\n    [6480, 6509],\n    [6512, 6516],\n    [6528, 6571],\n    [6576, 6601],\n    [6656, 6678],\n    [6688, 6740],\n    [6917, 6963],\n    [6981, 6987],\n    [7043, 7072],\n    [7086, 7087],\n    [7098, 7141],\n    [7168, 7203],\n    [7245, 7247],\n    [7258, 7287],\n    [7401, 7404],\n    [7406, 7409],\n    [7413, 7414],\n    [8501, 8504],\n    [11568, 11623],\n    [11648, 11670],\n    [11680, 11686],\n    [11688, 11694],\n    [11696, 11702],\n    [11704, 11710],\n    [11712, 11718],\n    [11720, 11726],\n    [11728, 11734],\n    [11736, 11742],\n    12294,\n    12348,\n    [12353, 12438],\n    12447,\n    [12449, 12538],\n    12543,\n    [12549, 12590],\n    [12593, 12686],\n    [12704, 12730],\n    [12784, 12799],\n    [13312, 19893],\n    [19968, 40938],\n    [40960, 40980],\n    [40982, 42124],\n    [42192, 42231],\n    [42240, 42507],\n    [42512, 42527],\n    [42538, 42539],\n    42606,\n    [42656, 42725],\n    42895,\n    42999,\n    [43003, 43009],\n    [43011, 43013],\n    [43015, 43018],\n    [43020, 43042],\n    [43072, 43123],\n    [43138, 43187],\n    [43250, 43255],\n    43259,\n    43261,\n    [43274, 43301],\n    [43312, 43334],\n    [43360, 43388],\n    [43396, 43442],\n    [43488, 43492],\n    [43495, 43503],\n    [43514, 43518],\n    [43520, 43560],\n    [43584, 43586],\n    [43588, 43595],\n    [43616, 43631],\n    [43633, 43638],\n    43642,\n    [43646, 43695],\n    43697,\n    [43701, 43702],\n    [43705, 43709],\n    43712,\n    43714,\n    [43739, 43740],\n    [43744, 43754],\n    43762,\n    [43777, 43782],\n    [43785, 43790],\n    [43793, 43798],\n    [43808, 43814],\n    [43816, 43822],\n    [43968, 44002],\n    [44032, 55203],\n    [55216, 55238],\n    [55243, 55291],\n    [63744, 64109],\n    [64112, 64217],\n    64285,\n    [64287, 64296],\n    [64298, 64310],\n    [64312, 64316],\n    64318,\n    [64320, 64321],\n    [64323, 64324],\n    [64326, 64433],\n    [64467, 64829],\n    [64848, 64911],\n    [64914, 64967],\n    [65008, 65019],\n    [65136, 65140],\n    [65142, 65276],\n    [65382, 65391],\n    [65393, 65437],\n    [65440, 65470],\n    [65474, 65479],\n    [65482, 65487],\n    [65490, 65495],\n    [65498, 65500],\n    [65536, 65547],\n    [65549, 65574],\n    [65576, 65594],\n    [65596, 65597],\n    [65599, 65613],\n    [65616, 65629],\n    [65664, 65786],\n    [66176, 66204],\n    [66208, 66256],\n    [66304, 66335],\n    [66349, 66368],\n    [66370, 66377],\n    [66384, 66421],\n    [66432, 66461],\n    [66464, 66499],\n    [66504, 66511],\n    [66640, 66717],\n    [66816, 66855],\n    [66864, 66915],\n    [67072, 67382],\n    [67392, 67413],\n    [67424, 67431],\n    [67584, 67589],\n    67592,\n    [67594, 67637],\n    [67639, 67640],\n    67644,\n    [67647, 67669],\n    [67680, 67702],\n    [67712, 67742],\n    [67808, 67826],\n    [67828, 67829],\n    [67840, 67861],\n    [67872, 67897],\n    [67968, 68023],\n    [68030, 68031],\n    68096,\n    [68112, 68115],\n    [68117, 68119],\n    [68121, 68147],\n    [68192, 68220],\n    [68224, 68252],\n    [68288, 68295],\n    [68297, 68324],\n    [68352, 68405],\n    [68416, 68437],\n    [68448, 68466],\n    [68480, 68497],\n    [68608, 68680],\n    [69635, 69687],\n    [69763, 69807],\n    [69840, 69864],\n    [69891, 69926],\n    [69968, 70002],\n    70006,\n    [70019, 70066],\n    [70081, 70084],\n    70106,\n    70108,\n    [70144, 70161],\n    [70163, 70187],\n    [70272, 70278],\n    70280,\n    [70282, 70285],\n    [70287, 70301],\n    [70303, 70312],\n    [70320, 70366],\n    [70405, 70412],\n    [70415, 70416],\n    [70419, 70440],\n    [70442, 70448],\n    [70450, 70451],\n    [70453, 70457],\n    70461,\n    70480,\n    [70493, 70497],\n    [70656, 70708],\n    [70727, 70730],\n    [70784, 70831],\n    [70852, 70853],\n    70855,\n    [71040, 71086],\n    [71128, 71131],\n    [71168, 71215],\n    71236,\n    [71296, 71338],\n    [71424, 71449],\n    71935,\n    72192,\n    [72203, 72242],\n    72250,\n    72272,\n    [72284, 72323],\n    [72326, 72329],\n    [72384, 72440],\n    [72704, 72712],\n    [72714, 72750],\n    72768,\n    [72818, 72847],\n    [72960, 72966],\n    [72968, 72969],\n    [72971, 73008],\n    73030,\n    [73728, 74649],\n    [74880, 75075],\n    [77824, 78894],\n    [82944, 83526],\n    [92160, 92728],\n    [92736, 92766],\n    [92880, 92909],\n    [92928, 92975],\n    [93027, 93047],\n    [93053, 93071],\n    [93952, 94020],\n    94032,\n    [94208, 100332],\n    [100352, 101106],\n    [110592, 110878],\n    [110960, 111355],\n    [113664, 113770],\n    [113776, 113788],\n    [113792, 113800],\n    [113808, 113817],\n    [124928, 125124],\n    [126464, 126467],\n    [126469, 126495],\n    [126497, 126498],\n    126500,\n    126503,\n    [126505, 126514],\n    [126516, 126519],\n    126521,\n    126523,\n    126530,\n    126535,\n    126537,\n    126539,\n    [126541, 126543],\n    [126545, 126546],\n    126548,\n    126551,\n    126553,\n    126555,\n    126557,\n    126559,\n    [126561, 126562],\n    126564,\n    [126567, 126570],\n    [126572, 126578],\n    [126580, 126583],\n    [126585, 126588],\n    126590,\n    [126592, 126601],\n    [126603, 126619],\n    [126625, 126627],\n    [126629, 126633],\n    [126635, 126651],\n    [131072, 173782],\n    [173824, 177972],\n    [177984, 178205],\n    [178208, 183969],\n    [183984, 191456],\n    [194560, 195101],\n];\nexports.unicodeLm = [\n    [688, 705],\n    [710, 721],\n    [736, 740],\n    748,\n    750,\n    884,\n    890,\n    1369,\n    1600,\n    [1765, 1766],\n    [2036, 2037],\n    2042,\n    2074,\n    2084,\n    2088,\n    2417,\n    3654,\n    3782,\n    4348,\n    6103,\n    6211,\n    6823,\n    [7288, 7293],\n    [7468, 7530],\n    7544,\n    [7579, 7615],\n    8305,\n    8319,\n    [8336, 8348],\n    [11388, 11389],\n    11631,\n    11823,\n    12293,\n    [12337, 12341],\n    12347,\n    [12445, 12446],\n    [12540, 12542],\n    40981,\n    [42232, 42237],\n    42508,\n    42623,\n    [42652, 42653],\n    [42775, 42783],\n    42864,\n    42888,\n    [43000, 43001],\n    43471,\n    43494,\n    43632,\n    43741,\n    [43763, 43764],\n    [43868, 43871],\n    65392,\n    [65438, 65439],\n    [92992, 92995],\n    [94099, 94111],\n    [94176, 94177],\n];\nexports.unicodeNl = [\n    [5870, 5872],\n    [8544, 8578],\n    [8581, 8584],\n    12295,\n    [12321, 12329],\n    [12344, 12346],\n    [42726, 42735],\n    [65856, 65908],\n    66369,\n    66378,\n    [66513, 66517],\n    [74752, 74862],\n];\nexports.unicodeMn = [\n    [768, 879],\n    [1155, 1159],\n    [1425, 1469],\n    1471,\n    [1473, 1474],\n    [1476, 1477],\n    1479,\n    [1552, 1562],\n    [1611, 1631],\n    1648,\n    [1750, 1756],\n    [1759, 1764],\n    [1767, 1768],\n    [1770, 1773],\n    1809,\n    [1840, 1866],\n    [1958, 1968],\n    [2027, 2035],\n    [2070, 2073],\n    [2075, 2083],\n    [2085, 2087],\n    [2089, 2093],\n    [2137, 2139],\n    [2260, 2273],\n    [2275, 2306],\n    2362,\n    2364,\n    [2369, 2376],\n    2381,\n    [2385, 2391],\n    [2402, 2403],\n    2433,\n    2492,\n    [2497, 2500],\n    2509,\n    [2530, 2531],\n    [2561, 2562],\n    2620,\n    [2625, 2626],\n    [2631, 2632],\n    [2635, 2637],\n    2641,\n    [2672, 2673],\n    2677,\n    [2689, 2690],\n    2748,\n    [2753, 2757],\n    [2759, 2760],\n    2765,\n    [2786, 2787],\n    [2810, 2815],\n    2817,\n    2876,\n    2879,\n    [2881, 2884],\n    2893,\n    2902,\n    [2914, 2915],\n    2946,\n    3008,\n    3021,\n    3072,\n    [3134, 3136],\n    [3142, 3144],\n    [3146, 3149],\n    [3157, 3158],\n    [3170, 3171],\n    3201,\n    3260,\n    3263,\n    3270,\n    [3276, 3277],\n    [3298, 3299],\n    [3328, 3329],\n    [3387, 3388],\n    [3393, 3396],\n    3405,\n    [3426, 3427],\n    3530,\n    [3538, 3540],\n    3542,\n    3633,\n    [3636, 3642],\n    [3655, 3662],\n    3761,\n    [3764, 3769],\n    [3771, 3772],\n    [3784, 3789],\n    [3864, 3865],\n    3893,\n    3895,\n    3897,\n    [3953, 3966],\n    [3968, 3972],\n    [3974, 3975],\n    [3981, 3991],\n    [3993, 4028],\n    4038,\n    [4141, 4144],\n    [4146, 4151],\n    [4153, 4154],\n    [4157, 4158],\n    [4184, 4185],\n    [4190, 4192],\n    [4209, 4212],\n    4226,\n    [4229, 4230],\n    4237,\n    4253,\n    [4957, 4959],\n    [5906, 5908],\n    [5938, 5940],\n    [5970, 5971],\n    [6002, 6003],\n    [6068, 6069],\n    [6071, 6077],\n    6086,\n    [6089, 6099],\n    6109,\n    [6155, 6157],\n    [6277, 6278],\n    6313,\n    [6432, 6434],\n    [6439, 6440],\n    6450,\n    [6457, 6459],\n    [6679, 6680],\n    6683,\n    6742,\n    [6744, 6750],\n    6752,\n    6754,\n    [6757, 6764],\n    [6771, 6780],\n    6783,\n    [6832, 6845],\n    [6912, 6915],\n    6964,\n    [6966, 6970],\n    6972,\n    6978,\n    [7019, 7027],\n    [7040, 7041],\n    [7074, 7077],\n    [7080, 7081],\n    [7083, 7085],\n    7142,\n    [7144, 7145],\n    7149,\n    [7151, 7153],\n    [7212, 7219],\n    [7222, 7223],\n    [7376, 7378],\n    [7380, 7392],\n    [7394, 7400],\n    7405,\n    7412,\n    [7416, 7417],\n    [7616, 7673],\n    [7675, 7679],\n    [8400, 8412],\n    8417,\n    [8421, 8432],\n    [11503, 11505],\n    11647,\n    [11744, 11775],\n    [12330, 12333],\n    [12441, 12442],\n    42607,\n    [42612, 42621],\n    [42654, 42655],\n    [42736, 42737],\n    43010,\n    43014,\n    43019,\n    [43045, 43046],\n    [43204, 43205],\n    [43232, 43249],\n    [43302, 43309],\n    [43335, 43345],\n    [43392, 43394],\n    43443,\n    [43446, 43449],\n    43452,\n    43493,\n    [43561, 43566],\n    [43569, 43570],\n    [43573, 43574],\n    43587,\n    43596,\n    43644,\n    43696,\n    [43698, 43700],\n    [43703, 43704],\n    [43710, 43711],\n    43713,\n    [43756, 43757],\n    43766,\n    44005,\n    44008,\n    44013,\n    64286,\n    [65024, 65039],\n    [65056, 65071],\n    66045,\n    66272,\n    [66422, 66426],\n    [68097, 68099],\n    [68101, 68102],\n    [68108, 68111],\n    [68152, 68154],\n    68159,\n    [68325, 68326],\n    69633,\n    [69688, 69702],\n    [69759, 69761],\n    [69811, 69814],\n    [69817, 69818],\n    [69888, 69890],\n    [69927, 69931],\n    [69933, 69940],\n    70003,\n    [70016, 70017],\n    [70070, 70078],\n    [70090, 70092],\n    [70191, 70193],\n    70196,\n    [70198, 70199],\n    70206,\n    70367,\n    [70371, 70378],\n    [70400, 70401],\n    70460,\n    70464,\n    [70502, 70508],\n    [70512, 70516],\n    [70712, 70719],\n    [70722, 70724],\n    70726,\n    [70835, 70840],\n    70842,\n    [70847, 70848],\n    [70850, 70851],\n    [71090, 71093],\n    [71100, 71101],\n    [71103, 71104],\n    [71132, 71133],\n    [71219, 71226],\n    71229,\n    [71231, 71232],\n    71339,\n    71341,\n    [71344, 71349],\n    71351,\n    [71453, 71455],\n    [71458, 71461],\n    [71463, 71467],\n    [72193, 72198],\n    [72201, 72202],\n    [72243, 72248],\n    [72251, 72254],\n    72263,\n    [72273, 72278],\n    [72281, 72283],\n    [72330, 72342],\n    [72344, 72345],\n    [72752, 72758],\n    [72760, 72765],\n    72767,\n    [72850, 72871],\n    [72874, 72880],\n    [72882, 72883],\n    [72885, 72886],\n    [73009, 73014],\n    73018,\n    [73020, 73021],\n    [73023, 73029],\n    73031,\n    [92912, 92916],\n    [92976, 92982],\n    [94095, 94098],\n    [113821, 113822],\n    [119143, 119145],\n    [119163, 119170],\n    [119173, 119179],\n    [119210, 119213],\n    [119362, 119364],\n    [121344, 121398],\n    [121403, 121452],\n    121461,\n    121476,\n    [121499, 121503],\n    [121505, 121519],\n    [122880, 122886],\n    [122888, 122904],\n    [122907, 122913],\n    [122915, 122916],\n    [122918, 122922],\n    [125136, 125142],\n    [125252, 125258],\n    [917760, 917999],\n];\nexports.unicodeMc = [\n    2307,\n    2363,\n    [2366, 2368],\n    [2377, 2380],\n    [2382, 2383],\n    [2434, 2435],\n    [2494, 2496],\n    [2503, 2504],\n    [2507, 2508],\n    2519,\n    2563,\n    [2622, 2624],\n    2691,\n    [2750, 2752],\n    2761,\n    [2763, 2764],\n    [2818, 2819],\n    2878,\n    2880,\n    [2887, 2888],\n    [2891, 2892],\n    2903,\n    [3006, 3007],\n    [3009, 3010],\n    [3014, 3016],\n    [3018, 3020],\n    3031,\n    [3073, 3075],\n    [3137, 3140],\n    [3202, 3203],\n    3262,\n    [3264, 3268],\n    [3271, 3272],\n    [3274, 3275],\n    [3285, 3286],\n    [3330, 3331],\n    [3390, 3392],\n    [3398, 3400],\n    [3402, 3404],\n    3415,\n    [3458, 3459],\n    [3535, 3537],\n    [3544, 3551],\n    [3570, 3571],\n    [3902, 3903],\n    3967,\n    [4139, 4140],\n    4145,\n    4152,\n    [4155, 4156],\n    [4182, 4183],\n    [4194, 4196],\n    [4199, 4205],\n    [4227, 4228],\n    [4231, 4236],\n    4239,\n    [4250, 4252],\n    6070,\n    [6078, 6085],\n    [6087, 6088],\n    [6435, 6438],\n    [6441, 6443],\n    [6448, 6449],\n    [6451, 6456],\n    [6681, 6682],\n    6741,\n    6743,\n    6753,\n    [6755, 6756],\n    [6765, 6770],\n    6916,\n    6965,\n    6971,\n    [6973, 6977],\n    [6979, 6980],\n    7042,\n    7073,\n    [7078, 7079],\n    7082,\n    7143,\n    [7146, 7148],\n    7150,\n    [7154, 7155],\n    [7204, 7211],\n    [7220, 7221],\n    7393,\n    [7410, 7411],\n    7415,\n    [12334, 12335],\n    [43043, 43044],\n    43047,\n    [43136, 43137],\n    [43188, 43203],\n    [43346, 43347],\n    43395,\n    [43444, 43445],\n    [43450, 43451],\n    [43453, 43456],\n    [43567, 43568],\n    [43571, 43572],\n    43597,\n    43643,\n    43645,\n    43755,\n    [43758, 43759],\n    43765,\n    [44003, 44004],\n    [44006, 44007],\n    [44009, 44010],\n    44012,\n    69632,\n    69634,\n    69762,\n    [69808, 69810],\n    [69815, 69816],\n    69932,\n    70018,\n    [70067, 70069],\n    [70079, 70080],\n    [70188, 70190],\n    [70194, 70195],\n    70197,\n    [70368, 70370],\n    [70402, 70403],\n    [70462, 70463],\n    [70465, 70468],\n    [70471, 70472],\n    [70475, 70477],\n    70487,\n    [70498, 70499],\n    [70709, 70711],\n    [70720, 70721],\n    70725,\n    [70832, 70834],\n    70841,\n    [70843, 70846],\n    70849,\n    [71087, 71089],\n    [71096, 71099],\n    71102,\n    [71216, 71218],\n    [71227, 71228],\n    71230,\n    71340,\n    [71342, 71343],\n    71350,\n    [71456, 71457],\n    71462,\n    [72199, 72200],\n    72249,\n    [72279, 72280],\n    72343,\n    72751,\n    72766,\n    72873,\n    72881,\n    72884,\n    [94033, 94078],\n    [119141, 119142],\n    [119149, 119154],\n];\nexports.unicodeNd = [\n    [48, 57],\n    [1632, 1641],\n    [1776, 1785],\n    [1984, 1993],\n    [2406, 2415],\n    [2534, 2543],\n    [2662, 2671],\n    [2790, 2799],\n    [2918, 2927],\n    [3046, 3055],\n    [3174, 3183],\n    [3302, 3311],\n    [3430, 3439],\n    [3558, 3567],\n    [3664, 3673],\n    [3792, 3801],\n    [3872, 3881],\n    [4160, 4169],\n    [4240, 4249],\n    [6112, 6121],\n    [6160, 6169],\n    [6470, 6479],\n    [6608, 6617],\n    [6784, 6793],\n    [6800, 6809],\n    [6992, 7001],\n    [7088, 7097],\n    [7232, 7241],\n    [7248, 7257],\n    [42528, 42537],\n    [43216, 43225],\n    [43264, 43273],\n    [43472, 43481],\n    [43504, 43513],\n    [43600, 43609],\n    [44016, 44025],\n    [65296, 65305],\n    [66720, 66729],\n    [69734, 69743],\n    [69872, 69881],\n    [69942, 69951],\n    [70096, 70105],\n    [70384, 70393],\n    [70736, 70745],\n    [70864, 70873],\n    [71248, 71257],\n    [71360, 71369],\n    [71472, 71481],\n    [71904, 71913],\n    [72784, 72793],\n    [73040, 73049],\n    [92768, 92777],\n    [93008, 93017],\n    [120782, 120831],\n    [125264, 125273],\n];\nexports.unicodePc = [95, [8255, 8256], 8276, [65075, 65076], [65101, 65103], 65343];\n\n\n//# sourceURL=webpack://pyright-server/./src/parser/unicode.ts?");

/***/ }),

/***/ "./src/server.ts":
/*!***********************!*\
  !*** ./src/server.ts ***!
  \***********************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: top-level-this-exports, __webpack_exports__, __webpack_require__ */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * server.ts\n *\n * Implements pyright language server.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst node_1 = __webpack_require__(/*! vscode-languageserver/node */ \"./node_modules/vscode-languageserver/node.js\");\nconst worker_threads_1 = __webpack_require__(/*! worker_threads */ \"worker_threads\");\nconst backgroundAnalysis_1 = __webpack_require__(/*! ./backgroundAnalysis */ \"./src/backgroundAnalysis.ts\");\nconst commandController_1 = __webpack_require__(/*! ./commands/commandController */ \"./src/commands/commandController.ts\");\nconst cancellationUtils_1 = __webpack_require__(/*! ./common/cancellationUtils */ \"./src/common/cancellationUtils.ts\");\nconst console_1 = __webpack_require__(/*! ./common/console */ \"./src/common/console.ts\");\nconst core_1 = __webpack_require__(/*! ./common/core */ \"./src/common/core.ts\");\nconst pathUtils_1 = __webpack_require__(/*! ./common/pathUtils */ \"./src/common/pathUtils.ts\");\nconst languageServerBase_1 = __webpack_require__(/*! ./languageServerBase */ \"./src/languageServerBase.ts\");\nconst codeActionProvider_1 = __webpack_require__(/*! ./languageService/codeActionProvider */ \"./src/languageService/codeActionProvider.ts\");\nconst maxAnalysisTimeInForeground = { openFilesTimeInMs: 50, noOpenFilesTimeInMs: 200 };\nclass PyrightServer extends languageServerBase_1.LanguageServerBase {\n    constructor() {\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        const version = __webpack_require__(/*! ../package.json */ \"./package.json\").version || '';\n        // When executed from CLI command (pyright-langserver), __rootDirectory is\n        // already defined. When executed from VSCode extension, rootDirectory should\n        // be the parent directory of __dirname.\n        const rootDirectory = global.__rootDirectory || pathUtils_1.getDirectoryPath(__dirname);\n        super({\n            productName: 'Pyright',\n            rootDirectory,\n            version,\n            maxAnalysisTimeInForeground,\n            progressReporterFactory: reporterFactory,\n            supportedCodeActions: [node_1.CodeActionKind.QuickFix, node_1.CodeActionKind.SourceOrganizeImports],\n        });\n        this._controller = new commandController_1.CommandController(this);\n    }\n    getSettings(workspace) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const serverSettings = {\n                watchForSourceChanges: true,\n                openFilesOnly: true,\n                useLibraryCodeForTypes: false,\n                disableLanguageServices: false,\n                disableOrganizeImports: false,\n                typeCheckingMode: 'basic',\n                diagnosticSeverityOverrides: {},\n                logLevel: console_1.LogLevel.Info,\n                autoImportCompletions: true,\n            };\n            try {\n                const pythonSection = yield this.getConfiguration(workspace, 'python');\n                if (pythonSection) {\n                    serverSettings.pythonPath = pathUtils_1.normalizeSlashes(pythonSection.pythonPath);\n                    serverSettings.venvPath = pathUtils_1.normalizeSlashes(pythonSection.venvPath);\n                }\n                const pythonAnalysisSection = yield this.getConfiguration(workspace, 'python.analysis');\n                if (pythonAnalysisSection) {\n                    const typeshedPaths = pythonAnalysisSection.typeshedPaths;\n                    if (typeshedPaths && util_1.isArray(typeshedPaths) && typeshedPaths.length > 0) {\n                        serverSettings.typeshedPath = pathUtils_1.normalizeSlashes(typeshedPaths[0]);\n                    }\n                    const stubPath = pythonAnalysisSection.stubPath;\n                    if (stubPath && core_1.isString(stubPath)) {\n                        serverSettings.stubPath = pathUtils_1.normalizeSlashes(stubPath);\n                    }\n                    const diagnosticSeverityOverrides = pythonAnalysisSection.diagnosticSeverityOverrides;\n                    if (diagnosticSeverityOverrides) {\n                        for (const [name, value] of Object.entries(diagnosticSeverityOverrides)) {\n                            const ruleName = this.getDiagnosticRuleName(name);\n                            const severity = this.getSeverityOverrides(value);\n                            if (ruleName && severity) {\n                                serverSettings.diagnosticSeverityOverrides[ruleName] = severity;\n                            }\n                        }\n                    }\n                    if (pythonAnalysisSection.diagnosticMode !== undefined) {\n                        serverSettings.openFilesOnly = this.isOpenFilesOnly(pythonAnalysisSection.diagnosticMode);\n                    }\n                    else if (pythonAnalysisSection.openFilesOnly !== undefined) {\n                        serverSettings.openFilesOnly = !!pythonAnalysisSection.openFilesOnly;\n                    }\n                    if (pythonAnalysisSection.useLibraryCodeForTypes !== undefined) {\n                        serverSettings.useLibraryCodeForTypes = !!pythonAnalysisSection.useLibraryCodeForTypes;\n                    }\n                    serverSettings.logLevel = this.convertLogLevel(pythonAnalysisSection.logLevel);\n                    serverSettings.autoSearchPaths = !!pythonAnalysisSection.autoSearchPaths;\n                    const extraPaths = pythonAnalysisSection.extraPaths;\n                    if (extraPaths && util_1.isArray(extraPaths) && extraPaths.length > 0) {\n                        serverSettings.extraPaths = extraPaths.map((p) => pathUtils_1.normalizeSlashes(p));\n                    }\n                    if (pythonAnalysisSection.typeCheckingMode !== undefined) {\n                        serverSettings.typeCheckingMode = pythonAnalysisSection.typeCheckingMode;\n                    }\n                    if (pythonAnalysisSection.autoImportCompletions !== undefined) {\n                        serverSettings.autoImportCompletions = pythonAnalysisSection.autoImportCompletions;\n                    }\n                }\n                else {\n                    serverSettings.autoSearchPaths = true;\n                }\n                const pyrightSection = yield this.getConfiguration(workspace, 'pyright');\n                if (pyrightSection) {\n                    if (pyrightSection.openFilesOnly !== undefined) {\n                        serverSettings.openFilesOnly = !!pyrightSection.openFilesOnly;\n                    }\n                    if (pyrightSection.useLibraryCodeForTypes !== undefined) {\n                        serverSettings.useLibraryCodeForTypes = !!pyrightSection.useLibraryCodeForTypes;\n                    }\n                    serverSettings.disableLanguageServices = !!pyrightSection.disableLanguageServices;\n                    serverSettings.disableOrganizeImports = !!pyrightSection.disableOrganizeImports;\n                    if (pyrightSection.typeCheckingMode !== undefined) {\n                        serverSettings.typeCheckingMode = pyrightSection.typeCheckingMode;\n                    }\n                }\n            }\n            catch (error) {\n                this.console.error(`Error reading settings: ${error}`);\n            }\n            return serverSettings;\n        });\n    }\n    createBackgroundAnalysis() {\n        if (core_1.isDebugMode() || !cancellationUtils_1.getCancellationFolderName()) {\n            // Don't do background analysis if we're in debug mode or an old client\n            // is used where cancellation is not supported.\n            return undefined;\n        }\n        return new backgroundAnalysis_1.BackgroundAnalysis(this.console);\n    }\n    executeCommand(params, token) {\n        return this._controller.execute(params, token);\n    }\n    isLongRunningCommand(command) {\n        return this._controller.isLongRunningCommand(command);\n    }\n    executeCodeAction(params, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.recordUserInteractionTime();\n            const filePath = pathUtils_1.convertUriToPath(params.textDocument.uri);\n            const workspace = yield this.getWorkspaceForFile(filePath);\n            return codeActionProvider_1.CodeActionProvider.getCodeActionsForPosition(workspace, filePath, params.range, token);\n        });\n    }\n}\nfunction reporterFactory(connection) {\n    return {\n        isEnabled(data) {\n            return true;\n        },\n        begin() {\n            connection.sendNotification('pyright/beginProgress');\n        },\n        report(message) {\n            connection.sendNotification('pyright/reportProgress', message);\n        },\n        end() {\n            connection.sendNotification('pyright/endProgress');\n        },\n    };\n}\nif (worker_threads_1.isMainThread) {\n    new PyrightServer();\n}\n\n\n//# sourceURL=webpack://pyright-server/./src/server.ts?");

/***/ }),

/***/ "./src/workspaceMap.ts":
/*!*****************************!*\
  !*** ./src/workspaceMap.ts ***!
  \*****************************/
/*! flagged exports */
/*! export WorkspaceMap [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*\n * workspaceMap.ts\n *\n * Workspace management related functionality.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WorkspaceMap = void 0;\nconst deferred_1 = __webpack_require__(/*! ./common/deferred */ \"./src/common/deferred.ts\");\nclass WorkspaceMap extends Map {\n    constructor(_ls) {\n        super();\n        this._ls = _ls;\n        this._defaultWorkspacePath = '<default>';\n    }\n    getNonDefaultWorkspaces() {\n        const workspaces = [];\n        this.forEach((workspace) => {\n            if (workspace.rootPath) {\n                workspaces.push(workspace);\n            }\n        });\n        return workspaces;\n    }\n    getWorkspaceForFile(filePath) {\n        let bestRootPath;\n        let bestInstance;\n        this.forEach((workspace) => {\n            if (workspace.rootPath) {\n                // Is the file is under this workspace folder?\n                if (filePath.startsWith(workspace.rootPath)) {\n                    // Is this the fist candidate? If not, is this workspace folder\n                    // contained within the previous candidate folder? We always want\n                    // to select the innermost folder, since that overrides the\n                    // outer folders.\n                    if (bestRootPath === undefined || workspace.rootPath.startsWith(bestRootPath)) {\n                        bestRootPath = workspace.rootPath;\n                        bestInstance = workspace;\n                    }\n                }\n            }\n        });\n        // If there were multiple workspaces or we couldn't find any,\n        // create a default one to use for this file.\n        if (bestInstance === undefined) {\n            let defaultWorkspace = this.get(this._defaultWorkspacePath);\n            if (!defaultWorkspace) {\n                // If there is only one workspace, use that one.\n                const workspaceNames = [...this.keys()];\n                if (workspaceNames.length === 1) {\n                    return this.get(workspaceNames[0]);\n                }\n                // Create a default workspace for files that are outside\n                // of all workspaces.\n                defaultWorkspace = {\n                    workspaceName: '',\n                    rootPath: '',\n                    rootUri: '',\n                    serviceInstance: this._ls.createAnalyzerService(this._defaultWorkspacePath),\n                    disableLanguageServices: false,\n                    disableOrganizeImports: false,\n                    isInitialized: deferred_1.createDeferred(),\n                };\n                this.set(this._defaultWorkspacePath, defaultWorkspace);\n                this._ls.updateSettingsForWorkspace(defaultWorkspace).ignoreErrors();\n            }\n            return defaultWorkspace;\n        }\n        return bestInstance;\n    }\n}\nexports.WorkspaceMap = WorkspaceMap;\n\n\n//# sourceURL=webpack://pyright-server/./src/workspaceMap.ts?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/api.js":
/*!*******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/api.js ***!
  \*******************************************************/
/*! flagged exports */
/*! export AbstractMessageReader [provided] [no usage info] [missing usage info prevents renaming] */
/*! export AbstractMessageWriter [provided] [no usage info] [missing usage info prevents renaming] */
/*! export CancellationReceiverStrategy [provided] [no usage info] [missing usage info prevents renaming] */
/*! export CancellationSenderStrategy [provided] [no usage info] [missing usage info prevents renaming] */
/*! export CancellationStrategy [provided] [no usage info] [missing usage info prevents renaming] */
/*! export CancellationToken [provided] [no usage info] [missing usage info prevents renaming] */
/*! export CancellationTokenSource [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ConnectionError [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ConnectionErrors [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ConnectionOptions [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ConnectionStrategy [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Disposable [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Emitter [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ErrorCodes [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Event [provided] [no usage info] [missing usage info prevents renaming] */
/*! export LogTraceNotification [provided] [no usage info] [missing usage info prevents renaming] */
/*! export MessageReader [provided] [no usage info] [missing usage info prevents renaming] */
/*! export MessageWriter [provided] [no usage info] [missing usage info prevents renaming] */
/*! export NotificationType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export NotificationType0 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export NotificationType1 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export NotificationType2 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export NotificationType3 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export NotificationType4 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export NotificationType5 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export NotificationType6 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export NotificationType7 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export NotificationType8 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export NotificationType9 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export NullLogger [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ParameterStructures [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ProgressType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export RAL [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ReadableStreamMessageReader [provided] [no usage info] [missing usage info prevents renaming] */
/*! export RequestType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export RequestType0 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export RequestType1 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export RequestType2 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export RequestType3 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export RequestType4 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export RequestType5 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export RequestType6 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export RequestType7 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export RequestType8 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export RequestType9 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ResponseError [provided] [no usage info] [missing usage info prevents renaming] */
/*! export SetTraceNotification [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Trace [provided] [no usage info] [missing usage info prevents renaming] */
/*! export TraceFormat [provided] [no usage info] [missing usage info prevents renaming] */
/*! export WriteableStreamMessageWriter [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export createMessageConnection [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n/// <reference path=\"../../typings/thenable.d.ts\" />\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst messages_1 = __webpack_require__(/*! ../common/messages */ \"./node_modules/vscode-jsonrpc/lib/common/messages.js\");\nexports.RequestType = messages_1.RequestType;\nexports.RequestType0 = messages_1.RequestType0;\nexports.RequestType1 = messages_1.RequestType1;\nexports.RequestType2 = messages_1.RequestType2;\nexports.RequestType3 = messages_1.RequestType3;\nexports.RequestType4 = messages_1.RequestType4;\nexports.RequestType5 = messages_1.RequestType5;\nexports.RequestType6 = messages_1.RequestType6;\nexports.RequestType7 = messages_1.RequestType7;\nexports.RequestType8 = messages_1.RequestType8;\nexports.RequestType9 = messages_1.RequestType9;\nexports.ResponseError = messages_1.ResponseError;\nexports.ErrorCodes = messages_1.ErrorCodes;\nexports.NotificationType = messages_1.NotificationType;\nexports.NotificationType0 = messages_1.NotificationType0;\nexports.NotificationType1 = messages_1.NotificationType1;\nexports.NotificationType2 = messages_1.NotificationType2;\nexports.NotificationType3 = messages_1.NotificationType3;\nexports.NotificationType4 = messages_1.NotificationType4;\nexports.NotificationType5 = messages_1.NotificationType5;\nexports.NotificationType6 = messages_1.NotificationType6;\nexports.NotificationType7 = messages_1.NotificationType7;\nexports.NotificationType8 = messages_1.NotificationType8;\nexports.NotificationType9 = messages_1.NotificationType9;\nexports.ParameterStructures = messages_1.ParameterStructures;\nconst disposable_1 = __webpack_require__(/*! ../common/disposable */ \"./node_modules/vscode-jsonrpc/lib/common/disposable.js\");\nexports.Disposable = disposable_1.Disposable;\nconst events_1 = __webpack_require__(/*! ../common/events */ \"./node_modules/vscode-jsonrpc/lib/common/events.js\");\nexports.Event = events_1.Event;\nexports.Emitter = events_1.Emitter;\nconst cancellation_1 = __webpack_require__(/*! ../common/cancellation */ \"./node_modules/vscode-jsonrpc/lib/common/cancellation.js\");\nexports.CancellationTokenSource = cancellation_1.CancellationTokenSource;\nexports.CancellationToken = cancellation_1.CancellationToken;\nconst messageReader_1 = __webpack_require__(/*! ../common/messageReader */ \"./node_modules/vscode-jsonrpc/lib/common/messageReader.js\");\nexports.MessageReader = messageReader_1.MessageReader;\nexports.AbstractMessageReader = messageReader_1.AbstractMessageReader;\nexports.ReadableStreamMessageReader = messageReader_1.ReadableStreamMessageReader;\nconst messageWriter_1 = __webpack_require__(/*! ../common/messageWriter */ \"./node_modules/vscode-jsonrpc/lib/common/messageWriter.js\");\nexports.MessageWriter = messageWriter_1.MessageWriter;\nexports.AbstractMessageWriter = messageWriter_1.AbstractMessageWriter;\nexports.WriteableStreamMessageWriter = messageWriter_1.WriteableStreamMessageWriter;\nconst connection_1 = __webpack_require__(/*! ../common/connection */ \"./node_modules/vscode-jsonrpc/lib/common/connection.js\");\nexports.ConnectionStrategy = connection_1.ConnectionStrategy;\nexports.ConnectionOptions = connection_1.ConnectionOptions;\nexports.NullLogger = connection_1.NullLogger;\nexports.createMessageConnection = connection_1.createMessageConnection;\nexports.ProgressType = connection_1.ProgressType;\nexports.Trace = connection_1.Trace;\nexports.TraceFormat = connection_1.TraceFormat;\nexports.SetTraceNotification = connection_1.SetTraceNotification;\nexports.LogTraceNotification = connection_1.LogTraceNotification;\nexports.ConnectionErrors = connection_1.ConnectionErrors;\nexports.ConnectionError = connection_1.ConnectionError;\nexports.CancellationReceiverStrategy = connection_1.CancellationReceiverStrategy;\nexports.CancellationSenderStrategy = connection_1.CancellationSenderStrategy;\nexports.CancellationStrategy = connection_1.CancellationStrategy;\nconst ral_1 = __webpack_require__(/*! ./ral */ \"./node_modules/vscode-jsonrpc/lib/common/ral.js\");\nexports.RAL = ral_1.default;\n//# sourceMappingURL=api.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-jsonrpc/lib/common/api.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js":
/*!****************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/cancellation.js ***!
  \****************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ral_1 = __webpack_require__(/*! ./ral */ \"./node_modules/vscode-jsonrpc/lib/common/ral.js\");\nconst Is = __webpack_require__(/*! ./is */ \"./node_modules/vscode-jsonrpc/lib/common/is.js\");\nconst events_1 = __webpack_require__(/*! ./events */ \"./node_modules/vscode-jsonrpc/lib/common/events.js\");\nvar CancellationToken;\n(function (CancellationToken) {\n    CancellationToken.None = Object.freeze({\n        isCancellationRequested: false,\n        onCancellationRequested: events_1.Event.None\n    });\n    CancellationToken.Cancelled = Object.freeze({\n        isCancellationRequested: true,\n        onCancellationRequested: events_1.Event.None\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && (candidate === CancellationToken.None\n            || candidate === CancellationToken.Cancelled\n            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));\n    }\n    CancellationToken.is = is;\n})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));\nconst shortcutEvent = Object.freeze(function (callback, context) {\n    const handle = ral_1.default().timer.setTimeout(callback.bind(context), 0);\n    return { dispose() { ral_1.default().timer.clearTimeout(handle); } };\n});\nclass MutableToken {\n    constructor() {\n        this._isCancelled = false;\n    }\n    cancel() {\n        if (!this._isCancelled) {\n            this._isCancelled = true;\n            if (this._emitter) {\n                this._emitter.fire(undefined);\n                this.dispose();\n            }\n        }\n    }\n    get isCancellationRequested() {\n        return this._isCancelled;\n    }\n    get onCancellationRequested() {\n        if (this._isCancelled) {\n            return shortcutEvent;\n        }\n        if (!this._emitter) {\n            this._emitter = new events_1.Emitter();\n        }\n        return this._emitter.event;\n    }\n    dispose() {\n        if (this._emitter) {\n            this._emitter.dispose();\n            this._emitter = undefined;\n        }\n    }\n}\nclass CancellationTokenSource {\n    get token() {\n        if (!this._token) {\n            // be lazy and create the token only when\n            // actually needed\n            this._token = new MutableToken();\n        }\n        return this._token;\n    }\n    cancel() {\n        if (!this._token) {\n            // save an object by returning the default\n            // cancelled token when cancellation happens\n            // before someone asks for the token\n            this._token = CancellationToken.Cancelled;\n        }\n        else {\n            this._token.cancel();\n        }\n    }\n    dispose() {\n        if (!this._token) {\n            // ensure to initialize with an empty token if we had none\n            this._token = CancellationToken.None;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually dispose\n            this._token.dispose();\n        }\n    }\n}\nexports.CancellationTokenSource = CancellationTokenSource;\n//# sourceMappingURL=cancellation.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-jsonrpc/lib/common/cancellation.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/connection.js":
/*!**************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/connection.js ***!
  \**************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ral_1 = __webpack_require__(/*! ./ral */ \"./node_modules/vscode-jsonrpc/lib/common/ral.js\");\nconst Is = __webpack_require__(/*! ./is */ \"./node_modules/vscode-jsonrpc/lib/common/is.js\");\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-jsonrpc/lib/common/messages.js\");\nconst linkedMap_1 = __webpack_require__(/*! ./linkedMap */ \"./node_modules/vscode-jsonrpc/lib/common/linkedMap.js\");\nconst events_1 = __webpack_require__(/*! ./events */ \"./node_modules/vscode-jsonrpc/lib/common/events.js\");\nconst cancellation_1 = __webpack_require__(/*! ./cancellation */ \"./node_modules/vscode-jsonrpc/lib/common/cancellation.js\");\nvar CancelNotification;\n(function (CancelNotification) {\n    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');\n})(CancelNotification || (CancelNotification = {}));\nvar ProgressNotification;\n(function (ProgressNotification) {\n    ProgressNotification.type = new messages_1.NotificationType('$/progress');\n})(ProgressNotification || (ProgressNotification = {}));\nclass ProgressType {\n    constructor() {\n    }\n}\nexports.ProgressType = ProgressType;\nvar StarRequestHandler;\n(function (StarRequestHandler) {\n    function is(value) {\n        return Is.func(value);\n    }\n    StarRequestHandler.is = is;\n})(StarRequestHandler || (StarRequestHandler = {}));\nexports.NullLogger = Object.freeze({\n    error: () => { },\n    warn: () => { },\n    info: () => { },\n    log: () => { }\n});\nvar Trace;\n(function (Trace) {\n    Trace[Trace[\"Off\"] = 0] = \"Off\";\n    Trace[Trace[\"Messages\"] = 1] = \"Messages\";\n    Trace[Trace[\"Verbose\"] = 2] = \"Verbose\";\n})(Trace = exports.Trace || (exports.Trace = {}));\n(function (Trace) {\n    function fromString(value) {\n        if (!Is.string(value)) {\n            return Trace.Off;\n        }\n        value = value.toLowerCase();\n        switch (value) {\n            case 'off':\n                return Trace.Off;\n            case 'messages':\n                return Trace.Messages;\n            case 'verbose':\n                return Trace.Verbose;\n            default:\n                return Trace.Off;\n        }\n    }\n    Trace.fromString = fromString;\n    function toString(value) {\n        switch (value) {\n            case Trace.Off:\n                return 'off';\n            case Trace.Messages:\n                return 'messages';\n            case Trace.Verbose:\n                return 'verbose';\n            default:\n                return 'off';\n        }\n    }\n    Trace.toString = toString;\n})(Trace = exports.Trace || (exports.Trace = {}));\nvar TraceFormat;\n(function (TraceFormat) {\n    TraceFormat[\"Text\"] = \"text\";\n    TraceFormat[\"JSON\"] = \"json\";\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\n(function (TraceFormat) {\n    function fromString(value) {\n        value = value.toLowerCase();\n        if (value === 'json') {\n            return TraceFormat.JSON;\n        }\n        else {\n            return TraceFormat.Text;\n        }\n    }\n    TraceFormat.fromString = fromString;\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\nvar SetTraceNotification;\n(function (SetTraceNotification) {\n    SetTraceNotification.type = new messages_1.NotificationType('$/setTraceNotification');\n})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));\nvar LogTraceNotification;\n(function (LogTraceNotification) {\n    LogTraceNotification.type = new messages_1.NotificationType('$/logTraceNotification');\n})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));\nvar ConnectionErrors;\n(function (ConnectionErrors) {\n    /**\n     * The connection is closed.\n     */\n    ConnectionErrors[ConnectionErrors[\"Closed\"] = 1] = \"Closed\";\n    /**\n     * The connection got disposed.\n     */\n    ConnectionErrors[ConnectionErrors[\"Disposed\"] = 2] = \"Disposed\";\n    /**\n     * The connection is already in listening mode.\n     */\n    ConnectionErrors[ConnectionErrors[\"AlreadyListening\"] = 3] = \"AlreadyListening\";\n})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));\nclass ConnectionError extends Error {\n    constructor(code, message) {\n        super(message);\n        this.code = code;\n        Object.setPrototypeOf(this, ConnectionError.prototype);\n    }\n}\nexports.ConnectionError = ConnectionError;\nvar ConnectionStrategy;\n(function (ConnectionStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.cancelUndispatched);\n    }\n    ConnectionStrategy.is = is;\n})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));\nvar CancellationReceiverStrategy;\n(function (CancellationReceiverStrategy) {\n    CancellationReceiverStrategy.Message = Object.freeze({\n        createCancellationTokenSource(_) {\n            return new cancellation_1.CancellationTokenSource();\n        }\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.createCancellationTokenSource);\n    }\n    CancellationReceiverStrategy.is = is;\n})(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));\nvar CancellationSenderStrategy;\n(function (CancellationSenderStrategy) {\n    CancellationSenderStrategy.Message = Object.freeze({\n        sendCancellation(conn, id) {\n            conn.sendNotification(CancelNotification.type, { id });\n        },\n        cleanup(_) { }\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);\n    }\n    CancellationSenderStrategy.is = is;\n})(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));\nvar CancellationStrategy;\n(function (CancellationStrategy) {\n    CancellationStrategy.Message = Object.freeze({\n        receiver: CancellationReceiverStrategy.Message,\n        sender: CancellationSenderStrategy.Message\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);\n    }\n    CancellationStrategy.is = is;\n})(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));\nvar ConnectionOptions;\n(function (ConnectionOptions) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));\n    }\n    ConnectionOptions.is = is;\n})(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));\nvar ConnectionState;\n(function (ConnectionState) {\n    ConnectionState[ConnectionState[\"New\"] = 1] = \"New\";\n    ConnectionState[ConnectionState[\"Listening\"] = 2] = \"Listening\";\n    ConnectionState[ConnectionState[\"Closed\"] = 3] = \"Closed\";\n    ConnectionState[ConnectionState[\"Disposed\"] = 4] = \"Disposed\";\n})(ConnectionState || (ConnectionState = {}));\nfunction createMessageConnection(messageReader, messageWriter, _logger, options) {\n    const logger = _logger !== undefined ? _logger : exports.NullLogger;\n    let sequenceNumber = 0;\n    let notificationSquenceNumber = 0;\n    let unknownResponseSquenceNumber = 0;\n    const version = '2.0';\n    let starRequestHandler = undefined;\n    const requestHandlers = Object.create(null);\n    let starNotificationHandler = undefined;\n    const notificationHandlers = Object.create(null);\n    const progressHandlers = new Map();\n    let timer;\n    let messageQueue = new linkedMap_1.LinkedMap();\n    let responsePromises = Object.create(null);\n    let requestTokens = Object.create(null);\n    let trace = Trace.Off;\n    let traceFormat = TraceFormat.Text;\n    let tracer;\n    let state = ConnectionState.New;\n    const errorEmitter = new events_1.Emitter();\n    const closeEmitter = new events_1.Emitter();\n    const unhandledNotificationEmitter = new events_1.Emitter();\n    const unhandledProgressEmitter = new events_1.Emitter();\n    const disposeEmitter = new events_1.Emitter();\n    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;\n    function createRequestQueueKey(id) {\n        if (id === null) {\n            throw new Error(`Can't send requests with id null since the response can't be correlated.`);\n        }\n        return 'req-' + id.toString();\n    }\n    function createResponseQueueKey(id) {\n        if (id === null) {\n            return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();\n        }\n        else {\n            return 'res-' + id.toString();\n        }\n    }\n    function createNotificationQueueKey() {\n        return 'not-' + (++notificationSquenceNumber).toString();\n    }\n    function addMessageToQueue(queue, message) {\n        if (messages_1.isRequestMessage(message)) {\n            queue.set(createRequestQueueKey(message.id), message);\n        }\n        else if (messages_1.isResponseMessage(message)) {\n            queue.set(createResponseQueueKey(message.id), message);\n        }\n        else {\n            queue.set(createNotificationQueueKey(), message);\n        }\n    }\n    function cancelUndispatched(_message) {\n        return undefined;\n    }\n    function isListening() {\n        return state === ConnectionState.Listening;\n    }\n    function isClosed() {\n        return state === ConnectionState.Closed;\n    }\n    function isDisposed() {\n        return state === ConnectionState.Disposed;\n    }\n    function closeHandler() {\n        if (state === ConnectionState.New || state === ConnectionState.Listening) {\n            state = ConnectionState.Closed;\n            closeEmitter.fire(undefined);\n        }\n        // If the connection is disposed don't sent close events.\n    }\n    function readErrorHandler(error) {\n        errorEmitter.fire([error, undefined, undefined]);\n    }\n    function writeErrorHandler(data) {\n        errorEmitter.fire(data);\n    }\n    messageReader.onClose(closeHandler);\n    messageReader.onError(readErrorHandler);\n    messageWriter.onClose(closeHandler);\n    messageWriter.onError(writeErrorHandler);\n    function triggerMessageQueue() {\n        if (timer || messageQueue.size === 0) {\n            return;\n        }\n        timer = ral_1.default().timer.setImmediate(() => {\n            timer = undefined;\n            processMessageQueue();\n        });\n    }\n    function processMessageQueue() {\n        if (messageQueue.size === 0) {\n            return;\n        }\n        const message = messageQueue.shift();\n        try {\n            if (messages_1.isRequestMessage(message)) {\n                handleRequest(message);\n            }\n            else if (messages_1.isNotificationMessage(message)) {\n                handleNotification(message);\n            }\n            else if (messages_1.isResponseMessage(message)) {\n                handleResponse(message);\n            }\n            else {\n                handleInvalidMessage(message);\n            }\n        }\n        finally {\n            triggerMessageQueue();\n        }\n    }\n    const callback = (message) => {\n        try {\n            // We have received a cancellation message. Check if the message is still in the queue\n            // and cancel it if allowed to do so.\n            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {\n                const key = createRequestQueueKey(message.params.id);\n                const toCancel = messageQueue.get(key);\n                if (messages_1.isRequestMessage(toCancel)) {\n                    const strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;\n                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);\n                    if (response && (response.error !== undefined || response.result !== undefined)) {\n                        messageQueue.delete(key);\n                        response.id = toCancel.id;\n                        traceSendingResponse(response, message.method, Date.now());\n                        messageWriter.write(response);\n                        return;\n                    }\n                }\n            }\n            addMessageToQueue(messageQueue, message);\n        }\n        finally {\n            triggerMessageQueue();\n        }\n    };\n    function handleRequest(requestMessage) {\n        if (isDisposed()) {\n            // we return here silently since we fired an event when the\n            // connection got disposed.\n            return;\n        }\n        function reply(resultOrError, method, startTime) {\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id\n            };\n            if (resultOrError instanceof messages_1.ResponseError) {\n                message.error = resultOrError.toJson();\n            }\n            else {\n                message.result = resultOrError === undefined ? null : resultOrError;\n            }\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message);\n        }\n        function replyError(error, method, startTime) {\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id,\n                error: error.toJson()\n            };\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message);\n        }\n        function replySuccess(result, method, startTime) {\n            // The JSON RPC defines that a response must either have a result or an error\n            // So we can't treat undefined as a valid response result.\n            if (result === undefined) {\n                result = null;\n            }\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id,\n                result: result\n            };\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message);\n        }\n        traceReceivedRequest(requestMessage);\n        const element = requestHandlers[requestMessage.method];\n        let type;\n        let requestHandler;\n        if (element) {\n            type = element.type;\n            requestHandler = element.handler;\n        }\n        const startTime = Date.now();\n        if (requestHandler || starRequestHandler) {\n            const tokenKey = String(requestMessage.id);\n            const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);\n            requestTokens[tokenKey] = cancellationSource;\n            try {\n                let handlerResult;\n                if (requestHandler) {\n                    if (requestMessage.params === undefined) {\n                        if (type !== undefined && type.numberOfParams !== 0) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but recevied none.`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(cancellationSource.token);\n                    }\n                    else if (Array.isArray(requestMessage.params)) {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);\n                    }\n                    else {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);\n                    }\n                }\n                else if (starRequestHandler) {\n                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);\n                }\n                const promise = handlerResult;\n                if (!handlerResult) {\n                    delete requestTokens[tokenKey];\n                    replySuccess(handlerResult, requestMessage.method, startTime);\n                }\n                else if (promise.then) {\n                    promise.then((resultOrError) => {\n                        delete requestTokens[tokenKey];\n                        reply(resultOrError, requestMessage.method, startTime);\n                    }, error => {\n                        delete requestTokens[tokenKey];\n                        if (error instanceof messages_1.ResponseError) {\n                            replyError(error, requestMessage.method, startTime);\n                        }\n                        else if (error && Is.string(error.message)) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n                        }\n                        else {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n                        }\n                    });\n                }\n                else {\n                    delete requestTokens[tokenKey];\n                    reply(handlerResult, requestMessage.method, startTime);\n                }\n            }\n            catch (error) {\n                delete requestTokens[tokenKey];\n                if (error instanceof messages_1.ResponseError) {\n                    reply(error, requestMessage.method, startTime);\n                }\n                else if (error && Is.string(error.message)) {\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n                }\n                else {\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n                }\n            }\n        }\n        else {\n            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);\n        }\n    }\n    function handleResponse(responseMessage) {\n        if (isDisposed()) {\n            // See handle request.\n            return;\n        }\n        if (responseMessage.id === null) {\n            if (responseMessage.error) {\n                logger.error(`Received response message without id: Error is: \\n${JSON.stringify(responseMessage.error, undefined, 4)}`);\n            }\n            else {\n                logger.error(`Received response message without id. No further error information provided.`);\n            }\n        }\n        else {\n            const key = String(responseMessage.id);\n            const responsePromise = responsePromises[key];\n            traceReceivedResponse(responseMessage, responsePromise);\n            if (responsePromise) {\n                delete responsePromises[key];\n                try {\n                    if (responseMessage.error) {\n                        const error = responseMessage.error;\n                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));\n                    }\n                    else if (responseMessage.result !== undefined) {\n                        responsePromise.resolve(responseMessage.result);\n                    }\n                    else {\n                        throw new Error('Should never happen.');\n                    }\n                }\n                catch (error) {\n                    if (error.message) {\n                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);\n                    }\n                    else {\n                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);\n                    }\n                }\n            }\n        }\n    }\n    function handleNotification(message) {\n        if (isDisposed()) {\n            // See handle request.\n            return;\n        }\n        let type = undefined;\n        let notificationHandler;\n        if (message.method === CancelNotification.type.method) {\n            notificationHandler = (params) => {\n                const id = params.id;\n                const source = requestTokens[String(id)];\n                if (source) {\n                    source.cancel();\n                }\n            };\n        }\n        else {\n            const element = notificationHandlers[message.method];\n            if (element) {\n                notificationHandler = element.handler;\n                type = element.type;\n            }\n        }\n        if (notificationHandler || starNotificationHandler) {\n            try {\n                traceReceivedNotification(message);\n                if (notificationHandler) {\n                    if (message.params === undefined) {\n                        if (type !== undefined) {\n                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {\n                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but recevied none.`);\n                            }\n                        }\n                        notificationHandler();\n                    }\n                    else if (Array.isArray(message.params)) {\n                        if (type !== undefined) {\n                            if (type.parameterStructures === messages_1.ParameterStructures.byName) {\n                                logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);\n                            }\n                            if (type.numberOfParams !== message.params.length) {\n                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${message.params.length} argumennts`);\n                            }\n                        }\n                        notificationHandler(...message.params);\n                    }\n                    else {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\n                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);\n                        }\n                        notificationHandler(message.params);\n                    }\n                }\n                else if (starNotificationHandler) {\n                    starNotificationHandler(message.method, message.params);\n                }\n            }\n            catch (error) {\n                if (error.message) {\n                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);\n                }\n                else {\n                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);\n                }\n            }\n        }\n        else {\n            unhandledNotificationEmitter.fire(message);\n        }\n    }\n    function handleInvalidMessage(message) {\n        if (!message) {\n            logger.error('Received empty message.');\n            return;\n        }\n        logger.error(`Received message which is neither a response nor a notification message:\\n${JSON.stringify(message, null, 4)}`);\n        // Test whether we find an id to reject the promise\n        const responseMessage = message;\n        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {\n            const key = String(responseMessage.id);\n            const responseHandler = responsePromises[key];\n            if (responseHandler) {\n                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));\n            }\n        }\n    }\n    function traceSendingRequest(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose && message.params) {\n                data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\n            }\n            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);\n        }\n        else {\n            logLSPMessage('send-request', message);\n        }\n    }\n    function traceSendingNotification(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose) {\n                if (message.params) {\n                    data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\n                }\n                else {\n                    data = 'No parameters provided.\\n\\n';\n                }\n            }\n            tracer.log(`Sending notification '${message.method}'.`, data);\n        }\n        else {\n            logLSPMessage('send-notification', message);\n        }\n    }\n    function traceSendingResponse(message, method, startTime) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose) {\n                if (message.error && message.error.data) {\n                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\\n\\n`;\n                }\n                else {\n                    if (message.result) {\n                        data = `Result: ${JSON.stringify(message.result, null, 4)}\\n\\n`;\n                    }\n                    else if (message.error === undefined) {\n                        data = 'No result returned.\\n\\n';\n                    }\n                }\n            }\n            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);\n        }\n        else {\n            logLSPMessage('send-response', message);\n        }\n    }\n    function traceReceivedRequest(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose && message.params) {\n                data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\n            }\n            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);\n        }\n        else {\n            logLSPMessage('receive-request', message);\n        }\n    }\n    function traceReceivedNotification(message) {\n        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose) {\n                if (message.params) {\n                    data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\n                }\n                else {\n                    data = 'No parameters provided.\\n\\n';\n                }\n            }\n            tracer.log(`Received notification '${message.method}'.`, data);\n        }\n        else {\n            logLSPMessage('receive-notification', message);\n        }\n    }\n    function traceReceivedResponse(message, responsePromise) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose) {\n                if (message.error && message.error.data) {\n                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\\n\\n`;\n                }\n                else {\n                    if (message.result) {\n                        data = `Result: ${JSON.stringify(message.result, null, 4)}\\n\\n`;\n                    }\n                    else if (message.error === undefined) {\n                        data = 'No result returned.\\n\\n';\n                    }\n                }\n            }\n            if (responsePromise) {\n                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';\n                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);\n            }\n            else {\n                tracer.log(`Received response ${message.id} without active response promise.`, data);\n            }\n        }\n        else {\n            logLSPMessage('receive-response', message);\n        }\n    }\n    function logLSPMessage(type, message) {\n        if (!tracer || trace === Trace.Off) {\n            return;\n        }\n        const lspMessage = {\n            isLSPMessage: true,\n            type,\n            message,\n            timestamp: Date.now()\n        };\n        tracer.log(lspMessage);\n    }\n    function throwIfClosedOrDisposed() {\n        if (isClosed()) {\n            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');\n        }\n        if (isDisposed()) {\n            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');\n        }\n    }\n    function throwIfListening() {\n        if (isListening()) {\n            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');\n        }\n    }\n    function throwIfNotListening() {\n        if (!isListening()) {\n            throw new Error('Call listen() first.');\n        }\n    }\n    function undefinedToNull(param) {\n        if (param === undefined) {\n            return null;\n        }\n        else {\n            return param;\n        }\n    }\n    function nullToUndefined(param) {\n        if (param === null) {\n            return undefined;\n        }\n        else {\n            return param;\n        }\n    }\n    function isNamedParam(param) {\n        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';\n    }\n    function computeSingleParam(parameterStructures, param) {\n        switch (parameterStructures) {\n            case messages_1.ParameterStructures.auto:\n                if (isNamedParam(param)) {\n                    return nullToUndefined(param);\n                }\n                else {\n                    return [undefinedToNull(param)];\n                }\n                break;\n            case messages_1.ParameterStructures.byName:\n                if (!isNamedParam(param)) {\n                    throw new Error(`Recevied parameters by name but param is not an object literal.`);\n                }\n                return nullToUndefined(param);\n            case messages_1.ParameterStructures.byPosition:\n                return [undefinedToNull(param)];\n            default:\n                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);\n        }\n    }\n    function computeMessageParams(type, params) {\n        let result;\n        const numberOfParams = type.numberOfParams;\n        switch (numberOfParams) {\n            case 0:\n                result = undefined;\n                break;\n            case 1:\n                result = computeSingleParam(type.parameterStructures, params[0]);\n                break;\n            default:\n                result = [];\n                for (let i = 0; i < params.length && i < numberOfParams; i++) {\n                    result.push(undefinedToNull(params[i]));\n                }\n                if (params.length < numberOfParams) {\n                    for (let i = params.length; i < numberOfParams; i++) {\n                        result.push(null);\n                    }\n                }\n                break;\n        }\n        return result;\n    }\n    const connection = {\n        sendNotification: (type, ...args) => {\n            throwIfClosedOrDisposed();\n            let method;\n            let messageParams;\n            if (Is.string(type)) {\n                method = type;\n                const first = args[0];\n                let paramStart = 0;\n                let parameterStructures = messages_1.ParameterStructures.auto;\n                if (messages_1.ParameterStructures.is(first)) {\n                    paramStart = 1;\n                    parameterStructures = first;\n                }\n                let paramEnd = args.length;\n                const numberOfParams = paramEnd - paramStart;\n                switch (numberOfParams) {\n                    case 0:\n                        messageParams = undefined;\n                        break;\n                    case 1:\n                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);\n                        break;\n                    default:\n                        if (parameterStructures === messages_1.ParameterStructures.byName) {\n                            throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' notification parameter structure.`);\n                        }\n                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\n                        break;\n                }\n            }\n            else {\n                const params = args;\n                method = type.method;\n                messageParams = computeMessageParams(type, params);\n            }\n            const notificationMessage = {\n                jsonrpc: version,\n                method: method,\n                params: messageParams\n            };\n            traceSendingNotification(notificationMessage);\n            messageWriter.write(notificationMessage);\n        },\n        onNotification: (type, handler) => {\n            throwIfClosedOrDisposed();\n            if (Is.func(type)) {\n                starNotificationHandler = type;\n            }\n            else if (handler) {\n                if (Is.string(type)) {\n                    notificationHandlers[type] = { type: undefined, handler };\n                }\n                else {\n                    notificationHandlers[type.method] = { type, handler };\n                }\n            }\n        },\n        onProgress: (_type, token, handler) => {\n            if (progressHandlers.has(token)) {\n                throw new Error(`Progress handler for token ${token} already registered`);\n            }\n            progressHandlers.set(token, handler);\n            return {\n                dispose: () => {\n                    progressHandlers.delete(token);\n                }\n            };\n        },\n        sendProgress: (_type, token, value) => {\n            connection.sendNotification(ProgressNotification.type, { token, value });\n        },\n        onUnhandledProgress: unhandledProgressEmitter.event,\n        sendRequest: (type, ...args) => {\n            throwIfClosedOrDisposed();\n            throwIfNotListening();\n            let method;\n            let messageParams;\n            let token = undefined;\n            if (Is.string(type)) {\n                method = type;\n                const first = args[0];\n                const last = args[args.length - 1];\n                let paramStart = 0;\n                let parameterStructures = messages_1.ParameterStructures.auto;\n                if (messages_1.ParameterStructures.is(first)) {\n                    paramStart = 1;\n                    parameterStructures = first;\n                }\n                let paramEnd = args.length;\n                if (cancellation_1.CancellationToken.is(last)) {\n                    paramEnd = paramEnd - 1;\n                    token = last;\n                }\n                const numberOfParams = paramEnd - paramStart;\n                switch (numberOfParams) {\n                    case 0:\n                        messageParams = undefined;\n                        break;\n                    case 1:\n                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);\n                        break;\n                    default:\n                        if (parameterStructures === messages_1.ParameterStructures.byName) {\n                            throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' request parameter structure.`);\n                        }\n                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\n                        break;\n                }\n            }\n            else {\n                const params = args;\n                method = type.method;\n                messageParams = computeMessageParams(type, params);\n                const numberOfParams = type.numberOfParams;\n                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;\n            }\n            const id = sequenceNumber++;\n            let disposable;\n            if (token) {\n                disposable = token.onCancellationRequested(() => {\n                    cancellationStrategy.sender.sendCancellation(connection, id);\n                });\n            }\n            const result = new Promise((resolve, reject) => {\n                const requestMessage = {\n                    jsonrpc: version,\n                    id: id,\n                    method: method,\n                    params: messageParams\n                };\n                const resolveWithCleanup = (r) => {\n                    resolve(r);\n                    cancellationStrategy.sender.cleanup(id);\n                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();\n                };\n                const rejectWithCleanup = (r) => {\n                    reject(r);\n                    cancellationStrategy.sender.cleanup(id);\n                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();\n                };\n                let responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };\n                traceSendingRequest(requestMessage);\n                try {\n                    messageWriter.write(requestMessage);\n                }\n                catch (e) {\n                    // Writing the message failed. So we need to reject the promise.\n                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));\n                    responsePromise = null;\n                }\n                if (responsePromise) {\n                    responsePromises[String(id)] = responsePromise;\n                }\n            });\n            return result;\n        },\n        onRequest: (type, handler) => {\n            throwIfClosedOrDisposed();\n            if (StarRequestHandler.is(type)) {\n                starRequestHandler = type;\n            }\n            else if (Is.string(type)) {\n                if (handler !== undefined) {\n                    requestHandlers[type] = { handler: handler, type: undefined };\n                }\n            }\n            else {\n                if (handler !== undefined) {\n                    requestHandlers[type.method] = { type, handler };\n                }\n            }\n        },\n        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {\n            let _sendNotification = false;\n            let _traceFormat = TraceFormat.Text;\n            if (sendNotificationOrTraceOptions !== undefined) {\n                if (Is.boolean(sendNotificationOrTraceOptions)) {\n                    _sendNotification = sendNotificationOrTraceOptions;\n                }\n                else {\n                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;\n                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;\n                }\n            }\n            trace = _value;\n            traceFormat = _traceFormat;\n            if (trace === Trace.Off) {\n                tracer = undefined;\n            }\n            else {\n                tracer = _tracer;\n            }\n            if (_sendNotification && !isClosed() && !isDisposed()) {\n                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });\n            }\n        },\n        onError: errorEmitter.event,\n        onClose: closeEmitter.event,\n        onUnhandledNotification: unhandledNotificationEmitter.event,\n        onDispose: disposeEmitter.event,\n        dispose: () => {\n            if (isDisposed()) {\n                return;\n            }\n            state = ConnectionState.Disposed;\n            disposeEmitter.fire(undefined);\n            const error = new Error('Connection got disposed.');\n            Object.keys(responsePromises).forEach((key) => {\n                responsePromises[key].reject(error);\n            });\n            responsePromises = Object.create(null);\n            requestTokens = Object.create(null);\n            messageQueue = new linkedMap_1.LinkedMap();\n            // Test for backwards compatibility\n            if (Is.func(messageWriter.dispose)) {\n                messageWriter.dispose();\n            }\n            if (Is.func(messageReader.dispose)) {\n                messageReader.dispose();\n            }\n        },\n        listen: () => {\n            throwIfClosedOrDisposed();\n            throwIfListening();\n            state = ConnectionState.Listening;\n            messageReader.listen(callback);\n        },\n        inspect: () => {\n            // eslint-disable-next-line no-console\n            ral_1.default().console.log('inspect');\n        }\n    };\n    connection.onNotification(LogTraceNotification.type, (params) => {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);\n    });\n    connection.onNotification(ProgressNotification.type, (params) => {\n        const handler = progressHandlers.get(params.token);\n        if (handler) {\n            handler(params.value);\n        }\n        else {\n            unhandledProgressEmitter.fire(params);\n        }\n    });\n    return connection;\n}\nexports.createMessageConnection = createMessageConnection;\n//# sourceMappingURL=connection.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-jsonrpc/lib/common/connection.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/disposable.js":
/*!**************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/disposable.js ***!
  \**************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Disposable;\n(function (Disposable) {\n    function create(func) {\n        return {\n            dispose: func\n        };\n    }\n    Disposable.create = create;\n})(Disposable = exports.Disposable || (exports.Disposable = {}));\n//# sourceMappingURL=disposable.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-jsonrpc/lib/common/disposable.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/events.js":
/*!**********************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/events.js ***!
  \**********************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ral_1 = __webpack_require__(/*! ./ral */ \"./node_modules/vscode-jsonrpc/lib/common/ral.js\");\nvar Event;\n(function (Event) {\n    const _disposable = { dispose() { } };\n    Event.None = function () { return _disposable; };\n})(Event = exports.Event || (exports.Event = {}));\nclass CallbackList {\n    add(callback, context = null, bucket) {\n        if (!this._callbacks) {\n            this._callbacks = [];\n            this._contexts = [];\n        }\n        this._callbacks.push(callback);\n        this._contexts.push(context);\n        if (Array.isArray(bucket)) {\n            bucket.push({ dispose: () => this.remove(callback, context) });\n        }\n    }\n    remove(callback, context = null) {\n        if (!this._callbacks) {\n            return;\n        }\n        let foundCallbackWithDifferentContext = false;\n        for (let i = 0, len = this._callbacks.length; i < len; i++) {\n            if (this._callbacks[i] === callback) {\n                if (this._contexts[i] === context) {\n                    // callback & context match => remove it\n                    this._callbacks.splice(i, 1);\n                    this._contexts.splice(i, 1);\n                    return;\n                }\n                else {\n                    foundCallbackWithDifferentContext = true;\n                }\n            }\n        }\n        if (foundCallbackWithDifferentContext) {\n            throw new Error('When adding a listener with a context, you should remove it with the same context');\n        }\n    }\n    invoke(...args) {\n        if (!this._callbacks) {\n            return [];\n        }\n        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);\n        for (let i = 0, len = callbacks.length; i < len; i++) {\n            try {\n                ret.push(callbacks[i].apply(contexts[i], args));\n            }\n            catch (e) {\n                // eslint-disable-next-line no-console\n                ral_1.default().console.error(e);\n            }\n        }\n        return ret;\n    }\n    isEmpty() {\n        return !this._callbacks || this._callbacks.length === 0;\n    }\n    dispose() {\n        this._callbacks = undefined;\n        this._contexts = undefined;\n    }\n}\nclass Emitter {\n    constructor(_options) {\n        this._options = _options;\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        if (!this._event) {\n            this._event = (listener, thisArgs, disposables) => {\n                if (!this._callbacks) {\n                    this._callbacks = new CallbackList();\n                }\n                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {\n                    this._options.onFirstListenerAdd(this);\n                }\n                this._callbacks.add(listener, thisArgs);\n                const result = {\n                    dispose: () => {\n                        if (!this._callbacks) {\n                            // disposable is disposed after emitter is disposed.\n                            return;\n                        }\n                        this._callbacks.remove(listener, thisArgs);\n                        result.dispose = Emitter._noop;\n                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {\n                            this._options.onLastListenerRemove(this);\n                        }\n                    }\n                };\n                if (Array.isArray(disposables)) {\n                    disposables.push(result);\n                }\n                return result;\n            };\n        }\n        return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        if (this._callbacks) {\n            this._callbacks.invoke.call(this._callbacks, event);\n        }\n    }\n    dispose() {\n        if (this._callbacks) {\n            this._callbacks.dispose();\n            this._callbacks = undefined;\n        }\n    }\n}\nexports.Emitter = Emitter;\nEmitter._noop = function () { };\n//# sourceMappingURL=events.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-jsonrpc/lib/common/events.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/is.js":
/*!******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/is.js ***!
  \******************************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export array [provided] [no usage info] [missing usage info prevents renaming] */
/*! export boolean [provided] [no usage info] [missing usage info prevents renaming] */
/*! export error [provided] [no usage info] [missing usage info prevents renaming] */
/*! export func [provided] [no usage info] [missing usage info prevents renaming] */
/*! export number [provided] [no usage info] [missing usage info prevents renaming] */
/*! export string [provided] [no usage info] [missing usage info prevents renaming] */
/*! export stringArray [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction boolean(value) {\n    return value === true || value === false;\n}\nexports.boolean = boolean;\nfunction string(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexports.string = string;\nfunction number(value) {\n    return typeof value === 'number' || value instanceof Number;\n}\nexports.number = number;\nfunction error(value) {\n    return value instanceof Error;\n}\nexports.error = error;\nfunction func(value) {\n    return typeof value === 'function';\n}\nexports.func = func;\nfunction array(value) {\n    return Array.isArray(value);\n}\nexports.array = array;\nfunction stringArray(value) {\n    return array(value) && value.every(elem => string(elem));\n}\nexports.stringArray = stringArray;\n//# sourceMappingURL=is.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-jsonrpc/lib/common/is.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/linkedMap.js":
/*!*************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/linkedMap.js ***!
  \*************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Touch;\n(function (Touch) {\n    Touch.None = 0;\n    Touch.First = 1;\n    Touch.AsOld = Touch.First;\n    Touch.Last = 2;\n    Touch.AsNew = Touch.Last;\n})(Touch = exports.Touch || (exports.Touch = {}));\nclass LinkedMap {\n    constructor() {\n        this[Symbol.toStringTag] = 'LinkedMap';\n        this._map = new Map();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state = 0;\n    }\n    clear() {\n        this._map.clear();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state++;\n    }\n    isEmpty() {\n        return !this._head && !this._tail;\n    }\n    get size() {\n        return this._size;\n    }\n    get first() {\n        var _a;\n        return (_a = this._head) === null || _a === void 0 ? void 0 : _a.value;\n    }\n    get last() {\n        var _a;\n        return (_a = this._tail) === null || _a === void 0 ? void 0 : _a.value;\n    }\n    has(key) {\n        return this._map.has(key);\n    }\n    get(key, touch = Touch.None) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        if (touch !== Touch.None) {\n            this.touch(item, touch);\n        }\n        return item.value;\n    }\n    set(key, value, touch = Touch.None) {\n        let item = this._map.get(key);\n        if (item) {\n            item.value = value;\n            if (touch !== Touch.None) {\n                this.touch(item, touch);\n            }\n        }\n        else {\n            item = { key, value, next: undefined, previous: undefined };\n            switch (touch) {\n                case Touch.None:\n                    this.addItemLast(item);\n                    break;\n                case Touch.First:\n                    this.addItemFirst(item);\n                    break;\n                case Touch.Last:\n                    this.addItemLast(item);\n                    break;\n                default:\n                    this.addItemLast(item);\n                    break;\n            }\n            this._map.set(key, item);\n            this._size++;\n        }\n        return this;\n    }\n    delete(key) {\n        return !!this.remove(key);\n    }\n    remove(key) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        this._map.delete(key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    shift() {\n        if (!this._head && !this._tail) {\n            return undefined;\n        }\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        const item = this._head;\n        this._map.delete(item.key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    forEach(callbackfn, thisArg) {\n        const state = this._state;\n        let current = this._head;\n        while (current) {\n            if (thisArg) {\n                callbackfn.bind(thisArg)(current.value, current.key, this);\n            }\n            else {\n                callbackfn(current.value, current.key, this);\n            }\n            if (this._state !== state) {\n                throw new Error(`LinkedMap got modified during iteration.`);\n            }\n            current = current.next;\n        }\n    }\n    keys() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.key, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    values() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.value, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    entries() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: [current.key, current.value], done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    trimOld(newSize) {\n        if (newSize >= this.size) {\n            return;\n        }\n        if (newSize === 0) {\n            this.clear();\n            return;\n        }\n        let current = this._head;\n        let currentSize = this.size;\n        while (current && currentSize > newSize) {\n            this._map.delete(current.key);\n            current = current.next;\n            currentSize--;\n        }\n        this._head = current;\n        this._size = currentSize;\n        if (current) {\n            current.previous = undefined;\n        }\n        this._state++;\n    }\n    addItemFirst(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._tail = item;\n        }\n        else if (!this._head) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.next = this._head;\n            this._head.previous = item;\n        }\n        this._head = item;\n        this._state++;\n    }\n    addItemLast(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._head = item;\n        }\n        else if (!this._tail) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.previous = this._tail;\n            this._tail.next = item;\n        }\n        this._tail = item;\n        this._state++;\n    }\n    removeItem(item) {\n        if (item === this._head && item === this._tail) {\n            this._head = undefined;\n            this._tail = undefined;\n        }\n        else if (item === this._head) {\n            // This can only happend if size === 1 which is handle\n            // by the case above.\n            if (!item.next) {\n                throw new Error('Invalid list');\n            }\n            item.next.previous = undefined;\n            this._head = item.next;\n        }\n        else if (item === this._tail) {\n            // This can only happend if size === 1 which is handle\n            // by the case above.\n            if (!item.previous) {\n                throw new Error('Invalid list');\n            }\n            item.previous.next = undefined;\n            this._tail = item.previous;\n        }\n        else {\n            const next = item.next;\n            const previous = item.previous;\n            if (!next || !previous) {\n                throw new Error('Invalid list');\n            }\n            next.previous = previous;\n            previous.next = next;\n        }\n        item.next = undefined;\n        item.previous = undefined;\n        this._state++;\n    }\n    touch(item, touch) {\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        if ((touch !== Touch.First && touch !== Touch.Last)) {\n            return;\n        }\n        if (touch === Touch.First) {\n            if (item === this._head) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item\n            if (item === this._tail) {\n                // previous must be defined since item was not head but is tail\n                // So there are more than on item in the map\n                previous.next = undefined;\n                this._tail = previous;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            // Insert the node at head\n            item.previous = undefined;\n            item.next = this._head;\n            this._head.previous = item;\n            this._head = item;\n            this._state++;\n        }\n        else if (touch === Touch.Last) {\n            if (item === this._tail) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item.\n            if (item === this._head) {\n                // next must be defined since item was not tail but is head\n                // So there are more than on item in the map\n                next.previous = undefined;\n                this._head = next;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            item.next = undefined;\n            item.previous = this._tail;\n            this._tail.next = item;\n            this._tail = item;\n            this._state++;\n        }\n    }\n    toJSON() {\n        const data = [];\n        this.forEach((value, key) => {\n            data.push([key, value]);\n        });\n        return data;\n    }\n    fromJSON(data) {\n        this.clear();\n        for (const [key, value] of data) {\n            this.set(key, value);\n        }\n    }\n}\nexports.LinkedMap = LinkedMap;\nclass LRUCache extends LinkedMap {\n    constructor(limit, ratio = 1) {\n        super();\n        this._limit = limit;\n        this._ratio = Math.min(Math.max(0, ratio), 1);\n    }\n    get limit() {\n        return this._limit;\n    }\n    set limit(limit) {\n        this._limit = limit;\n        this.checkTrim();\n    }\n    get ratio() {\n        return this._ratio;\n    }\n    set ratio(ratio) {\n        this._ratio = Math.min(Math.max(0, ratio), 1);\n        this.checkTrim();\n    }\n    get(key, touch = Touch.AsNew) {\n        return super.get(key, touch);\n    }\n    peek(key) {\n        return super.get(key, Touch.None);\n    }\n    set(key, value) {\n        super.set(key, value, Touch.Last);\n        this.checkTrim();\n        return this;\n    }\n    checkTrim() {\n        if (this.size > this._limit) {\n            this.trimOld(Math.round(this._limit * this._ratio));\n        }\n    }\n}\nexports.LRUCache = LRUCache;\n//# sourceMappingURL=linkedMap.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-jsonrpc/lib/common/linkedMap.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/messageReader.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/messageReader.js ***!
  \*****************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ral_1 = __webpack_require__(/*! ./ral */ \"./node_modules/vscode-jsonrpc/lib/common/ral.js\");\nconst Is = __webpack_require__(/*! ./is */ \"./node_modules/vscode-jsonrpc/lib/common/is.js\");\nconst events_1 = __webpack_require__(/*! ./events */ \"./node_modules/vscode-jsonrpc/lib/common/events.js\");\nvar MessageReader;\n(function (MessageReader) {\n    function is(value) {\n        let candidate = value;\n        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&\n            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);\n    }\n    MessageReader.is = is;\n})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));\nclass AbstractMessageReader {\n    constructor() {\n        this.errorEmitter = new events_1.Emitter();\n        this.closeEmitter = new events_1.Emitter();\n        this.partialMessageEmitter = new events_1.Emitter();\n    }\n    dispose() {\n        this.errorEmitter.dispose();\n        this.closeEmitter.dispose();\n    }\n    get onError() {\n        return this.errorEmitter.event;\n    }\n    fireError(error) {\n        this.errorEmitter.fire(this.asError(error));\n    }\n    get onClose() {\n        return this.closeEmitter.event;\n    }\n    fireClose() {\n        this.closeEmitter.fire(undefined);\n    }\n    get onPartialMessage() {\n        return this.partialMessageEmitter.event;\n    }\n    firePartialMessage(info) {\n        this.partialMessageEmitter.fire(info);\n    }\n    asError(error) {\n        if (error instanceof Error) {\n            return error;\n        }\n        else {\n            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\n        }\n    }\n}\nexports.AbstractMessageReader = AbstractMessageReader;\nvar ResolvedMessageReaderOptions;\n(function (ResolvedMessageReaderOptions) {\n    function fromOptions(options) {\n        var _a;\n        let charset;\n        let result;\n        let contentDecoder;\n        const contentDecoders = new Map();\n        let contentTypeDecoder;\n        const contentTypeDecoders = new Map();\n        if (options === undefined || typeof options === 'string') {\n            charset = options !== null && options !== void 0 ? options : 'utf-8';\n        }\n        else {\n            charset = (_a = options.charset) !== null && _a !== void 0 ? _a : 'utf-8';\n            if (options.contentDecoder !== undefined) {\n                contentDecoder = options.contentDecoder;\n                contentDecoders.set(contentDecoder.name, contentDecoder);\n            }\n            if (options.contentDecoders !== undefined) {\n                for (const decoder of options.contentDecoders) {\n                    contentDecoders.set(decoder.name, decoder);\n                }\n            }\n            if (options.contentTypeDecoder !== undefined) {\n                contentTypeDecoder = options.contentTypeDecoder;\n                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);\n            }\n            if (options.contentTypeDecoders !== undefined) {\n                for (const decoder of options.contentTypeDecoders) {\n                    contentTypeDecoders.set(decoder.name, decoder);\n                }\n            }\n        }\n        if (contentTypeDecoder === undefined) {\n            contentTypeDecoder = ral_1.default().applicationJson.decoder;\n            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);\n        }\n        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };\n    }\n    ResolvedMessageReaderOptions.fromOptions = fromOptions;\n})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));\nclass ReadableStreamMessageReader extends AbstractMessageReader {\n    constructor(readable, options) {\n        super();\n        this.readable = readable;\n        this.options = ResolvedMessageReaderOptions.fromOptions(options);\n        this.buffer = ral_1.default().messageBuffer.create(this.options.charset);\n        this._partialMessageTimeout = 10000;\n        this.nextMessageLength = -1;\n        this.messageToken = 0;\n    }\n    set partialMessageTimeout(timeout) {\n        this._partialMessageTimeout = timeout;\n    }\n    get partialMessageTimeout() {\n        return this._partialMessageTimeout;\n    }\n    listen(callback) {\n        this.nextMessageLength = -1;\n        this.messageToken = 0;\n        this.partialMessageTimer = undefined;\n        this.callback = callback;\n        const result = this.readable.onData((data) => {\n            this.onData(data);\n        });\n        this.readable.onError((error) => this.fireError(error));\n        this.readable.onClose(() => this.fireClose());\n        return result;\n    }\n    onData(data) {\n        this.buffer.append(data);\n        while (true) {\n            if (this.nextMessageLength === -1) {\n                const headers = this.buffer.tryReadHeaders();\n                if (!headers) {\n                    return;\n                }\n                const contentLength = headers.get('Content-Length');\n                if (!contentLength) {\n                    throw new Error('Header must provide a Content-Length property.');\n                }\n                const length = parseInt(contentLength);\n                if (isNaN(length)) {\n                    throw new Error('Content-Length value must be a number.');\n                }\n                this.nextMessageLength = length;\n            }\n            const body = this.buffer.tryReadBody(this.nextMessageLength);\n            if (body === undefined) {\n                /** We haven't received the full message yet. */\n                this.setPartialMessageTimer();\n                return;\n            }\n            this.clearPartialMessageTimer();\n            this.nextMessageLength = -1;\n            let p;\n            if (this.options.contentDecoder !== undefined) {\n                p = this.options.contentDecoder.decode(body);\n            }\n            else {\n                p = Promise.resolve(body);\n            }\n            p.then((value) => {\n                this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {\n                    this.callback(msg);\n                }, (error) => {\n                    this.fireError(error);\n                });\n            }, (error) => {\n                this.fireError(error);\n            });\n        }\n    }\n    clearPartialMessageTimer() {\n        if (this.partialMessageTimer) {\n            ral_1.default().timer.clearTimeout(this.partialMessageTimer);\n            this.partialMessageTimer = undefined;\n        }\n    }\n    setPartialMessageTimer() {\n        this.clearPartialMessageTimer();\n        if (this._partialMessageTimeout <= 0) {\n            return;\n        }\n        this.partialMessageTimer = ral_1.default().timer.setTimeout((token, timeout) => {\n            this.partialMessageTimer = undefined;\n            if (token === this.messageToken) {\n                this.firePartialMessage({ messageToken: token, waitingTime: timeout });\n                this.setPartialMessageTimer();\n            }\n        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);\n    }\n}\nexports.ReadableStreamMessageReader = ReadableStreamMessageReader;\n//# sourceMappingURL=messageReader.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-jsonrpc/lib/common/messageReader.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/messageWriter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/messageWriter.js ***!
  \*****************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ral_1 = __webpack_require__(/*! ./ral */ \"./node_modules/vscode-jsonrpc/lib/common/ral.js\");\nconst Is = __webpack_require__(/*! ./is */ \"./node_modules/vscode-jsonrpc/lib/common/is.js\");\nconst semaphore_1 = __webpack_require__(/*! ./semaphore */ \"./node_modules/vscode-jsonrpc/lib/common/semaphore.js\");\nconst events_1 = __webpack_require__(/*! ./events */ \"./node_modules/vscode-jsonrpc/lib/common/events.js\");\nconst ContentLength = 'Content-Length: ';\nconst CRLF = '\\r\\n';\nvar MessageWriter;\n(function (MessageWriter) {\n    function is(value) {\n        let candidate = value;\n        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&\n            Is.func(candidate.onError) && Is.func(candidate.write);\n    }\n    MessageWriter.is = is;\n})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));\nclass AbstractMessageWriter {\n    constructor() {\n        this.errorEmitter = new events_1.Emitter();\n        this.closeEmitter = new events_1.Emitter();\n    }\n    dispose() {\n        this.errorEmitter.dispose();\n        this.closeEmitter.dispose();\n    }\n    get onError() {\n        return this.errorEmitter.event;\n    }\n    fireError(error, message, count) {\n        this.errorEmitter.fire([this.asError(error), message, count]);\n    }\n    get onClose() {\n        return this.closeEmitter.event;\n    }\n    fireClose() {\n        this.closeEmitter.fire(undefined);\n    }\n    asError(error) {\n        if (error instanceof Error) {\n            return error;\n        }\n        else {\n            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\n        }\n    }\n}\nexports.AbstractMessageWriter = AbstractMessageWriter;\nvar ResolvedMessageWriterOptions;\n(function (ResolvedMessageWriterOptions) {\n    function fromOptions(options) {\n        var _a, _b;\n        if (options === undefined || typeof options === 'string') {\n            return { charset: options !== null && options !== void 0 ? options : 'utf-8', contentTypeEncoder: ral_1.default().applicationJson.encoder };\n        }\n        else {\n            return { charset: (_a = options.charset) !== null && _a !== void 0 ? _a : 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: (_b = options.contentTypeEncoder) !== null && _b !== void 0 ? _b : ral_1.default().applicationJson.encoder };\n        }\n    }\n    ResolvedMessageWriterOptions.fromOptions = fromOptions;\n})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));\nclass WriteableStreamMessageWriter extends AbstractMessageWriter {\n    constructor(writable, options) {\n        super();\n        this.writable = writable;\n        this.options = ResolvedMessageWriterOptions.fromOptions(options);\n        this.errorCount = 0;\n        this.writeSemaphore = new semaphore_1.Semaphore(1);\n        this.writable.onError((error) => this.fireError(error));\n        this.writable.onClose(() => this.fireClose());\n    }\n    async write(msg) {\n        return this.writeSemaphore.lock(async () => {\n            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {\n                if (this.options.contentEncoder !== undefined) {\n                    return this.options.contentEncoder.encode(buffer);\n                }\n                else {\n                    return buffer;\n                }\n            });\n            return payload.then((buffer) => {\n                const headers = [];\n                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);\n                headers.push(CRLF);\n                return this.doWrite(msg, headers, buffer);\n            }, (error) => {\n                this.fireError(error);\n                throw error;\n            });\n        });\n    }\n    async doWrite(msg, headers, data) {\n        try {\n            await this.writable.write(headers.join(''), 'ascii');\n            return this.writable.write(data);\n        }\n        catch (error) {\n            this.handleError(error, msg);\n            return Promise.reject(error);\n        }\n    }\n    handleError(error, msg) {\n        this.errorCount++;\n        this.fireError(error, msg, this.errorCount);\n    }\n}\nexports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;\n//# sourceMappingURL=messageWriter.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-jsonrpc/lib/common/messageWriter.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/messages.js":
/*!************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/messages.js ***!
  \************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst is = __webpack_require__(/*! ./is */ \"./node_modules/vscode-jsonrpc/lib/common/is.js\");\n/**\n * Predefined error codes.\n */\nvar ErrorCodes;\n(function (ErrorCodes) {\n    // Defined by JSON RPC\n    ErrorCodes.ParseError = -32700;\n    ErrorCodes.InvalidRequest = -32600;\n    ErrorCodes.MethodNotFound = -32601;\n    ErrorCodes.InvalidParams = -32602;\n    ErrorCodes.InternalError = -32603;\n    ErrorCodes.serverErrorStart = -32099;\n    ErrorCodes.serverErrorEnd = -32000;\n    ErrorCodes.ServerNotInitialized = -32002;\n    ErrorCodes.UnknownErrorCode = -32001;\n    // Defined by the protocol.\n    ErrorCodes.RequestCancelled = -32800;\n    ErrorCodes.ContentModified = -32801;\n    // Defined by VSCode library.\n    ErrorCodes.MessageWriteError = 1;\n    ErrorCodes.MessageReadError = 2;\n})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));\n/**\n * An error object return in a response in case a request\n * has failed.\n */\nclass ResponseError extends Error {\n    constructor(code, message, data) {\n        super(message);\n        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;\n        this.data = data;\n        Object.setPrototypeOf(this, ResponseError.prototype);\n    }\n    toJson() {\n        return {\n            code: this.code,\n            message: this.message,\n            data: this.data,\n        };\n    }\n}\nexports.ResponseError = ResponseError;\nclass ParameterStructures {\n    constructor(kind) {\n        this.kind = kind;\n    }\n    static is(value) {\n        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;\n    }\n    toString() {\n        return this.kind;\n    }\n}\nexports.ParameterStructures = ParameterStructures;\n/**\n * The parameter structure is automatically inferred on the number of parameters\n * and the parameter type in case of a single param.\n */\nParameterStructures.auto = new ParameterStructures('auto');\n/**\n * Forces `byPosition` parameter structure. This is useful if you have a single\n * parameter which has a literal type.\n */\nParameterStructures.byPosition = new ParameterStructures('byPosition');\n/**\n * Forces `byName` parameter structure. This is only useful when having a single\n * parameter. The library will report errors if used with a different number of\n * parameters.\n */\nParameterStructures.byName = new ParameterStructures('byName');\n/**\n * An abstract implementation of a MessageType.\n */\nclass AbstractMessageSignature {\n    constructor(_method, _numberOfParams) {\n        this._method = _method;\n        this._numberOfParams = _numberOfParams;\n    }\n    get method() {\n        return this._method;\n    }\n    get numberOfParams() {\n        return this._numberOfParams;\n    }\n    get parameterStructures() {\n        return ParameterStructures.auto;\n    }\n}\nexports.AbstractMessageSignature = AbstractMessageSignature;\n/**\n * Classes to type request response pairs\n *\n * The type parameter RO will be removed in the next major version\n * of the JSON RPC library since it is a LSP concept and doesn't\n * belong here. For now it is tagged as default never.\n */\nclass RequestType0 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 0);\n    }\n}\nexports.RequestType0 = RequestType0;\nclass RequestType extends AbstractMessageSignature {\n    constructor(method, _parameterStructures = ParameterStructures.auto) {\n        super(method, 1);\n        this._parameterStructures = _parameterStructures;\n    }\n    get parameterStructures() {\n        return this._parameterStructures;\n    }\n}\nexports.RequestType = RequestType;\nclass RequestType1 extends AbstractMessageSignature {\n    constructor(method, _parameterStructures = ParameterStructures.auto) {\n        super(method, 1);\n        this._parameterStructures = _parameterStructures;\n    }\n    get parameterStructures() {\n        return this._parameterStructures;\n    }\n}\nexports.RequestType1 = RequestType1;\nclass RequestType2 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 2);\n    }\n}\nexports.RequestType2 = RequestType2;\nclass RequestType3 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 3);\n    }\n}\nexports.RequestType3 = RequestType3;\nclass RequestType4 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 4);\n    }\n}\nexports.RequestType4 = RequestType4;\nclass RequestType5 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 5);\n    }\n}\nexports.RequestType5 = RequestType5;\nclass RequestType6 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 6);\n    }\n}\nexports.RequestType6 = RequestType6;\nclass RequestType7 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 7);\n    }\n}\nexports.RequestType7 = RequestType7;\nclass RequestType8 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 8);\n    }\n}\nexports.RequestType8 = RequestType8;\nclass RequestType9 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 9);\n    }\n}\nexports.RequestType9 = RequestType9;\n/**\n * The type parameter RO will be removed in the next major version\n * of the JSON RPC library since it is a LSP concept and doesn't\n * belong here. For now it is tagged as default never.\n */\nclass NotificationType extends AbstractMessageSignature {\n    constructor(method, _parameterStructures = ParameterStructures.auto) {\n        super(method, 1);\n        this._parameterStructures = _parameterStructures;\n        this._ = undefined;\n    }\n    get parameterStructures() {\n        return this._parameterStructures;\n    }\n}\nexports.NotificationType = NotificationType;\nclass NotificationType0 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 0);\n    }\n}\nexports.NotificationType0 = NotificationType0;\nclass NotificationType1 extends AbstractMessageSignature {\n    constructor(method, _parameterStructures = ParameterStructures.auto) {\n        super(method, 1);\n        this._parameterStructures = _parameterStructures;\n    }\n    get parameterStructures() {\n        return this._parameterStructures;\n    }\n}\nexports.NotificationType1 = NotificationType1;\nclass NotificationType2 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 2);\n    }\n}\nexports.NotificationType2 = NotificationType2;\nclass NotificationType3 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 3);\n    }\n}\nexports.NotificationType3 = NotificationType3;\nclass NotificationType4 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 4);\n    }\n}\nexports.NotificationType4 = NotificationType4;\nclass NotificationType5 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 5);\n    }\n}\nexports.NotificationType5 = NotificationType5;\nclass NotificationType6 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 6);\n    }\n}\nexports.NotificationType6 = NotificationType6;\nclass NotificationType7 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 7);\n    }\n}\nexports.NotificationType7 = NotificationType7;\nclass NotificationType8 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 8);\n    }\n}\nexports.NotificationType8 = NotificationType8;\nclass NotificationType9 extends AbstractMessageSignature {\n    constructor(method) {\n        super(method, 9);\n    }\n}\nexports.NotificationType9 = NotificationType9;\n/**\n * Tests if the given message is a request message\n */\nfunction isRequestMessage(message) {\n    const candidate = message;\n    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));\n}\nexports.isRequestMessage = isRequestMessage;\n/**\n * Tests if the given message is a notification message\n */\nfunction isNotificationMessage(message) {\n    const candidate = message;\n    return candidate && is.string(candidate.method) && message.id === void 0;\n}\nexports.isNotificationMessage = isNotificationMessage;\n/**\n * Tests if the given message is a response message\n */\nfunction isResponseMessage(message) {\n    const candidate = message;\n    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);\n}\nexports.isResponseMessage = isResponseMessage;\n//# sourceMappingURL=messages.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-jsonrpc/lib/common/messages.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/ral.js":
/*!*******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/ral.js ***!
  \*******************************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nlet _ral;\nfunction RAL() {\n    if (_ral === undefined) {\n        throw new Error(`No runtime abstraction layer installed`);\n    }\n    return _ral;\n}\n(function (RAL) {\n    function install(ral) {\n        if (ral === undefined) {\n            throw new Error(`No runtime abstraction layer provided`);\n        }\n        _ral = ral;\n    }\n    RAL.install = install;\n})(RAL || (RAL = {}));\nexports.default = RAL;\n//# sourceMappingURL=ral.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-jsonrpc/lib/common/ral.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/semaphore.js":
/*!*************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/semaphore.js ***!
  \*************************************************************/
/*! flagged exports */
/*! export Semaphore [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ral_1 = __webpack_require__(/*! ./ral */ \"./node_modules/vscode-jsonrpc/lib/common/ral.js\");\nclass Semaphore {\n    constructor(capacity = 1) {\n        if (capacity <= 0) {\n            throw new Error('Capacity must be greater than 0');\n        }\n        this._capacity = capacity;\n        this._active = 0;\n        this._waiting = [];\n    }\n    lock(thunk) {\n        return new Promise((resolve, reject) => {\n            this._waiting.push({ thunk, resolve, reject });\n            this.runNext();\n        });\n    }\n    get active() {\n        return this._active;\n    }\n    runNext() {\n        if (this._waiting.length === 0 || this._active === this._capacity) {\n            return;\n        }\n        ral_1.default().timer.setImmediate(() => this.doRunNext());\n    }\n    doRunNext() {\n        if (this._waiting.length === 0 || this._active === this._capacity) {\n            return;\n        }\n        const next = this._waiting.shift();\n        this._active++;\n        if (this._active > this._capacity) {\n            throw new Error(`To many thunks active`);\n        }\n        try {\n            const result = next.thunk();\n            if (result instanceof Promise) {\n                result.then((value) => {\n                    this._active--;\n                    next.resolve(value);\n                    this.runNext();\n                }, (err) => {\n                    this._active--;\n                    next.reject(err);\n                    this.runNext();\n                });\n            }\n            else {\n                this._active--;\n                next.resolve(result);\n                this.runNext();\n            }\n        }\n        catch (err) {\n            this._active--;\n            next.reject(err);\n            this.runNext();\n        }\n    }\n}\nexports.Semaphore = Semaphore;\n//# sourceMappingURL=semaphore.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-jsonrpc/lib/common/semaphore.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/node/main.js":
/*!******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/node/main.js ***!
  \******************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ----------------------------------------------------------------------------------------- */\nconst ril_1 = __webpack_require__(/*! ./ril */ \"./node_modules/vscode-jsonrpc/lib/node/ril.js\");\n// Install the node runtime abstract.\nril_1.default.install();\nconst api_1 = __webpack_require__(/*! ../common/api */ \"./node_modules/vscode-jsonrpc/lib/common/api.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\n__export(__webpack_require__(/*! ../common/api */ \"./node_modules/vscode-jsonrpc/lib/common/api.js\"));\nclass IPCMessageReader extends api_1.AbstractMessageReader {\n    constructor(process) {\n        super();\n        this.process = process;\n        let eventEmitter = this.process;\n        eventEmitter.on('error', (error) => this.fireError(error));\n        eventEmitter.on('close', () => this.fireClose());\n    }\n    listen(callback) {\n        this.process.on('message', callback);\n        return api_1.Disposable.create(() => this.process.off('message', callback));\n    }\n}\nexports.IPCMessageReader = IPCMessageReader;\nclass IPCMessageWriter extends api_1.AbstractMessageWriter {\n    constructor(process) {\n        super();\n        this.process = process;\n        this.errorCount = 0;\n        let eventEmitter = this.process;\n        eventEmitter.on('error', (error) => this.fireError(error));\n        eventEmitter.on('close', () => this.fireClose);\n    }\n    write(msg) {\n        try {\n            if (typeof this.process.send === 'function') {\n                this.process.send(msg, undefined, undefined, (error) => {\n                    if (error) {\n                        this.errorCount++;\n                        this.handleError(error, msg);\n                    }\n                    else {\n                        this.errorCount = 0;\n                    }\n                });\n            }\n            return Promise.resolve();\n        }\n        catch (error) {\n            this.handleError(error, msg);\n            return Promise.reject(error);\n        }\n    }\n    handleError(error, msg) {\n        this.errorCount++;\n        this.fireError(error, msg, this.errorCount);\n    }\n}\nexports.IPCMessageWriter = IPCMessageWriter;\nclass SocketMessageReader extends api_1.ReadableStreamMessageReader {\n    constructor(socket, encoding = 'utf-8') {\n        super(ril_1.default().stream.asReadableStream(socket), encoding);\n    }\n}\nexports.SocketMessageReader = SocketMessageReader;\nclass SocketMessageWriter extends api_1.WriteableStreamMessageWriter {\n    constructor(socket, options) {\n        super(ril_1.default().stream.asWritableStream(socket), options);\n        this.socket = socket;\n    }\n    dispose() {\n        super.dispose();\n        this.socket.destroy();\n    }\n}\nexports.SocketMessageWriter = SocketMessageWriter;\nclass StreamMessageReader extends api_1.ReadableStreamMessageReader {\n    constructor(readble, encoding) {\n        super(ril_1.default().stream.asReadableStream(readble), encoding);\n    }\n}\nexports.StreamMessageReader = StreamMessageReader;\nclass StreamMessageWriter extends api_1.WriteableStreamMessageWriter {\n    constructor(writable, options) {\n        super(ril_1.default().stream.asWritableStream(writable), options);\n    }\n}\nexports.StreamMessageWriter = StreamMessageWriter;\nfunction generateRandomPipeName() {\n    const randomSuffix = crypto_1.randomBytes(21).toString('hex');\n    if (process.platform === 'win32') {\n        return `\\\\\\\\.\\\\pipe\\\\vscode-jsonrpc-${randomSuffix}-sock`;\n    }\n    else {\n        // Mac/Unix: use socket file\n        return path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);\n    }\n}\nexports.generateRandomPipeName = generateRandomPipeName;\nfunction createClientPipeTransport(pipeName, encoding = 'utf-8') {\n    let connectResolve;\n    const connected = new Promise((resolve, _reject) => {\n        connectResolve = resolve;\n    });\n    return new Promise((resolve, reject) => {\n        let server = net_1.createServer((socket) => {\n            server.close();\n            connectResolve([\n                new SocketMessageReader(socket, encoding),\n                new SocketMessageWriter(socket, encoding)\n            ]);\n        });\n        server.on('error', reject);\n        server.listen(pipeName, () => {\n            server.removeListener('error', reject);\n            resolve({\n                onConnected: () => { return connected; }\n            });\n        });\n    });\n}\nexports.createClientPipeTransport = createClientPipeTransport;\nfunction createServerPipeTransport(pipeName, encoding = 'utf-8') {\n    const socket = net_1.createConnection(pipeName);\n    return [\n        new SocketMessageReader(socket, encoding),\n        new SocketMessageWriter(socket, encoding)\n    ];\n}\nexports.createServerPipeTransport = createServerPipeTransport;\nfunction createClientSocketTransport(port, encoding = 'utf-8') {\n    let connectResolve;\n    const connected = new Promise((resolve, _reject) => {\n        connectResolve = resolve;\n    });\n    return new Promise((resolve, reject) => {\n        const server = net_1.createServer((socket) => {\n            server.close();\n            connectResolve([\n                new SocketMessageReader(socket, encoding),\n                new SocketMessageWriter(socket, encoding)\n            ]);\n        });\n        server.on('error', reject);\n        server.listen(port, '127.0.0.1', () => {\n            server.removeListener('error', reject);\n            resolve({\n                onConnected: () => { return connected; }\n            });\n        });\n    });\n}\nexports.createClientSocketTransport = createClientSocketTransport;\nfunction createServerSocketTransport(port, encoding = 'utf-8') {\n    const socket = net_1.createConnection(port, '127.0.0.1');\n    return [\n        new SocketMessageReader(socket, encoding),\n        new SocketMessageWriter(socket, encoding)\n    ];\n}\nexports.createServerSocketTransport = createServerSocketTransport;\nfunction isMessageReader(value) {\n    return value.listen !== undefined && value.read === undefined;\n}\nfunction isMessageWriter(value) {\n    return value.write !== undefined && value.end === undefined;\n}\nfunction createMessageConnection(input, output, logger, options) {\n    if (!logger) {\n        logger = api_1.NullLogger;\n    }\n    const reader = isMessageReader(input) ? input : new StreamMessageReader(input);\n    const writer = isMessageWriter(output) ? output : new StreamMessageWriter(output);\n    if (api_1.ConnectionStrategy.is(options)) {\n        options = { connectionStrategy: options };\n    }\n    return api_1.createMessageConnection(reader, writer, logger, options);\n}\nexports.createMessageConnection = createMessageConnection;\n//# sourceMappingURL=main.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-jsonrpc/lib/node/main.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/node/ril.js":
/*!*****************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/node/ril.js ***!
  \*****************************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ral_1 = __webpack_require__(/*! ../common/ral */ \"./node_modules/vscode-jsonrpc/lib/common/ral.js\");\nconst disposable_1 = __webpack_require__(/*! ../common/disposable */ \"./node_modules/vscode-jsonrpc/lib/common/disposable.js\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst DefaultSize = 8192;\nconst CR = Buffer.from('\\r', 'ascii')[0];\nconst LF = Buffer.from('\\n', 'ascii')[0];\nconst CRLF = '\\r\\n';\nclass MessageBuffer {\n    constructor(encoding = 'utf-8') {\n        this._encoding = encoding;\n        this.index = 0;\n        this.buffer = Buffer.allocUnsafe(DefaultSize);\n    }\n    get encoding() {\n        return this._encoding;\n    }\n    append(chunk) {\n        let toAppend;\n        if (typeof chunk === 'string') {\n            toAppend = Buffer.from(chunk, this._encoding);\n        }\n        else {\n            toAppend = chunk;\n        }\n        if (this.buffer.length - this.index >= toAppend.length) {\n            this.buffer.set(toAppend, this.index);\n        }\n        else {\n            var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;\n            if (this.index === 0) {\n                this.buffer = Buffer.allocUnsafe(newSize);\n                this.buffer.set(toAppend);\n            }\n            else {\n                this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);\n            }\n        }\n        this.index += toAppend.length;\n    }\n    tryReadHeaders() {\n        let current = 0;\n        while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {\n            current++;\n        }\n        // No header / body separator found (e.g CRLFCRLF)\n        if (current + 3 >= this.index) {\n            return undefined;\n        }\n        const result = new Map();\n        const headers = this.buffer.toString('ascii', 0, current).split(CRLF);\n        headers.forEach((header) => {\n            let index = header.indexOf(':');\n            if (index === -1) {\n                throw new Error('Message header must separate key and value using :');\n            }\n            let key = header.substr(0, index);\n            let value = header.substr(index + 1).trim();\n            result.set(key, value);\n        });\n        let nextStart = current + 4;\n        this.buffer = this.buffer.slice(nextStart);\n        this.index = this.index - nextStart;\n        return result;\n    }\n    tryReadBody(length) {\n        if (this.index < length) {\n            return undefined;\n        }\n        const result = Buffer.alloc(length);\n        this.buffer.copy(result, 0, 0, length);\n        const nextStart = length;\n        this.buffer.copy(this.buffer, 0, nextStart);\n        this.index = this.index - nextStart;\n        return result;\n    }\n    get numberOfBytes() {\n        return this.index;\n    }\n}\nclass ReadableStreamWrapper {\n    constructor(stream) {\n        this.stream = stream;\n    }\n    onClose(listener) {\n        this.stream.on('close', listener);\n        return disposable_1.Disposable.create(() => this.stream.off('close', listener));\n    }\n    onError(listener) {\n        this.stream.on('error', listener);\n        return disposable_1.Disposable.create(() => this.stream.off('error', listener));\n    }\n    onEnd(listener) {\n        this.stream.on('end', listener);\n        return disposable_1.Disposable.create(() => this.stream.off('end', listener));\n    }\n    onData(listener) {\n        this.stream.on('data', listener);\n        return disposable_1.Disposable.create(() => this.stream.off('data', listener));\n    }\n}\nclass WritableStreamWrapper {\n    constructor(stream) {\n        this.stream = stream;\n    }\n    onClose(listener) {\n        this.stream.on('close', listener);\n        return disposable_1.Disposable.create(() => this.stream.off('close', listener));\n    }\n    onError(listener) {\n        this.stream.on('error', listener);\n        return disposable_1.Disposable.create(() => this.stream.off('error', listener));\n    }\n    onEnd(listener) {\n        this.stream.on('end', listener);\n        return disposable_1.Disposable.create(() => this.stream.off('end', listener));\n    }\n    write(data, encoding) {\n        return new Promise((resolve, reject) => {\n            const callback = (error) => {\n                if (error === undefined || error === null) {\n                    resolve();\n                }\n                else {\n                    reject(error);\n                }\n            };\n            if (typeof data === 'string') {\n                this.stream.write(data, encoding, callback);\n            }\n            else {\n                this.stream.write(data, callback);\n            }\n        });\n    }\n    end() {\n        this.stream.end();\n    }\n}\nconst _ril = Object.freeze({\n    messageBuffer: Object.freeze({\n        create: (encoding) => new MessageBuffer(encoding)\n    }),\n    applicationJson: Object.freeze({\n        encoder: Object.freeze({\n            name: 'application/json',\n            encode: (msg, options) => {\n                return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));\n            }\n        }),\n        decoder: Object.freeze({\n            name: 'application/json',\n            decode: (buffer, options) => {\n                if (buffer instanceof Buffer) {\n                    return Promise.resolve(JSON.parse(buffer.toString(options.charset)));\n                }\n                else {\n                    return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));\n                }\n            }\n        })\n    }),\n    stream: Object.freeze({\n        asReadableStream: (socket) => new ReadableStreamWrapper(socket),\n        asWritableStream: (socket) => new WritableStreamWrapper(socket)\n    }),\n    console: console,\n    timer: Object.freeze({\n        setTimeout(callback, ms, ...args) {\n            return setTimeout(callback, ms, ...args);\n        },\n        clearTimeout(handle) {\n            clearTimeout(handle);\n        },\n        setImmediate(callback, ...args) {\n            return setImmediate(callback, ...args);\n        },\n        clearImmediate(handle) {\n            clearImmediate(handle);\n        }\n    })\n});\nfunction RIL() {\n    return _ril;\n}\n(function (RIL) {\n    function install() {\n        ral_1.default.install(_ril);\n    }\n    RIL.install = install;\n})(RIL || (RIL = {}));\nexports.default = RIL;\n//# sourceMappingURL=ril.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-jsonrpc/lib/node/ril.js?");

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/node.js":
/*!*********************************************!*\
  !*** ./node_modules/vscode-jsonrpc/node.js ***!
  \*********************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ----------------------------------------------------------------------------------------- */\n\n\nmodule.exports = __webpack_require__(/*! ./lib/node/main */ \"./node_modules/vscode-jsonrpc/lib/node/main.js\");\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-jsonrpc/node.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/api.js":
/*!***********************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/api.js ***!
  \***********************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__export(__webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/node/main.js\"));\n__export(__webpack_require__(/*! vscode-languageserver-types */ \"./node_modules/vscode-languageserver-types/lib/esm/main.js\"));\n__export(__webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/common/messages.js\"));\n__export(__webpack_require__(/*! ./protocol */ \"./node_modules/vscode-languageserver-protocol/lib/common/protocol.js\"));\nvar connection_1 = __webpack_require__(/*! ./connection */ \"./node_modules/vscode-languageserver-protocol/lib/common/connection.js\");\nexports.createProtocolConnection = connection_1.createProtocolConnection;\nconst st = __webpack_require__(/*! ./protocol.semanticTokens.proposed */ \"./node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.proposed.js\");\nvar Proposed;\n(function (Proposed) {\n    Proposed.SemanticTokenTypes = st.SemanticTokenTypes;\n    Proposed.SemanticTokenModifiers = st.SemanticTokenModifiers;\n    Proposed.SemanticTokens = st.SemanticTokens;\n    let SemanticTokensRequest;\n    (function (SemanticTokensRequest) {\n        SemanticTokensRequest.method = st.SemanticTokensRequest.method;\n        SemanticTokensRequest.type = st.SemanticTokensRequest.type;\n    })(SemanticTokensRequest = Proposed.SemanticTokensRequest || (Proposed.SemanticTokensRequest = {}));\n    let SemanticTokensEditsRequest;\n    (function (SemanticTokensEditsRequest) {\n        SemanticTokensEditsRequest.method = st.SemanticTokensEditsRequest.method;\n        SemanticTokensEditsRequest.type = st.SemanticTokensEditsRequest.type;\n    })(SemanticTokensEditsRequest = Proposed.SemanticTokensEditsRequest || (Proposed.SemanticTokensEditsRequest = {}));\n    let SemanticTokensRangeRequest;\n    (function (SemanticTokensRangeRequest) {\n        SemanticTokensRangeRequest.method = st.SemanticTokensRangeRequest.method;\n        SemanticTokensRangeRequest.type = st.SemanticTokensRangeRequest.type;\n    })(SemanticTokensRangeRequest = Proposed.SemanticTokensRangeRequest || (Proposed.SemanticTokensRangeRequest = {}));\n})(Proposed = exports.Proposed || (exports.Proposed = {}));\n//# sourceMappingURL=api.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/lib/common/api.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/connection.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/connection.js ***!
  \******************************************************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export createProtocolConnection [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/node/main.js\");\nfunction createProtocolConnection(input, output, logger, options) {\n    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {\n        options = { connectionStrategy: options };\n    }\n    return vscode_jsonrpc_1.createMessageConnection(input, output, logger, options);\n}\nexports.createProtocolConnection = createProtocolConnection;\n//# sourceMappingURL=connection.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/lib/common/connection.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/messages.js ***!
  \****************************************************************************/
/*! flagged exports */
/*! export ProtocolNotificationType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ProtocolNotificationType0 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ProtocolRequestType [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ProtocolRequestType0 [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/node/main.js\");\nclass ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {\n    constructor(method) {\n        super(method);\n    }\n}\nexports.ProtocolRequestType0 = ProtocolRequestType0;\nclass ProtocolRequestType extends vscode_jsonrpc_1.RequestType {\n    constructor(method) {\n        super(method, vscode_jsonrpc_1.ParameterStructures.byName);\n    }\n}\nexports.ProtocolRequestType = ProtocolRequestType;\nclass ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {\n    constructor(method) {\n        super(method, vscode_jsonrpc_1.ParameterStructures.byName);\n    }\n}\nexports.ProtocolNotificationType = ProtocolNotificationType;\nclass ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {\n    constructor(method) {\n        super(method);\n    }\n}\nexports.ProtocolNotificationType0 = ProtocolNotificationType0;\n//# sourceMappingURL=messages.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/lib/common/messages.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js ***!
  \******************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) TypeFox and others. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/common/messages.js\");\n/**\n * A request to result a `CallHierarchyItem` in a document at a given position.\n * Can be used as an input to a incoming or outgoing call hierarchy.\n *\n * @since 3.16.0\n */\nvar CallHierarchyPrepareRequest;\n(function (CallHierarchyPrepareRequest) {\n    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';\n    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);\n})(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));\n/**\n * A request to resolve the incoming calls for a given `CallHierarchyItem`.\n *\n * @since 3.16.0\n */\nvar CallHierarchyIncomingCallsRequest;\n(function (CallHierarchyIncomingCallsRequest) {\n    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';\n    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);\n})(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));\n/**\n * A request to resolve the outgoing calls for a given `CallHierarchyItem`.\n *\n * @since 3.16.0\n */\nvar CallHierarchyOutgoingCallsRequest;\n(function (CallHierarchyOutgoingCallsRequest) {\n    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';\n    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);\n})(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));\n//# sourceMappingURL=protocol.callHierarchy.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js ***!
  \******************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/node/main.js\");\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/common/messages.js\");\n/**\n * A request to list all color symbols found in a given text document. The request's\n * parameter is of type [DocumentColorParams](#DocumentColorParams) the\n * response is of type [ColorInformation[]](#ColorInformation) or a Thenable\n * that resolves to such.\n */\nvar DocumentColorRequest;\n(function (DocumentColorRequest) {\n    DocumentColorRequest.method = 'textDocument/documentColor';\n    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);\n    /** @deprecated Use DocumentColorRequest.type */\n    DocumentColorRequest.resultType = new vscode_jsonrpc_1.ProgressType();\n})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));\n/**\n * A request to list all presentation for a color. The request's\n * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the\n * response is of type [ColorInformation[]](#ColorInformation) or a Thenable\n * that resolves to such.\n */\nvar ColorPresentationRequest;\n(function (ColorPresentationRequest) {\n    ColorPresentationRequest.type = new messages_1.ProtocolRequestType('textDocument/colorPresentation');\n})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));\n//# sourceMappingURL=protocol.colorProvider.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js ***!
  \******************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/common/messages.js\");\n/**\n * The 'workspace/configuration' request is sent from the server to the client to fetch a certain\n * configuration setting.\n *\n * This pull model replaces the old push model were the client signaled configuration change via an\n * event. If the server still needs to react to configuration changes (since the server caches the\n * result of `workspace/configuration` requests) the server should register for an empty configuration\n * change event and empty the cache if such an event is received.\n */\nvar ConfigurationRequest;\n(function (ConfigurationRequest) {\n    ConfigurationRequest.type = new messages_1.ProtocolRequestType('workspace/configuration');\n})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));\n//# sourceMappingURL=protocol.configuration.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js ***!
  \****************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/node/main.js\");\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/common/messages.js\");\n// @ts-ignore: to avoid inlining LocatioLink as dynamic import\nlet __noDynamicImport;\n/**\n * A request to resolve the type definition locations of a symbol at a given text\n * document position. The request's parameter is of type [TextDocumentPositioParams]\n * (#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)\n * or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves\n * to such.\n */\nvar DeclarationRequest;\n(function (DeclarationRequest) {\n    DeclarationRequest.method = 'textDocument/declaration';\n    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);\n    /** @deprecated Use DeclarationRequest.type */\n    DeclarationRequest.resultType = new vscode_jsonrpc_1.ProgressType();\n})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));\n//# sourceMappingURL=protocol.declaration.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js ***!
  \*****************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/node/main.js\");\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/common/messages.js\");\n/**\n * Enum of known range kinds\n */\nvar FoldingRangeKind;\n(function (FoldingRangeKind) {\n    /**\n     * Folding range for a comment\n     */\n    FoldingRangeKind[\"Comment\"] = \"comment\";\n    /**\n     * Folding range for a imports or includes\n     */\n    FoldingRangeKind[\"Imports\"] = \"imports\";\n    /**\n     * Folding range for a region (e.g. `#region`)\n     */\n    FoldingRangeKind[\"Region\"] = \"region\";\n})(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));\n/**\n * A request to provide folding ranges in a document. The request's\n * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the\n * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable\n * that resolves to such.\n */\nvar FoldingRangeRequest;\n(function (FoldingRangeRequest) {\n    FoldingRangeRequest.method = 'textDocument/foldingRange';\n    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);\n    /** @deprecated Use FoldingRangeRequest.type */\n    FoldingRangeRequest.resultType = new vscode_jsonrpc_1.ProgressType();\n})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));\n//# sourceMappingURL=protocol.foldingRange.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js ***!
  \*******************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/node/main.js\");\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/common/messages.js\");\n// @ts-ignore: to avoid inlining LocatioLink as dynamic import\nlet __noDynamicImport;\n/**\n * A request to resolve the implementation locations of a symbol at a given text\n * document position. The request's parameter is of type [TextDocumentPositioParams]\n * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a\n * Thenable that resolves to such.\n */\nvar ImplementationRequest;\n(function (ImplementationRequest) {\n    ImplementationRequest.method = 'textDocument/implementation';\n    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);\n    /** @deprecated Use ImplementationRequest.type */\n    ImplementationRequest.resultType = new vscode_jsonrpc_1.ProgressType();\n})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));\n//# sourceMappingURL=protocol.implementation.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.js ***!
  \****************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Is = __webpack_require__(/*! ./utils/is */ \"./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js\");\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/node/main.js\");\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/common/messages.js\");\nconst protocol_implementation_1 = __webpack_require__(/*! ./protocol.implementation */ \"./node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js\");\nexports.ImplementationRequest = protocol_implementation_1.ImplementationRequest;\nconst protocol_typeDefinition_1 = __webpack_require__(/*! ./protocol.typeDefinition */ \"./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js\");\nexports.TypeDefinitionRequest = protocol_typeDefinition_1.TypeDefinitionRequest;\nconst protocol_workspaceFolders_1 = __webpack_require__(/*! ./protocol.workspaceFolders */ \"./node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js\");\nexports.WorkspaceFoldersRequest = protocol_workspaceFolders_1.WorkspaceFoldersRequest;\nexports.DidChangeWorkspaceFoldersNotification = protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;\nconst protocol_configuration_1 = __webpack_require__(/*! ./protocol.configuration */ \"./node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js\");\nexports.ConfigurationRequest = protocol_configuration_1.ConfigurationRequest;\nconst protocol_colorProvider_1 = __webpack_require__(/*! ./protocol.colorProvider */ \"./node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js\");\nexports.DocumentColorRequest = protocol_colorProvider_1.DocumentColorRequest;\nexports.ColorPresentationRequest = protocol_colorProvider_1.ColorPresentationRequest;\nconst protocol_foldingRange_1 = __webpack_require__(/*! ./protocol.foldingRange */ \"./node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js\");\nexports.FoldingRangeRequest = protocol_foldingRange_1.FoldingRangeRequest;\nconst protocol_declaration_1 = __webpack_require__(/*! ./protocol.declaration */ \"./node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js\");\nexports.DeclarationRequest = protocol_declaration_1.DeclarationRequest;\nconst protocol_selectionRange_1 = __webpack_require__(/*! ./protocol.selectionRange */ \"./node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js\");\nexports.SelectionRangeRequest = protocol_selectionRange_1.SelectionRangeRequest;\nconst protocol_progress_1 = __webpack_require__(/*! ./protocol.progress */ \"./node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js\");\nexports.WorkDoneProgress = protocol_progress_1.WorkDoneProgress;\nexports.WorkDoneProgressCreateRequest = protocol_progress_1.WorkDoneProgressCreateRequest;\nexports.WorkDoneProgressCancelNotification = protocol_progress_1.WorkDoneProgressCancelNotification;\nconst protocol_callHierarchy_1 = __webpack_require__(/*! ./protocol.callHierarchy */ \"./node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js\");\nexports.CallHierarchyIncomingCallsRequest = protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;\nexports.CallHierarchyOutgoingCallsRequest = protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;\nexports.CallHierarchyPrepareRequest = protocol_callHierarchy_1.CallHierarchyPrepareRequest;\n// @ts-ignore: to avoid inlining LocatioLink as dynamic import\nlet __noDynamicImport;\n/**\n * The DocumentFilter namespace provides helper functions to work with\n * [DocumentFilter](#DocumentFilter) literals.\n */\nvar DocumentFilter;\n(function (DocumentFilter) {\n    function is(value) {\n        const candidate = value;\n        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);\n    }\n    DocumentFilter.is = is;\n})(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));\n/**\n * The DocumentSelector namespace provides helper functions to work with\n * [DocumentSelector](#DocumentSelector)s.\n */\nvar DocumentSelector;\n(function (DocumentSelector) {\n    function is(value) {\n        if (!Array.isArray(value)) {\n            return false;\n        }\n        for (let elem of value) {\n            if (!Is.string(elem) && !DocumentFilter.is(elem)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    DocumentSelector.is = is;\n})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));\n/**\n * The `client/registerCapability` request is sent from the server to the client to register a new capability\n * handler on the client side.\n */\nvar RegistrationRequest;\n(function (RegistrationRequest) {\n    RegistrationRequest.type = new messages_1.ProtocolRequestType('client/registerCapability');\n})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));\n/**\n * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability\n * handler on the client side.\n */\nvar UnregistrationRequest;\n(function (UnregistrationRequest) {\n    UnregistrationRequest.type = new messages_1.ProtocolRequestType('client/unregisterCapability');\n})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));\nvar ResourceOperationKind;\n(function (ResourceOperationKind) {\n    /**\n     * Supports creating new files and folders.\n     */\n    ResourceOperationKind.Create = 'create';\n    /**\n     * Supports renaming existing files and folders.\n     */\n    ResourceOperationKind.Rename = 'rename';\n    /**\n     * Supports deleting existing files and folders.\n     */\n    ResourceOperationKind.Delete = 'delete';\n})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));\nvar FailureHandlingKind;\n(function (FailureHandlingKind) {\n    /**\n     * Applying the workspace change is simply aborted if one of the changes provided\n     * fails. All operations executed before the failing operation stay executed.\n     */\n    FailureHandlingKind.Abort = 'abort';\n    /**\n     * All operations are executed transactional. That means they either all\n     * succeed or no changes at all are applied to the workspace.\n     */\n    FailureHandlingKind.Transactional = 'transactional';\n    /**\n     * If the workspace edit contains only textual file changes they are executed transactional.\n     * If resource changes (create, rename or delete file) are part of the change the failure\n     * handling startegy is abort.\n     */\n    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';\n    /**\n     * The client tries to undo the operations already executed. But there is no\n     * guarantee that this is succeeding.\n     */\n    FailureHandlingKind.Undo = 'undo';\n})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));\n/**\n * The StaticRegistrationOptions namespace provides helper functions to work with\n * [StaticRegistrationOptions](#StaticRegistrationOptions) literals.\n */\nvar StaticRegistrationOptions;\n(function (StaticRegistrationOptions) {\n    function hasId(value) {\n        const candidate = value;\n        return candidate && Is.string(candidate.id) && candidate.id.length > 0;\n    }\n    StaticRegistrationOptions.hasId = hasId;\n})(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));\n/**\n * The TextDocumentRegistrationOptions namespace provides helper functions to work with\n * [TextDocumentRegistrationOptions](#TextDocumentRegistrationOptions) literals.\n */\nvar TextDocumentRegistrationOptions;\n(function (TextDocumentRegistrationOptions) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));\n    }\n    TextDocumentRegistrationOptions.is = is;\n})(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));\n/**\n * The WorkDoneProgressOptions namespace provides helper functions to work with\n * [WorkDoneProgressOptions](#WorkDoneProgressOptions) literals.\n */\nvar WorkDoneProgressOptions;\n(function (WorkDoneProgressOptions) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));\n    }\n    WorkDoneProgressOptions.is = is;\n    function hasWorkDoneProgress(value) {\n        const candidate = value;\n        return candidate && Is.boolean(candidate.workDoneProgress);\n    }\n    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;\n})(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));\n/**\n * The initialize request is sent from the client to the server.\n * It is sent once as the request after starting up the server.\n * The requests parameter is of type [InitializeParams](#InitializeParams)\n * the response if of type [InitializeResult](#InitializeResult) of a Thenable that\n * resolves to such.\n */\nvar InitializeRequest;\n(function (InitializeRequest) {\n    InitializeRequest.type = new messages_1.ProtocolRequestType('initialize');\n})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));\n/**\n * Known error codes for an `InitializeError`;\n */\nvar InitializeError;\n(function (InitializeError) {\n    /**\n     * If the protocol version provided by the client can't be handled by the server.\n     * @deprecated This initialize error got replaced by client capabilities. There is\n     * no version handshake in version 3.0x\n     */\n    InitializeError.unknownProtocolVersion = 1;\n})(InitializeError = exports.InitializeError || (exports.InitializeError = {}));\n/**\n * The intialized notification is sent from the client to the\n * server after the client is fully initialized and the server\n * is allowed to send requests from the server to the client.\n */\nvar InitializedNotification;\n(function (InitializedNotification) {\n    InitializedNotification.type = new messages_1.ProtocolNotificationType('initialized');\n})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));\n//---- Shutdown Method ----\n/**\n * A shutdown request is sent from the client to the server.\n * It is sent once when the client decides to shutdown the\n * server. The only notification that is sent after a shutdown request\n * is the exit event.\n */\nvar ShutdownRequest;\n(function (ShutdownRequest) {\n    ShutdownRequest.type = new messages_1.ProtocolRequestType0('shutdown');\n})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));\n//---- Exit Notification ----\n/**\n * The exit event is sent from the client to the server to\n * ask the server to exit its process.\n */\nvar ExitNotification;\n(function (ExitNotification) {\n    ExitNotification.type = new messages_1.ProtocolNotificationType0('exit');\n})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));\n/**\n * The configuration change notification is sent from the client to the server\n * when the client's configuration has changed. The notification contains\n * the changed configuration as defined by the language client.\n */\nvar DidChangeConfigurationNotification;\n(function (DidChangeConfigurationNotification) {\n    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeConfiguration');\n})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));\n//---- Message show and log notifications ----\n/**\n * The message type\n */\nvar MessageType;\n(function (MessageType) {\n    /**\n     * An error message.\n     */\n    MessageType.Error = 1;\n    /**\n     * A warning message.\n     */\n    MessageType.Warning = 2;\n    /**\n     * An information message.\n     */\n    MessageType.Info = 3;\n    /**\n     * A log message.\n     */\n    MessageType.Log = 4;\n})(MessageType = exports.MessageType || (exports.MessageType = {}));\n/**\n * The show message notification is sent from a server to a client to ask\n * the client to display a particular message in the user interface.\n */\nvar ShowMessageNotification;\n(function (ShowMessageNotification) {\n    ShowMessageNotification.type = new messages_1.ProtocolNotificationType('window/showMessage');\n})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));\n/**\n * The show message request is sent from the server to the client to show a message\n * and a set of options actions to the user.\n */\nvar ShowMessageRequest;\n(function (ShowMessageRequest) {\n    ShowMessageRequest.type = new messages_1.ProtocolRequestType('window/showMessageRequest');\n})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));\n/**\n * The log message notification is sent from the server to the client to ask\n * the client to log a particular message.\n */\nvar LogMessageNotification;\n(function (LogMessageNotification) {\n    LogMessageNotification.type = new messages_1.ProtocolNotificationType('window/logMessage');\n})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));\n//---- Telemetry notification\n/**\n * The telemetry event notification is sent from the server to the client to ask\n * the client to log telemetry data.\n */\nvar TelemetryEventNotification;\n(function (TelemetryEventNotification) {\n    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType('telemetry/event');\n})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));\n/**\n * Defines how the host (editor) should sync\n * document changes to the language server.\n */\nvar TextDocumentSyncKind;\n(function (TextDocumentSyncKind) {\n    /**\n     * Documents should not be synced at all.\n     */\n    TextDocumentSyncKind.None = 0;\n    /**\n     * Documents are synced by always sending the full content\n     * of the document.\n     */\n    TextDocumentSyncKind.Full = 1;\n    /**\n     * Documents are synced by sending the full content on open.\n     * After that only incremental updates to the document are\n     * send.\n     */\n    TextDocumentSyncKind.Incremental = 2;\n})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));\n/**\n * The document open notification is sent from the client to the server to signal\n * newly opened text documents. The document's truth is now managed by the client\n * and the server must not try to read the document's truth using the document's\n * uri. Open in this sense means it is managed by the client. It doesn't necessarily\n * mean that its content is presented in an editor. An open notification must not\n * be sent more than once without a corresponding close notification send before.\n * This means open and close notification must be balanced and the max open count\n * is one.\n */\nvar DidOpenTextDocumentNotification;\n(function (DidOpenTextDocumentNotification) {\n    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';\n    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);\n})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));\n/**\n * The document change notification is sent from the client to the server to signal\n * changes to a text document.\n */\nvar DidChangeTextDocumentNotification;\n(function (DidChangeTextDocumentNotification) {\n    DidChangeTextDocumentNotification.method = 'textDocument/didChange';\n    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);\n})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));\n/**\n * The document close notification is sent from the client to the server when\n * the document got closed in the client. The document's truth now exists where\n * the document's uri points to (e.g. if the document's uri is a file uri the\n * truth now exists on disk). As with the open notification the close notification\n * is about managing the document's content. Receiving a close notification\n * doesn't mean that the document was open in an editor before. A close\n * notification requires a previous open notification to be sent.\n */\nvar DidCloseTextDocumentNotification;\n(function (DidCloseTextDocumentNotification) {\n    DidCloseTextDocumentNotification.method = 'textDocument/didClose';\n    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);\n})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));\n/**\n * The document save notification is sent from the client to the server when\n * the document got saved in the client.\n */\nvar DidSaveTextDocumentNotification;\n(function (DidSaveTextDocumentNotification) {\n    DidSaveTextDocumentNotification.method = 'textDocument/didSave';\n    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);\n})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));\n/**\n * Represents reasons why a text document is saved.\n */\nvar TextDocumentSaveReason;\n(function (TextDocumentSaveReason) {\n    /**\n     * Manually triggered, e.g. by the user pressing save, by starting debugging,\n     * or by an API call.\n     */\n    TextDocumentSaveReason.Manual = 1;\n    /**\n     * Automatic after a delay.\n     */\n    TextDocumentSaveReason.AfterDelay = 2;\n    /**\n     * When the editor lost focus.\n     */\n    TextDocumentSaveReason.FocusOut = 3;\n})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));\n/**\n * A document will save notification is sent from the client to the server before\n * the document is actually saved.\n */\nvar WillSaveTextDocumentNotification;\n(function (WillSaveTextDocumentNotification) {\n    WillSaveTextDocumentNotification.method = 'textDocument/willSave';\n    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);\n})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));\n/**\n * A document will save request is sent from the client to the server before\n * the document is actually saved. The request can return an array of TextEdits\n * which will be applied to the text document before it is saved. Please note that\n * clients might drop results if computing the text edits took too long or if a\n * server constantly fails on this request. This is done to keep the save fast and\n * reliable.\n */\nvar WillSaveTextDocumentWaitUntilRequest;\n(function (WillSaveTextDocumentWaitUntilRequest) {\n    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';\n    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);\n})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));\n/**\n * The watched files notification is sent from the client to the server when\n * the client detects changes to file watched by the language client.\n */\nvar DidChangeWatchedFilesNotification;\n(function (DidChangeWatchedFilesNotification) {\n    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWatchedFiles');\n})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));\n/**\n * The file event type\n */\nvar FileChangeType;\n(function (FileChangeType) {\n    /**\n     * The file got created.\n     */\n    FileChangeType.Created = 1;\n    /**\n     * The file got changed.\n     */\n    FileChangeType.Changed = 2;\n    /**\n     * The file got deleted.\n     */\n    FileChangeType.Deleted = 3;\n})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));\nvar WatchKind;\n(function (WatchKind) {\n    /**\n     * Interested in create events.\n     */\n    WatchKind.Create = 1;\n    /**\n     * Interested in change events\n     */\n    WatchKind.Change = 2;\n    /**\n     * Interested in delete events\n     */\n    WatchKind.Delete = 4;\n})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));\n/**\n * Diagnostics notification are sent from the server to the client to signal\n * results of validation runs.\n */\nvar PublishDiagnosticsNotification;\n(function (PublishDiagnosticsNotification) {\n    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType('textDocument/publishDiagnostics');\n})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));\n/**\n * How a completion was triggered\n */\nvar CompletionTriggerKind;\n(function (CompletionTriggerKind) {\n    /**\n     * Completion was triggered by typing an identifier (24x7 code\n     * complete), manual invocation (e.g Ctrl+Space) or via API.\n     */\n    CompletionTriggerKind.Invoked = 1;\n    /**\n     * Completion was triggered by a trigger character specified by\n     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.\n     */\n    CompletionTriggerKind.TriggerCharacter = 2;\n    /**\n     * Completion was re-triggered as current completion list is incomplete\n     */\n    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;\n})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));\n/**\n * Request to request completion at a given text document position. The request's\n * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response\n * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)\n * or a Thenable that resolves to such.\n *\n * The request can delay the computation of the [`detail`](#CompletionItem.detail)\n * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`\n * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,\n * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.\n */\nvar CompletionRequest;\n(function (CompletionRequest) {\n    CompletionRequest.method = 'textDocument/completion';\n    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);\n    /** @deprecated Use CompletionRequest.type */\n    CompletionRequest.resultType = new vscode_jsonrpc_1.ProgressType();\n})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));\n/**\n * Request to resolve additional information for a given completion item.The request's\n * parameter is of type [CompletionItem](#CompletionItem) the response\n * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.\n */\nvar CompletionResolveRequest;\n(function (CompletionResolveRequest) {\n    CompletionResolveRequest.method = 'completionItem/resolve';\n    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);\n})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));\n/**\n * Request to request hover information at a given text document position. The request's\n * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of\n * type [Hover](#Hover) or a Thenable that resolves to such.\n */\nvar HoverRequest;\n(function (HoverRequest) {\n    HoverRequest.method = 'textDocument/hover';\n    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);\n})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));\n/**\n * How a signature help was triggered.\n *\n * @since 3.15.0\n */\nvar SignatureHelpTriggerKind;\n(function (SignatureHelpTriggerKind) {\n    /**\n     * Signature help was invoked manually by the user or by a command.\n     */\n    SignatureHelpTriggerKind.Invoked = 1;\n    /**\n     * Signature help was triggered by a trigger character.\n     */\n    SignatureHelpTriggerKind.TriggerCharacter = 2;\n    /**\n     * Signature help was triggered by the cursor moving or by the document content changing.\n     */\n    SignatureHelpTriggerKind.ContentChange = 3;\n})(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));\nvar SignatureHelpRequest;\n(function (SignatureHelpRequest) {\n    SignatureHelpRequest.method = 'textDocument/signatureHelp';\n    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);\n})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));\n/**\n * A request to resolve the definition location of a symbol at a given text\n * document position. The request's parameter is of type [TextDocumentPosition]\n * (#TextDocumentPosition) the response is of either type [Definition](#Definition)\n * or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves\n * to such.\n */\nvar DefinitionRequest;\n(function (DefinitionRequest) {\n    DefinitionRequest.method = 'textDocument/definition';\n    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);\n    /** @deprecated Use DefinitionRequest.type */\n    DefinitionRequest.resultType = new vscode_jsonrpc_1.ProgressType();\n})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));\n/**\n * A request to resolve project-wide references for the symbol denoted\n * by the given text document position. The request's parameter is of\n * type [ReferenceParams](#ReferenceParams) the response is of type\n * [Location[]](#Location) or a Thenable that resolves to such.\n */\nvar ReferencesRequest;\n(function (ReferencesRequest) {\n    ReferencesRequest.method = 'textDocument/references';\n    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);\n    /** @deprecated Use ReferencesRequest.type */\n    ReferencesRequest.resultType = new vscode_jsonrpc_1.ProgressType();\n})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));\n/**\n * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given\n * text document position. The request's parameter is of type [TextDocumentPosition]\n * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]\n * (#DocumentHighlight) or a Thenable that resolves to such.\n */\nvar DocumentHighlightRequest;\n(function (DocumentHighlightRequest) {\n    DocumentHighlightRequest.method = 'textDocument/documentHighlight';\n    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);\n    /** @deprecated Use DocumentHighlightRequest.type */\n    DocumentHighlightRequest.resultType = new vscode_jsonrpc_1.ProgressType();\n})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));\n/**\n * A request to list all symbols found in a given text document. The request's\n * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the\n * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable\n * that resolves to such.\n */\nvar DocumentSymbolRequest;\n(function (DocumentSymbolRequest) {\n    DocumentSymbolRequest.method = 'textDocument/documentSymbol';\n    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);\n    /** @deprecated Use DocumentSymbolRequest.type */\n    DocumentSymbolRequest.resultType = new vscode_jsonrpc_1.ProgressType();\n})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));\n/**\n * A request to provide commands for the given text document and range.\n */\nvar CodeActionRequest;\n(function (CodeActionRequest) {\n    CodeActionRequest.method = 'textDocument/codeAction';\n    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);\n    /** @deprecated Use CodeActionRequest.type */\n    CodeActionRequest.resultType = new vscode_jsonrpc_1.ProgressType();\n})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));\n/**\n * A request to list project-wide symbols matching the query string given\n * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is\n * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that\n * resolves to such.\n */\nvar WorkspaceSymbolRequest;\n(function (WorkspaceSymbolRequest) {\n    WorkspaceSymbolRequest.method = 'workspace/symbol';\n    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);\n    /** @deprecated Use WorkspaceSymbolRequest.type */\n    WorkspaceSymbolRequest.resultType = new vscode_jsonrpc_1.ProgressType();\n})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));\n/**\n * A request to provide code lens for the given text document.\n */\nvar CodeLensRequest;\n(function (CodeLensRequest) {\n    CodeLensRequest.type = new messages_1.ProtocolRequestType('textDocument/codeLens');\n    /** @deprecated Use CodeLensRequest.type */\n    CodeLensRequest.resultType = new vscode_jsonrpc_1.ProgressType();\n})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));\n/**\n * A request to resolve a command for a given code lens.\n */\nvar CodeLensResolveRequest;\n(function (CodeLensResolveRequest) {\n    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType('codeLens/resolve');\n})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));\n/**\n * A request to provide document links\n */\nvar DocumentLinkRequest;\n(function (DocumentLinkRequest) {\n    DocumentLinkRequest.method = 'textDocument/documentLink';\n    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);\n    /** @deprecated Use DocumentLinkRequest.type */\n    DocumentLinkRequest.resultType = new vscode_jsonrpc_1.ProgressType();\n})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));\n/**\n * Request to resolve additional information for a given document link. The request's\n * parameter is of type [DocumentLink](#DocumentLink) the response\n * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.\n */\nvar DocumentLinkResolveRequest;\n(function (DocumentLinkResolveRequest) {\n    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType('documentLink/resolve');\n})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));\n/**\n * A request to to format a whole document.\n */\nvar DocumentFormattingRequest;\n(function (DocumentFormattingRequest) {\n    DocumentFormattingRequest.method = 'textDocument/formatting';\n    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);\n})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));\n/**\n * A request to to format a range in a document.\n */\nvar DocumentRangeFormattingRequest;\n(function (DocumentRangeFormattingRequest) {\n    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';\n    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);\n})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));\n/**\n * A request to format a document on type.\n */\nvar DocumentOnTypeFormattingRequest;\n(function (DocumentOnTypeFormattingRequest) {\n    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';\n    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);\n})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));\n/**\n * A request to rename a symbol.\n */\nvar RenameRequest;\n(function (RenameRequest) {\n    RenameRequest.method = 'textDocument/rename';\n    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);\n})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));\n/**\n * A request to test and perform the setup necessary for a rename.\n */\nvar PrepareRenameRequest;\n(function (PrepareRenameRequest) {\n    PrepareRenameRequest.method = 'textDocument/prepareRename';\n    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);\n})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));\n/**\n * A request send from the client to the server to execute a command. The request might return\n * a workspace edit which the client will apply to the workspace.\n */\nvar ExecuteCommandRequest;\n(function (ExecuteCommandRequest) {\n    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType('workspace/executeCommand');\n})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));\n/**\n * A request sent from the server to the client to modified certain resources.\n */\nvar ApplyWorkspaceEditRequest;\n(function (ApplyWorkspaceEditRequest) {\n    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');\n})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));\n//# sourceMappingURL=protocol.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js ***!
  \*************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/node/main.js\");\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/common/messages.js\");\nvar WorkDoneProgress;\n(function (WorkDoneProgress) {\n    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();\n})(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));\n/**\n * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress\n * reporting from the server.\n */\nvar WorkDoneProgressCreateRequest;\n(function (WorkDoneProgressCreateRequest) {\n    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType('window/workDoneProgress/create');\n})(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));\n/**\n * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress\n * initiated on the server side.\n */\nvar WorkDoneProgressCancelNotification;\n(function (WorkDoneProgressCancelNotification) {\n    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType('window/workDoneProgress/cancel');\n})(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));\n//# sourceMappingURL=protocol.progress.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js ***!
  \*******************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/node/main.js\");\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/common/messages.js\");\n/**\n * A request to provide selection ranges in a document. The request's\n * parameter is of type [SelectionRangeParams](#SelectionRangeParams), the\n * response is of type [SelectionRange[]](#SelectionRange[]) or a Thenable\n * that resolves to such.\n */\nvar SelectionRangeRequest;\n(function (SelectionRangeRequest) {\n    SelectionRangeRequest.method = 'textDocument/selectionRange';\n    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);\n    /** @deprecated  Use SelectionRangeRequest.type */\n    SelectionRangeRequest.resultType = new vscode_jsonrpc_1.ProgressType();\n})(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));\n//# sourceMappingURL=protocol.selectionRange.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.proposed.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.proposed.js ***!
  \****************************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/common/messages.js\");\n/**\n * A set of predefined token types. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0 - Proposed state\n */\nvar SemanticTokenTypes;\n(function (SemanticTokenTypes) {\n    SemanticTokenTypes[\"namespace\"] = \"namespace\";\n    SemanticTokenTypes[\"type\"] = \"type\";\n    SemanticTokenTypes[\"class\"] = \"class\";\n    SemanticTokenTypes[\"enum\"] = \"enum\";\n    SemanticTokenTypes[\"interface\"] = \"interface\";\n    SemanticTokenTypes[\"struct\"] = \"struct\";\n    SemanticTokenTypes[\"typeParameter\"] = \"typeParameter\";\n    SemanticTokenTypes[\"parameter\"] = \"parameter\";\n    SemanticTokenTypes[\"variable\"] = \"variable\";\n    SemanticTokenTypes[\"property\"] = \"property\";\n    SemanticTokenTypes[\"enumMember\"] = \"enumMember\";\n    SemanticTokenTypes[\"event\"] = \"event\";\n    SemanticTokenTypes[\"function\"] = \"function\";\n    SemanticTokenTypes[\"member\"] = \"member\";\n    SemanticTokenTypes[\"macro\"] = \"macro\";\n    SemanticTokenTypes[\"keyword\"] = \"keyword\";\n    SemanticTokenTypes[\"modifier\"] = \"modifier\";\n    SemanticTokenTypes[\"comment\"] = \"comment\";\n    SemanticTokenTypes[\"string\"] = \"string\";\n    SemanticTokenTypes[\"number\"] = \"number\";\n    SemanticTokenTypes[\"regexp\"] = \"regexp\";\n    SemanticTokenTypes[\"operator\"] = \"operator\";\n})(SemanticTokenTypes = exports.SemanticTokenTypes || (exports.SemanticTokenTypes = {}));\n/**\n * A set of predefined token modifiers. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0 - Proposed state\n */\nvar SemanticTokenModifiers;\n(function (SemanticTokenModifiers) {\n    SemanticTokenModifiers[\"declaration\"] = \"declaration\";\n    SemanticTokenModifiers[\"definition\"] = \"definition\";\n    SemanticTokenModifiers[\"readonly\"] = \"readonly\";\n    SemanticTokenModifiers[\"static\"] = \"static\";\n    SemanticTokenModifiers[\"deprecated\"] = \"deprecated\";\n    SemanticTokenModifiers[\"abstract\"] = \"abstract\";\n    SemanticTokenModifiers[\"async\"] = \"async\";\n    SemanticTokenModifiers[\"modification\"] = \"modification\";\n    SemanticTokenModifiers[\"documentation\"] = \"documentation\";\n    SemanticTokenModifiers[\"defaultLibrary\"] = \"defaultLibrary\";\n})(SemanticTokenModifiers = exports.SemanticTokenModifiers || (exports.SemanticTokenModifiers = {}));\n/**\n * @since 3.16.0 - Proposed state\n */\nvar SemanticTokens;\n(function (SemanticTokens) {\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&\n            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');\n    }\n    SemanticTokens.is = is;\n})(SemanticTokens = exports.SemanticTokens || (exports.SemanticTokens = {}));\n/**\n * @since 3.16.0 - Proposed state\n */\nvar SemanticTokensRequest;\n(function (SemanticTokensRequest) {\n    SemanticTokensRequest.method = 'textDocument/semanticTokens';\n    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);\n})(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));\n/**\n * @since 3.16.0 - Proposed state\n */\nvar SemanticTokensEditsRequest;\n(function (SemanticTokensEditsRequest) {\n    SemanticTokensEditsRequest.method = 'textDocument/semanticTokens/edits';\n    SemanticTokensEditsRequest.type = new messages_1.ProtocolRequestType(SemanticTokensEditsRequest.method);\n})(SemanticTokensEditsRequest = exports.SemanticTokensEditsRequest || (exports.SemanticTokensEditsRequest = {}));\n/**\n * @since 3.16.0 - Proposed state\n */\nvar SemanticTokensRangeRequest;\n(function (SemanticTokensRangeRequest) {\n    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';\n    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);\n})(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));\n//# sourceMappingURL=protocol.semanticTokens.proposed.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.proposed.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js ***!
  \*******************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ \"./node_modules/vscode-jsonrpc/lib/node/main.js\");\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/common/messages.js\");\n// @ts-ignore: to avoid inlining LocatioLink as dynamic import\nlet __noDynamicImport;\n/**\n * A request to resolve the type definition locations of a symbol at a given text\n * document position. The request's parameter is of type [TextDocumentPositioParams]\n * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a\n * Thenable that resolves to such.\n */\nvar TypeDefinitionRequest;\n(function (TypeDefinitionRequest) {\n    TypeDefinitionRequest.method = 'textDocument/typeDefinition';\n    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);\n    /** @deprecated Use TypeDefinitionRequest.type */\n    TypeDefinitionRequest.resultType = new vscode_jsonrpc_1.ProgressType();\n})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));\n//# sourceMappingURL=protocol.typeDefinition.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js ***!
  \*********************************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst messages_1 = __webpack_require__(/*! ./messages */ \"./node_modules/vscode-languageserver-protocol/lib/common/messages.js\");\n/**\n * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.\n */\nvar WorkspaceFoldersRequest;\n(function (WorkspaceFoldersRequest) {\n    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0('workspace/workspaceFolders');\n})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));\n/**\n * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace\n * folder configuration changes.\n */\nvar DidChangeWorkspaceFoldersNotification;\n(function (DidChangeWorkspaceFoldersNotification) {\n    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWorkspaceFolders');\n})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));\n//# sourceMappingURL=protocol.workspaceFolders.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js ***!
  \****************************************************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export array [provided] [no usage info] [missing usage info prevents renaming] */
/*! export boolean [provided] [no usage info] [missing usage info prevents renaming] */
/*! export error [provided] [no usage info] [missing usage info prevents renaming] */
/*! export func [provided] [no usage info] [missing usage info prevents renaming] */
/*! export number [provided] [no usage info] [missing usage info prevents renaming] */
/*! export objectLiteral [provided] [no usage info] [missing usage info prevents renaming] */
/*! export string [provided] [no usage info] [missing usage info prevents renaming] */
/*! export stringArray [provided] [no usage info] [missing usage info prevents renaming] */
/*! export typedArray [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction boolean(value) {\n    return value === true || value === false;\n}\nexports.boolean = boolean;\nfunction string(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexports.string = string;\nfunction number(value) {\n    return typeof value === 'number' || value instanceof Number;\n}\nexports.number = number;\nfunction error(value) {\n    return value instanceof Error;\n}\nexports.error = error;\nfunction func(value) {\n    return typeof value === 'function';\n}\nexports.func = func;\nfunction array(value) {\n    return Array.isArray(value);\n}\nexports.array = array;\nfunction stringArray(value) {\n    return array(value) && value.every(elem => string(elem));\n}\nexports.stringArray = stringArray;\nfunction typedArray(value, check) {\n    return Array.isArray(value) && value.every(check);\n}\nexports.typedArray = typedArray;\nfunction objectLiteral(value) {\n    // Strictly speaking class instances pass this check as well. Since the LSP\n    // doesn't use classes we ignore this for now. If we do we need to add something\n    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n    return value !== null && typeof value === 'object';\n}\nexports.objectLiteral = objectLiteral;\n//# sourceMappingURL=is.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/node/main.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/node/main.js ***!
  \**********************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst node_1 = __webpack_require__(/*! vscode-jsonrpc/node */ \"./node_modules/vscode-jsonrpc/node.js\");\n__export(__webpack_require__(/*! vscode-jsonrpc/node */ \"./node_modules/vscode-jsonrpc/node.js\"));\n__export(__webpack_require__(/*! ../common/api */ \"./node_modules/vscode-languageserver-protocol/lib/common/api.js\"));\nfunction createProtocolConnection(input, output, logger, options) {\n    return node_1.createMessageConnection(input, output, logger, options);\n}\nexports.createProtocolConnection = createProtocolConnection;\n//# sourceMappingURL=main.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/lib/node/main.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/node.js":
/*!*************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/node.js ***!
  \*************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ----------------------------------------------------------------------------------------- */\n\n\nmodule.exports = __webpack_require__(/*! ./lib/node/main */ \"./node_modules/vscode-languageserver-protocol/lib/node/main.js\");\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-protocol/node.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver-types/lib/esm/main.js":
/*!******************************************************************!*\
  !*** ./node_modules/vscode-languageserver-types/lib/esm/main.js ***!
  \******************************************************************/
/*! namespace exports */
/*! export CodeAction [provided] [no usage info] [missing usage info prevents renaming] */
/*! export CodeActionContext [provided] [no usage info] [missing usage info prevents renaming] */
/*! export CodeActionKind [provided] [no usage info] [missing usage info prevents renaming] */
/*! export CodeLens [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Color [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ColorInformation [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ColorPresentation [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Command [provided] [no usage info] [missing usage info prevents renaming] */
/*! export CompletionItem [provided] [no usage info] [missing usage info prevents renaming] */
/*! export CompletionItemKind [provided] [no usage info] [missing usage info prevents renaming] */
/*! export CompletionItemTag [provided] [no usage info] [missing usage info prevents renaming] */
/*! export CompletionList [provided] [no usage info] [missing usage info prevents renaming] */
/*! export CreateFile [provided] [no usage info] [missing usage info prevents renaming] */
/*! export DeleteFile [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Diagnostic [provided] [no usage info] [missing usage info prevents renaming] */
/*! export DiagnosticCode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export DiagnosticRelatedInformation [provided] [no usage info] [missing usage info prevents renaming] */
/*! export DiagnosticSeverity [provided] [no usage info] [missing usage info prevents renaming] */
/*! export DiagnosticTag [provided] [no usage info] [missing usage info prevents renaming] */
/*! export DocumentHighlight [provided] [no usage info] [missing usage info prevents renaming] */
/*! export DocumentHighlightKind [provided] [no usage info] [missing usage info prevents renaming] */
/*! export DocumentLink [provided] [no usage info] [missing usage info prevents renaming] */
/*! export DocumentSymbol [provided] [no usage info] [missing usage info prevents renaming] */
/*! export EOL [provided] [no usage info] [missing usage info prevents renaming] */
/*! export FoldingRange [provided] [no usage info] [missing usage info prevents renaming] */
/*! export FoldingRangeKind [provided] [no usage info] [missing usage info prevents renaming] */
/*! export FormattingOptions [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Hover [provided] [no usage info] [missing usage info prevents renaming] */
/*! export InsertReplaceEdit [provided] [no usage info] [missing usage info prevents renaming] */
/*! export InsertTextFormat [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Location [provided] [no usage info] [missing usage info prevents renaming] */
/*! export LocationLink [provided] [no usage info] [missing usage info prevents renaming] */
/*! export MarkedString [provided] [no usage info] [missing usage info prevents renaming] */
/*! export MarkupContent [provided] [no usage info] [missing usage info prevents renaming] */
/*! export MarkupKind [provided] [no usage info] [missing usage info prevents renaming] */
/*! export ParameterInformation [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Position [provided] [no usage info] [missing usage info prevents renaming] */
/*! export Range [provided] [no usage info] [missing usage info prevents renaming] */
/*! export RenameFile [provided] [no usage info] [missing usage info prevents renaming] */
/*! export SelectionRange [provided] [no usage info] [missing usage info prevents renaming] */
/*! export SignatureInformation [provided] [no usage info] [missing usage info prevents renaming] */
/*! export SymbolInformation [provided] [no usage info] [missing usage info prevents renaming] */
/*! export SymbolKind [provided] [no usage info] [missing usage info prevents renaming] */
/*! export SymbolTag [provided] [no usage info] [missing usage info prevents renaming] */
/*! export TextDocument [provided] [no usage info] [missing usage info prevents renaming] */
/*! export TextDocumentEdit [provided] [no usage info] [missing usage info prevents renaming] */
/*! export TextDocumentIdentifier [provided] [no usage info] [missing usage info prevents renaming] */
/*! export TextDocumentItem [provided] [no usage info] [missing usage info prevents renaming] */
/*! export TextEdit [provided] [no usage info] [missing usage info prevents renaming] */
/*! export VersionedTextDocumentIdentifier [provided] [no usage info] [missing usage info prevents renaming] */
/*! export WorkspaceChange [provided] [no usage info] [missing usage info prevents renaming] */
/*! export WorkspaceEdit [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Position\": () => /* binding */ Position,\n/* harmony export */   \"Range\": () => /* binding */ Range,\n/* harmony export */   \"Location\": () => /* binding */ Location,\n/* harmony export */   \"LocationLink\": () => /* binding */ LocationLink,\n/* harmony export */   \"Color\": () => /* binding */ Color,\n/* harmony export */   \"ColorInformation\": () => /* binding */ ColorInformation,\n/* harmony export */   \"ColorPresentation\": () => /* binding */ ColorPresentation,\n/* harmony export */   \"FoldingRangeKind\": () => /* binding */ FoldingRangeKind,\n/* harmony export */   \"FoldingRange\": () => /* binding */ FoldingRange,\n/* harmony export */   \"DiagnosticRelatedInformation\": () => /* binding */ DiagnosticRelatedInformation,\n/* harmony export */   \"DiagnosticSeverity\": () => /* binding */ DiagnosticSeverity,\n/* harmony export */   \"DiagnosticTag\": () => /* binding */ DiagnosticTag,\n/* harmony export */   \"DiagnosticCode\": () => /* binding */ DiagnosticCode,\n/* harmony export */   \"Diagnostic\": () => /* binding */ Diagnostic,\n/* harmony export */   \"Command\": () => /* binding */ Command,\n/* harmony export */   \"TextEdit\": () => /* binding */ TextEdit,\n/* harmony export */   \"TextDocumentEdit\": () => /* binding */ TextDocumentEdit,\n/* harmony export */   \"CreateFile\": () => /* binding */ CreateFile,\n/* harmony export */   \"RenameFile\": () => /* binding */ RenameFile,\n/* harmony export */   \"DeleteFile\": () => /* binding */ DeleteFile,\n/* harmony export */   \"WorkspaceEdit\": () => /* binding */ WorkspaceEdit,\n/* harmony export */   \"WorkspaceChange\": () => /* binding */ WorkspaceChange,\n/* harmony export */   \"TextDocumentIdentifier\": () => /* binding */ TextDocumentIdentifier,\n/* harmony export */   \"VersionedTextDocumentIdentifier\": () => /* binding */ VersionedTextDocumentIdentifier,\n/* harmony export */   \"TextDocumentItem\": () => /* binding */ TextDocumentItem,\n/* harmony export */   \"MarkupKind\": () => /* binding */ MarkupKind,\n/* harmony export */   \"MarkupContent\": () => /* binding */ MarkupContent,\n/* harmony export */   \"CompletionItemKind\": () => /* binding */ CompletionItemKind,\n/* harmony export */   \"InsertTextFormat\": () => /* binding */ InsertTextFormat,\n/* harmony export */   \"CompletionItemTag\": () => /* binding */ CompletionItemTag,\n/* harmony export */   \"InsertReplaceEdit\": () => /* binding */ InsertReplaceEdit,\n/* harmony export */   \"CompletionItem\": () => /* binding */ CompletionItem,\n/* harmony export */   \"CompletionList\": () => /* binding */ CompletionList,\n/* harmony export */   \"MarkedString\": () => /* binding */ MarkedString,\n/* harmony export */   \"Hover\": () => /* binding */ Hover,\n/* harmony export */   \"ParameterInformation\": () => /* binding */ ParameterInformation,\n/* harmony export */   \"SignatureInformation\": () => /* binding */ SignatureInformation,\n/* harmony export */   \"DocumentHighlightKind\": () => /* binding */ DocumentHighlightKind,\n/* harmony export */   \"DocumentHighlight\": () => /* binding */ DocumentHighlight,\n/* harmony export */   \"SymbolKind\": () => /* binding */ SymbolKind,\n/* harmony export */   \"SymbolTag\": () => /* binding */ SymbolTag,\n/* harmony export */   \"SymbolInformation\": () => /* binding */ SymbolInformation,\n/* harmony export */   \"DocumentSymbol\": () => /* binding */ DocumentSymbol,\n/* harmony export */   \"CodeActionKind\": () => /* binding */ CodeActionKind,\n/* harmony export */   \"CodeActionContext\": () => /* binding */ CodeActionContext,\n/* harmony export */   \"CodeAction\": () => /* binding */ CodeAction,\n/* harmony export */   \"CodeLens\": () => /* binding */ CodeLens,\n/* harmony export */   \"FormattingOptions\": () => /* binding */ FormattingOptions,\n/* harmony export */   \"DocumentLink\": () => /* binding */ DocumentLink,\n/* harmony export */   \"SelectionRange\": () => /* binding */ SelectionRange,\n/* harmony export */   \"EOL\": () => /* binding */ EOL,\n/* harmony export */   \"TextDocument\": () => /* binding */ TextDocument\n/* harmony export */ });\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\n/**\n * The Position namespace provides helper functions to work with\n * [Position](#Position) literals.\n */\nvar Position;\n(function (Position) {\n    /**\n     * Creates a new Position literal from the given line and character.\n     * @param line The position's line.\n     * @param character The position's character.\n     */\n    function create(line, character) {\n        return { line: line, character: character };\n    }\n    Position.create = create;\n    /**\n     * Checks whether the given liternal conforms to the [Position](#Position) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.number(candidate.line) && Is.number(candidate.character);\n    }\n    Position.is = is;\n})(Position || (Position = {}));\n/**\n * The Range namespace provides helper functions to work with\n * [Range](#Range) literals.\n */\nvar Range;\n(function (Range) {\n    function create(one, two, three, four) {\n        if (Is.number(one) && Is.number(two) && Is.number(three) && Is.number(four)) {\n            return { start: Position.create(one, two), end: Position.create(three, four) };\n        }\n        else if (Position.is(one) && Position.is(two)) {\n            return { start: one, end: two };\n        }\n        else {\n            throw new Error(\"Range#create called with invalid arguments[\" + one + \", \" + two + \", \" + three + \", \" + four + \"]\");\n        }\n    }\n    Range.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Range](#Range) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n    }\n    Range.is = is;\n})(Range || (Range = {}));\n/**\n * The Location namespace provides helper functions to work with\n * [Location](#Location) literals.\n */\nvar Location;\n(function (Location) {\n    /**\n     * Creates a Location literal.\n     * @param uri The location's uri.\n     * @param range The location's range.\n     */\n    function create(uri, range) {\n        return { uri: uri, range: range };\n    }\n    Location.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Location](#Location) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n    }\n    Location.is = is;\n})(Location || (Location = {}));\n/**\n * The LocationLink namespace provides helper functions to work with\n * [LocationLink](#LocationLink) literals.\n */\nvar LocationLink;\n(function (LocationLink) {\n    /**\n     * Creates a LocationLink literal.\n     * @param targetUri The definition's uri.\n     * @param targetRange The full range of the definition.\n     * @param targetSelectionRange The span of the symbol definition at the target.\n     * @param originSelectionRange The span of the symbol being defined in the originating source file.\n     */\n    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };\n    }\n    LocationLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\n            && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange))\n            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n    }\n    LocationLink.is = is;\n})(LocationLink || (LocationLink = {}));\n/**\n * The Color namespace provides helper functions to work with\n * [Color](#Color) literals.\n */\nvar Color;\n(function (Color) {\n    /**\n     * Creates a new Color literal.\n     */\n    function create(red, green, blue, alpha) {\n        return {\n            red: red,\n            green: green,\n            blue: blue,\n            alpha: alpha,\n        };\n    }\n    Color.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Color](#Color) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.number(candidate.red)\n            && Is.number(candidate.green)\n            && Is.number(candidate.blue)\n            && Is.number(candidate.alpha);\n    }\n    Color.is = is;\n})(Color || (Color = {}));\n/**\n * The ColorInformation namespace provides helper functions to work with\n * [ColorInformation](#ColorInformation) literals.\n */\nvar ColorInformation;\n(function (ColorInformation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(range, color) {\n        return {\n            range: range,\n            color: color,\n        };\n    }\n    ColorInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Range.is(candidate.range) && Color.is(candidate.color);\n    }\n    ColorInformation.is = is;\n})(ColorInformation || (ColorInformation = {}));\n/**\n * The Color namespace provides helper functions to work with\n * [ColorPresentation](#ColorPresentation) literals.\n */\nvar ColorPresentation;\n(function (ColorPresentation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(label, textEdit, additionalTextEdits) {\n        return {\n            label: label,\n            textEdit: textEdit,\n            additionalTextEdits: additionalTextEdits,\n        };\n    }\n    ColorPresentation.create = create;\n    /**\n     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.string(candidate.label)\n            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\n            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n    }\n    ColorPresentation.is = is;\n})(ColorPresentation || (ColorPresentation = {}));\n/**\n * Enum of known range kinds\n */\nvar FoldingRangeKind;\n(function (FoldingRangeKind) {\n    /**\n     * Folding range for a comment\n     */\n    FoldingRangeKind[\"Comment\"] = \"comment\";\n    /**\n     * Folding range for a imports or includes\n     */\n    FoldingRangeKind[\"Imports\"] = \"imports\";\n    /**\n     * Folding range for a region (e.g. `#region`)\n     */\n    FoldingRangeKind[\"Region\"] = \"region\";\n})(FoldingRangeKind || (FoldingRangeKind = {}));\n/**\n * The folding range namespace provides helper functions to work with\n * [FoldingRange](#FoldingRange) literals.\n */\nvar FoldingRange;\n(function (FoldingRange) {\n    /**\n     * Creates a new FoldingRange literal.\n     */\n    function create(startLine, endLine, startCharacter, endCharacter, kind) {\n        var result = {\n            startLine: startLine,\n            endLine: endLine\n        };\n        if (Is.defined(startCharacter)) {\n            result.startCharacter = startCharacter;\n        }\n        if (Is.defined(endCharacter)) {\n            result.endCharacter = endCharacter;\n        }\n        if (Is.defined(kind)) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    FoldingRange.create = create;\n    /**\n     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.number(candidate.startLine) && Is.number(candidate.startLine)\n            && (Is.undefined(candidate.startCharacter) || Is.number(candidate.startCharacter))\n            && (Is.undefined(candidate.endCharacter) || Is.number(candidate.endCharacter))\n            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n    }\n    FoldingRange.is = is;\n})(FoldingRange || (FoldingRange = {}));\n/**\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\n * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.\n */\nvar DiagnosticRelatedInformation;\n(function (DiagnosticRelatedInformation) {\n    /**\n     * Creates a new DiagnosticRelatedInformation literal.\n     */\n    function create(location, message) {\n        return {\n            location: location,\n            message: message\n        };\n    }\n    DiagnosticRelatedInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n    }\n    DiagnosticRelatedInformation.is = is;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\n/**\n * The diagnostic's severity.\n */\nvar DiagnosticSeverity;\n(function (DiagnosticSeverity) {\n    /**\n     * Reports an error.\n     */\n    DiagnosticSeverity.Error = 1;\n    /**\n     * Reports a warning.\n     */\n    DiagnosticSeverity.Warning = 2;\n    /**\n     * Reports an information.\n     */\n    DiagnosticSeverity.Information = 3;\n    /**\n     * Reports a hint.\n     */\n    DiagnosticSeverity.Hint = 4;\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\n/**\n * The diagnostic tags.\n *\n * @since 3.15.0\n */\nvar DiagnosticTag;\n(function (DiagnosticTag) {\n    /**\n     * Unused or unnecessary code.\n     *\n     * Clients are allowed to render diagnostics with this tag faded out instead of having\n     * an error squiggle.\n     */\n    DiagnosticTag.Unnecessary = 1;\n    /**\n     * Deprecated or obsolete code.\n     *\n     * Clients are allowed to rendered diagnostics with this tag strike through.\n     */\n    DiagnosticTag.Deprecated = 2;\n})(DiagnosticTag || (DiagnosticTag = {}));\n/**\n * The DiagnosticCode namespace provides functions to deal with complex diagnostic codes.\n *\n * @since 3.16.0 - Proposed state\n */\nvar DiagnosticCode;\n(function (DiagnosticCode) {\n    /**\n     * Checks whether the given liternal conforms to the [DiagnosticCode](#DiagnosticCode) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && candidate !== null && (Is.number(candidate.value) || Is.string(candidate.value)) && Is.string(candidate.target);\n    }\n    DiagnosticCode.is = is;\n})(DiagnosticCode || (DiagnosticCode = {}));\n/**\n * The Diagnostic namespace provides helper functions to work with\n * [Diagnostic](#Diagnostic) literals.\n */\nvar Diagnostic;\n(function (Diagnostic) {\n    /**\n     * Creates a new Diagnostic literal.\n     */\n    function create(range, message, severity, code, source, relatedInformation) {\n        var result = { range: range, message: message };\n        if (Is.defined(severity)) {\n            result.severity = severity;\n        }\n        if (Is.defined(code)) {\n            result.code = code;\n        }\n        if (Is.defined(source)) {\n            result.source = source;\n        }\n        if (Is.defined(relatedInformation)) {\n            result.relatedInformation = relatedInformation;\n        }\n        return result;\n    }\n    Diagnostic.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate)\n            && Range.is(candidate.range)\n            && Is.string(candidate.message)\n            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\n            && (Is.number(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\n            && (Is.string(candidate.source) || Is.undefined(candidate.source))\n            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n    }\n    Diagnostic.is = is;\n})(Diagnostic || (Diagnostic = {}));\n/**\n * The Command namespace provides helper functions to work with\n * [Command](#Command) literals.\n */\nvar Command;\n(function (Command) {\n    /**\n     * Creates a new Command literal.\n     */\n    function create(title, command) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var result = { title: title, command: command };\n        if (Is.defined(args) && args.length > 0) {\n            result.arguments = args;\n        }\n        return result;\n    }\n    Command.create = create;\n    /**\n     * Checks whether the given literal conforms to the [Command](#Command) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n    }\n    Command.is = is;\n})(Command || (Command = {}));\n/**\n * The TextEdit namespace provides helper function to create replace,\n * insert and delete edits more easily.\n */\nvar TextEdit;\n(function (TextEdit) {\n    /**\n     * Creates a replace text edit.\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     */\n    function replace(range, newText) {\n        return { range: range, newText: newText };\n    }\n    TextEdit.replace = replace;\n    /**\n     * Creates a insert text edit.\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     */\n    function insert(position, newText) {\n        return { range: { start: position, end: position }, newText: newText };\n    }\n    TextEdit.insert = insert;\n    /**\n     * Creates a delete text edit.\n     * @param range The range of text to be deleted.\n     */\n    function del(range) {\n        return { range: range, newText: '' };\n    }\n    TextEdit.del = del;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate)\n            && Is.string(candidate.newText)\n            && Range.is(candidate.range);\n    }\n    TextEdit.is = is;\n})(TextEdit || (TextEdit = {}));\n/**\n * The TextDocumentEdit namespace provides helper function to create\n * an edit that manipulates a text document.\n */\nvar TextDocumentEdit;\n(function (TextDocumentEdit) {\n    /**\n     * Creates a new `TextDocumentEdit`\n     */\n    function create(textDocument, edits) {\n        return { textDocument: textDocument, edits: edits };\n    }\n    TextDocumentEdit.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate)\n            && VersionedTextDocumentIdentifier.is(candidate.textDocument)\n            && Array.isArray(candidate.edits);\n    }\n    TextDocumentEdit.is = is;\n})(TextDocumentEdit || (TextDocumentEdit = {}));\nvar CreateFile;\n(function (CreateFile) {\n    function create(uri, options) {\n        var result = {\n            kind: 'create',\n            uri: uri\n        };\n        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\n            result.options = options;\n        }\n        return result;\n    }\n    CreateFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) &&\n            (candidate.options === void 0 ||\n                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));\n    }\n    CreateFile.is = is;\n})(CreateFile || (CreateFile = {}));\nvar RenameFile;\n(function (RenameFile) {\n    function create(oldUri, newUri, options) {\n        var result = {\n            kind: 'rename',\n            oldUri: oldUri,\n            newUri: newUri\n        };\n        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\n            result.options = options;\n        }\n        return result;\n    }\n    RenameFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) &&\n            (candidate.options === void 0 ||\n                ((candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))));\n    }\n    RenameFile.is = is;\n})(RenameFile || (RenameFile = {}));\nvar DeleteFile;\n(function (DeleteFile) {\n    function create(uri, options) {\n        var result = {\n            kind: 'delete',\n            uri: uri\n        };\n        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {\n            result.options = options;\n        }\n        return result;\n    }\n    DeleteFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) &&\n            (candidate.options === void 0 ||\n                ((candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))));\n    }\n    DeleteFile.is = is;\n})(DeleteFile || (DeleteFile = {}));\nvar WorkspaceEdit;\n(function (WorkspaceEdit) {\n    function is(value) {\n        var candidate = value;\n        return candidate &&\n            (candidate.changes !== void 0 || candidate.documentChanges !== void 0) &&\n            (candidate.documentChanges === void 0 || candidate.documentChanges.every(function (change) {\n                if (Is.string(change.kind)) {\n                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n                }\n                else {\n                    return TextDocumentEdit.is(change);\n                }\n            }));\n    }\n    WorkspaceEdit.is = is;\n})(WorkspaceEdit || (WorkspaceEdit = {}));\nvar TextEditChangeImpl = /** @class */ (function () {\n    function TextEditChangeImpl(edits) {\n        this.edits = edits;\n    }\n    TextEditChangeImpl.prototype.insert = function (position, newText) {\n        this.edits.push(TextEdit.insert(position, newText));\n    };\n    TextEditChangeImpl.prototype.replace = function (range, newText) {\n        this.edits.push(TextEdit.replace(range, newText));\n    };\n    TextEditChangeImpl.prototype.delete = function (range) {\n        this.edits.push(TextEdit.del(range));\n    };\n    TextEditChangeImpl.prototype.add = function (edit) {\n        this.edits.push(edit);\n    };\n    TextEditChangeImpl.prototype.all = function () {\n        return this.edits;\n    };\n    TextEditChangeImpl.prototype.clear = function () {\n        this.edits.splice(0, this.edits.length);\n    };\n    return TextEditChangeImpl;\n}());\n/**\n * A workspace change helps constructing changes to a workspace.\n */\nvar WorkspaceChange = /** @class */ (function () {\n    function WorkspaceChange(workspaceEdit) {\n        var _this = this;\n        this._textEditChanges = Object.create(null);\n        if (workspaceEdit) {\n            this._workspaceEdit = workspaceEdit;\n            if (workspaceEdit.documentChanges) {\n                workspaceEdit.documentChanges.forEach(function (change) {\n                    if (TextDocumentEdit.is(change)) {\n                        var textEditChange = new TextEditChangeImpl(change.edits);\n                        _this._textEditChanges[change.textDocument.uri] = textEditChange;\n                    }\n                });\n            }\n            else if (workspaceEdit.changes) {\n                Object.keys(workspaceEdit.changes).forEach(function (key) {\n                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                    _this._textEditChanges[key] = textEditChange;\n                });\n            }\n        }\n    }\n    Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\n        /**\n         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal\n         * use to be returned from a workspace edit operation like rename.\n         */\n        get: function () {\n            if (this._workspaceEdit === undefined) {\n                return { documentChanges: [] };\n            }\n            return this._workspaceEdit;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    WorkspaceChange.prototype.getTextEditChange = function (key) {\n        if (VersionedTextDocumentIdentifier.is(key)) {\n            if (!this._workspaceEdit) {\n                this._workspaceEdit = {\n                    documentChanges: []\n                };\n            }\n            if (!this._workspaceEdit.documentChanges) {\n                throw new Error('Workspace edit is not configured for document changes.');\n            }\n            var textDocument = key;\n            var result = this._textEditChanges[textDocument.uri];\n            if (!result) {\n                var edits = [];\n                var textDocumentEdit = {\n                    textDocument: textDocument,\n                    edits: edits\n                };\n                this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                result = new TextEditChangeImpl(edits);\n                this._textEditChanges[textDocument.uri] = result;\n            }\n            return result;\n        }\n        else {\n            if (!this._workspaceEdit) {\n                this._workspaceEdit = {\n                    changes: Object.create(null)\n                };\n            }\n            if (!this._workspaceEdit.changes) {\n                throw new Error('Workspace edit is not configured for normal text edit changes.');\n            }\n            var result = this._textEditChanges[key];\n            if (!result) {\n                var edits = [];\n                this._workspaceEdit.changes[key] = edits;\n                result = new TextEditChangeImpl(edits);\n                this._textEditChanges[key] = result;\n            }\n            return result;\n        }\n    };\n    WorkspaceChange.prototype.createFile = function (uri, options) {\n        this.checkDocumentChanges();\n        this._workspaceEdit.documentChanges.push(CreateFile.create(uri, options));\n    };\n    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, options) {\n        this.checkDocumentChanges();\n        this._workspaceEdit.documentChanges.push(RenameFile.create(oldUri, newUri, options));\n    };\n    WorkspaceChange.prototype.deleteFile = function (uri, options) {\n        this.checkDocumentChanges();\n        this._workspaceEdit.documentChanges.push(DeleteFile.create(uri, options));\n    };\n    WorkspaceChange.prototype.checkDocumentChanges = function () {\n        if (!this._workspaceEdit || !this._workspaceEdit.documentChanges) {\n            throw new Error('Workspace edit is not configured for document changes.');\n        }\n    };\n    return WorkspaceChange;\n}());\n\n/**\n * The TextDocumentIdentifier namespace provides helper functions to work with\n * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.\n */\nvar TextDocumentIdentifier;\n(function (TextDocumentIdentifier) {\n    /**\n     * Creates a new TextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     */\n    function create(uri) {\n        return { uri: uri };\n    }\n    TextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri);\n    }\n    TextDocumentIdentifier.is = is;\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\n/**\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.\n */\nvar VersionedTextDocumentIdentifier;\n(function (VersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new VersionedTextDocumentIdentifier literal.\n     * @param uri The document's uri.\n     * @param uri The document's text.\n     */\n    function create(uri, version) {\n        return { uri: uri, version: version };\n    }\n    VersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.number(candidate.version));\n    }\n    VersionedTextDocumentIdentifier.is = is;\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\n/**\n * The TextDocumentItem namespace provides helper functions to work with\n * [TextDocumentItem](#TextDocumentItem) literals.\n */\nvar TextDocumentItem;\n(function (TextDocumentItem) {\n    /**\n     * Creates a new TextDocumentItem literal.\n     * @param uri The document's uri.\n     * @param languageId The document's language identifier.\n     * @param version The document's version number.\n     * @param text The document's text.\n     */\n    function create(uri, languageId, version, text) {\n        return { uri: uri, languageId: languageId, version: version, text: text };\n    }\n    TextDocumentItem.create = create;\n    /**\n     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.number(candidate.version) && Is.string(candidate.text);\n    }\n    TextDocumentItem.is = is;\n})(TextDocumentItem || (TextDocumentItem = {}));\n/**\n * Describes the content type that a client supports in various\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n *\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\n * are reserved for internal usage.\n */\nvar MarkupKind;\n(function (MarkupKind) {\n    /**\n     * Plain text is supported as a content format\n     */\n    MarkupKind.PlainText = 'plaintext';\n    /**\n     * Markdown is supported as a content format\n     */\n    MarkupKind.Markdown = 'markdown';\n})(MarkupKind || (MarkupKind = {}));\n(function (MarkupKind) {\n    /**\n     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n    }\n    MarkupKind.is = is;\n})(MarkupKind || (MarkupKind = {}));\nvar MarkupContent;\n(function (MarkupContent) {\n    /**\n     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n    }\n    MarkupContent.is = is;\n})(MarkupContent || (MarkupContent = {}));\n/**\n * The kind of a completion entry.\n */\nvar CompletionItemKind;\n(function (CompletionItemKind) {\n    CompletionItemKind.Text = 1;\n    CompletionItemKind.Method = 2;\n    CompletionItemKind.Function = 3;\n    CompletionItemKind.Constructor = 4;\n    CompletionItemKind.Field = 5;\n    CompletionItemKind.Variable = 6;\n    CompletionItemKind.Class = 7;\n    CompletionItemKind.Interface = 8;\n    CompletionItemKind.Module = 9;\n    CompletionItemKind.Property = 10;\n    CompletionItemKind.Unit = 11;\n    CompletionItemKind.Value = 12;\n    CompletionItemKind.Enum = 13;\n    CompletionItemKind.Keyword = 14;\n    CompletionItemKind.Snippet = 15;\n    CompletionItemKind.Color = 16;\n    CompletionItemKind.File = 17;\n    CompletionItemKind.Reference = 18;\n    CompletionItemKind.Folder = 19;\n    CompletionItemKind.EnumMember = 20;\n    CompletionItemKind.Constant = 21;\n    CompletionItemKind.Struct = 22;\n    CompletionItemKind.Event = 23;\n    CompletionItemKind.Operator = 24;\n    CompletionItemKind.TypeParameter = 25;\n})(CompletionItemKind || (CompletionItemKind = {}));\n/**\n * Defines whether the insert text in a completion item should be interpreted as\n * plain text or a snippet.\n */\nvar InsertTextFormat;\n(function (InsertTextFormat) {\n    /**\n     * The primary text to be inserted is treated as a plain string.\n     */\n    InsertTextFormat.PlainText = 1;\n    /**\n     * The primary text to be inserted is treated as a snippet.\n     *\n     * A snippet can define tab stops and placeholders with `$1`, `$2`\n     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n     * the end of the snippet. Placeholders with equal identifiers are linked,\n     * that is typing in one will update others too.\n     *\n     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n     */\n    InsertTextFormat.Snippet = 2;\n})(InsertTextFormat || (InsertTextFormat = {}));\n/**\n * Completion item tags are extra annotations that tweak the rendering of a completion\n * item.\n *\n * @since 3.15.0\n */\nvar CompletionItemTag;\n(function (CompletionItemTag) {\n    /**\n     * Render a completion as obsolete, usually using a strike-out.\n     */\n    CompletionItemTag.Deprecated = 1;\n})(CompletionItemTag || (CompletionItemTag = {}));\n/**\n * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n *\n * @since 3.16.0 - Proposed state\n */\nvar InsertReplaceEdit;\n(function (InsertReplaceEdit) {\n    /**\n     * Creates a new insert / replace edit\n     */\n    function create(newText, insert, replace) {\n        return { newText: newText, insert: insert, replace: replace };\n    }\n    InsertReplaceEdit.create = create;\n    /**\n     * Checks whether the given liternal conforms to the [InsertReplaceEdit](#InsertReplaceEdit) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n    }\n    InsertReplaceEdit.is = is;\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\n/**\n * The CompletionItem namespace provides functions to deal with\n * completion items.\n */\nvar CompletionItem;\n(function (CompletionItem) {\n    /**\n     * Create a completion item and seed it with a label.\n     * @param label The completion item's label\n     */\n    function create(label) {\n        return { label: label };\n    }\n    CompletionItem.create = create;\n})(CompletionItem || (CompletionItem = {}));\n/**\n * The CompletionList namespace provides functions to deal with\n * completion lists.\n */\nvar CompletionList;\n(function (CompletionList) {\n    /**\n     * Creates a new completion list.\n     *\n     * @param items The completion items.\n     * @param isIncomplete The list is not complete.\n     */\n    function create(items, isIncomplete) {\n        return { items: items ? items : [], isIncomplete: !!isIncomplete };\n    }\n    CompletionList.create = create;\n})(CompletionList || (CompletionList = {}));\nvar MarkedString;\n(function (MarkedString) {\n    /**\n     * Creates a marked string from plain text.\n     *\n     * @param plainText The plain text.\n     */\n    function fromPlainText(plainText) {\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    }\n    MarkedString.fromPlainText = fromPlainText;\n    /**\n     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\n    }\n    MarkedString.is = is;\n})(MarkedString || (MarkedString = {}));\nvar Hover;\n(function (Hover) {\n    /**\n     * Checks whether the given value conforms to the [Hover](#Hover) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\n            MarkedString.is(candidate.contents) ||\n            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));\n    }\n    Hover.is = is;\n})(Hover || (Hover = {}));\n/**\n * The ParameterInformation namespace provides helper functions to work with\n * [ParameterInformation](#ParameterInformation) literals.\n */\nvar ParameterInformation;\n(function (ParameterInformation) {\n    /**\n     * Creates a new parameter information literal.\n     *\n     * @param label A label string.\n     * @param documentation A doc string.\n     */\n    function create(label, documentation) {\n        return documentation ? { label: label, documentation: documentation } : { label: label };\n    }\n    ParameterInformation.create = create;\n})(ParameterInformation || (ParameterInformation = {}));\n/**\n * The SignatureInformation namespace provides helper functions to work with\n * [SignatureInformation](#SignatureInformation) literals.\n */\nvar SignatureInformation;\n(function (SignatureInformation) {\n    function create(label, documentation) {\n        var parameters = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            parameters[_i - 2] = arguments[_i];\n        }\n        var result = { label: label };\n        if (Is.defined(documentation)) {\n            result.documentation = documentation;\n        }\n        if (Is.defined(parameters)) {\n            result.parameters = parameters;\n        }\n        else {\n            result.parameters = [];\n        }\n        return result;\n    }\n    SignatureInformation.create = create;\n})(SignatureInformation || (SignatureInformation = {}));\n/**\n * A document highlight kind.\n */\nvar DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind.Text = 1;\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind.Read = 2;\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind.Write = 3;\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * DocumentHighlight namespace to provide helper functions to work with\n * [DocumentHighlight](#DocumentHighlight) literals.\n */\nvar DocumentHighlight;\n(function (DocumentHighlight) {\n    /**\n     * Create a DocumentHighlight object.\n     * @param range The range the highlight applies to.\n     */\n    function create(range, kind) {\n        var result = { range: range };\n        if (Is.number(kind)) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    DocumentHighlight.create = create;\n})(DocumentHighlight || (DocumentHighlight = {}));\n/**\n * A symbol kind.\n */\nvar SymbolKind;\n(function (SymbolKind) {\n    SymbolKind.File = 1;\n    SymbolKind.Module = 2;\n    SymbolKind.Namespace = 3;\n    SymbolKind.Package = 4;\n    SymbolKind.Class = 5;\n    SymbolKind.Method = 6;\n    SymbolKind.Property = 7;\n    SymbolKind.Field = 8;\n    SymbolKind.Constructor = 9;\n    SymbolKind.Enum = 10;\n    SymbolKind.Interface = 11;\n    SymbolKind.Function = 12;\n    SymbolKind.Variable = 13;\n    SymbolKind.Constant = 14;\n    SymbolKind.String = 15;\n    SymbolKind.Number = 16;\n    SymbolKind.Boolean = 17;\n    SymbolKind.Array = 18;\n    SymbolKind.Object = 19;\n    SymbolKind.Key = 20;\n    SymbolKind.Null = 21;\n    SymbolKind.EnumMember = 22;\n    SymbolKind.Struct = 23;\n    SymbolKind.Event = 24;\n    SymbolKind.Operator = 25;\n    SymbolKind.TypeParameter = 26;\n})(SymbolKind || (SymbolKind = {}));\n/**\n * Symbol tags are extra annotations that tweak the rendering of a symbol.\n * @since 3.15\n */\nvar SymbolTag;\n(function (SymbolTag) {\n    /**\n     * Render a symbol as obsolete, usually using a strike-out.\n     */\n    SymbolTag.Deprecated = 1;\n})(SymbolTag || (SymbolTag = {}));\nvar SymbolInformation;\n(function (SymbolInformation) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the location of the symbol.\n     * @param uri The resource of the location of symbol, defaults to the current document.\n     * @param containerName The name of the symbol containing the symbol.\n     */\n    function create(name, kind, range, uri, containerName) {\n        var result = {\n            name: name,\n            kind: kind,\n            location: { uri: uri, range: range }\n        };\n        if (containerName) {\n            result.containerName = containerName;\n        }\n        return result;\n    }\n    SymbolInformation.create = create;\n})(SymbolInformation || (SymbolInformation = {}));\nvar DocumentSymbol;\n(function (DocumentSymbol) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param detail The detail of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the symbol.\n     * @param selectionRange The selectionRange of the symbol.\n     * @param children Children of the symbol.\n     */\n    function create(name, detail, kind, range, selectionRange, children) {\n        var result = {\n            name: name,\n            detail: detail,\n            kind: kind,\n            range: range,\n            selectionRange: selectionRange\n        };\n        if (children !== void 0) {\n            result.children = children;\n        }\n        return result;\n    }\n    DocumentSymbol.create = create;\n    /**\n     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate &&\n            Is.string(candidate.name) && Is.number(candidate.kind) &&\n            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\n            (candidate.detail === void 0 || Is.string(candidate.detail)) &&\n            (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) &&\n            (candidate.children === void 0 || Array.isArray(candidate.children)) &&\n            (candidate.tags === void 0 || Array.isArray(candidate.tags));\n    }\n    DocumentSymbol.is = is;\n})(DocumentSymbol || (DocumentSymbol = {}));\n/**\n * A set of predefined code action kinds\n */\nvar CodeActionKind;\n(function (CodeActionKind) {\n    /**\n     * Empty kind.\n     */\n    CodeActionKind.Empty = '';\n    /**\n     * Base kind for quickfix actions: 'quickfix'\n     */\n    CodeActionKind.QuickFix = 'quickfix';\n    /**\n     * Base kind for refactoring actions: 'refactor'\n     */\n    CodeActionKind.Refactor = 'refactor';\n    /**\n     * Base kind for refactoring extraction actions: 'refactor.extract'\n     *\n     * Example extract actions:\n     *\n     * - Extract method\n     * - Extract function\n     * - Extract variable\n     * - Extract interface from class\n     * - ...\n     */\n    CodeActionKind.RefactorExtract = 'refactor.extract';\n    /**\n     * Base kind for refactoring inline actions: 'refactor.inline'\n     *\n     * Example inline actions:\n     *\n     * - Inline function\n     * - Inline variable\n     * - Inline constant\n     * - ...\n     */\n    CodeActionKind.RefactorInline = 'refactor.inline';\n    /**\n     * Base kind for refactoring rewrite actions: 'refactor.rewrite'\n     *\n     * Example rewrite actions:\n     *\n     * - Convert JavaScript function to class\n     * - Add or remove parameter\n     * - Encapsulate field\n     * - Make method static\n     * - Move method to base class\n     * - ...\n     */\n    CodeActionKind.RefactorRewrite = 'refactor.rewrite';\n    /**\n     * Base kind for source actions: `source`\n     *\n     * Source code actions apply to the entire file.\n     */\n    CodeActionKind.Source = 'source';\n    /**\n     * Base kind for an organize imports source action: `source.organizeImports`\n     */\n    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\n    /**\n     * Base kind for auto-fix source actions: `source.fixAll`.\n     *\n     * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n     *\n     * @since 3.15.0\n     */\n    CodeActionKind.SourceFixAll = 'source.fixAll';\n})(CodeActionKind || (CodeActionKind = {}));\n/**\n * The CodeActionContext namespace provides helper functions to work with\n * [CodeActionContext](#CodeActionContext) literals.\n */\nvar CodeActionContext;\n(function (CodeActionContext) {\n    /**\n     * Creates a new CodeActionContext literal.\n     */\n    function create(diagnostics, only) {\n        var result = { diagnostics: diagnostics };\n        if (only !== void 0 && only !== null) {\n            result.only = only;\n        }\n        return result;\n    }\n    CodeActionContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));\n    }\n    CodeActionContext.is = is;\n})(CodeActionContext || (CodeActionContext = {}));\nvar CodeAction;\n(function (CodeAction) {\n    function create(title, commandOrEdit, kind) {\n        var result = { title: title };\n        if (Command.is(commandOrEdit)) {\n            result.command = commandOrEdit;\n        }\n        else {\n            result.edit = commandOrEdit;\n        }\n        if (kind !== void 0) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    CodeAction.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && Is.string(candidate.title) &&\n            (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\n            (candidate.kind === void 0 || Is.string(candidate.kind)) &&\n            (candidate.edit !== void 0 || candidate.command !== void 0) &&\n            (candidate.command === void 0 || Command.is(candidate.command)) &&\n            (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) &&\n            (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));\n    }\n    CodeAction.is = is;\n})(CodeAction || (CodeAction = {}));\n/**\n * The CodeLens namespace provides helper functions to work with\n * [CodeLens](#CodeLens) literals.\n */\nvar CodeLens;\n(function (CodeLens) {\n    /**\n     * Creates a new CodeLens literal.\n     */\n    function create(range, data) {\n        var result = { range: range };\n        if (Is.defined(data)) {\n            result.data = data;\n        }\n        return result;\n    }\n    CodeLens.create = create;\n    /**\n     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n    }\n    CodeLens.is = is;\n})(CodeLens || (CodeLens = {}));\n/**\n * The FormattingOptions namespace provides helper functions to work with\n * [FormattingOptions](#FormattingOptions) literals.\n */\nvar FormattingOptions;\n(function (FormattingOptions) {\n    /**\n     * Creates a new FormattingOptions literal.\n     */\n    function create(tabSize, insertSpaces) {\n        return { tabSize: tabSize, insertSpaces: insertSpaces };\n    }\n    FormattingOptions.create = create;\n    /**\n     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.number(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n    }\n    FormattingOptions.is = is;\n})(FormattingOptions || (FormattingOptions = {}));\n/**\n * The DocumentLink namespace provides helper functions to work with\n * [DocumentLink](#DocumentLink) literals.\n */\nvar DocumentLink;\n(function (DocumentLink) {\n    /**\n     * Creates a new DocumentLink literal.\n     */\n    function create(range, target, data) {\n        return { range: range, target: target, data: data };\n    }\n    DocumentLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n    }\n    DocumentLink.is = is;\n})(DocumentLink || (DocumentLink = {}));\n/**\n * The SelectionRange namespace provides helper function to work with\n * SelectionRange literals.\n */\nvar SelectionRange;\n(function (SelectionRange) {\n    /**\n     * Creates a new SelectionRange\n     * @param range the range.\n     * @param parent an optional parent.\n     */\n    function create(range, parent) {\n        return { range: range, parent: parent };\n    }\n    SelectionRange.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n    }\n    SelectionRange.is = is;\n})(SelectionRange || (SelectionRange = {}));\nvar EOL = ['\\n', '\\r\\n', '\\r'];\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nvar TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new ITextDocument literal from the given uri and content.\n     * @param uri The document's uri.\n     * @param languageId  The document's language Id.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount)\n            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n    }\n    TextDocument.is = is;\n    function applyEdits(document, edits) {\n        var text = document.getText();\n        var sortedEdits = mergeSort(edits, function (a, b) {\n            var diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        var lastModifiedOffset = text.length;\n        for (var i = sortedEdits.length - 1; i >= 0; i--) {\n            var e = sortedEdits[i];\n            var startOffset = document.offsetAt(e.range.start);\n            var endOffset = document.offsetAt(e.range.end);\n            if (endOffset <= lastModifiedOffset) {\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n            }\n            else {\n                throw new Error('Overlapping edit');\n            }\n            lastModifiedOffset = startOffset;\n        }\n        return text;\n    }\n    TextDocument.applyEdits = applyEdits;\n    function mergeSort(data, compare) {\n        if (data.length <= 1) {\n            // sorted\n            return data;\n        }\n        var p = (data.length / 2) | 0;\n        var left = data.slice(0, p);\n        var right = data.slice(p);\n        mergeSort(left, compare);\n        mergeSort(right, compare);\n        var leftIdx = 0;\n        var rightIdx = 0;\n        var i = 0;\n        while (leftIdx < left.length && rightIdx < right.length) {\n            var ret = compare(left[leftIdx], right[rightIdx]);\n            if (ret <= 0) {\n                // smaller_equal -> take left to preserve order\n                data[i++] = left[leftIdx++];\n            }\n            else {\n                // greater -> take right\n                data[i++] = right[rightIdx++];\n            }\n        }\n        while (leftIdx < left.length) {\n            data[i++] = left[leftIdx++];\n        }\n        while (rightIdx < right.length) {\n            data[i++] = right[rightIdx++];\n        }\n        return data;\n    }\n})(TextDocument || (TextDocument = {}));\nvar FullTextDocument = /** @class */ (function () {\n    function FullTextDocument(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n        get: function () {\n            return this._uri;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n        get: function () {\n            return this._languageId;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\n        get: function () {\n            return this._version;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    FullTextDocument.prototype.getText = function (range) {\n        if (range) {\n            var start = this.offsetAt(range.start);\n            var end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    };\n    FullTextDocument.prototype.update = function (event, version) {\n        this._content = event.text;\n        this._version = version;\n        this._lineOffsets = undefined;\n    };\n    FullTextDocument.prototype.getLineOffsets = function () {\n        if (this._lineOffsets === undefined) {\n            var lineOffsets = [];\n            var text = this._content;\n            var isLineStart = true;\n            for (var i = 0; i < text.length; i++) {\n                if (isLineStart) {\n                    lineOffsets.push(i);\n                    isLineStart = false;\n                }\n                var ch = text.charAt(i);\n                isLineStart = (ch === '\\r' || ch === '\\n');\n                if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                    i++;\n                }\n            }\n            if (isLineStart && text.length > 0) {\n                lineOffsets.push(text.length);\n            }\n            this._lineOffsets = lineOffsets;\n        }\n        return this._lineOffsets;\n    };\n    FullTextDocument.prototype.positionAt = function (offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        var lineOffsets = this.getLineOffsets();\n        var low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return Position.create(0, offset);\n        }\n        while (low < high) {\n            var mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        var line = low - 1;\n        return Position.create(line, offset - lineOffsets[line]);\n    };\n    FullTextDocument.prototype.offsetAt = function (position) {\n        var lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        var lineOffset = lineOffsets[position.line];\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    };\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n        get: function () {\n            return this.getLineOffsets().length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return FullTextDocument;\n}());\nvar Is;\n(function (Is) {\n    var toString = Object.prototype.toString;\n    function defined(value) {\n        return typeof value !== 'undefined';\n    }\n    Is.defined = defined;\n    function undefined(value) {\n        return typeof value === 'undefined';\n    }\n    Is.undefined = undefined;\n    function boolean(value) {\n        return value === true || value === false;\n    }\n    Is.boolean = boolean;\n    function string(value) {\n        return toString.call(value) === '[object String]';\n    }\n    Is.string = string;\n    function number(value) {\n        return toString.call(value) === '[object Number]';\n    }\n    Is.number = number;\n    function func(value) {\n        return toString.call(value) === '[object Function]';\n    }\n    Is.func = func;\n    function objectLiteral(value) {\n        // Strictly speaking class instances pass this check as well. Since the LSP\n        // doesn't use classes we ignore this for now. If we do we need to add something\n        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n        return value !== null && typeof value === 'object';\n    }\n    Is.objectLiteral = objectLiteral;\n    function typedArray(value, check) {\n        return Array.isArray(value) && value.every(check);\n    }\n    Is.typedArray = typedArray;\n})(Is || (Is = {}));\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver-types/lib/esm/main.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/api.js":
/*!**************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/api.js ***!
  \**************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst st = __webpack_require__(/*! ./semanticTokens.proposed */ \"./node_modules/vscode-languageserver/lib/common/semanticTokens.proposed.js\");\n__export(__webpack_require__(/*! vscode-languageserver-protocol/ */ \"./node_modules/vscode-languageserver-protocol/lib/node/main.js\"));\n__export(__webpack_require__(/*! ./server */ \"./node_modules/vscode-languageserver/lib/common/server.js\"));\nvar ProposedFeatures;\n(function (ProposedFeatures) {\n    ProposedFeatures.all = {\n        __brand: 'features',\n        languages: st.SemanticTokensFeature\n    };\n    ProposedFeatures.SemanticTokensBuilder = st.SemanticTokensBuilder;\n})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));\n//# sourceMappingURL=api.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver/lib/common/api.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/callHierarchy.js":
/*!************************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/callHierarchy.js ***!
  \************************************************************************/
/*! flagged exports */
/*! export CallHierarchyFeature [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/node/main.js\");\nexports.CallHierarchyFeature = (Base) => {\n    return class extends Base {\n        get callHierarchy() {\n            return {\n                onPrepare: (handler) => {\n                    this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);\n                    });\n                },\n                onIncomingCalls: (handler) => {\n                    const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;\n                    this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n                onOutgoingCalls: (handler) => {\n                    const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;\n                    this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                }\n            };\n        }\n    };\n};\n//# sourceMappingURL=callHierarchy.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver/lib/common/callHierarchy.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/configuration.js":
/*!************************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/configuration.js ***!
  \************************************************************************/
/*! flagged exports */
/*! export ConfigurationFeature [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/node/main.js\");\nconst Is = __webpack_require__(/*! ./utils/is */ \"./node_modules/vscode-languageserver/lib/common/utils/is.js\");\nexports.ConfigurationFeature = (Base) => {\n    return class extends Base {\n        getConfiguration(arg) {\n            if (!arg) {\n                return this._getConfiguration({});\n            }\n            else if (Is.string(arg)) {\n                return this._getConfiguration({ section: arg });\n            }\n            else {\n                return this._getConfiguration(arg);\n            }\n        }\n        _getConfiguration(arg) {\n            let params = {\n                items: Array.isArray(arg) ? arg : [arg]\n            };\n            return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {\n                return Array.isArray(arg) ? result : result[0];\n            });\n        }\n    };\n};\n//# sourceMappingURL=configuration.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver/lib/common/configuration.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/progress.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/progress.js ***!
  \*******************************************************************/
/*! flagged exports */
/*! export ProgressFeature [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export attachPartialResult [provided] [no usage info] [missing usage info prevents renaming] */
/*! export attachWorkDone [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/node/main.js\");\nconst uuid_1 = __webpack_require__(/*! ./utils/uuid */ \"./node_modules/vscode-languageserver/lib/common/utils/uuid.js\");\nclass WorkDoneProgressReporterImpl {\n    constructor(_connection, _token) {\n        this._connection = _connection;\n        this._token = _token;\n        WorkDoneProgressReporterImpl.Instances.set(this._token, this);\n    }\n    begin(title, percentage, message, cancellable) {\n        let param = {\n            kind: 'begin',\n            title,\n            percentage,\n            message,\n            cancellable\n        };\n        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);\n    }\n    report(arg0, arg1) {\n        let param = {\n            kind: 'report'\n        };\n        if (typeof arg0 === 'number') {\n            param.percentage = arg0;\n            if (arg1 !== undefined) {\n                param.message = arg1;\n            }\n        }\n        else {\n            param.message = arg0;\n        }\n        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);\n    }\n    done() {\n        WorkDoneProgressReporterImpl.Instances.delete(this._token);\n        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: 'end' });\n    }\n}\nWorkDoneProgressReporterImpl.Instances = new Map();\nclass WorkDoneProgressServerReporterImpl extends WorkDoneProgressReporterImpl {\n    constructor(connection, token) {\n        super(connection, token);\n        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();\n    }\n    get token() {\n        return this._source.token;\n    }\n    done() {\n        this._source.dispose();\n        super.done();\n    }\n    cancel() {\n        this._source.cancel();\n    }\n}\nclass NullProgressReporter {\n    constructor() {\n    }\n    begin() {\n    }\n    report() {\n    }\n    done() {\n    }\n}\nclass NullProgressServerReporter extends NullProgressReporter {\n    constructor() {\n        super();\n        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();\n    }\n    get token() {\n        return this._source.token;\n    }\n    done() {\n        this._source.dispose();\n    }\n    cancel() {\n        this._source.cancel();\n    }\n}\nfunction attachWorkDone(connection, params) {\n    if (params === undefined || params.workDoneToken === undefined) {\n        return new NullProgressReporter();\n    }\n    const token = params.workDoneToken;\n    delete params.workDoneToken;\n    return new WorkDoneProgressReporterImpl(connection, token);\n}\nexports.attachWorkDone = attachWorkDone;\nexports.ProgressFeature = (Base) => {\n    return class extends Base {\n        constructor() {\n            super();\n            this._progressSupported = false;\n        }\n        initialize(capabilities) {\n            var _a;\n            if (((_a = capabilities === null || capabilities === void 0 ? void 0 : capabilities.window) === null || _a === void 0 ? void 0 : _a.workDoneProgress) === true) {\n                this._progressSupported = true;\n                this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {\n                    let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);\n                    if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {\n                        progress.cancel();\n                    }\n                });\n            }\n        }\n        attachWorkDoneProgress(token) {\n            if (token === undefined) {\n                return new NullProgressReporter();\n            }\n            else {\n                return new WorkDoneProgressReporterImpl(this.connection, token);\n            }\n        }\n        createWorkDoneProgress() {\n            if (this._progressSupported) {\n                const token = uuid_1.generateUuid();\n                return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {\n                    const result = new WorkDoneProgressServerReporterImpl(this.connection, token);\n                    return result;\n                });\n            }\n            else {\n                return Promise.resolve(new NullProgressServerReporter());\n            }\n        }\n    };\n};\nvar ResultProgress;\n(function (ResultProgress) {\n    ResultProgress.type = new vscode_languageserver_protocol_1.ProgressType();\n})(ResultProgress || (ResultProgress = {}));\nclass ResultProgressReporterImpl {\n    constructor(_connection, _token) {\n        this._connection = _connection;\n        this._token = _token;\n    }\n    report(data) {\n        this._connection.sendProgress(ResultProgress.type, this._token, data);\n    }\n}\nfunction attachPartialResult(connection, params) {\n    if (params === undefined || params.partialResultToken === undefined) {\n        return undefined;\n    }\n    const token = params.partialResultToken;\n    delete params.partialResultToken;\n    return new ResultProgressReporterImpl(connection, token);\n}\nexports.attachPartialResult = attachPartialResult;\n//# sourceMappingURL=progress.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver/lib/common/progress.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/semanticTokens.proposed.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/semanticTokens.proposed.js ***!
  \**********************************************************************************/
/*! flagged exports */
/*! export SemanticTokensBuilder [provided] [no usage info] [missing usage info prevents renaming] */
/*! export SemanticTokensFeature [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/node/main.js\");\nexports.SemanticTokensFeature = (Base) => {\n    return class extends Base {\n        get semanticTokens() {\n            return {\n                on: (handler) => {\n                    const type = vscode_languageserver_protocol_1.Proposed.SemanticTokensRequest.type;\n                    this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n                onEdits: (handler) => {\n                    const type = vscode_languageserver_protocol_1.Proposed.SemanticTokensEditsRequest.type;\n                    this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n                onRange: (handler) => {\n                    const type = vscode_languageserver_protocol_1.Proposed.SemanticTokensRangeRequest.type;\n                    this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                }\n            };\n        }\n    };\n};\nclass SemanticTokensBuilder {\n    constructor() {\n        this._prevData = undefined;\n        this.initialize();\n    }\n    initialize() {\n        this._id = Date.now();\n        this._prevLine = 0;\n        this._prevChar = 0;\n        this._data = [];\n        this._dataLen = 0;\n    }\n    push(line, char, length, tokenType, tokenModifiers) {\n        let pushLine = line;\n        let pushChar = char;\n        if (this._dataLen > 0) {\n            pushLine -= this._prevLine;\n            if (pushLine === 0) {\n                pushChar -= this._prevChar;\n            }\n        }\n        this._data[this._dataLen++] = pushLine;\n        this._data[this._dataLen++] = pushChar;\n        this._data[this._dataLen++] = length;\n        this._data[this._dataLen++] = tokenType;\n        this._data[this._dataLen++] = tokenModifiers;\n        this._prevLine = line;\n        this._prevChar = char;\n    }\n    get id() {\n        return this._id.toString();\n    }\n    previousResult(id) {\n        if (this.id === id) {\n            this._prevData = this._data;\n        }\n        this.initialize();\n    }\n    build() {\n        this._prevData = undefined;\n        return {\n            resultId: this.id,\n            data: this._data\n        };\n    }\n    canBuildEdits() {\n        return this._prevData !== undefined;\n    }\n    buildEdits() {\n        if (this._prevData !== undefined) {\n            const prevDataLength = this._prevData.length;\n            const dataLength = this._data.length;\n            let startIndex = 0;\n            while (startIndex < dataLength && startIndex < prevDataLength && this._prevData[startIndex] === this._data[startIndex]) {\n                startIndex++;\n            }\n            if (startIndex < dataLength && startIndex < prevDataLength) {\n                // Find end index\n                let endIndex = 0;\n                while (endIndex < dataLength && endIndex < prevDataLength && this._prevData[prevDataLength - 1 - endIndex] === this._data[dataLength - 1 - endIndex]) {\n                    endIndex++;\n                }\n                const newData = this._data.slice(startIndex, dataLength - endIndex);\n                const result = {\n                    resultId: this.id,\n                    edits: [\n                        { start: startIndex, deleteCount: prevDataLength - endIndex - startIndex, data: newData }\n                    ]\n                };\n                return result;\n            }\n            else if (startIndex < dataLength) {\n                return { resultId: this.id, edits: [\n                        { start: startIndex, deleteCount: 0, data: this._data.slice(startIndex) }\n                    ] };\n            }\n            else if (startIndex < prevDataLength) {\n                return { resultId: this.id, edits: [\n                        { start: startIndex, deleteCount: prevDataLength - startIndex }\n                    ] };\n            }\n            else {\n                return { resultId: this.id, edits: [] };\n            }\n        }\n        else {\n            return this.build();\n        }\n    }\n}\nexports.SemanticTokensBuilder = SemanticTokensBuilder;\n//# sourceMappingURL=semanticTokens.proposed.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver/lib/common/semanticTokens.proposed.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/server.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/server.js ***!
  \*****************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/node/main.js\");\nconst Is = __webpack_require__(/*! ./utils/is */ \"./node_modules/vscode-languageserver/lib/common/utils/is.js\");\nconst UUID = __webpack_require__(/*! ./utils/uuid */ \"./node_modules/vscode-languageserver/lib/common/utils/uuid.js\");\nconst progress_1 = __webpack_require__(/*! ./progress */ \"./node_modules/vscode-languageserver/lib/common/progress.js\");\nconst configuration_1 = __webpack_require__(/*! ./configuration */ \"./node_modules/vscode-languageserver/lib/common/configuration.js\");\nconst workspaceFolders_1 = __webpack_require__(/*! ./workspaceFolders */ \"./node_modules/vscode-languageserver/lib/common/workspaceFolders.js\");\nconst callHierarchy_1 = __webpack_require__(/*! ./callHierarchy */ \"./node_modules/vscode-languageserver/lib/common/callHierarchy.js\");\nfunction null2Undefined(value) {\n    if (value === null) {\n        return undefined;\n    }\n    return value;\n}\n/**\n * A manager for simple text documents\n */\nclass TextDocuments {\n    /**\n     * Create a new text document manager.\n     */\n    constructor(configuration) {\n        this._documents = Object.create(null);\n        this._configuration = configuration;\n        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();\n        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * has been opened or the content changes.\n     */\n    get onDidChangeContent() {\n        return this._onDidChangeContent.event;\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * has been opened.\n     */\n    get onDidOpen() {\n        return this._onDidOpen.event;\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * will be saved.\n     */\n    get onWillSave() {\n        return this._onWillSave.event;\n    }\n    /**\n     * Sets a handler that will be called if a participant wants to provide\n     * edits during a text document save.\n     */\n    onWillSaveWaitUntil(handler) {\n        this._willSaveWaitUntil = handler;\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * has been saved.\n     */\n    get onDidSave() {\n        return this._onDidSave.event;\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * has been closed.\n     */\n    get onDidClose() {\n        return this._onDidClose.event;\n    }\n    /**\n     * Returns the document for the given URI. Returns undefined if\n     * the document is not mananged by this instance.\n     *\n     * @param uri The text document's URI to retrieve.\n     * @return the text document or `undefined`.\n     */\n    get(uri) {\n        return this._documents[uri];\n    }\n    /**\n     * Returns all text documents managed by this instance.\n     *\n     * @return all text documents.\n     */\n    all() {\n        return Object.keys(this._documents).map(key => this._documents[key]);\n    }\n    /**\n     * Returns the URIs of all text documents managed by this instance.\n     *\n     * @return the URI's of all text documents.\n     */\n    keys() {\n        return Object.keys(this._documents);\n    }\n    /**\n     * Listens for `low level` notification on the given connection to\n     * update the text documents managed by this instance.\n     *\n     * Please note that the connection only provides handlers not an event model. Therefore\n     * listening on a connection will overwrite the following handlers on a connection:\n     * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,\n     * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.\n     *\n     * Use the correspnding events on the TextDocuments instance instead.\n     *\n     * @param connection The connection to listen on.\n     */\n    listen(connection) {\n        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;\n        connection.onDidOpenTextDocument((event) => {\n            let td = event.textDocument;\n            let document = this._configuration.create(td.uri, td.languageId, td.version, td.text);\n            this._documents[td.uri] = document;\n            let toFire = Object.freeze({ document });\n            this._onDidOpen.fire(toFire);\n            this._onDidChangeContent.fire(toFire);\n        });\n        connection.onDidChangeTextDocument((event) => {\n            let td = event.textDocument;\n            let changes = event.contentChanges;\n            if (changes.length === 0) {\n                return;\n            }\n            let document = this._documents[td.uri];\n            const { version } = td;\n            if (version === null || version === undefined) {\n                throw new Error(`Received document change event for ${td.uri} without valid version identifier`);\n            }\n            document = this._configuration.update(document, changes, version);\n            this._documents[td.uri] = document;\n            this._onDidChangeContent.fire(Object.freeze({ document }));\n        });\n        connection.onDidCloseTextDocument((event) => {\n            let document = this._documents[event.textDocument.uri];\n            if (document) {\n                delete this._documents[event.textDocument.uri];\n                this._onDidClose.fire(Object.freeze({ document }));\n            }\n        });\n        connection.onWillSaveTextDocument((event) => {\n            let document = this._documents[event.textDocument.uri];\n            if (document) {\n                this._onWillSave.fire(Object.freeze({ document, reason: event.reason }));\n            }\n        });\n        connection.onWillSaveTextDocumentWaitUntil((event, token) => {\n            let document = this._documents[event.textDocument.uri];\n            if (document && this._willSaveWaitUntil) {\n                return this._willSaveWaitUntil(Object.freeze({ document, reason: event.reason }), token);\n            }\n            else {\n                return [];\n            }\n        });\n        connection.onDidSaveTextDocument((event) => {\n            let document = this._documents[event.textDocument.uri];\n            if (document) {\n                this._onDidSave.fire(Object.freeze({ document }));\n            }\n        });\n    }\n}\nexports.TextDocuments = TextDocuments;\n/**\n * Helps tracking error message. Equal occurences of the same\n * message are only stored once. This class is for example\n * useful if text documents are validated in a loop and equal\n * error message should be folded into one.\n */\nclass ErrorMessageTracker {\n    constructor() {\n        this._messages = Object.create(null);\n    }\n    /**\n     * Add a message to the tracker.\n     *\n     * @param message The message to add.\n     */\n    add(message) {\n        let count = this._messages[message];\n        if (!count) {\n            count = 0;\n        }\n        count++;\n        this._messages[message] = count;\n    }\n    /**\n     * Send all tracked messages to the connection's window.\n     *\n     * @param connection The connection established between client and server.\n     */\n    sendErrors(connection) {\n        Object.keys(this._messages).forEach(message => {\n            connection.window.showErrorMessage(message);\n        });\n    }\n}\nexports.ErrorMessageTracker = ErrorMessageTracker;\nclass RemoteConsoleImpl {\n    constructor() {\n    }\n    rawAttach(connection) {\n        this._rawConnection = connection;\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    initialize(_capabilities) {\n    }\n    error(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);\n    }\n    warn(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);\n    }\n    info(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);\n    }\n    log(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);\n    }\n    send(type, message) {\n        if (this._rawConnection) {\n            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message });\n        }\n    }\n}\nclass _RemoteWindowImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    showErrorMessage(message, ...actions) {\n        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);\n    }\n    showWarningMessage(message, ...actions) {\n        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);\n    }\n    showInformationMessage(message, ...actions) {\n        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);\n    }\n}\nconst RemoteWindowImpl = progress_1.ProgressFeature(_RemoteWindowImpl);\nvar BulkRegistration;\n(function (BulkRegistration) {\n    /**\n     * Creates a new bulk registration.\n     * @return an empty bulk registration.\n     */\n    function create() {\n        return new BulkRegistrationImpl();\n    }\n    BulkRegistration.create = create;\n})(BulkRegistration = exports.BulkRegistration || (exports.BulkRegistration = {}));\nclass BulkRegistrationImpl {\n    constructor() {\n        this._registrations = [];\n        this._registered = new Set();\n    }\n    add(type, registerOptions) {\n        const method = Is.string(type) ? type : type.method;\n        if (this._registered.has(method)) {\n            throw new Error(`${method} is already added to this registration`);\n        }\n        const id = UUID.generateUuid();\n        this._registrations.push({\n            id: id,\n            method: method,\n            registerOptions: registerOptions || {}\n        });\n        this._registered.add(method);\n    }\n    asRegistrationParams() {\n        return {\n            registrations: this._registrations\n        };\n    }\n}\nvar BulkUnregistration;\n(function (BulkUnregistration) {\n    function create() {\n        return new BulkUnregistrationImpl(undefined, []);\n    }\n    BulkUnregistration.create = create;\n})(BulkUnregistration = exports.BulkUnregistration || (exports.BulkUnregistration = {}));\nclass BulkUnregistrationImpl {\n    constructor(_connection, unregistrations) {\n        this._connection = _connection;\n        this._unregistrations = new Map();\n        unregistrations.forEach(unregistration => {\n            this._unregistrations.set(unregistration.method, unregistration);\n        });\n    }\n    get isAttached() {\n        return !!this._connection;\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    add(unregistration) {\n        this._unregistrations.set(unregistration.method, unregistration);\n    }\n    dispose() {\n        let unregistrations = [];\n        for (let unregistration of this._unregistrations.values()) {\n            unregistrations.push(unregistration);\n        }\n        let params = {\n            unregisterations: unregistrations\n        };\n        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(undefined, (_error) => {\n            this._connection.console.info(`Bulk unregistration failed.`);\n        });\n    }\n    disposeSingle(arg) {\n        const method = Is.string(arg) ? arg : arg.method;\n        const unregistration = this._unregistrations.get(method);\n        if (!unregistration) {\n            return false;\n        }\n        let params = {\n            unregisterations: [unregistration]\n        };\n        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {\n            this._unregistrations.delete(method);\n        }, (_error) => {\n            this._connection.console.info(`Unregistering request handler for ${unregistration.id} failed.`);\n        });\n        return true;\n    }\n}\nclass RemoteClientImpl {\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    register(typeOrRegistrations, registerOptionsOrType, registerOptions) {\n        if (typeOrRegistrations instanceof BulkRegistrationImpl) {\n            return this.registerMany(typeOrRegistrations);\n        }\n        else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {\n            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);\n        }\n        else {\n            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);\n        }\n    }\n    registerSingle1(unregistration, type, registerOptions) {\n        const method = Is.string(type) ? type : type.method;\n        const id = UUID.generateUuid();\n        let params = {\n            registrations: [{ id, method, registerOptions: registerOptions || {} }]\n        };\n        if (!unregistration.isAttached) {\n            unregistration.attach(this.connection);\n        }\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {\n            unregistration.add({ id: id, method: method });\n            return unregistration;\n        }, (_error) => {\n            this.connection.console.info(`Registering request handler for ${method} failed.`);\n            return Promise.reject(_error);\n        });\n    }\n    registerSingle2(type, registerOptions) {\n        const method = Is.string(type) ? type : type.method;\n        const id = UUID.generateUuid();\n        let params = {\n            registrations: [{ id, method, registerOptions: registerOptions || {} }]\n        };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {\n            return vscode_languageserver_protocol_1.Disposable.create(() => {\n                this.unregisterSingle(id, method);\n            });\n        }, (_error) => {\n            this.connection.console.info(`Registering request handler for ${method} failed.`);\n            return Promise.reject(_error);\n        });\n    }\n    unregisterSingle(id, method) {\n        let params = {\n            unregisterations: [{ id, method }]\n        };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(undefined, (_error) => {\n            this.connection.console.info(`Unregistering request handler for ${id} failed.`);\n        });\n    }\n    registerMany(registrations) {\n        let params = registrations.asRegistrationParams();\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {\n            return new BulkUnregistrationImpl(this._connection, params.registrations.map(registration => { return { id: registration.id, method: registration.method }; }));\n        }, (_error) => {\n            this.connection.console.info(`Bulk registration failed.`);\n            return Promise.reject(_error);\n        });\n    }\n}\nclass _RemoteWorkspaceImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    applyEdit(paramOrEdit) {\n        function isApplyWorkspaceEditParams(value) {\n            return value && !!value.edit;\n        }\n        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);\n    }\n}\nconst RemoteWorkspaceImpl = workspaceFolders_1.WorkspaceFoldersFeature(configuration_1.ConfigurationFeature(_RemoteWorkspaceImpl));\nclass TracerImpl {\n    constructor() {\n        this._trace = vscode_languageserver_protocol_1.Trace.Off;\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    set trace(value) {\n        this._trace = value;\n    }\n    log(message, verbose) {\n        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {\n            return;\n        }\n        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {\n            message: message,\n            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : undefined\n        });\n    }\n}\nclass TelemetryImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    logEvent(data) {\n        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data);\n    }\n}\nclass _LanguagesImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    attachWorkDoneProgress(params) {\n        return progress_1.attachWorkDone(this.connection, params);\n    }\n    attachPartialResultProgress(_type, params) {\n        return progress_1.attachPartialResult(this.connection, params);\n    }\n}\nexports._LanguagesImpl = _LanguagesImpl;\nconst LanguagesImpl = callHierarchy_1.CallHierarchyFeature(_LanguagesImpl);\nfunction combineConsoleFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineConsoleFeatures = combineConsoleFeatures;\nfunction combineTelemetryFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineTelemetryFeatures = combineTelemetryFeatures;\nfunction combineTracerFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineTracerFeatures = combineTracerFeatures;\nfunction combineClientFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineClientFeatures = combineClientFeatures;\nfunction combineWindowFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineWindowFeatures = combineWindowFeatures;\nfunction combineWorkspaceFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineWorkspaceFeatures = combineWorkspaceFeatures;\nfunction combineLanguagesFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineLanguagesFeatures = combineLanguagesFeatures;\nfunction combineFeatures(one, two) {\n    function combine(one, two, func) {\n        if (one && two) {\n            return func(one, two);\n        }\n        else if (one) {\n            return one;\n        }\n        else {\n            return two;\n        }\n    }\n    let result = {\n        __brand: 'features',\n        console: combine(one.console, two.console, combineConsoleFeatures),\n        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),\n        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),\n        client: combine(one.client, two.client, combineClientFeatures),\n        window: combine(one.window, two.window, combineWindowFeatures),\n        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures)\n    };\n    return result;\n}\nexports.combineFeatures = combineFeatures;\nfunction createConnection(connectionFactory, watchDog, factories) {\n    const logger = (factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl());\n    const connection = connectionFactory(logger);\n    logger.rawAttach(connection);\n    const tracer = (factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl());\n    const telemetry = (factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl());\n    const client = (factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl());\n    const remoteWindow = (factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl());\n    const workspace = (factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl());\n    const languages = (factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl());\n    const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages];\n    function asPromise(value) {\n        if (value instanceof Promise) {\n            return value;\n        }\n        else if (Is.thenable(value)) {\n            return new Promise((resolve, reject) => {\n                value.then((resolved) => resolve(resolved), (error) => reject(error));\n            });\n        }\n        else {\n            return Promise.resolve(value);\n        }\n    }\n    let shutdownHandler = undefined;\n    let initializeHandler = undefined;\n    let exitHandler = undefined;\n    let protocolConnection = {\n        listen: () => connection.listen(),\n        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),\n        onRequest: (type, handler) => connection.onRequest(type, handler),\n        sendNotification: (type, param) => {\n            const method = Is.string(type) ? type : type.method;\n            if (arguments.length === 1) {\n                connection.sendNotification(method);\n            }\n            else {\n                connection.sendNotification(method, param);\n            }\n        },\n        onNotification: (type, handler) => connection.onNotification(type, handler),\n        onProgress: connection.onProgress,\n        sendProgress: connection.sendProgress,\n        onInitialize: (handler) => initializeHandler = handler,\n        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),\n        onShutdown: (handler) => shutdownHandler = handler,\n        onExit: (handler) => exitHandler = handler,\n        get console() { return logger; },\n        get telemetry() { return telemetry; },\n        get tracer() { return tracer; },\n        get client() { return client; },\n        get window() { return remoteWindow; },\n        get workspace() { return workspace; },\n        get languages() { return languages; },\n        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),\n        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),\n        __textDocumentSync: undefined,\n        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),\n        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),\n        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),\n        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),\n        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),\n        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),\n        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),\n        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);\n        }),\n        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));\n        }),\n        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),\n        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);\n        }),\n        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));\n        }),\n        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));\n        }),\n        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));\n        }),\n        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));\n        }),\n        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));\n        }),\n        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));\n        }),\n        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));\n        }),\n        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));\n        }),\n        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));\n        }),\n        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));\n        }),\n        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);\n        }),\n        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);\n        }),\n        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);\n        }),\n        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));\n        }),\n        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));\n        }),\n        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));\n        }),\n        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));\n        }),\n        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));\n        }),\n        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {\n            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);\n        }),\n        dispose: () => connection.dispose()\n    };\n    for (let remote of allRemotes) {\n        remote.attach(protocolConnection);\n    }\n    connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {\n        watchDog.initialize(params);\n        if (Is.string(params.trace)) {\n            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);\n        }\n        for (let remote of allRemotes) {\n            remote.initialize(params.capabilities);\n        }\n        if (initializeHandler) {\n            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, progress_1.attachWorkDone(connection, params), undefined);\n            return asPromise(result).then((value) => {\n                if (value instanceof vscode_languageserver_protocol_1.ResponseError) {\n                    return value;\n                }\n                let result = value;\n                if (!result) {\n                    result = { capabilities: {} };\n                }\n                let capabilities = result.capabilities;\n                if (!capabilities) {\n                    capabilities = {};\n                    result.capabilities = capabilities;\n                }\n                if (capabilities.textDocumentSync === undefined || capabilities.textDocumentSync === null) {\n                    capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;\n                }\n                else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {\n                    capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;\n                }\n                for (let remote of allRemotes) {\n                    remote.fillServerCapabilities(capabilities);\n                }\n                return result;\n            });\n        }\n        else {\n            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };\n            for (let remote of allRemotes) {\n                remote.fillServerCapabilities(result.capabilities);\n            }\n            return result;\n        }\n    });\n    connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {\n        watchDog.shutdownReceived = true;\n        if (shutdownHandler) {\n            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);\n        }\n        else {\n            return undefined;\n        }\n    });\n    connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {\n        try {\n            if (exitHandler) {\n                exitHandler();\n            }\n        }\n        finally {\n            if (watchDog.shutdownReceived) {\n                watchDog.exit(0);\n            }\n            else {\n                watchDog.exit(1);\n            }\n        }\n    });\n    connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {\n        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);\n    });\n    return protocolConnection;\n}\nexports.createConnection = createConnection;\n//# sourceMappingURL=server.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver/lib/common/server.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/utils/is.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/utils/is.js ***!
  \*******************************************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export array [provided] [no usage info] [missing usage info prevents renaming] */
/*! export boolean [provided] [no usage info] [missing usage info prevents renaming] */
/*! export error [provided] [no usage info] [missing usage info prevents renaming] */
/*! export func [provided] [no usage info] [missing usage info prevents renaming] */
/*! export number [provided] [no usage info] [missing usage info prevents renaming] */
/*! export string [provided] [no usage info] [missing usage info prevents renaming] */
/*! export stringArray [provided] [no usage info] [missing usage info prevents renaming] */
/*! export thenable [provided] [no usage info] [missing usage info prevents renaming] */
/*! export typedArray [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction boolean(value) {\n    return value === true || value === false;\n}\nexports.boolean = boolean;\nfunction string(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexports.string = string;\nfunction number(value) {\n    return typeof value === 'number' || value instanceof Number;\n}\nexports.number = number;\nfunction error(value) {\n    return value instanceof Error;\n}\nexports.error = error;\nfunction func(value) {\n    return typeof value === 'function';\n}\nexports.func = func;\nfunction array(value) {\n    return Array.isArray(value);\n}\nexports.array = array;\nfunction stringArray(value) {\n    return array(value) && value.every(elem => string(elem));\n}\nexports.stringArray = stringArray;\nfunction typedArray(value, check) {\n    return Array.isArray(value) && value.every(check);\n}\nexports.typedArray = typedArray;\nfunction thenable(value) {\n    return value && func(value.then);\n}\nexports.thenable = thenable;\n//# sourceMappingURL=is.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver/lib/common/utils/is.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/utils/uuid.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/utils/uuid.js ***!
  \*********************************************************************/
/*! flagged exports */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! export empty [provided] [no usage info] [missing usage info prevents renaming] */
/*! export generateUuid [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isUUID [provided] [no usage info] [missing usage info prevents renaming] */
/*! export parse [provided] [no usage info] [missing usage info prevents renaming] */
/*! export v4 [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__ */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass ValueUUID {\n    constructor(_value) {\n        this._value = _value;\n        // empty\n    }\n    asHex() {\n        return this._value;\n    }\n    equals(other) {\n        return this.asHex() === other.asHex();\n    }\n}\nclass V4UUID extends ValueUUID {\n    constructor() {\n        super([\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            '-',\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            '-',\n            '4',\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            '-',\n            V4UUID._oneOf(V4UUID._timeHighBits),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            '-',\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n        ].join(''));\n    }\n    static _oneOf(array) {\n        return array[Math.floor(array.length * Math.random())];\n    }\n    static _randomHex() {\n        return V4UUID._oneOf(V4UUID._chars);\n    }\n}\nV4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\nV4UUID._timeHighBits = ['8', '9', 'a', 'b'];\n/**\n * An empty UUID that contains only zeros.\n */\nexports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');\nfunction v4() {\n    return new V4UUID();\n}\nexports.v4 = v4;\nconst _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\nfunction isUUID(value) {\n    return _UUIDPattern.test(value);\n}\nexports.isUUID = isUUID;\n/**\n * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.\n * @param value A uuid string.\n */\nfunction parse(value) {\n    if (!isUUID(value)) {\n        throw new Error('invalid uuid');\n    }\n    return new ValueUUID(value);\n}\nexports.parse = parse;\nfunction generateUuid() {\n    return v4().asHex();\n}\nexports.generateUuid = generateUuid;\n//# sourceMappingURL=uuid.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver/lib/common/utils/uuid.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/common/workspaceFolders.js":
/*!***************************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/common/workspaceFolders.js ***!
  \***************************************************************************/
/*! flagged exports */
/*! export WorkspaceFoldersFeature [provided] [no usage info] [missing usage info prevents renaming] */
/*! export __esModule [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ \"./node_modules/vscode-languageserver-protocol/lib/node/main.js\");\nexports.WorkspaceFoldersFeature = (Base) => {\n    return class extends Base {\n        initialize(capabilities) {\n            let workspaceCapabilities = capabilities.workspace;\n            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {\n                this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();\n                this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {\n                    this._onDidChangeWorkspaceFolders.fire(params.event);\n                });\n            }\n        }\n        getWorkspaceFolders() {\n            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);\n        }\n        get onDidChangeWorkspaceFolders() {\n            if (!this._onDidChangeWorkspaceFolders) {\n                throw new Error('Client doesn\\'t support sending workspace folder change events.');\n            }\n            if (!this._unregistration) {\n                this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);\n            }\n            return this._onDidChangeWorkspaceFolders.event;\n        }\n    };\n};\n//# sourceMappingURL=workspaceFolders.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver/lib/common/workspaceFolders.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/node/files.js":
/*!**************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/node/files.js ***!
  \**************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst url = __webpack_require__(/*! url */ \"url\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\n/**\n * @deprecated Use the `vscode-uri` npm module which provides a more\n * complete implementation of handling VS Code URIs.\n */\nfunction uriToFilePath(uri) {\n    let parsed = url.parse(uri);\n    if (parsed.protocol !== 'file:' || !parsed.path) {\n        return undefined;\n    }\n    let segments = parsed.path.split('/');\n    for (var i = 0, len = segments.length; i < len; i++) {\n        segments[i] = decodeURIComponent(segments[i]);\n    }\n    if (process.platform === 'win32' && segments.length > 1) {\n        let first = segments[0];\n        let second = segments[1];\n        // Do we have a drive letter and we started with a / which is the\n        // case if the first segement is empty (see split above)\n        if (first.length === 0 && second.length > 1 && second[1] === ':') {\n            // Remove first slash\n            segments.shift();\n        }\n    }\n    return path.normalize(segments.join('/'));\n}\nexports.uriToFilePath = uriToFilePath;\nfunction isWindows() {\n    return process.platform === 'win32';\n}\nfunction resolve(moduleName, nodePath, cwd, tracer) {\n    const nodePathKey = 'NODE_PATH';\n    const app = [\n        'var p = process;',\n        'p.on(\\'message\\',function(m){',\n        'if(m.c===\\'e\\'){',\n        'p.exit(0);',\n        '}',\n        'else if(m.c===\\'rs\\'){',\n        'try{',\n        'var r=require.resolve(m.a);',\n        'p.send({c:\\'r\\',s:true,r:r});',\n        '}',\n        'catch(err){',\n        'p.send({c:\\'r\\',s:false});',\n        '}',\n        '}',\n        '});'\n    ].join('');\n    return new Promise((resolve, reject) => {\n        let env = process.env;\n        let newEnv = Object.create(null);\n        Object.keys(env).forEach(key => newEnv[key] = env[key]);\n        if (nodePath && fs.existsSync(nodePath) /* see issue 545 */) {\n            if (newEnv[nodePathKey]) {\n                newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];\n            }\n            else {\n                newEnv[nodePathKey] = nodePath;\n            }\n            if (tracer) {\n                tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);\n            }\n        }\n        newEnv['ELECTRON_RUN_AS_NODE'] = '1';\n        try {\n            let cp = child_process_1.fork('', [], {\n                cwd: cwd,\n                env: newEnv,\n                execArgv: ['-e', app]\n            });\n            if (cp.pid === void 0) {\n                reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));\n                return;\n            }\n            cp.on('error', (error) => {\n                reject(error);\n            });\n            cp.on('message', (message) => {\n                if (message.c === 'r') {\n                    cp.send({ c: 'e' });\n                    if (message.s) {\n                        resolve(message.r);\n                    }\n                    else {\n                        reject(new Error(`Failed to resolve module: ${moduleName}`));\n                    }\n                }\n            });\n            let message = {\n                c: 'rs',\n                a: moduleName\n            };\n            cp.send(message);\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\nexports.resolve = resolve;\n/**\n * Resolve the global npm package path.\n * @deprecated Since this depends on the used package manager and their version the best is that servers\n * implement this themselves since they know best what kind of package managers to support.\n * @param tracer the tracer to use\n */\nfunction resolveGlobalNodePath(tracer) {\n    let npmCommand = 'npm';\n    const env = Object.create(null);\n    Object.keys(process.env).forEach(key => env[key] = process.env[key]);\n    env['NO_UPDATE_NOTIFIER'] = 'true';\n    const options = {\n        encoding: 'utf8',\n        env\n    };\n    if (isWindows()) {\n        npmCommand = 'npm.cmd';\n        options.shell = true;\n    }\n    let handler = () => { };\n    try {\n        process.on('SIGPIPE', handler);\n        let stdout = child_process_1.spawnSync(npmCommand, ['config', 'get', 'prefix'], options).stdout;\n        if (!stdout) {\n            if (tracer) {\n                tracer(`'npm config get prefix' didn't return a value.`);\n            }\n            return undefined;\n        }\n        let prefix = stdout.trim();\n        if (tracer) {\n            tracer(`'npm config get prefix' value is: ${prefix}`);\n        }\n        if (prefix.length > 0) {\n            if (isWindows()) {\n                return path.join(prefix, 'node_modules');\n            }\n            else {\n                return path.join(prefix, 'lib', 'node_modules');\n            }\n        }\n        return undefined;\n    }\n    catch (err) {\n        return undefined;\n    }\n    finally {\n        process.removeListener('SIGPIPE', handler);\n    }\n}\nexports.resolveGlobalNodePath = resolveGlobalNodePath;\n/*\n * Resolve the global yarn pakage path.\n * @deprecated Since this depends on the used package manager and their version the best is that servers\n * implement this themselves since they know best what kind of package managers to support.\n * @param tracer the tracer to use\n */\nfunction resolveGlobalYarnPath(tracer) {\n    let yarnCommand = 'yarn';\n    let options = {\n        encoding: 'utf8'\n    };\n    if (isWindows()) {\n        yarnCommand = 'yarn.cmd';\n        options.shell = true;\n    }\n    let handler = () => { };\n    try {\n        process.on('SIGPIPE', handler);\n        let results = child_process_1.spawnSync(yarnCommand, ['global', 'dir', '--json'], options);\n        let stdout = results.stdout;\n        if (!stdout) {\n            if (tracer) {\n                tracer(`'yarn global dir' didn't return a value.`);\n                if (results.stderr) {\n                    tracer(results.stderr);\n                }\n            }\n            return undefined;\n        }\n        let lines = stdout.trim().split(/\\r?\\n/);\n        for (let line of lines) {\n            try {\n                let yarn = JSON.parse(line);\n                if (yarn.type === 'log') {\n                    return path.join(yarn.data, 'node_modules');\n                }\n            }\n            catch (e) {\n                // Do nothing. Ignore the line\n            }\n        }\n        return undefined;\n    }\n    catch (err) {\n        return undefined;\n    }\n    finally {\n        process.removeListener('SIGPIPE', handler);\n    }\n}\nexports.resolveGlobalYarnPath = resolveGlobalYarnPath;\nvar FileSystem;\n(function (FileSystem) {\n    let _isCaseSensitive = undefined;\n    function isCaseSensitive() {\n        if (_isCaseSensitive !== void 0) {\n            return _isCaseSensitive;\n        }\n        if (process.platform === 'win32') {\n            _isCaseSensitive = false;\n        }\n        else {\n            // convert current file name to upper case / lower case and check if file exists\n            // (guards against cases when name is already all uppercase or lowercase)\n            _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());\n        }\n        return _isCaseSensitive;\n    }\n    FileSystem.isCaseSensitive = isCaseSensitive;\n    function isParent(parent, child) {\n        if (isCaseSensitive()) {\n            return path.normalize(child).indexOf(path.normalize(parent)) === 0;\n        }\n        else {\n            return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;\n        }\n    }\n    FileSystem.isParent = isParent;\n})(FileSystem = exports.FileSystem || (exports.FileSystem = {}));\nfunction resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {\n    if (nodePath) {\n        if (!path.isAbsolute(nodePath)) {\n            nodePath = path.join(workspaceRoot, nodePath);\n        }\n        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {\n            if (FileSystem.isParent(nodePath, value)) {\n                return value;\n            }\n            else {\n                return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));\n            }\n        }).then(undefined, (_error) => {\n            return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);\n        });\n    }\n    else {\n        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);\n    }\n}\nexports.resolveModulePath = resolveModulePath;\n//# sourceMappingURL=files.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver/lib/node/files.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver/lib/node/main.js":
/*!*************************************************************!*\
  !*** ./node_modules/vscode-languageserver/lib/node/main.js ***!
  \*************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, __webpack_require__ */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n/// <reference path=\"../../typings/thenable.d.ts\" />\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Is = __webpack_require__(/*! ../common/utils/is */ \"./node_modules/vscode-languageserver/lib/common/utils/is.js\");\nconst server_1 = __webpack_require__(/*! ../common/server */ \"./node_modules/vscode-languageserver/lib/common/server.js\");\nconst fm = __webpack_require__(/*! ./files */ \"./node_modules/vscode-languageserver/lib/node/files.js\");\nconst node_1 = __webpack_require__(/*! vscode-languageserver-protocol/node */ \"./node_modules/vscode-languageserver-protocol/node.js\");\n__export(__webpack_require__(/*! ../common/api */ \"./node_modules/vscode-languageserver/lib/common/api.js\"));\nvar Files;\n(function (Files) {\n    Files.uriToFilePath = fm.uriToFilePath;\n    Files.resolveGlobalNodePath = fm.resolveGlobalNodePath;\n    Files.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;\n    Files.resolve = fm.resolve;\n    Files.resolveModulePath = fm.resolveModulePath;\n})(Files = exports.Files || (exports.Files = {}));\nlet _shutdownReceived = false;\nlet exitTimer = undefined;\nfunction setupExitTimer() {\n    const argName = '--clientProcessId';\n    function runTimer(value) {\n        try {\n            let processId = parseInt(value);\n            if (!isNaN(processId)) {\n                exitTimer = setInterval(() => {\n                    try {\n                        process.kill(processId, 0);\n                    }\n                    catch (ex) {\n                        // Parent process doesn't exist anymore. Exit the server.\n                        process.exit(_shutdownReceived ? 0 : 1);\n                    }\n                }, 3000);\n            }\n        }\n        catch (e) {\n            // Ignore errors;\n        }\n    }\n    for (let i = 2; i < process.argv.length; i++) {\n        let arg = process.argv[i];\n        if (arg === argName && i + 1 < process.argv.length) {\n            runTimer(process.argv[i + 1]);\n            return;\n        }\n        else {\n            let args = arg.split('=');\n            if (args[0] === argName) {\n                runTimer(args[1]);\n            }\n        }\n    }\n}\nsetupExitTimer();\nconst watchDog = {\n    initialize: (params) => {\n        const processId = params.processId;\n        if (Is.number(processId) && exitTimer === undefined) {\n            // We received a parent process id. Set up a timer to periodically check\n            // if the parent is still alive.\n            setInterval(() => {\n                try {\n                    process.kill(processId, 0);\n                }\n                catch (ex) {\n                    // Parent process doesn't exist anymore. Exit the server.\n                    process.exit(_shutdownReceived ? 0 : 1);\n                }\n            }, 3000);\n        }\n    },\n    get shutdownReceived() {\n        return _shutdownReceived;\n    },\n    set shutdownReceived(value) {\n        _shutdownReceived = value;\n    },\n    exit: (code) => {\n        process.exit(code);\n    }\n};\nfunction createConnection(arg1, arg2, arg3, arg4) {\n    let factories;\n    let input;\n    let output;\n    let options;\n    if (arg1 !== void 0 && arg1.__brand === 'features') {\n        factories = arg1;\n        arg1 = arg2;\n        arg2 = arg3;\n        arg3 = arg4;\n    }\n    if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {\n        options = arg1;\n    }\n    else {\n        input = arg1;\n        output = arg2;\n        options = arg3;\n    }\n    return _createConnection(input, output, options, factories);\n}\nexports.createConnection = createConnection;\nfunction _createConnection(input, output, options, factories) {\n    if (!input && !output && process.argv.length > 2) {\n        let port = void 0;\n        let pipeName = void 0;\n        let argv = process.argv.slice(2);\n        for (let i = 0; i < argv.length; i++) {\n            let arg = argv[i];\n            if (arg === '--node-ipc') {\n                input = new node_1.IPCMessageReader(process);\n                output = new node_1.IPCMessageWriter(process);\n                break;\n            }\n            else if (arg === '--stdio') {\n                input = process.stdin;\n                output = process.stdout;\n                break;\n            }\n            else if (arg === '--socket') {\n                port = parseInt(argv[i + 1]);\n                break;\n            }\n            else if (arg === '--pipe') {\n                pipeName = argv[i + 1];\n                break;\n            }\n            else {\n                var args = arg.split('=');\n                if (args[0] === '--socket') {\n                    port = parseInt(args[1]);\n                    break;\n                }\n                else if (args[0] === '--pipe') {\n                    pipeName = args[1];\n                    break;\n                }\n            }\n        }\n        if (port) {\n            let transport = node_1.createServerSocketTransport(port);\n            input = transport[0];\n            output = transport[1];\n        }\n        else if (pipeName) {\n            let transport = node_1.createServerPipeTransport(pipeName);\n            input = transport[0];\n            output = transport[1];\n        }\n    }\n    var commandLineMessage = 'Use arguments of createConnection or set command line parameters: \\'--node-ipc\\', \\'--stdio\\' or \\'--socket={number}\\'';\n    if (!input) {\n        throw new Error('Connection input stream is not set. ' + commandLineMessage);\n    }\n    if (!output) {\n        throw new Error('Connection output stream is not set. ' + commandLineMessage);\n    }\n    // Backwards compatibility\n    if (Is.func(input.read) && Is.func(input.on)) {\n        let inputStream = input;\n        inputStream.on('end', () => {\n            process.exit(_shutdownReceived ? 0 : 1);\n        });\n        inputStream.on('close', () => {\n            process.exit(_shutdownReceived ? 0 : 1);\n        });\n    }\n    const connectionFactory = (logger) => {\n        return node_1.createProtocolConnection(input, output, logger, options);\n    };\n    return server_1.createConnection(connectionFactory, watchDog, factories);\n}\n//# sourceMappingURL=main.js.map\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver/lib/node/main.js?");

/***/ }),

/***/ "./node_modules/vscode-languageserver/node.js":
/*!****************************************************!*\
  !*** ./node_modules/vscode-languageserver/node.js ***!
  \****************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__ */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ----------------------------------------------------------------------------------------- */\n\n\nmodule.exports = __webpack_require__(/*! ./lib/node/main */ \"./node_modules/vscode-languageserver/lib/node/main.js\");\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-languageserver/node.js?");

/***/ }),

/***/ "./node_modules/vscode-uri/lib/esm/index.js":
/*!**************************************************!*\
  !*** ./node_modules/vscode-uri/lib/esm/index.js ***!
  \**************************************************/
/*! namespace exports */
/*! export URI [provided] [no usage info] [missing usage info prevents renaming] */
/*! export uriToFsPath [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"URI\": () => /* binding */ URI,\n/* harmony export */   \"uriToFsPath\": () => /* binding */ uriToFsPath\n/* harmony export */ });\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar _a;\nvar isWindows;\nif (typeof process === 'object') {\n    isWindows = process.platform === 'win32';\n}\nelse if (typeof navigator === 'object') {\n    var userAgent = navigator.userAgent;\n    isWindows = userAgent.indexOf('Windows') >= 0;\n}\nfunction isHighSurrogate(charCode) {\n    return (0xD800 <= charCode && charCode <= 0xDBFF);\n}\nfunction isLowSurrogate(charCode) {\n    return (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\nfunction isLowerAsciiHex(code) {\n    return code >= 97 /* a */ && code <= 102 /* f */;\n}\nfunction isLowerAsciiLetter(code) {\n    return code >= 97 /* a */ && code <= 122 /* z */;\n}\nfunction isUpperAsciiLetter(code) {\n    return code >= 65 /* A */ && code <= 90 /* Z */;\n}\nfunction isAsciiLetter(code) {\n    return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);\n}\n//#endregion\nvar _schemePattern = /^\\w[\\w\\d+.-]*$/;\nvar _singleSlashStart = /^\\//;\nvar _doubleSlashStart = /^\\/\\//;\nfunction _validateUri(ret, _strict) {\n    // scheme, must be set\n    if (!ret.scheme && _strict) {\n        throw new Error(\"[UriError]: Scheme is missing: {scheme: \\\"\\\", authority: \\\"\" + ret.authority + \"\\\", path: \\\"\" + ret.path + \"\\\", query: \\\"\" + ret.query + \"\\\", fragment: \\\"\" + ret.fragment + \"\\\"}\");\n    }\n    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n    // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n    if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n        throw new Error('[UriError]: Scheme contains illegal characters.');\n    }\n    // path, http://tools.ietf.org/html/rfc3986#section-3.3\n    // If a URI contains an authority component, then the path component\n    // must either be empty or begin with a slash (\"/\") character.  If a URI\n    // does not contain an authority component, then the path cannot begin\n    // with two slash characters (\"//\").\n    if (ret.path) {\n        if (ret.authority) {\n            if (!_singleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n            }\n        }\n        else {\n            if (_doubleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n            }\n        }\n    }\n}\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme, _strict) {\n    if (!scheme && !_strict) {\n        return 'file';\n    }\n    return scheme;\n}\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme, path) {\n    // the slash-character is our 'default base' as we don't\n    // support constructing URIs relative to other URIs. This\n    // also means that we alter and potentially break paths.\n    // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n    switch (scheme) {\n        case 'https':\n        case 'http':\n        case 'file':\n            if (!path) {\n                path = _slash;\n            }\n            else if (path[0] !== _slash) {\n                path = _slash + path;\n            }\n            break;\n    }\n    return path;\n}\nvar _empty = '';\nvar _slash = '/';\nvar _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nvar URI = /** @class */ (function () {\n    /**\n     * @internal\n     */\n    function URI(schemeOrData, authority, path, query, fragment, _strict) {\n        if (_strict === void 0) { _strict = false; }\n        if (typeof schemeOrData === 'object') {\n            this.scheme = schemeOrData.scheme || _empty;\n            this.authority = schemeOrData.authority || _empty;\n            this.path = schemeOrData.path || _empty;\n            this.query = schemeOrData.query || _empty;\n            this.fragment = schemeOrData.fragment || _empty;\n            // no validation because it's this URI\n            // that creates uri components.\n            // _validateUri(this);\n        }\n        else {\n            this.scheme = _schemeFix(schemeOrData, _strict);\n            this.authority = authority || _empty;\n            this.path = _referenceResolution(this.scheme, path || _empty);\n            this.query = query || _empty;\n            this.fragment = fragment || _empty;\n            _validateUri(this, _strict);\n        }\n    }\n    URI.isUri = function (thing) {\n        if (thing instanceof URI) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return typeof thing.authority === 'string'\n            && typeof thing.fragment === 'string'\n            && typeof thing.path === 'string'\n            && typeof thing.query === 'string'\n            && typeof thing.scheme === 'string'\n            && typeof thing.fsPath === 'function'\n            && typeof thing.with === 'function'\n            && typeof thing.toString === 'function';\n    };\n    Object.defineProperty(URI.prototype, \"fsPath\", {\n        // ---- filesystem path -----------------------\n        /**\n         * Returns a string representing the corresponding file system path of this URI.\n         * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n         * platform specific path separator.\n         *\n         * * Will *not* validate the path for invalid characters and semantics.\n         * * Will *not* look at the scheme of this URI.\n         * * The result shall *not* be used for display purposes but for accessing a file on disk.\n         *\n         *\n         * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n         * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n         *\n         * ```ts\n            const u = URI.parse('file://server/c$/folder/file.txt')\n            u.authority === 'server'\n            u.path === '/shares/c$/file.txt'\n            u.fsPath === '\\\\server\\c$\\folder\\file.txt'\n        ```\n         *\n         * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n         * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n         * with URIs that represent files on disk (`file` scheme).\n         */\n        get: function () {\n            // if (this.scheme !== 'file') {\n            // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n            // }\n            return uriToFsPath(this, false);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // ---- modify to new -------------------------\n    URI.prototype.with = function (change) {\n        if (!change) {\n            return this;\n        }\n        var scheme = change.scheme, authority = change.authority, path = change.path, query = change.query, fragment = change.fragment;\n        if (scheme === undefined) {\n            scheme = this.scheme;\n        }\n        else if (scheme === null) {\n            scheme = _empty;\n        }\n        if (authority === undefined) {\n            authority = this.authority;\n        }\n        else if (authority === null) {\n            authority = _empty;\n        }\n        if (path === undefined) {\n            path = this.path;\n        }\n        else if (path === null) {\n            path = _empty;\n        }\n        if (query === undefined) {\n            query = this.query;\n        }\n        else if (query === null) {\n            query = _empty;\n        }\n        if (fragment === undefined) {\n            fragment = this.fragment;\n        }\n        else if (fragment === null) {\n            fragment = _empty;\n        }\n        if (scheme === this.scheme\n            && authority === this.authority\n            && path === this.path\n            && query === this.query\n            && fragment === this.fragment) {\n            return this;\n        }\n        return new _URI(scheme, authority, path, query, fragment);\n    };\n    // ---- parse & validate ------------------------\n    /**\n     * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\n     * `file:///usr/home`, or `scheme:with/path`.\n     *\n     * @param value A string which represents an URI (see `URI#toString`).\n     */\n    URI.parse = function (value, _strict) {\n        if (_strict === void 0) { _strict = false; }\n        var match = _regexp.exec(value);\n        if (!match) {\n            return new _URI(_empty, _empty, _empty, _empty, _empty);\n        }\n        return new _URI(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\n    };\n    /**\n     * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n     * `/usr/home`, or `\\\\server\\share\\some\\path`.\n     *\n     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n     * `URI.parse('file://' + path)` because the path might contain characters that are\n     * interpreted (# and ?). See the following sample:\n     * ```ts\n    const good = URI.file('/coding/c#/project1');\n    good.scheme === 'file';\n    good.path === '/coding/c#/project1';\n    good.fragment === '';\n    const bad = URI.parse('file://' + '/coding/c#/project1');\n    bad.scheme === 'file';\n    bad.path === '/coding/c'; // path is now broken\n    bad.fragment === '/project1';\n    ```\n     *\n     * @param path A file system path (see `URI#fsPath`)\n     */\n    URI.file = function (path) {\n        var authority = _empty;\n        // normalize to fwd-slashes on windows,\n        // on other systems bwd-slashes are valid\n        // filename character, eg /f\\oo/ba\\r.txt\n        if (isWindows) {\n            path = path.replace(/\\\\/g, _slash);\n        }\n        // check for authority as used in UNC shares\n        // or use the path as given\n        if (path[0] === _slash && path[1] === _slash) {\n            var idx = path.indexOf(_slash, 2);\n            if (idx === -1) {\n                authority = path.substring(2);\n                path = _slash;\n            }\n            else {\n                authority = path.substring(2, idx);\n                path = path.substring(idx) || _slash;\n            }\n        }\n        return new _URI('file', authority, path, _empty, _empty);\n    };\n    URI.from = function (components) {\n        return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);\n    };\n    // /**\n    //  * Join a URI path with path fragments and normalizes the resulting path.\n    //  *\n    //  * @param uri The input URI.\n    //  * @param pathFragment The path fragment to add to the URI path.\n    //  * @returns The resulting URI.\n    //  */\n    // static joinPath(uri: URI, ...pathFragment: string[]): URI {\n    // \tif (!uri.path) {\n    // \t\tthrow new Error(`[UriError]: cannot call joinPaths on URI without path`);\n    // \t}\n    // \tlet newPath: string;\n    // \tif (isWindows && uri.scheme === 'file') {\n    // \t\tnewPath = URI.file(paths.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\n    // \t} else {\n    // \t\tnewPath = paths.posix.join(uri.path, ...pathFragment);\n    // \t}\n    // \treturn uri.with({ path: newPath });\n    // }\n    // ---- printing/externalize ---------------------------\n    /**\n     * Creates a string representation for this URI. It's guaranteed that calling\n     * `URI.parse` with the result of this function creates an URI which is equal\n     * to this URI.\n     *\n     * * The result shall *not* be used for display purposes but for externalization or transport.\n     * * The result will be encoded using the percentage encoding and encoding happens mostly\n     * ignore the scheme-specific encoding rules.\n     *\n     * @param skipEncoding Do not encode the result, default is `false`\n     */\n    URI.prototype.toString = function (skipEncoding) {\n        if (skipEncoding === void 0) { skipEncoding = false; }\n        return _asFormatted(this, skipEncoding);\n    };\n    URI.prototype.toJSON = function () {\n        return this;\n    };\n    URI.revive = function (data) {\n        if (!data) {\n            return data;\n        }\n        else if (data instanceof URI) {\n            return data;\n        }\n        else {\n            var result = new _URI(data);\n            result._formatted = data.external;\n            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;\n            return result;\n        }\n    };\n    return URI;\n}());\n\nvar _pathSepMarker = isWindows ? 1 : undefined;\n// eslint-disable-next-line @typescript-eslint/class-name-casing\nvar _URI = /** @class */ (function (_super) {\n    __extends(_URI, _super);\n    function _URI() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._formatted = null;\n        _this._fsPath = null;\n        return _this;\n    }\n    Object.defineProperty(_URI.prototype, \"fsPath\", {\n        get: function () {\n            if (!this._fsPath) {\n                this._fsPath = uriToFsPath(this, false);\n            }\n            return this._fsPath;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    _URI.prototype.toString = function (skipEncoding) {\n        if (skipEncoding === void 0) { skipEncoding = false; }\n        if (!skipEncoding) {\n            if (!this._formatted) {\n                this._formatted = _asFormatted(this, false);\n            }\n            return this._formatted;\n        }\n        else {\n            // we don't cache that\n            return _asFormatted(this, true);\n        }\n    };\n    _URI.prototype.toJSON = function () {\n        var res = {\n            $mid: 1\n        };\n        // cached state\n        if (this._fsPath) {\n            res.fsPath = this._fsPath;\n            res._sep = _pathSepMarker;\n        }\n        if (this._formatted) {\n            res.external = this._formatted;\n        }\n        // uri components\n        if (this.path) {\n            res.path = this.path;\n        }\n        if (this.scheme) {\n            res.scheme = this.scheme;\n        }\n        if (this.authority) {\n            res.authority = this.authority;\n        }\n        if (this.query) {\n            res.query = this.query;\n        }\n        if (this.fragment) {\n            res.fragment = this.fragment;\n        }\n        return res;\n    };\n    return _URI;\n}(URI));\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nvar encodeTable = (_a = {},\n    _a[58 /* Colon */] = '%3A',\n    _a[47 /* Slash */] = '%2F',\n    _a[63 /* QuestionMark */] = '%3F',\n    _a[35 /* Hash */] = '%23',\n    _a[91 /* OpenSquareBracket */] = '%5B',\n    _a[93 /* CloseSquareBracket */] = '%5D',\n    _a[64 /* AtSign */] = '%40',\n    _a[33 /* ExclamationMark */] = '%21',\n    _a[36 /* DollarSign */] = '%24',\n    _a[38 /* Ampersand */] = '%26',\n    _a[39 /* SingleQuote */] = '%27',\n    _a[40 /* OpenParen */] = '%28',\n    _a[41 /* CloseParen */] = '%29',\n    _a[42 /* Asterisk */] = '%2A',\n    _a[43 /* Plus */] = '%2B',\n    _a[44 /* Comma */] = '%2C',\n    _a[59 /* Semicolon */] = '%3B',\n    _a[61 /* Equals */] = '%3D',\n    _a[32 /* Space */] = '%20',\n    _a);\nfunction encodeURIComponentFast(uriComponent, allowSlash) {\n    var res = undefined;\n    var nativeEncodePos = -1;\n    for (var pos = 0; pos < uriComponent.length; pos++) {\n        var code = uriComponent.charCodeAt(pos);\n        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n        if ((code >= 97 /* a */ && code <= 122 /* z */)\n            || (code >= 65 /* A */ && code <= 90 /* Z */)\n            || (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */)\n            || code === 45 /* Dash */\n            || code === 46 /* Period */\n            || code === 95 /* Underline */\n            || code === 126 /* Tilde */\n            || (allowSlash && code === 47 /* Slash */)) {\n            // check if we are delaying native encode\n            if (nativeEncodePos !== -1) {\n                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                nativeEncodePos = -1;\n            }\n            // check if we write into a new string (by default we try to return the param)\n            if (res !== undefined) {\n                res += uriComponent.charAt(pos);\n            }\n        }\n        else {\n            // encoding needed, we need to allocate a new string\n            if (res === undefined) {\n                res = uriComponent.substr(0, pos);\n            }\n            // check with default table first\n            var escaped = encodeTable[code];\n            if (escaped !== undefined) {\n                // check if we are delaying native encode\n                if (nativeEncodePos !== -1) {\n                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                    nativeEncodePos = -1;\n                }\n                // append escaped variant to result\n                res += escaped;\n            }\n            else if (nativeEncodePos === -1) {\n                // use native encode only when needed\n                nativeEncodePos = pos;\n            }\n        }\n    }\n    if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n    }\n    return res !== undefined ? res : uriComponent;\n}\nfunction encodeURIComponentMinimal(path) {\n    var res = undefined;\n    for (var pos = 0; pos < path.length; pos++) {\n        var code = path.charCodeAt(pos);\n        if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {\n            if (res === undefined) {\n                res = path.substr(0, pos);\n            }\n            res += encodeTable[code];\n        }\n        else {\n            if (res !== undefined) {\n                res += path[pos];\n            }\n        }\n    }\n    return res !== undefined ? res : path;\n}\n/**\n * Compute `fsPath` for the given uri\n */\nfunction uriToFsPath(uri, keepDriveLetterCasing) {\n    var value;\n    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n        // unc path: file://shares/c$/far/boo\n        value = \"//\" + uri.authority + uri.path;\n    }\n    else if (uri.path.charCodeAt(0) === 47 /* Slash */\n        && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)\n        && uri.path.charCodeAt(2) === 58 /* Colon */) {\n        if (!keepDriveLetterCasing) {\n            // windows drive letter: file:///c:/far/boo\n            value = uri.path[1].toLowerCase() + uri.path.substr(2);\n        }\n        else {\n            value = uri.path.substr(1);\n        }\n    }\n    else {\n        // other path\n        value = uri.path;\n    }\n    if (isWindows) {\n        value = value.replace(/\\//g, '\\\\');\n    }\n    return value;\n}\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri, skipEncoding) {\n    var encoder = !skipEncoding\n        ? encodeURIComponentFast\n        : encodeURIComponentMinimal;\n    var res = '';\n    var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;\n    if (scheme) {\n        res += scheme;\n        res += ':';\n    }\n    if (authority || scheme === 'file') {\n        res += _slash;\n        res += _slash;\n    }\n    if (authority) {\n        var idx = authority.indexOf('@');\n        if (idx !== -1) {\n            // <user>@<auth>\n            var userinfo = authority.substr(0, idx);\n            authority = authority.substr(idx + 1);\n            idx = userinfo.indexOf(':');\n            if (idx === -1) {\n                res += encoder(userinfo, false);\n            }\n            else {\n                // <user>:<pass>@<auth>\n                res += encoder(userinfo.substr(0, idx), false);\n                res += ':';\n                res += encoder(userinfo.substr(idx + 1), false);\n            }\n            res += '@';\n        }\n        authority = authority.toLowerCase();\n        idx = authority.indexOf(':');\n        if (idx === -1) {\n            res += encoder(authority, false);\n        }\n        else {\n            // <auth>:<port>\n            res += encoder(authority.substr(0, idx), false);\n            res += authority.substr(idx);\n        }\n    }\n    if (path) {\n        // lower-case windows drive letters in /C:/fff or C:/fff\n        if (path.length >= 3 && path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(2) === 58 /* Colon */) {\n            var code = path.charCodeAt(1);\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\n                path = \"/\" + String.fromCharCode(code + 32) + \":\" + path.substr(3); // \"/c:\".length === 3\n            }\n        }\n        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {\n            var code = path.charCodeAt(0);\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\n                path = String.fromCharCode(code + 32) + \":\" + path.substr(2); // \"/c:\".length === 3\n            }\n        }\n        // encode the rest of the path\n        res += encoder(path, true);\n    }\n    if (query) {\n        res += '?';\n        res += encoder(query, false);\n    }\n    if (fragment) {\n        res += '#';\n        res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n    }\n    return res;\n}\n// --- decode\nfunction decodeURIComponentGraceful(str) {\n    try {\n        return decodeURIComponent(str);\n    }\n    catch (_a) {\n        if (str.length > 3) {\n            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n        }\n        else {\n            return str;\n        }\n    }\n}\nvar _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\nfunction percentDecode(str) {\n    if (!str.match(_rEncodedAsHex)) {\n        return str;\n    }\n    return str.replace(_rEncodedAsHex, function (match) { return decodeURIComponentGraceful(match); });\n}\n\n\n//# sourceURL=webpack://pyright-server/./node_modules/vscode-uri/lib/esm/index.js?");

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! default exports */
/*! export dependencies [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export assert [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export chalk [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export chokidar [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export command-line-args [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export leven [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typescript-char [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export vscode-languageserver [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export vscode-uri [provided] [no usage info] [missing usage info prevents renaming] */
/*!   other exports [not provided] [no usage info] */
/*! export description [provided] [no usage info] [missing usage info prevents renaming] */
/*! export devDependencies [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export @types/chalk [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export @types/chokidar [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export @types/command-line-args [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export @types/fs-extra [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export @types/jest [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export @types/node [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export @typescript-eslint/eslint-plugin [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export @typescript-eslint/parser [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export eslint [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export eslint-config-prettier [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export fs-extra [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export jest [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export jest-junit [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export node-loader [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export prettier [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export ts-jest [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export ts-loader [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typescript [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export webpack [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export webpack-cli [provided] [no usage info] [missing usage info prevents renaming] */
/*!   other exports [not provided] [no usage info] */
/*! export displayName [provided] [no usage info] [missing usage info prevents renaming] */
/*! export license [provided] [no usage info] [missing usage info prevents renaming] */
/*! export main [provided] [no usage info] [missing usage info prevents renaming] */
/*! export name [provided] [no usage info] [missing usage info prevents renaming] */
/*! export scripts [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export build [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export build:cli [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export build:serverDebug [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export build:serverProd [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export eslint [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export installServer [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export start [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export start:serverDebug [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export start:serverProd [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export test [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export test:pipeline [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export watch [provided] [no usage info] [missing usage info prevents renaming] */
/*!   other exports [not provided] [no usage info] */
/*! export types [provided] [no usage info] [missing usage info prevents renaming] */
/*! export version [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"pyright-server\\\",\\\"displayName\\\":\\\"pyright\\\",\\\"description\\\":\\\"Type checker for the Python language\\\",\\\"version\\\":\\\"1.1.60\\\",\\\"license\\\":\\\"MIT\\\",\\\"scripts\\\":{\\\"start\\\":\\\"npm run start:serverDebug && npm run start:server\\\",\\\"start:serverDebug\\\":\\\"npm i && npm run build:serverDebug\\\",\\\"start:serverProd\\\":\\\"npm i && npm run build:serverProd\\\",\\\"build\\\":\\\"npm run build:serverProd && npm run build:serverDebug && npm run build:cli\\\",\\\"build:serverDebug\\\":\\\"tsc && npm run installServer\\\",\\\"build:serverProd\\\":\\\"npm run installServer && webpack --config webpack.config-extension.js\\\",\\\"installServer\\\":\\\"node ./customInstallServerIntoExtension.js ../client ./package.json ./tsconfig.json ./package-lock.json\\\",\\\"build:cli\\\":\\\"node ./copyTypeshedFallback.js && npm run eslint && webpack --config webpack.config-cli.js\\\",\\\"eslint\\\":\\\"eslint src/**/*.ts\\\",\\\"watch\\\":\\\"tsc --watch\\\",\\\"test\\\":\\\"jest --detectOpenHandles --forceExit\\\",\\\"test:pipeline\\\":\\\"jest --detectOpenHandles --forceExit --reporters=jest-junit --reporters=default --coverage --coverageReporters=cobertura --coverageReporters=html --coverageReporters=json\\\"},\\\"dependencies\\\":{\\\"assert\\\":\\\"^2.0.0\\\",\\\"chalk\\\":\\\"^4.1.0\\\",\\\"chokidar\\\":\\\"^3.4.0\\\",\\\"command-line-args\\\":\\\"^5.1.1\\\",\\\"leven\\\":\\\"^3.1.0\\\",\\\"typescript-char\\\":\\\"^0.0.0\\\",\\\"vscode-languageserver\\\":\\\"^7.0.0-next.4\\\",\\\"vscode-uri\\\":\\\"^2.1.2\\\"},\\\"devDependencies\\\":{\\\"@types/chalk\\\":\\\"^2.2.0\\\",\\\"@types/chokidar\\\":\\\"^2.1.3\\\",\\\"@types/command-line-args\\\":\\\"^5.0.0\\\",\\\"@types/fs-extra\\\":\\\"^9.0.1\\\",\\\"@types/jest\\\":\\\"^26.0.0\\\",\\\"@types/node\\\":\\\"^14.0.13\\\",\\\"@typescript-eslint/eslint-plugin\\\":\\\"^3.3.0\\\",\\\"@typescript-eslint/parser\\\":\\\"^3.3.0\\\",\\\"eslint\\\":\\\"^7.3.0\\\",\\\"eslint-config-prettier\\\":\\\"^6.11.0\\\",\\\"fs-extra\\\":\\\"^9.0.1\\\",\\\"jest\\\":\\\"^26.0.1\\\",\\\"jest-junit\\\":\\\"^11.0.0\\\",\\\"node-loader\\\":\\\"^0.6.0\\\",\\\"prettier\\\":\\\"2.0.5\\\",\\\"ts-jest\\\":\\\"^26.1.0\\\",\\\"ts-loader\\\":\\\"^7.0.5\\\",\\\"typescript\\\":\\\"^3.9.5\\\",\\\"webpack\\\":\\\"^5.0.0-beta.22\\\",\\\"webpack-cli\\\":\\\"^3.3.12\\\"},\\\"types\\\":\\\"out/main.d.ts\\\",\\\"main\\\":\\\"out/main.js\\\"}\");\n\n//# sourceURL=webpack://pyright-server/./package.json?");

/***/ }),

/***/ "./src/localization/package.nls.de.json":
/*!**********************************************!*\
  !*** ./src/localization/package.nls.de.json ***!
  \**********************************************/
/*! default exports */
/*! exports [not provided] [no usage info] */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = {};\n\n//# sourceURL=webpack://pyright-server/./src/localization/package.nls.de.json?");

/***/ }),

/***/ "./src/localization/package.nls.en-us.json":
/*!*************************************************!*\
  !*** ./src/localization/package.nls.en-us.json ***!
  \*************************************************/
/*! default exports */
/*! export CodeAction [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export addOptionalToAnnotation [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export createTypeStub [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export createTypeStubFor [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export executingCommand [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export filesToAnalyzeCount [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export filesToAnalyzeOne [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export findingReferences [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export organizeImports [provided] [no usage info] [missing usage info prevents renaming] */
/*!   other exports [not provided] [no usage info] */
/*! export Diagnostic [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export annotatedTypeArgMissing [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export annotationFormatString [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export annotationNotSupported [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export annotationSpansStrings [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export annotationStringEscape [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export annotationTripleQuote [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export argAssignment [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export argAssignmentFunction [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export argAssignmentParam [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export argAssignmentParamFunction [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export argMissingForParam [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export argMissingForParams [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export argPositional [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export argPositionalExpectedCount [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export argPositionalExpectedOne [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export argTypePartiallyUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export argTypeUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export assertAlwaysTrue [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export assignmentExprComprehension [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export assignmentExprContext [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export assignmentInProtocol [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export assignmentTargetExpr [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export awaitIllegal [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export awaitNotInAsync [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export backticksIllegal [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export baseClassCircular [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export baseClassDoubleGeneric [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export baseClassFinal [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export baseClassInvalid [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export baseClassUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export breakOutsideLoop [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export callableExtraArgs [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export callableFirstArg [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export classDecoratorTypeUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export classMethodClsParam [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export classVarFirstArgMissing [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export classVarTooManyArgs [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export comprehensionInDict [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export comprehensionInSet [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export constantRedefinition [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export constructorNoArgs [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export continueInFinally [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export continueOutsideLoop [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export dataClassFieldWithDefault [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export declaredReturnTypePartiallyUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export declaredReturnTypeUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export defaultValueContainsCall [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export defaultValueNotAllowed [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export delTargetExpr [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export dictInAnnotation [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export dictKeyValuePairs [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export duplicateArgsParam [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export duplicateCatchAll [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export duplicateImport [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export duplicateKwargsParam [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export duplicateNameOnly [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export duplicateParam [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export duplicatePositionOnly [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export duplicateUnpack [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export ellipsisContext [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export ellipsisSecondArg [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export enumFirstArg [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export enumSecondArg [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export exceptionTypeIncorrect [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export exceptionTypeNotClass [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedAfterDecorator [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedAsAfterException [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedAssignRightHandExpr [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedBinaryRightHandExpr [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedBoolLiteral [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedClassName [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedCloseBrace [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedCloseBracket [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedCloseParen [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedColon [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedDecoratorName [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedDecoratorNewline [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedDelExpr [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedElse [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedExceptionClass [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedExceptionObj [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedExpr [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedFunctionAfterAsync [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedFunctionName [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedIdentifier [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedImport [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedImportAlias [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedImportSymbols [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedIn [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedInExpr [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedIndentedBlock [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedMemberName [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedModuleName [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedNameAfterAs [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedNamedArgument [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedNewlineOrSemicolon [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedOpenParen [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedParamName [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedReturnExpr [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedSliceIndex [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedTypeNotString [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export expectedYieldExpr [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export finalContext [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export finalMethodOverride [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export finalReassigned [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export finalRedeclaration [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export finalRedeclarationBySubclass [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export finalTooManyArgs [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export finalUnassigned [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export formatStringBrace [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export formatStringBytes [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export formatStringEscape [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export formatStringIllegal [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export formatStringUnicode [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export formatStringUnterminated [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export functionDecoratorTypeUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export genericClassAssigned [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export genericClassDeleted [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export genericNotAllowed [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export genericTypeArgMissing [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export genericTypeArgTypeVar [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export genericTypeArgUnique [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export globalReassignment [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export globalRedefinition [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export implicitStringConcat [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export importCycleDetected [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export importDepthExceeded [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export importResolveFailure [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export importSourceResolveFailure [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export importSymbolUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export incompatibleMethodOverride [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export inconsistentIndent [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export inconsistentTabs [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export initSubclassClsParam [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export instanceMethodSelfParam [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export invalidIdentifierChar [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export invalidStubStatement [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export invalidTokenChars [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export isInstanceInvalidType [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export isSubclassInvalidType [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export keyRequiredDeleted [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export keyValueInSet [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export lambdaReturnTypePartiallyUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export lambdaReturnTypeUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export listInAnnotation [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export literalEmptyArgs [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export literalUnsupportedType [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export memberAccess [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export memberDelete [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export memberSet [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export metaclassDuplicate [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export methodNotDefined [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export methodNotDefinedOnType [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export methodOrdering [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export methodOverridden [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export methodReturnsNonObject [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export moduleContext [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export moduleUnknownMember [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export namedExceptAfterCatchAll [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export namedTupleEmptyName [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export namedTupleFirstArg [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export namedTupleNameString [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export namedTupleNameType [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export namedTupleNameUnique [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export namedTupleNoTypes [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export namedTupleSecondArg [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export newClsParam [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export noOverload [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export noReturnContainsReturn [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export noReturnContainsYield [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export noReturnReturnsNone [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export nonDefaultAfterDefault [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export nonLocalInModule [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export nonLocalNoBinding [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export nonLocalReassignment [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export nonLocalRedefinition [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export noneNotCallable [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export noneNotIterable [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export noneNotSubscriptable [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export noneNotUsableWith [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export noneOperator [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export noneUnknownMember [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export objectNotCallable [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export obscuredClassDeclaration [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export obscuredFunctionDeclaration [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export obscuredParameterDeclaration [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export obscuredVariableDeclaration [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export operatorLessOrGreaterDeprecated [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export optionalExtraArgs [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export paramAfterKwargsParam [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export paramAlreadyAssigned [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export paramAssignmentMismatch [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export paramNameMissing [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export paramSpecAssignedName [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export paramSpecContext [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export paramSpecFirstArg [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export paramSpecIllegal [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export paramSpecUnknownArg [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export paramSpecUnknownMember [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export paramSpecUnknownParam [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export paramTypePartiallyUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export paramTypeUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export positionArgAfterNamedArg [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export positionOnlyAfterNameOnly [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export positionOnlyIncompatible [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export privateUsedOutsideOfClass [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export privateUsedOutsideOfModule [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export protectedUsedOutsideOfClass [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export protocolIllegal [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export protocolUsedInCall [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export raiseParams [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export relativeImportNotAllowed [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export returnMissing [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export returnOutsideFunction [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export returnTypeMismatch [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export returnTypePartiallyUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export returnTypeUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export staticClsSelfParam [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export stringNonAsciiBytes [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export stringUnsupportedEscape [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export stringUnterminated [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export stubFileMissing [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export stubUsesGetAttr [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export sublistParamsIncompatible [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export superCallArgCount [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export superCallFirstArg [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export superCallSecondArg [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export superCallZeroArgForm [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export symbolIsPossiblyUnbound [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export symbolIsUnbound [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export symbolIsUndefined [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export symbolOverridden [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export tupleInAnnotation [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export tupleSizeMismatch [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeAbstract [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeAliasNotInModule [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeAliasRedeclared [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeArgsExpectingNone [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeArgsMismatchOne [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeArgsTooMany [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeAssignmentMismatch [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeCallNotAllowed [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeExpectedClass [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeNotAwaitable [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeNotCallable [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeNotIntantiable [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeNotIterable [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeNotSpecializable [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeNotSubscriptable [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeNotSupportBinaryOperator [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeNotSupportUnaryOperator [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeNotUsableWith [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typePartiallyUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeVarAssignedName [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeVarAssignmentMismatch [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeVarBoundAndConstrained [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeVarFirstArg [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeVarGeneric [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeVarUnknownParam [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeVarVariance [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictAccess [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictBadVar [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictBaseClass [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictDelete [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictEmptyName [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictEntryName [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictEntryUnique [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictExtraArgs [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictFirstArg [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictSecondArgDict [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictSecondArgDictEntry [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictSet [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictTotalParam [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unaccessedClass [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unaccessedFunction [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unaccessedImport [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unaccessedSymbol [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unaccessedVariable [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unexpectedAsyncToken [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unexpectedExprToken [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unexpectedIndent [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unexpectedUnindent [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unionSyntaxIllegal [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unnecessaryCast [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unnecessaryIsInstanceAlways [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unnecessaryIsInstanceNever [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unnecessaryIsSubclassAlways [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unnecessaryIsSubclassNever [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unpackInDict [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unpackInSet [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unpackTuplesIllegal [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export unreachableCode [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export varAnnotationIllegal [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export walrusIllegal [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export walrusNotAllowed [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export wildcardInFunction [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export yieldFromIllegal [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export yieldFromOutsideAsync [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export yieldOutsideFunction [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export yieldTypeMismatch [provided] [no usage info] [missing usage info prevents renaming] */
/*!   other exports [not provided] [no usage info] */
/*! export DiagnosticAddendum [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export argParam [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export argParamFunction [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export argumentType [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export argumentTypes [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export assignToNone [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export asyncHelp [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export finalMethod [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export functionReturnTypeMismatch [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export functionTooFewParams [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export functionTooManyParams [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export keyUndefined [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export literalAssignmentMismatch [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export memberAssignment [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export memberIsAbstract [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export memberIsAbstractMore [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export memberSetClassVar [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export memberTypeMismatch [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export memberUnknown [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export namedParamMissingInDest [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export namedParamMissingInSource [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export namedParamTypeMismatch [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export noOverloadAssignable [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export overloadCallName [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export overriddenMethod [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export overriddenSymbol [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export overrideParamCount [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export overrideParamName [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export overrideParamType [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export overrideReturnType [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export overrideType [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export paramAssignment [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export paramType [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export propertyMissingDeleter [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export propertyMissingSetter [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export protocolMemberClassVar [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export protocolMemberMissing [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export seeClassDeclaration [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export seeDeclaration [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export seeFunctionDeclaration [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export seeMethodDeclaration [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export seeParameterDeclaration [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export seeVariableDeclaration [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export tupleEntryTypeMismatch [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export tupleSizeMismatch [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeAssignmentMismatch [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeBound [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeConstrainedTypeVar [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeConstraint [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeIncompatible [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeNotClass [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeNotStringLiteral [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeOfSymbol [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeParamSpec [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeUnsupported [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeVarIsContravariant [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeVarIsCovariant [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeVarIsInvariant [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typeVarNotAllowed [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictFieldMissing [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictFieldNotRequired [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictFieldRequired [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictFieldTypeMismatch [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export typedDictFieldUndefined [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export useDictInstead [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export useListInstead [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export useTupleInstead [provided] [no usage info] [missing usage info prevents renaming] */
/*!   export useTypeInstead [provided] [no usage info] [missing usage info prevents renaming] */
/*!   other exports [not provided] [no usage info] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse(\"{\\\"Diagnostic\\\":{\\\"annotatedTypeArgMissing\\\":\\\"Expected at least one type argument after \\\\\\\"Annotated\\\\\\\"\\\",\\\"annotationFormatString\\\":\\\"Type annotations cannot use format string literals (f-strings)\\\",\\\"annotationNotSupported\\\":\\\"Type annotation not supported for this type of expression\\\",\\\"annotationSpansStrings\\\":\\\"Type annotations cannot span multiple string literals\\\",\\\"annotationStringEscape\\\":\\\"Type annotations cannot contain escape characters\\\",\\\"annotationTripleQuote\\\":\\\"Type annotations cannot use triple quotes\\\",\\\"argAssignment\\\":\\\"Argument of type \\\\\\\"{argType}\\\\\\\" cannot be assigned to parameter of type \\\\\\\"{paramType}\\\\\\\"\\\",\\\"argAssignmentFunction\\\":\\\"Argument of type \\\\\\\"{argType}\\\\\\\" cannot be assigned to parameter of type \\\\\\\"{paramType}\\\\\\\" in function \\\\\\\"{functionName}\\\\\\\"\\\",\\\"argAssignmentParam\\\":\\\"Argument of type \\\\\\\"{argType}\\\\\\\" cannot be assigned to parameter \\\\\\\"{paramName}\\\\\\\" of type \\\\\\\"{paramType}\\\\\\\"\\\",\\\"argAssignmentParamFunction\\\":\\\"Argument of type \\\\\\\"{argType}\\\\\\\" cannot be assigned to parameter \\\\\\\"{paramName}\\\\\\\" of type \\\\\\\"{paramType}\\\\\\\" in function \\\\\\\"{functionName}\\\\\\\"\\\",\\\"argMissingForParam\\\":\\\"Argument missing for parameter {name}\\\",\\\"argMissingForParams\\\":\\\"Arguments missing for parameters {names}\\\",\\\"argPositional\\\":\\\"Expected positional argument\\\",\\\"argPositionalExpectedCount\\\":\\\"Expected {expected} positional arguments\\\",\\\"argPositionalExpectedOne\\\":\\\"Expected 1 positional argument\\\",\\\"argTypePartiallyUnknown\\\":\\\"Argument type is partially unknown\\\",\\\"argTypeUnknown\\\":\\\"Argument type is unknown\\\",\\\"assertAlwaysTrue\\\":\\\"Assert expression always evaluates to true\\\",\\\"assignmentExprContext\\\":\\\"Assignment expression must be within module, function or lambda\\\",\\\"assignmentExprComprehension\\\":\\\"Assignment expression target \\\\\\\"{name}\\\\\\\" cannot use same name as comprehension for target\\\",\\\"assignmentInProtocol\\\":\\\"Assignment to instance or class variables not allowed within a Protocol class\\\",\\\"assignmentTargetExpr\\\":\\\"Expression cannot be assignment target\\\",\\\"awaitIllegal\\\":\\\"Use of \\\\\\\"await\\\\\\\" requires Python 3.5 or newer\\\",\\\"awaitNotInAsync\\\":\\\"\\\\\\\"await\\\\\\\" allowed only within async function\\\",\\\"backticksIllegal\\\":\\\"Expressions surrounded by backticks are not supported in Python 3.x; use repr instead\\\",\\\"baseClassCircular\\\":\\\"Class cannot derive from itself\\\",\\\"baseClassDoubleGeneric\\\":\\\"Class cannot derive from \\\\\\\"Generic\\\\\\\" more than once\\\",\\\"baseClassFinal\\\":\\\"Base class \\\\\\\"{type}\\\\\\\" is marked final and cannot be subclassed\\\",\\\"baseClassInvalid\\\":\\\"Argument to class must be a base class\\\",\\\"baseClassUnknown\\\":\\\"Base class type is unknown, obscuring type of derived class\\\",\\\"breakOutsideLoop\\\":\\\"\\\\\\\"break\\\\\\\" can be used only within a loop\\\",\\\"callableExtraArgs\\\":\\\"Expected only two type arguments to \\\\\\\"Callable\\\\\\\"\\\",\\\"callableFirstArg\\\":\\\"Expected parameter type list or \\\\\\\"...\\\\\\\"\\\",\\\"classDecoratorTypeUnknown\\\":\\\"Untyped class decorator obscures type of class; ignoring decorator\\\",\\\"classMethodClsParam\\\":\\\"Class methods should take a \\\\\\\"cls\\\\\\\" parameter\\\",\\\"classVarFirstArgMissing\\\":\\\"Expected a type argument after \\\\\\\"ClassVar\\\\\\\"\\\",\\\"classVarTooManyArgs\\\":\\\"Expected only one type argument after \\\\\\\"ClassVar\\\\\\\"\\\",\\\"comprehensionInDict\\\":\\\"Comprehension cannot be used with other dictionary entries\\\",\\\"comprehensionInSet\\\":\\\"Comprehension cannot be used with other set entries\\\",\\\"constantRedefinition\\\":\\\"\\\\\\\"{name}\\\\\\\" is constant and cannot be redefined\\\",\\\"continueInFinally\\\":\\\"\\\\\\\"continue\\\\\\\" cannot be used within a finally clause\\\",\\\"continueOutsideLoop\\\":\\\"\\\\\\\"continue\\\\\\\" can be used only within a loop\\\",\\\"constructorNoArgs\\\":\\\"Expected no arguments to \\\\\\\"{type}\\\\\\\" constructor\\\",\\\"dataClassFieldWithDefault\\\":\\\"Data class fields without default value cannot appear after data fields with default values\\\",\\\"declaredReturnTypePartiallyUnknown\\\":\\\"Declared return type, \\\\\\\"{returnType}\\\\\\\", is partially unknown\\\",\\\"declaredReturnTypeUnknown\\\":\\\"Declared return type is unknown\\\",\\\"defaultValueContainsCall\\\":\\\"Function calls within default value initializer are not permitted\\\",\\\"defaultValueNotAllowed\\\":\\\"Parameter with \\\\\\\"*\\\\\\\" or \\\\\\\"**\\\\\\\" cannot have default value\\\",\\\"delTargetExpr\\\":\\\"Expression cannot be deleted\\\",\\\"dictInAnnotation\\\":\\\"Dictionary expression not allowed in type annotation\\\",\\\"dictKeyValuePairs\\\":\\\"Dictionary entries must contain key/value pairs\\\",\\\"duplicateArgsParam\\\":\\\"Only one \\\\\\\"*\\\\\\\" parameter is allowed\\\",\\\"duplicateCatchAll\\\":\\\"Only one catch-all except clause is allowed\\\",\\\"duplicateImport\\\":\\\"\\\\\\\"{importName}\\\\\\\" is imported more than once\\\",\\\"duplicateKwargsParam\\\":\\\"Only one \\\\\\\"**\\\\\\\" parameter is allowed\\\",\\\"duplicateNameOnly\\\":\\\"Only one \\\\\\\"*\\\\\\\" separator is allowed\\\",\\\"duplicateParam\\\":\\\"Duplicate parameter \\\\\\\"{name}\\\\\\\"\\\",\\\"duplicatePositionOnly\\\":\\\"Only one \\\\\\\"/\\\\\\\" parameter is allowed\\\",\\\"duplicateUnpack\\\":\\\"Only one unpack operation allowed in list\\\",\\\"ellipsisContext\\\":\\\"\\\\\\\"...\\\\\\\" not allowed in this context\\\",\\\"ellipsisSecondArg\\\":\\\"\\\\\\\"...\\\\\\\" allowed only as the second of two arguments\\\",\\\"enumFirstArg\\\":\\\"Expected enum class name as first argument\\\",\\\"enumSecondArg\\\":\\\"Expected enum item string as second parameter\\\",\\\"exceptionTypeIncorrect\\\":\\\"\\\\\\\"{type}\\\\\\\" does not derive from BaseException\\\",\\\"exceptionTypeNotClass\\\":\\\"\\\\\\\"{type}\\\\\\\" is not valid exception class\\\",\\\"expectedAfterDecorator\\\":\\\"Expected function or class declaration after decorator\\\",\\\"expectedAsAfterException\\\":\\\"Expected \\\\\\\"as\\\\\\\" after exception type\\\",\\\"expectedAssignRightHandExpr\\\":\\\"Expected expression to the right of \\\\\\\"=\\\\\\\"\\\",\\\"expectedBinaryRightHandExpr\\\":\\\"Expected expression to the right of operator\\\",\\\"expectedBoolLiteral\\\":\\\"Expected True or False\\\",\\\"expectedClassName\\\":\\\"Expected class name\\\",\\\"expectedCloseBrace\\\":\\\"Expected \\\\\\\"}\\\\\\\"\\\",\\\"expectedCloseBracket\\\":\\\"Expected \\\\\\\"]\\\\\\\"\\\",\\\"expectedCloseParen\\\":\\\"Expected \\\\\\\")\\\\\\\"\\\",\\\"expectedColon\\\":\\\"Expected \\\\\\\":\\\\\\\"\\\",\\\"expectedDecoratorName\\\":\\\"Expected decorator name\\\",\\\"expectedDecoratorNewline\\\":\\\"Expected new line at end of decorator\\\",\\\"expectedDelExpr\\\":\\\"Expected expression after \\\\\\\"del\\\\\\\"\\\",\\\"expectedElse\\\":\\\"Expected \\\\\\\"else\\\\\\\"\\\",\\\"expectedExceptionClass\\\":\\\"Expected exception class or object\\\",\\\"expectedExceptionObj\\\":\\\"Expected exception object or None\\\",\\\"expectedExpr\\\":\\\"Expected expression\\\",\\\"expectedIdentifier\\\":\\\"Expected identifier\\\",\\\"expectedImport\\\":\\\"Expected \\\\\\\"import\\\\\\\"\\\",\\\"expectedImportAlias\\\":\\\"Expected symbol after \\\\\\\"as\\\\\\\"\\\",\\\"expectedImportSymbols\\\":\\\"Expected one or more symbol names after import\\\",\\\"expectedIndentedBlock\\\":\\\"Expected indented block\\\",\\\"expectedInExpr\\\":\\\"Expected expression after \\\\\\\"in\\\\\\\"\\\",\\\"expectedIn\\\":\\\"Expected \\\\\\\"in\\\\\\\"\\\",\\\"expectedFunctionAfterAsync\\\":\\\"Expected function definition after \\\\\\\"async\\\\\\\"\\\",\\\"expectedFunctionName\\\":\\\"Expected function name after \\\\\\\"def\\\\\\\"\\\",\\\"expectedMemberName\\\":\\\"Expected member name after \\\\\\\".\\\\\\\"\\\",\\\"expectedModuleName\\\":\\\"Expected module name\\\",\\\"expectedNameAfterAs\\\":\\\"Expected symbol name after \\\\\\\"as\\\\\\\"\\\",\\\"expectedNamedArgument\\\":\\\"Named argument must follow \\\\\\\"*\\\\\\\"\\\",\\\"expectedNewlineOrSemicolon\\\":\\\"Statements must be separated by newlines or semicolons\\\",\\\"expectedOpenParen\\\":\\\"Expected \\\\\\\"(\\\\\\\"\\\",\\\"expectedParamName\\\":\\\"Expected parameter name\\\",\\\"expectedReturnExpr\\\":\\\"Expected expression after \\\\\\\"return\\\\\\\"\\\",\\\"expectedSliceIndex\\\":\\\"Expected index or slice expression\\\",\\\"expectedTypeNotString\\\":\\\"Expected type but received a string literal\\\",\\\"expectedYieldExpr\\\":\\\"Expected expression in yield statement\\\",\\\"finalContext\\\":\\\"\\\\\\\"Final\\\\\\\" is not allowed in this context\\\",\\\"finalMethodOverride\\\":\\\"Method \\\\\\\"{name}\\\\\\\" cannot override final method defined in class \\\\\\\"{className}\\\\\\\"\\\",\\\"finalReassigned\\\":\\\"\\\\\\\"{name}\\\\\\\" is declared as Final and cannot be reassigned\\\",\\\"finalRedeclaration\\\":\\\"\\\\\\\"{name}\\\\\\\" was previously declared as Final\\\",\\\"finalRedeclarationBySubclass\\\":\\\"\\\\\\\"{name}\\\\\\\" cannot be redeclared because parent class \\\\\\\"{className}\\\\\\\" declares it as Final\\\",\\\"finalTooManyArgs\\\":\\\"Expected a single type argument after \\\\\\\"Final\\\\\\\"\\\",\\\"finalUnassigned\\\":\\\"\\\\\\\"{name}\\\\\\\" is declared Final, but value is not assigned\\\",\\\"formatStringBrace\\\":\\\"Single close brace not allowed within f-string literal; use double close brace\\\",\\\"formatStringBytes\\\":\\\"Format string literals (f-strings) cannot be binary\\\",\\\"formatStringEscape\\\":\\\"Escape sequence (backslash) not allowed in expression portion of f-string\\\",\\\"formatStringUnicode\\\":\\\"Format string literals (f-strings) cannot be unicode\\\",\\\"formatStringIllegal\\\":\\\"Format string literals (f-strings) require Python 3.6 or newer\\\",\\\"formatStringUnterminated\\\":\\\"Unterminated expression in f-string; missing close brace\\\",\\\"functionDecoratorTypeUnknown\\\":\\\"Untyped function decorator obscures type of function; ignoring decorator\\\",\\\"genericClassAssigned\\\":\\\"Generic class type cannot be assigned\\\",\\\"genericClassDeleted\\\":\\\"Generic class type cannot be deleted\\\",\\\"genericNotAllowed\\\":\\\"\\\\\\\"Generic\\\\\\\" is not valid in this context\\\",\\\"genericTypeArgMissing\\\":\\\"\\\\\\\"Generic\\\\\\\" requires at least one type argument\\\",\\\"genericTypeArgTypeVar\\\":\\\"Type argument for \\\\\\\"Generic\\\\\\\" must be a type variable\\\",\\\"genericTypeArgUnique\\\":\\\"Type arguments for \\\\\\\"Generic\\\\\\\" must be unique\\\",\\\"globalReassignment\\\":\\\"\\\\\\\"{name}\\\\\\\" is assigned before global declaration\\\",\\\"globalRedefinition\\\":\\\"\\\\\\\"{name}\\\\\\\" was already declared global\\\",\\\"implicitStringConcat\\\":\\\"Implicit string concatenation not allowed\\\",\\\"importCycleDetected\\\":\\\"Cycle detected in import chain\\\",\\\"importDepthExceeded\\\":\\\"Import chain depth exceeded {depth}\\\",\\\"importResolveFailure\\\":\\\"Import \\\\\\\"{importName}\\\\\\\" could not be resolved\\\",\\\"importSourceResolveFailure\\\":\\\"Import \\\\\\\"{importName}\\\\\\\" could not be resolved from source\\\",\\\"importSymbolUnknown\\\":\\\"\\\\\\\"{name}\\\\\\\" is unknown import symbol\\\",\\\"incompatibleMethodOverride\\\":\\\"Method \\\\\\\"{name}\\\\\\\" overrides class \\\\\\\"{className}\\\\\\\" in an incompatible manner\\\",\\\"inconsistentIndent\\\":\\\"Unindent amount does not match previous indent\\\",\\\"inconsistentTabs\\\":\\\"Inconsistent use of tabs and spaces in indentation\\\",\\\"initSubclassClsParam\\\":\\\"__init_subclass__ override should take a \\\\\\\"cls\\\\\\\" parameter\\\",\\\"instanceMethodSelfParam\\\":\\\"Instance methods should take a \\\\\\\"self\\\\\\\" parameter\\\",\\\"invalidIdentifierChar\\\":\\\"Invalid character in identifier\\\",\\\"invalidStubStatement\\\":\\\"Statement is meaningless within a type stub file\\\",\\\"invalidTokenChars\\\":\\\"Invalid character in token \\\\\\\"{text}\\\\\\\"\\\",\\\"isInstanceInvalidType\\\":\\\"Second argument to \\\\\\\"isinstance\\\\\\\" must be a class or tuple of classes\\\",\\\"isSubclassInvalidType\\\":\\\"Second argument to \\\\\\\"issubclass\\\\\\\" must be a class or tuple of classes\\\",\\\"keyRequiredDeleted\\\":\\\"\\\\\\\"{name}\\\\\\\" is a required key and cannot be deleted\\\",\\\"keyValueInSet\\\":\\\"Key/value pairs are not allowed within a set\\\",\\\"lambdaReturnTypeUnknown\\\":\\\"Return type of lambda is unknown\\\",\\\"lambdaReturnTypePartiallyUnknown\\\":\\\"Return type of lambda, \\\\\\\"{returnType}\\\\\\\", is partially unknown\\\",\\\"listInAnnotation\\\":\\\"List expression not allowed in type annotation\\\",\\\"literalUnsupportedType\\\":\\\"Type arguments for \\\\\\\"Literal\\\\\\\" must be None, a literal value (int, bool, str, or bytes), or an enum value\\\",\\\"literalEmptyArgs\\\":\\\"Expected one or more type arguments after \\\\\\\"Literal\\\\\\\"\\\",\\\"memberAccess\\\":\\\"Cannot access member \\\\\\\"{name}\\\\\\\" for type \\\\\\\"{type}\\\\\\\"\\\",\\\"memberDelete\\\":\\\"Cannot delete member \\\\\\\"{name}\\\\\\\" for type \\\\\\\"{type}\\\\\\\"\\\",\\\"memberSet\\\":\\\"Cannot assign member \\\\\\\"{name}\\\\\\\" for type \\\\\\\"{type}\\\\\\\"\\\",\\\"metaclassDuplicate\\\":\\\"Only one metaclass can be provided\\\",\\\"methodNotDefined\\\":\\\"\\\\\\\"{name}\\\\\\\" method not defined\\\",\\\"methodNotDefinedOnType\\\":\\\"\\\\\\\"{name}\\\\\\\" method not defined on type \\\\\\\"{type}\\\\\\\"\\\",\\\"methodOrdering\\\":\\\"Cannot create consistent method ordering\\\",\\\"methodOverridden\\\":\\\"\\\\\\\"{name}\\\\\\\" overrides method of same name in class \\\\\\\"{className}\\\\\\\"\\\",\\\"methodReturnsNonObject\\\":\\\"\\\\\\\"{name}\\\\\\\" method does not return an object\\\",\\\"moduleContext\\\":\\\"Module not allowed in this context\\\",\\\"moduleUnknownMember\\\":\\\"\\\\\\\"{name}\\\\\\\" is not a known member of module\\\",\\\"namedExceptAfterCatchAll\\\":\\\"A named except clause cannot appear after catch-all except clause\\\",\\\"namedTupleEmptyName\\\":\\\"Names within a named tuple cannot be empty\\\",\\\"namedTupleFirstArg\\\":\\\"Expected named tuple class name as first argument\\\",\\\"namedTupleNameString\\\":\\\"Expected string literal for tuple entry name\\\",\\\"namedTupleNameType\\\":\\\"Expected two-entry tuple specifying entry name and type\\\",\\\"namedTupleNameUnique\\\":\\\"Names within a named tuple must be unique\\\",\\\"namedTupleNoTypes\\\":\\\"\\\\\\\"namedtuple\\\\\\\" provides no types for tuple entries; use \\\\\\\"NamedTuple\\\\\\\" instead\\\",\\\"namedTupleSecondArg\\\":\\\"Expected named tuple entry list as second argument\\\",\\\"newClsParam\\\":\\\"__new__ override should take a \\\\\\\"cls\\\\\\\" parameter\\\",\\\"nonDefaultAfterDefault\\\":\\\"Non-default argument follows default argument\\\",\\\"noneNotCallable\\\":\\\"Object of type \\\\\\\"None\\\\\\\" cannot be called\\\",\\\"noneNotIterable\\\":\\\"Object of type \\\\\\\"None\\\\\\\" cannot be used as iterable value\\\",\\\"noneOperator\\\":\\\"Operator \\\\\\\"{operator}\\\\\\\" not supported for \\\\\\\"None\\\\\\\"\\\",\\\"noneNotSubscriptable\\\":\\\"Object of type \\\\\\\"None\\\\\\\" cannot be subscripted\\\",\\\"noneNotUsableWith\\\":\\\"Object of type \\\\\\\"None\\\\\\\" cannot be used with \\\\\\\"with\\\\\\\"\\\",\\\"noneUnknownMember\\\":\\\"\\\\\\\"{name}\\\\\\\" is not a known member of \\\\\\\"None\\\\\\\"\\\",\\\"nonLocalNoBinding\\\":\\\"No binding for nonlocal \\\\\\\"{name}\\\\\\\" found\\\",\\\"nonLocalReassignment\\\":\\\"\\\\\\\"{name}\\\\\\\" is assigned before nonlocal declaration\\\",\\\"nonLocalRedefinition\\\":\\\"\\\\\\\"{name}\\\\\\\" was already declared nonlocal\\\",\\\"nonLocalInModule\\\":\\\"Nonlocal declaration not allowed at module level\\\",\\\"noOverload\\\":\\\"No overloads for \\\\\\\"{expression}\\\\\\\" match parameters\\\",\\\"noReturnContainsReturn\\\":\\\"Function with declared return type \\\\\\\"NoReturn\\\\\\\" cannot include a return statement\\\",\\\"noReturnContainsYield\\\":\\\"Function with declared return type \\\\\\\"NoReturn\\\\\\\" cannot include a yield statement\\\",\\\"noReturnReturnsNone\\\":\\\"Function with declared type of \\\\\\\"NoReturn\\\\\\\" cannot return \\\\\\\"None\\\\\\\"\\\",\\\"objectNotCallable\\\":\\\"object of \\\\\\\"{type}\\\\\\\" is not callable\\\",\\\"obscuredClassDeclaration\\\":\\\"Class declaration \\\\\\\"{name}\\\\\\\" is obscured by a declaration of the same name\\\",\\\"obscuredFunctionDeclaration\\\":\\\"Function declaration \\\\\\\"{name}\\\\\\\" is obscured by a declaration of the same name\\\",\\\"obscuredParameterDeclaration\\\":\\\"Parameter declaration \\\\\\\"{name}\\\\\\\" is obscured by a declaration of the same name\\\",\\\"obscuredVariableDeclaration\\\":\\\"Declaration \\\\\\\"{name}\\\\\\\" is obscured by a declaration of the same name\\\",\\\"operatorLessOrGreaterDeprecated\\\":\\\"Operator \\\\\\\"<>\\\\\\\" is not supported in Python 3; use \\\\\\\"!=\\\\\\\" instead\\\",\\\"optionalExtraArgs\\\":\\\"Expected one type argument after \\\\\\\"Optional\\\\\\\"\\\",\\\"paramAfterKwargsParam\\\":\\\"Parameter cannot follow \\\\\\\"**\\\\\\\" parameter\\\",\\\"paramAlreadyAssigned\\\":\\\"Parameter \\\\\\\"{name}\\\\\\\" is already assigned\\\",\\\"paramNameMissing\\\":\\\"No parameter named \\\\\\\"{name}\\\\\\\"\\\",\\\"paramSpecAssignedName\\\":\\\"ParamSpec must be assigned to a variable named \\\\\\\"{name}\\\\\\\"\\\",\\\"paramSpecContext\\\":\\\"ParamSpec not allowed in this context\\\",\\\"paramSpecIllegal\\\":\\\"ParamSpec requires Python 3.9 or newer\\\",\\\"paramSpecFirstArg\\\":\\\"Expected name of ParamSpec as first argument\\\",\\\"paramSpecUnknownArg\\\":\\\"ParamSpec does not support more than one argument\\\",\\\"paramSpecUnknownMember\\\":\\\"\\\\\\\"{name}\\\\\\\" is not a known member of ParamSpec\\\",\\\"paramSpecUnknownParam\\\":\\\"\\\\\\\"{name}\\\\\\\" is unknown parameter to ParamSpec\\\",\\\"paramAssignmentMismatch\\\":\\\"Expression of type \\\\\\\"{sourceType}\\\\\\\" cannot be assigned to parameter of type \\\\\\\"{paramType}\\\\\\\"\\\",\\\"paramTypeUnknown\\\":\\\"Type of parameter \\\\\\\"{paramName}\\\\\\\" is unknown\\\",\\\"paramTypePartiallyUnknown\\\":\\\"Type of parameter \\\\\\\"{paramName}\\\\\\\" is partially unknown\\\",\\\"positionArgAfterNamedArg\\\":\\\"Positional argument cannot appear after named arguments\\\",\\\"positionOnlyAfterNameOnly\\\":\\\"\\\\\\\"/\\\\\\\" parameter must appear before \\\\\\\"*\\\\\\\" parameter\\\",\\\"positionOnlyIncompatible\\\":\\\"Position-only argument separator requires Python 3.8 or greater\\\",\\\"privateUsedOutsideOfClass\\\":\\\"\\\\\\\"{name}\\\\\\\" is private and used outside of the class in which it is declared\\\",\\\"privateUsedOutsideOfModule\\\":\\\"\\\\\\\"{name}\\\\\\\" is private and used outside of the module in which it is declared\\\",\\\"protectedUsedOutsideOfClass\\\":\\\"\\\\\\\"{name}\\\\\\\" is protected and used outside of the class in which it is declared\\\",\\\"protocolUsedInCall\\\":\\\"Protocol class cannot be used in \\\\\\\"{name}\\\\\\\" call\\\",\\\"protocolIllegal\\\":\\\"Use of \\\\\\\"Protocol\\\\\\\" requires Python 3.7 or newer\\\",\\\"raiseParams\\\":\\\"\\\\\\\"raise\\\\\\\" requires one or more parameters when used outside of except clause\\\",\\\"relativeImportNotAllowed\\\":\\\"Relative imports cannot be used with \\\\\\\"import .a\\\\\\\" form; use \\\\\\\"from . import a\\\\\\\" instead\\\",\\\"returnOutsideFunction\\\":\\\"\\\\\\\"return\\\\\\\" can be used only within a function\\\",\\\"returnMissing\\\":\\\"Function with declared type of \\\\\\\"{returnType}\\\\\\\" must return value\\\",\\\"returnTypeMismatch\\\":\\\"Expression of type \\\\\\\"{exprType}\\\\\\\" cannot be assigned to return type \\\\\\\"{returnType}\\\\\\\"\\\",\\\"returnTypeUnknown\\\":\\\"Return type is unknown\\\",\\\"returnTypePartiallyUnknown\\\":\\\"Return type, \\\\\\\"{returnType}\\\\\\\", is partially unknown\\\",\\\"staticClsSelfParam\\\":\\\"Static methods should not take a \\\\\\\"self\\\\\\\" or \\\\\\\"cls\\\\\\\" parameter\\\",\\\"stringNonAsciiBytes\\\":\\\"Non-ASCII character not allowed in bytes string literal\\\",\\\"stringUnsupportedEscape\\\":\\\"Unsupported escape sequence in string literal\\\",\\\"stringUnterminated\\\":\\\"String literal is unterminated\\\",\\\"stubFileMissing\\\":\\\"Stub file not found for \\\\\\\"{importName}\\\\\\\"\\\",\\\"stubUsesGetAttr\\\":\\\"Type stub file is incomplete; \\\\\\\"__getattr__\\\\\\\" obscures type errors for module\\\",\\\"sublistParamsIncompatible\\\":\\\"Sublist parameters are not supported in Python 3.x\\\",\\\"superCallArgCount\\\":\\\"Expected no more than two arguments to \\\\\\\"super\\\\\\\" call\\\",\\\"superCallFirstArg\\\":\\\"Expected class type as first argument to \\\\\\\"super\\\\\\\" call but received \\\\\\\"{type}\\\\\\\"\\\",\\\"superCallSecondArg\\\":\\\"Second argument to \\\\\\\"super\\\\\\\" call must be object or class that derives from \\\\\\\"{type}\\\\\\\"\\\",\\\"superCallZeroArgForm\\\":\\\"Zero-argument form of \\\\\\\"super\\\\\\\" call is valid only within a class\\\",\\\"symbolIsUnbound\\\":\\\"\\\\\\\"{name}\\\\\\\" is unbound\\\",\\\"symbolIsUndefined\\\":\\\"\\\\\\\"{name}\\\\\\\" is not defined\\\",\\\"symbolIsPossiblyUnbound\\\":\\\"\\\\\\\"{name}\\\\\\\" is possibly unbound\\\",\\\"symbolOverridden\\\":\\\"\\\\\\\"{name}\\\\\\\" overrides symbol of same name in class \\\\\\\"{className}\\\\\\\"\\\",\\\"tupleInAnnotation\\\":\\\"Tuple expression not allowed in type annotation\\\",\\\"tupleSizeMismatch\\\":\\\"Tuple size mismatch: expected {expected} but received {received}\\\",\\\"typeAbstract\\\":\\\"Cannot instantiate abstract class \\\\\\\"{type}\\\\\\\"\\\",\\\"typeAliasNotInModule\\\":\\\"A TypeAlias can be defined only within a module scope\\\",\\\"typeAliasRedeclared\\\":\\\"\\\\\\\"{name}\\\\\\\" is declared as a TypeAlias and can be assigned only once\\\",\\\"typeArgsExpectingNone\\\":\\\"Expected no type arguments\\\",\\\"typeArgsMismatchOne\\\":\\\"Expected one type argument but received {received}\\\",\\\"typeArgsTooMany\\\":\\\"Too many type arguments provided; expected {expected} but received {received}\\\",\\\"typeAssignmentMismatch\\\":\\\"Expression of type \\\\\\\"{sourceType}\\\\\\\" cannot be assigned to declared type \\\\\\\"{destType}\\\\\\\"\\\",\\\"typeCallNotAllowed\\\":\\\"type() call should not be used in type annotation\\\",\\\"typedDictAccess\\\":\\\"Could not access item in TypedDict\\\",\\\"typedDictBadVar\\\":\\\"TypedDict classes can contain only type annotations\\\",\\\"typedDictBaseClass\\\":\\\"All base classes for \\\\\\\"TypedDict\\\\\\\" classes must also be \\\\\\\"TypedDict\\\\\\\" classes\\\",\\\"typedDictDelete\\\":\\\"Could not delete item in TypedDict\\\",\\\"typedDictEmptyName\\\":\\\"Names within a TypedDict cannot be empty\\\",\\\"typedDictEntryName\\\":\\\"Expected string literal for dictionary entry name\\\",\\\"typedDictEntryUnique\\\":\\\"Names within a dictionary must be unique\\\",\\\"typedDictExtraArgs\\\":\\\"Extra TypedDict arguments not supported\\\",\\\"typedDictFirstArg\\\":\\\"Expected TypedDict class name as first argument\\\",\\\"typedDictSecondArgDict\\\":\\\"Expected dict or named parameter as second parameter\\\",\\\"typedDictSecondArgDictEntry\\\":\\\"Expected simple dictionary entry\\\",\\\"typedDictSet\\\":\\\"Could not assign item in TypedDict\\\",\\\"typedDictTotalParam\\\":\\\"Expected \\\\\\\"total\\\\\\\" parameter to have a value of True or False\\\",\\\"typeExpectedClass\\\":\\\"Expected class type but received \\\\\\\"{type}\\\\\\\"\\\",\\\"typeNotAwaitable\\\":\\\"\\\\\\\"{type}\\\\\\\" is not awaitable\\\",\\\"typeNotCallable\\\":\\\"\\\\\\\"{expression}\\\\\\\" has type \\\\\\\"{type}\\\\\\\" and is not callable\\\",\\\"typeNotIntantiable\\\":\\\"\\\\\\\"{type}\\\\\\\" cannot be instantiated\\\",\\\"typeNotIterable\\\":\\\"\\\\\\\"{type}\\\\\\\" is not iterable\\\",\\\"typeNotSpecializable\\\":\\\"Could not specialize type \\\\\\\"{type}\\\\\\\"\\\",\\\"typeNotSubscriptable\\\":\\\"Object of type \\\\\\\"{type}\\\\\\\" cannot be subscripted\\\",\\\"typeNotUsableWith\\\":\\\"Object of type \\\\\\\"{type}\\\\\\\" cannot be used with \\\\\\\"with\\\\\\\" because it does not implement {method}\\\",\\\"typeNotSupportBinaryOperator\\\":\\\"Operator \\\\\\\"{operator}\\\\\\\" not supported for types \\\\\\\"{leftType}\\\\\\\" and \\\\\\\"{rightType}\\\\\\\"\\\",\\\"typeNotSupportUnaryOperator\\\":\\\"Operator \\\\\\\"{operator}\\\\\\\" not supported for type \\\\\\\"{type}\\\\\\\"\\\",\\\"typePartiallyUnknown\\\":\\\"Type of \\\\\\\"{name}\\\\\\\" is partially unknown\\\",\\\"typeUnknown\\\":\\\"Type of \\\\\\\"{name}\\\\\\\" is unknown\\\",\\\"typeVarAssignedName\\\":\\\"TypeVar must be assigned to a variable named \\\\\\\"{name}\\\\\\\"\\\",\\\"typeVarAssignmentMismatch\\\":\\\"Type \\\\\\\"{type}\\\\\\\" cannot be assigned to TypeVar \\\\\\\"{name}\\\\\\\"\\\",\\\"typeVarBoundAndConstrained\\\":\\\"TypeVar cannot be both bound and constrained\\\",\\\"typeVarFirstArg\\\":\\\"Expected name of TypeVar as first argument\\\",\\\"typeVarGeneric\\\":\\\"TypeVar bound type cannot be generic\\\",\\\"typeVarUnknownParam\\\":\\\"\\\\\\\"{name}\\\\\\\" is unknown parameter to TypeVar\\\",\\\"typeVarVariance\\\":\\\"TypeVar cannot be both covariant and contravariant\\\",\\\"unaccessedClass\\\":\\\"Class \\\\\\\"{name}\\\\\\\" is not accessed\\\",\\\"unaccessedFunction\\\":\\\"Function \\\\\\\"{name}\\\\\\\" is not accessed\\\",\\\"unaccessedImport\\\":\\\"Import \\\\\\\"{name}\\\\\\\" is not accessed\\\",\\\"unaccessedSymbol\\\":\\\"\\\\\\\"{name}\\\\\\\" is not accessed\\\",\\\"unaccessedVariable\\\":\\\"Variable \\\\\\\"{name}\\\\\\\" is not accessed\\\",\\\"unexpectedAsyncToken\\\":\\\"Expected \\\\\\\"def\\\\\\\", \\\\\\\"with\\\\\\\" or \\\\\\\"for\\\\\\\" to follow \\\\\\\"async\\\\\\\"\\\",\\\"unexpectedExprToken\\\":\\\"Unexpected token at end of expression\\\",\\\"unexpectedIndent\\\":\\\"Unexpected indentation\\\",\\\"unexpectedUnindent\\\":\\\"Unindent not expected\\\",\\\"unionSyntaxIllegal\\\":\\\"Alternative syntax for unions requires Python 3.9 or newer\\\",\\\"unnecessaryCast\\\":\\\"Unnecessary \\\\\\\"cast\\\\\\\" call; type is already \\\\\\\"{type}\\\\\\\"\\\",\\\"unnecessaryIsInstanceAlways\\\":\\\"Unnecessary isinstance call; \\\\\\\"{testType}\\\\\\\" is always an instance of \\\\\\\"{classType}\\\\\\\"\\\",\\\"unnecessaryIsInstanceNever\\\":\\\"Unnecessary isinstance call; \\\\\\\"{testType}\\\\\\\" is never an instance of \\\\\\\"{classType}\\\\\\\"\\\",\\\"unnecessaryIsSubclassAlways\\\":\\\"Unnecessary issubclass call; \\\\\\\"{testType}\\\\\\\" is always a subclass of \\\\\\\"{classType}\\\\\\\"\\\",\\\"unnecessaryIsSubclassNever\\\":\\\"Unnecessary issubclass call; \\\\\\\"{testType}\\\\\\\" is never a subclass of \\\\\\\"{classType}\\\\\\\"\\\",\\\"unpackInDict\\\":\\\"Unpack operation not allowed in dictionaries\\\",\\\"unpackInSet\\\":\\\"Unpack operator not allowed within a set\\\",\\\"unpackTuplesIllegal\\\":\\\"Unpack operation not allowed in tuples prior to Python 3.8\\\",\\\"unreachableCode\\\":\\\"Code is unreachable\\\",\\\"varAnnotationIllegal\\\":\\\"Type annotations for variables requires Python 3.6 or newer; use type comment for compatibility with previous versions\\\",\\\"walrusIllegal\\\":\\\"Operator \\\\\\\":=\\\\\\\" requires Python 3.8 or newer\\\",\\\"walrusNotAllowed\\\":\\\"Operator \\\\\\\":=\\\\\\\" not allowed in this context\\\",\\\"wildcardInFunction\\\":\\\"Wildcard import is not allowed within a class or function\\\",\\\"yieldFromIllegal\\\":\\\"Use of \\\\\\\"yield from\\\\\\\" requires Python 3.3 or newer\\\",\\\"yieldFromOutsideAsync\\\":\\\"\\\\\\\"yield from\\\\\\\" not allowed in an async function\\\",\\\"yieldOutsideFunction\\\":\\\"\\\\\\\"yield\\\\\\\" not allowed outside of a function\\\",\\\"yieldTypeMismatch\\\":\\\"Expression of type \\\\\\\"{exprType}\\\\\\\" cannot be assigned to yield type \\\\\\\"{yieldType}\\\\\\\"\\\"},\\\"DiagnosticAddendum\\\":{\\\"argParam\\\":\\\"Argument corresponds to parameter \\\\\\\"{paramName}\\\\\\\"\\\",\\\"argParamFunction\\\":\\\"Argument corresponds to parameter \\\\\\\"{paramName}\\\\\\\" in function \\\\\\\"{functionName}\\\\\\\"\\\",\\\"argumentType\\\":\\\"Argument type is \\\\\\\"{type}\\\\\\\"\\\",\\\"argumentTypes\\\":\\\"Argument types: ({types})\\\",\\\"assignToNone\\\":\\\"Cannot assign to \\\\\\\"None\\\\\\\"\\\",\\\"asyncHelp\\\":\\\"Did you mean \\\\\\\"async with\\\\\\\"?\\\",\\\"finalMethod\\\":\\\"Final method\\\",\\\"keyUndefined\\\":\\\"\\\\\\\"{name}\\\\\\\" is not a defined key in \\\\\\\"{type}\\\\\\\"\\\",\\\"functionReturnTypeMismatch\\\":\\\"Function return type \\\\\\\"{sourceType}\\\\\\\" is not compatible with type \\\\\\\"{destType}\\\\\\\"\\\",\\\"functionTooFewParams\\\":\\\"Function accepts too few parameters; expected {expected} but received {received}\\\",\\\"functionTooManyParams\\\":\\\"Function accepts too many parameters; expected {expected} but received {received}\\\",\\\"literalAssignmentMismatch\\\":\\\"\\\\\\\"{sourceType}\\\\\\\" cannot be assigned to type \\\\\\\"{destType}\\\\\\\"\\\",\\\"memberSetClassVar\\\":\\\"Member \\\\\\\"{name}\\\\\\\" cannot be assigned through a class instance because it is a ClassVar\\\",\\\"memberAssignment\\\":\\\"Expression of type \\\\\\\"{type}\\\\\\\" cannot be assigned to member \\\\\\\"{name}\\\\\\\" of class \\\\\\\"{classType}\\\\\\\"\\\",\\\"memberIsAbstract\\\":\\\"\\\\\\\"{type}.{name}\\\\\\\" is abstract\\\",\\\"memberIsAbstractMore\\\":\\\"and {count} more...\\\",\\\"memberTypeMismatch\\\":\\\"\\\\\\\"{name}\\\\\\\" is an incompatible type\\\",\\\"memberUnknown\\\":\\\"Member \\\\\\\"{name}\\\\\\\" is unknown\\\",\\\"namedParamMissingInDest\\\":\\\"Named parameter \\\\\\\"{name}\\\\\\\" is missing in destination\\\",\\\"namedParamMissingInSource\\\":\\\"Named parameter \\\\\\\"{name}\\\\\\\" is missing in source\\\",\\\"namedParamTypeMismatch\\\":\\\"Named parameter \\\\\\\"{name}\\\\\\\" of type \\\\\\\"{sourceType}\\\\\\\" cannot be assigned to type \\\\\\\"{destType}\\\\\\\"\\\",\\\"noOverloadAssignable\\\":\\\"No overloaded function matches type \\\\\\\"{type}\\\\\\\"\\\",\\\"overloadCallName\\\":\\\"Calling function \\\\\\\"{name}\\\\\\\"\\\",\\\"overriddenMethod\\\":\\\"Overridden method\\\",\\\"overriddenSymbol\\\":\\\"Overridden symbol\\\",\\\"overrideParamCount\\\":\\\"Parameter count mismatch; base method has {baseCount}, but override has {overrideCount}\\\",\\\"overrideParamName\\\":\\\"Parameter {index} name mismatch: base parameter is named \\\\\\\"{baseName}\\\\\\\", override parameter is named \\\\\\\"{overrideName}\\\\\\\"\\\",\\\"overrideParamType\\\":\\\"Parameter {index} type mismatch: base parameter is type \\\\\\\"{baseType}\\\\\\\", override parameter is type \\\\\\\"{overrideType}\\\\\\\"\\\",\\\"overrideReturnType\\\":\\\"Return type mismatch: base method returns type \\\\\\\"{baseType}\\\\\\\", override returns type \\\\\\\"{overrideType}\\\\\\\"\\\",\\\"overrideType\\\":\\\"Base class defines type as \\\\\\\"{type}\\\\\\\"\\\",\\\"paramAssignment\\\":\\\"Parameter {index}: type \\\\\\\"{sourceType}\\\\\\\" cannot be assigned to type \\\\\\\"{destType}\\\\\\\"\\\",\\\"paramType\\\":\\\"Parameter type is \\\\\\\"{paramType}\\\\\\\"\\\",\\\"propertyMissingDeleter\\\":\\\"Property \\\\\\\"{name}\\\\\\\" has no defined deleter\\\",\\\"propertyMissingSetter\\\":\\\"Property \\\\\\\"{name}\\\\\\\" has no defined setter\\\",\\\"protocolMemberMissing\\\":\\\"\\\\\\\"{name}\\\\\\\" is not present\\\",\\\"protocolMemberClassVar\\\":\\\"\\\\\\\"{name}\\\\\\\" is not a class variable\\\",\\\"seeDeclaration\\\":\\\"See declaration\\\",\\\"seeClassDeclaration\\\":\\\"See class declaration\\\",\\\"seeFunctionDeclaration\\\":\\\"See function declaration\\\",\\\"seeMethodDeclaration\\\":\\\"See method declaration\\\",\\\"seeParameterDeclaration\\\":\\\"See parameter declaration\\\",\\\"seeVariableDeclaration\\\":\\\"See variable declaration\\\",\\\"tupleEntryTypeMismatch\\\":\\\"Tuple entry {entry} is incorrect type\\\",\\\"tupleSizeMismatch\\\":\\\"Tuple size mismatch; expected {expected} but received {received}\\\",\\\"typeAssignmentMismatch\\\":\\\"Type \\\\\\\"{sourceType}\\\\\\\" cannot be assigned to type \\\\\\\"{destType}\\\\\\\"\\\",\\\"typeBound\\\":\\\"Type \\\\\\\"{sourceType}\\\\\\\" is not compatible with bound type \\\\\\\"{destType}\\\\\\\" for TypeVar \\\\\\\"{name}\\\\\\\"\\\",\\\"typeConstrainedTypeVar\\\":\\\"Type \\\\\\\"{type}\\\\\\\" is not compatible with constrained TypeVar \\\\\\\"{name}\\\\\\\"\\\",\\\"typeConstraint\\\":\\\"Type \\\\\\\"{type}\\\\\\\" is not compatible with constrained type \\\\\\\"{name}\\\\\\\"\\\",\\\"typedDictFieldMissing\\\":\\\"\\\\\\\"{name}\\\\\\\" is missing from \\\\\\\"{type}\\\\\\\"\\\",\\\"typedDictFieldNotRequired\\\":\\\"\\\\\\\"{name}\\\\\\\" is not required in \\\\\\\"{type}\\\\\\\"\\\",\\\"typedDictFieldRequired\\\":\\\"\\\\\\\"{name}\\\\\\\" is required in \\\\\\\"{type}\\\\\\\"\\\",\\\"typedDictFieldTypeMismatch\\\":\\\"Type \\\\\\\"{type}\\\\\\\" is not assignable to field \\\\\\\"{name}\\\\\\\"\\\",\\\"typedDictFieldUndefined\\\":\\\"\\\\\\\"{name}\\\\\\\" is an undefined field in type \\\\\\\"{type}\\\\\\\"\\\",\\\"typeIncompatible\\\":\\\"\\\\\\\"{sourceType}\\\\\\\" is incompatible with \\\\\\\"{destType}\\\\\\\"\\\",\\\"typeNotClass\\\":\\\"\\\\\\\"{type}\\\\\\\" is not a class\\\",\\\"typeParamSpec\\\":\\\"Type \\\\\\\"{type}\\\\\\\" is not compatible with ParamSpec \\\\\\\"{name}\\\\\\\"\\\",\\\"typeNotStringLiteral\\\":\\\"\\\\\\\"{type}\\\\\\\" is not a string literal\\\",\\\"typeOfSymbol\\\":\\\"Type of \\\\\\\"{name}\\\\\\\" is \\\\\\\"{type}\\\\\\\"\\\",\\\"typeUnsupported\\\":\\\"Type \\\\\\\"{type}\\\\\\\" is unsupported\\\",\\\"typeVarIsContravariant\\\":\\\"TypeVar \\\\\\\"{name}\\\\\\\" is contravariant\\\",\\\"typeVarIsCovariant\\\":\\\"TypeVar \\\\\\\"{name}\\\\\\\" is covariant\\\",\\\"typeVarIsInvariant\\\":\\\"TypeVar \\\\\\\"{name}\\\\\\\" is invariant\\\",\\\"typeVarNotAllowed\\\":\\\"TypeVar or generic type with type arguments is not allowed\\\",\\\"useDictInstead\\\":\\\"Use Dict[T1, T2] instead\\\",\\\"useListInstead\\\":\\\"Use List[T] instead\\\",\\\"useTupleInstead\\\":\\\"Use Tuple[T1, ..., Tn] instead\\\",\\\"useTypeInstead\\\":\\\"Use Type[T] instead\\\"},\\\"CodeAction\\\":{\\\"addOptionalToAnnotation\\\":\\\"Add \\\\\\\"Optional\\\\\\\" to Type Annotation\\\",\\\"createTypeStub\\\":\\\"Create Type Stub\\\",\\\"createTypeStubFor\\\":\\\"Create Type Stub For \\\\\\\"{moduleName}\\\\\\\"\\\",\\\"executingCommand\\\":\\\"Executing command\\\",\\\"filesToAnalyzeOne\\\":\\\"1 file to analyze\\\",\\\"filesToAnalyzeCount\\\":\\\"{count} files to analyze\\\",\\\"findingReferences\\\":\\\"Finding references\\\",\\\"organizeImports\\\":\\\"Organize Imports\\\"}}\");\n\n//# sourceURL=webpack://pyright-server/./src/localization/package.nls.en-us.json?");

/***/ }),

/***/ "./src/localization/package.nls.es.json":
/*!**********************************************!*\
  !*** ./src/localization/package.nls.es.json ***!
  \**********************************************/
/*! default exports */
/*! exports [not provided] [no usage info] */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = {};\n\n//# sourceURL=webpack://pyright-server/./src/localization/package.nls.es.json?");

/***/ }),

/***/ "./src/localization/package.nls.fr.json":
/*!**********************************************!*\
  !*** ./src/localization/package.nls.fr.json ***!
  \**********************************************/
/*! default exports */
/*! exports [not provided] [no usage info] */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = {};\n\n//# sourceURL=webpack://pyright-server/./src/localization/package.nls.fr.json?");

/***/ }),

/***/ "./src/localization/package.nls.ja.json":
/*!**********************************************!*\
  !*** ./src/localization/package.nls.ja.json ***!
  \**********************************************/
/*! default exports */
/*! exports [not provided] [no usage info] */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = {};\n\n//# sourceURL=webpack://pyright-server/./src/localization/package.nls.ja.json?");

/***/ }),

/***/ "./src/localization/package.nls.ru.json":
/*!**********************************************!*\
  !*** ./src/localization/package.nls.ru.json ***!
  \**********************************************/
/*! default exports */
/*! exports [not provided] [no usage info] */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = {};\n\n//# sourceURL=webpack://pyright-server/./src/localization/package.nls.ru.json?");

/***/ }),

/***/ "./src/localization/package.nls.zh-cn.json":
/*!*************************************************!*\
  !*** ./src/localization/package.nls.zh-cn.json ***!
  \*************************************************/
/*! default exports */
/*! exports [not provided] [no usage info] */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = {};\n\n//# sourceURL=webpack://pyright-server/./src/localization/package.nls.zh-cn.json?");

/***/ }),

/***/ "./src/localization/package.nls.zh-tw.json":
/*!*************************************************!*\
  !*** ./src/localization/package.nls.zh-tw.json ***!
  \*************************************************/
/*! default exports */
/*! exports [not provided] [no usage info] */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = {};\n\n//# sourceURL=webpack://pyright-server/./src/localization/package.nls.zh-tw.json?");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"child_process\");\n\n//# sourceURL=webpack://pyright-server/external_%22child_process%22?");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"crypto\");\n\n//# sourceURL=webpack://pyright-server/external_%22crypto%22?");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"events\");\n\n//# sourceURL=webpack://pyright-server/external_%22events%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack://pyright-server/external_%22fs%22?");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"net\");\n\n//# sourceURL=webpack://pyright-server/external_%22net%22?");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"os\");\n\n//# sourceURL=webpack://pyright-server/external_%22os%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack://pyright-server/external_%22path%22?");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"stream\");\n\n//# sourceURL=webpack://pyright-server/external_%22stream%22?");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"url\");\n\n//# sourceURL=webpack://pyright-server/external_%22url%22?");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"util\");\n\n//# sourceURL=webpack://pyright-server/external_%22util%22?");

/***/ }),

/***/ "worker_threads":
/*!*********************************!*\
  !*** external "worker_threads" ***!
  \*********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/***/ ((module) => {

"use strict";
eval("module.exports = require(\"worker_threads\");\n\n//# sourceURL=webpack://pyright-server/external_%22worker_threads%22?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./src/server.ts");
/******/ })()
;